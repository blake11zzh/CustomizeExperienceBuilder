"use strict";(self.webpackChunkafd_experience_builder_doc=self.webpackChunkafd_experience_builder_doc||[]).push([[9791],{92272:function(e,t,a){a.r(t),a.d(t,{default:function(){return u}});var n=a(28453),r=a(96540);function c(e){const t=Object.assign({p:"p",code:"code",ul:"ul",li:"li",h3:"h3",a:"a",span:"span"},(0,n.RP)(),e.components);return r.createElement(r.Fragment,null,r.createElement(t.p,null,"Data source defines how your widget accesses data. For example, when data is from a remote server, the widget can use a data source class to query the data\nto the client side. When data is generated by a widget, it can be used by another widget by putting itself into a data source class."),"\n",r.createElement(t.p,null,"At a high level, a data source has a schema, some records, and may have some child/parent data source. In addition, every data source has a type, id, and status\nto help identify it. The ",r.createElement(t.code,null,"DataSource")," interface is defined in the ",r.createElement(t.code,null,"jimu-core")," package; it defines some of the following methods and properties:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.code,null,"id"),": the data source id."),"\n",r.createElement(t.li,null,r.createElement(t.code,null,"type"),": property used in the widget to check which type of data source it is using."),"\n",r.createElement(t.li,null,r.createElement(t.code,null,"fetchSchema"),": every data source must implement this method to return the schema. This is the schema defined in the remote data service. For example, when a user\nadds a data source in ArcGIS Experience Builder, the data source schema is not saved in the app config; instead, the ",r.createElement(t.code,null,"fetchSchema")," method is called to get the latest\ndata source schema."),"\n",r.createElement(t.li,null,r.createElement(t.code,null,"getSchema"),": method used by the widget to access the data source schema and fields in the data source."),"\n",r.createElement(t.li,null,r.createElement(t.code,null,"getRecords"),": method used by the widget to access the data records in the data source."),"\n",r.createElement(t.li,null,r.createElement(t.code,null,"getStatus"),":  the widget will use this method to get the data status of the data source. The statuses include ",r.createElement(t.code,null,"NotReady"),", ",r.createElement(t.code,null,"Unloaded"),", ",r.createElement(t.code,null,"Loading"),", ",r.createElement(t.code,null,"Loaded"),", and ",r.createElement(t.code,null,"LoadError"),".\nThe ",r.createElement(t.code,null,"NotReady")," is for the widget output data source only. When an output data source instance is created, the instance is not ready for use. The widget that generates the output data source should dispatch an action (DataSourceStatusChanged) to make the data source ready for use. If a data source status is not ready, the query should return an empty result. For other queriable data sources, the default status is ",r.createElement(t.code,null,"Unloaded"),". It will be changed to ",r.createElement(t.code,null,"Loading")," when data is requested, and will be changed to ",r.createElement(t.code,null,"Loaded")," or ",r.createElement(t.code,null,"LoadError")," finally."),"\n"),"\n",r.createElement(t.p,null,"Data source is managed by the ",r.createElement(t.code,null,"DataSourceManager")," to create and get data sources."),"\n",r.createElement(t.p,null,"To simplify the use of a data source, a ",r.createElement(t.code,null,"DataSourceComponent")," component is defined. This component accepts the ",r.createElement(t.code,null,"useDataSource")," property and returns the data source object and its status info through a callback.\nIt also accepts a function as its child, which can be used to get the data source object and info to render the data in the data source. The ",r.createElement(t.code,null,"DataSourceComponent")," component can also accept an optional ",r.createElement(t.code,null,"query")," property and will reload the data when the query is changed."),"\n",r.createElement(t.p,null,"Most commonly used data services support query data, so the API defines the ",r.createElement(t.code,null,"QueriableDataSource")," interface.\nThis interface has properties including ",r.createElement(t.code,null,"url"),", ",r.createElement(t.code,null,"load")," and ",r.createElement(t.code,null,"query")," etc. The difference between the ",r.createElement(t.code,null,"load")," and ",r.createElement(t.code,null,"query")," methods is that ",r.createElement(t.code,null,"load")," updates the data and the status of the data source, while ",r.createElement(t.code,null,"query")," queries and returns the records only."),"\n",r.createElement(t.p,null,"Some ArcGIS services support query data and they have similar query behavior, so the ",r.createElement(t.code,null,"ArcGISQueriableDataSource")," interface is defined to support the common operations of these services. And some sub interfaces are defined to support the specific operations of these services, such as ",r.createElement(t.code,null,"FeatureLayerDataSource"),", ",r.createElement(t.code,null,"SceneLayerDataSource"),", etc."),"\n",r.createElement(t.p,null,"More specifically, we define the ",r.createElement(t.code,null,"FeatureLayerDataSource")," data sources in Experience Builder to access a feature layer. To get the ArcGIS Maps SDK for JavaScript ",r.createElement(t.code,null,"FeatureLayer")," object through the feature layer data source, you can call the ",r.createElement(t.code,null,"createJSAPILayerByDataSource()")," method.\nThe actual data of a FeatureLayerDataSource can be from a remote database, or from a collection of client side features. Both types support query."),"\n",r.createElement(t.p,null,"In general, a data source is managed in two places: the data source object is managed in ",r.createElement(t.code,null,"DataSourceManager"),", and the data source info is managed in a redux app store.\nWhen using ",r.createElement(t.code,null,"DataSourceComponent"),", the component will call ",r.createElement(t.code,null,"DataSourceManager")," to create the data source on demand, and return the data source object and ",r.createElement(t.code,null,"dataSourceInfo")," by using a callback prop.\nIn ",r.createElement(t.code,null,"dataSourceInfo"),", the data source's ",r.createElement(t.code,null,"instanceStatus"),", ",r.createElement(t.code,null,"status"),", ",r.createElement(t.code,null,"selectedIds"),", etc. can be returned."),"\n",r.createElement(t.p,null,"Most of the ArcGIS server services are mapped to data source for easy access, such as ",r.createElement(t.code,null,"MapServiceDataSource"),", ",r.createElement(t.code,null,"FeatureServiceDataSource"),", etc.\n",r.createElement(t.code,null,"WebMap")," and ",r.createElement(t.code,null,"WebScene")," in the ArcGIS Maps SDK for JavaScript are wrapped as ",r.createElement(t.code,null,"WebMapDataSource")," and ",r.createElement(t.code,null,"WebSceneDataSource")," in the ",r.createElement(t.code,null,"jimu-arcgis")," package."),"\n",r.createElement(t.h3,{id:"data-source-set",className:"group relative s:flex s:flex-nowrap"},"Data Source Set",r.createElement(t.a,{href:"#data-source-set","aria-label":"data source set permalink",className:"anchor-link"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<calcite-icon scale="s" icon="link"></calcite-icon>'}}))),"\n",r.createElement(t.p,null,"A data source can have child data sources. As a result, you may include more than one data source to make it easier to use. This kind of data source is called a\n",r.createElement(t.code,null,"DataSourceSet"),". ",r.createElement(t.code,null,"WebMapDataSource")," is a ",r.createElement(t.code,null,"DataSourceSet"),". ",r.createElement(t.code,null,"DataSourceSet")," is also a type of data source but the ",r.createElement(t.code,null,"isDataSourceSet")," property is set to true. You can use ",r.createElement(t.code,null,"getChildDataSources")," to get the child data sources from a parent data source, and use ",r.createElement(t.code,null,"parentDataSource")," to get the parent data source from a child data source.\nChild data sources are created on demand, and you can use ",r.createElement(t.code,null,"createDataSourceById(dsId)")," to create a child data source by its ID."),"\n",r.createElement(t.h3,{id:"data-view",className:"group relative s:flex s:flex-nowrap"},"Data View",r.createElement(t.a,{href:"#data-view","aria-label":"data view permalink",className:"anchor-link"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<calcite-icon scale="s" icon="link"></calcite-icon>'}}))),"\n",r.createElement(t.p,null,"When multiple widgets connect to a single data source, a widget may want to see a local view of the data source. In this scenario, you would use a data view. The relationship between a data view and data source is very similar to the relationship between a view and a table in a relational database. Although a data source in Experience Builder is a view of the actual remote data source on the client-side, you can think of a data source as a table and data view as a view.\nAn app creator can create a data view from a data source and connect a widget to the data view in the builder. At the API level, the data view is managed by using the ",r.createElement(t.code,null,"DataSource")," class, so the data view has the same interface and behavior with the data source just with some properties differences. The data source that the data views based upon is called main data source, you can use ",r.createElement(t.code,null,"getMainDataSource")," to get it from a data view, or use ",r.createElement(t.code,null,"getDataViews")," to get all of the views of the main data source."),"\n",r.createElement(t.p,null,"The selection is shared between the main data source and all of its data views. The selection info is saved in two places: the selected records are saved in a selection view of the data source, the selected record ids are saved in the redux app store, under its data source id. The selection view is a special data view of the main data source, it's identified by ",r.createElement(t.code,null,"${mainDataSourceId}-selection"),"."),"\n",r.createElement(t.h3,{id:"local-data-source-and-data-view",className:"group relative s:flex s:flex-nowrap"},"Local data source and data view",r.createElement(t.a,{href:"#local-data-source-and-data-view","aria-label":"local data source and data view permalink",className:"anchor-link"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<calcite-icon scale="s" icon="link"></calcite-icon>'}}))),"\n",r.createElement(t.p,null,"Although multiple widgets can use different data views to retrieve different data, there are still scenarios that different widgets may need to connect to the same data source or the same data view but they still need to retrieve different data in the widget, such as a drop-down list in a widget. In this case, the widget can create a local data source or data view, the filter applied on the local data source or data view does not affect the related data source or data view. You can use ",r.createElement(t.code,null,"DataSourceComponent")," and pass in ",r.createElement(t.code,null,"localId"),", or use ",r.createElement(t.code,null,"DataSourceManager().getinstance().createLocalDataSource")," to use the local data source or data view."),"\n",r.createElement(t.h3,{id:"source-records-in-data-source",className:"group relative s:flex s:flex-nowrap"},"Source records in data source",r.createElement(t.a,{href:"#source-records-in-data-source","aria-label":"source records in data source permalink",className:"anchor-link"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<calcite-icon scale="s" icon="link"></calcite-icon>'}}))),"\n",r.createElement(t.p,null,"In most cases, the data is in a remote database, the data source instance just retrieves the data from the remote and stores it in the data source instance. However, for some data sources, the data is generated on the client-side such as a widget's output data sources and the selection view data source. In these scenarios, the data of the data source is stored in the ",r.createElement(t.code,null,"sourceRecords")," of the data source instance. You can use ",r.createElement(t.code,null,"getSourceRecords")," and ",r.createElement(t.code,null,"setSourceRecords")," to get and update it."),"\n",r.createElement(t.h3,{id:"widget-output-data-source",className:"group relative s:flex s:flex-nowrap"},"Widget output data source",r.createElement(t.a,{href:"#widget-output-data-source","aria-label":"widget output data source permalink",className:"anchor-link"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<calcite-icon scale="s" icon="link"></calcite-icon>'}}))),"\n",r.createElement(t.p,null,"A widget can use a data source, and it can generate a data source as well, we call the generated data source a widget output data source. A widget must save its output data source to the app config in its setting page by calling ",r.createElement(t.code,null,"this.props.onSettingChange")," so other widgets can use its output data source. The output data source is saved in ",r.createElement(t.code,null,"dataSources")," in the app config. Other widgets should not see any differences when they use the output data source or use the user added data source."),"\n",r.createElement(t.p,null,"Internally, when a widget generates an output data source and when the widget is rendered, an output data source and an output data view are created. The output data view is identified by ",r.createElement(t.code,null,"${outputDataSourceId}-output"),". The widget that uses the output data source is using the output view.\nWhen an output data source is created, its status is ",r.createElement(t.code,null,"NotReady"),". The widget that generates the output data source should update the data source when the data is ready, and then change the data source status to ",r.createElement(t.code,null,"Unloaded")," so other widgets know it's ready to use.\nThe way to update the data in the output data source depends on how the output data source is generated.\nA widget can generate a server-side output data source, which connects to a remote service. In this case, you can use ",r.createElement(t.code,null,"outputDs.updateQueryParams(queryParams, widgetId)"),", ",r.createElement(t.code,null,"outputDs.load(queryParams, { widgetId })")," or ",r.createElement(t.code,null,"<DataSourceComponent useDataSource={Immutable({ dataSourceId: outputDsId, mainDataSourceId: outputDsId })} query={queryParams}>")," to update the data source.\nA widget can generate a client-side output data source, which stores the data in the client-side. In this case, you can use ",r.createElement(t.code,null,"outputDs.setSourceFeatures(features, options)")," or ",r.createElement(t.code,null,"outputDs.setSourceRecords(records)")," to update data, depending on what kind of data the widget has generated. If the data generated by the widget has geometry, the ",r.createElement(t.code,null,"setSourceFeatures")," is recommended because you can specify the renderer for the features in this method. If the data generated by the widget does not have geometry, both ways are fine."),"\n",r.createElement(t.p,null,"The ",r.createElement(t.code,null,"originDataSources")," in the output data source JSON is used to maintain the relationship between the origin data source and the output data source. For example, if a widget's output data source does not have a schema defined, the origin data source's schema will be used.  The widget should update this property and the general properties including the ",r.createElement(t.code,null,"id"),", ",r.createElement(t.code,null,"type"),", etc.  The Query and Chart widget both generate an output data source. You can use their output data source JSON as a reference to see which properties are required in the output data source JSON."),"\n",r.createElement(t.h3,{id:"query-and-filter-data",className:"group relative s:flex s:flex-nowrap"},"Query and filter data",r.createElement(t.a,{href:"#query-and-filter-data","aria-label":"query and filter data permalink",className:"anchor-link"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<calcite-icon scale="s" icon="link"></calcite-icon>'}}))),"\n",r.createElement(t.p,null,"When a widget needs to load data, the recommended way is to use the ",r.createElement(t.code,null,"<DataSourceComponent>")," component or ",r.createElement(t.code,null,"dataSource.load()")," because the data source framework helps you manage the data cache and pagination issues.\nIf you just want to filter data instead of loading data, you can use ",r.createElement(t.code,null,"dataSource.updateQueryParams()"),"."),"\n",r.createElement(t.h3,{id:"query-fields",className:"group relative s:flex s:flex-nowrap"},"Query fields",r.createElement(t.a,{href:"#query-fields","aria-label":"query fields permalink",className:"anchor-link"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<calcite-icon scale="s" icon="link"></calcite-icon>'}}))),"\n",r.createElement(t.p,null,"A feature layer may have many fields, but in most cases widgets only need data from a few of those fields.\nIn most cases, a widget may need to query and display many data records. The recommended way for this kind of widget is to save the fields configurated in the settings to its ",r.createElement(t.code,null,"useDataSources")," via the ",r.createElement(t.code,null,"onSettingChange")," method, and then use the ",r.createElement(t.code,null,"<DataSourceComponent>")," to query and render the data. When taken this way, only the saved fields will be queried. When multiple widgets use the same data source, all saved fields will be queried together.\nHowever, some widgets may need to just display one record and lots of fields. In this case, the recommended way is to use the ",r.createElement(t.code,null,"dataSource.query()")," with the record ID to query the record to avoid querying too many fields when multiple widgets connect to the same data source.\nIf you use ",r.createElement(t.code,null,"dataSource.query(queryParam)")," to query data, you can set the ",r.createElement(t.code,null,"outFields")," property in the ",r.createElement(t.code,null,"queryParam")," object to specify the fields you want to query."),"\n",r.createElement(t.h3,{id:"client-side-query",className:"group relative s:flex s:flex-nowrap"},"Client-side query",r.createElement(t.a,{href:"#client-side-query","aria-label":"client side query permalink",className:"anchor-link"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<calcite-icon scale="s" icon="link"></calcite-icon>'}}))),"\n",r.createElement(t.p,null,"When a data source created from an URL needs to query data, the data source will send the query to the remote server. However, when the data source is created from a map layer and the Map widget has enabled client-side query, the data source will try to query data from the ",r.createElement(t.code,null,"MapView")," instead of sending a query to the back-end service.\nIf the ",r.createElement(t.code,null,"MapView")," or the corresponding ",r.createElement(t.code,null,"LayerView")," is not ready for a client-side query, the data source will still send the query to the remote server. There are couple of reasons why the ",r.createElement(t.code,null,"MapView")," or the ",r.createElement(t.code,null,"LayerView")," may not be ready. For example, the geometry in the query is not in the current map extent, or the ",r.createElement(t.code,null,"LayerView")," does not have all the features.\nBefore performing the client-side query, the ",r.createElement(t.code,null,"LayerView")," will add the ",r.createElement(t.code,null,"outFields")," in the query params to the ",r.createElement(t.code,null,"LayerView"),"'s fields and then perform the query. Adding too many fields to ",r.createElement(t.code,null,"LayerView")," may cause performance issues, and you can use ",r.createElement(t.code,null,"notAddFieldsToClient")," to prevent adding fields to the ",r.createElement(t.code,null,"LayerView"),"."),"\n",r.createElement(t.h3,{id:"data-action",className:"group relative s:flex s:flex-nowrap"},"Data Action",r.createElement(t.a,{href:"#data-action","aria-label":"data action permalink",className:"anchor-link"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<calcite-icon scale="s" icon="link"></calcite-icon>'}}))),"\n",r.createElement(t.p,null,"See ",r.createElement(t.a,{href:"/experience-builder/guide/core-concepts/data-action/"},"Data action")),"\n",r.createElement(t.h3,{id:"repeated-data-source",className:"group relative s:flex s:flex-nowrap"},"Repeated Data source",r.createElement(t.a,{href:"#repeated-data-source","aria-label":"repeated data source permalink",className:"anchor-link"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<calcite-icon scale="s" icon="link"></calcite-icon>'}}))),"\n",r.createElement(t.p,null,"The data source provided by ",r.createElement(t.code,null,"RepeatedDataSourceProvider")," is called a repeated data source. All children widgets of the widget that provide a data source will receive the repeated data source.\nThis is similar to ",r.createElement(t.a,{href:"https://reactjs.org/docs/context.html"},"React's Context"),". A widget can access repeated data source by ",r.createElement(t.code,null,"this.props.repeatedDataSource"),". The repeated data source will get the data source's ",r.createElement(t.code,null,"id"),", ",r.createElement(t.code,null,"record"),", and ",r.createElement(t.code,null,"recordIndex"),".\nAny widget can provide repeated data source by using ",r.createElement(t.code,null,"RepeatedDataSourceProvider"),". The ",r.createElement(t.code,null,"List")," widget in Experience Builder is a good example that provides a repeated data source.\nTo use a repeated data source, add the ",r.createElement(t.code,null,"supportRepeat")," property in a widget's manifest file."))}var o=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,n.RP)(),e.components);return t?r.createElement(t,e,r.createElement(c,e)):c(e)},l=a(69507),d=a(46427);const s=function(e){const{data:{topicNavigation:t}}=e;return r.createElement(l.A,null,r.createElement(d.S,Object.assign({},e,{topicNavigation:t,wrapInLayout:!1})))};function u(e){return r.createElement(s,e,r.createElement(o,e))}}}]);