{"version":3,"file":"7373.5ed960f3.iframe.bundle.js","mappings":";;AAuEA;AACA;AACA;;AAEA;;;;;;;;AASA;AC4CA;;;AAGA;AACA;AACA;;;;;;AC3FA;AClBA;AACA;AACA;;AC6CA;AAIA;;;AAGA;AACA;;;AAGA;;;AAMA;AACA;;ACFA;AACA;;;;;;;;;;;;;;;;AChEA;;;;;;;;AASA;;ACFA;AAGA;;AAGA;AAGA;;;AAIA;;;;;;;AAgDA;;;;;;;AAoCA;;;;AAkBA;;AC/GA;;;;;ACnBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;AAMA;;;;;;;;;;;;AAYA;AC1BA;AACA;AACA;AACA;ACTA;AACA;AACA;;AAGA;;;;;;;;;;;;;;;;;;;;ACPA;AACA;;;;;;;;;AASA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;ACRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClBA;ACmBA;AACA;;AAEA;AACA;ACMA;AACA;AACA;;;AAIA;;;;AAMA;;AC3DA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;;;ACXA;;;AAGA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;ACPA;ACsEA;;;;;;;AAOA;;;;;;;AAQA;;;;;;;;;;;;AAaA;ACrDA;AACA;AACA;AACA;AACA;AACA;;;;;AChEA;;;ACPA;;;;;;;;;;;;;;;AAeA;;;ACKA;AACA;AACA;AACA;AACA;AACA;AAEA;;ACyDA;AACA;AACA;AACA;AACA;;;AAIA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AAEA;;;ACTA;;AAEA;;;ACmBA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;ACKA;;;AAGA;AACA;;;;;;AAMA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AAiBA;AAaA;AACA;AACA;;AAEA;AACA;;AAGA;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAOA;;;;;;;AAOA;AACA;;;;;;;;;;;;;;;;AAgBA;;;;;;;AAQA;;AC/HA;;;;AAIA;AACA;AACA;;;;;;;;;;;AAWA;;AAEA;;;;;;;;;;;;;;;;;AAmBA;;AAGA;;;;;;;;;;AAUA;;;;;;;;;;;AAWA;;;;;;AAQA;;AAGA;;;;;;;;;AASA;;;;;;;;AAZA;AA0BA;;;;;;;;AAUA;AAEA;;;;;;;;;;AAFA;;;;;AC5FA;AACA;AACA;;;AAGA;;;;;AAKA;AACA;;;;AAIA;AACA;AACA;;;;;;;;;;AAUA;;;;AAIA;;;;;;AAMA;;;;AAIA;AACA;AACA;AACA;;;AAGA;AACA;;;;;;;;;AASA;AACA;;;AAIA;;;;;AAMA;AACA;;AAEA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;;;;;;;;;;AAUA;;;;AAIA;;;AAGA;;;;;;;AAOA;;;;;;;;;AASA;AACA;;;;;;AAMA;AACA;;;AAGA;AACA;;;;;AAKA;AACA;;;AAIA;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;ACnDA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;AAaA;;;AAGA;ACwBA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AClJA;AACA;AACA;AAEA;AAOA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC+BA;;;;;;;;;;;;;ACIA;;;;;AAKA;;;;;;AAMA;;;;;AAKA;;;;;;;AAOA;;;AAOA;;;;;;;;;;;;AAYA;AACA;;;;;AAKA;AACA;;;;;;;;;;;AAWA;AACA;;;AAGA;;;;;;AAMA;AACA;;;AAGA;;;;;AAKA;AACA;;;AAGA;;;;;AAKA;AACA;;;AAGA;;;AAGA;;;ACjIA;;;;;;;;;;;;;;;;;AAkBA","sources":["webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/runtime/widget-renderer.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/runtime/layout-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/fixed-layout/runtime/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/column-layout/runtime/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/row-layout/runtime/row.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/row-layout/runtime/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/runtime/layout-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/runtime/grid-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/runtime/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/accordion-layout/runtime/panel.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flex-row-layout/runtime/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/runtime/layout-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/runtime/screen-group.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/runtime/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/controller-panel/runtime/panel.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/controller-panel/runtime/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/runtime/page-body.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/runtime/page-header.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/runtime/page-footer.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/runtime/print-preview-tool.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/runtime/page-renderer.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/accordion-layout/common/item-title.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/accordion-layout/common/toggle-all.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/column-layout/common/style.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/column-layout/common/util.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/controller-panel/util.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/fixed-layout/common/util.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flex-row-layout/common/style.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flex-row-layout/common/util.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/common/screen-main-panel.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/common/screen-main-panel-list.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/common/screen-side-panel.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/layout-utils.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/common/splitter.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/common/utils.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/row-layout/common/util.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/row-layout/utils.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/runtime/section-nav.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/runtime/section-renderer-base.tsx"],"sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/** @jsx jsx */\nimport { React, ReactRedux, WidgetManager, jsx, css, ErrorBoundary, classNames, appActions, getAppStore, WidgetState, i18n } from 'jimu-core';\nimport { mapStateToWidgetProps } from '../utils';\nimport { styleUtils } from 'jimu-ui';\nclass _WidgetRenderer extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.onMouseDown = () => {\n            var _a;\n            // doesn't need to activate placeholder\n            if (this.props.widgetId) {\n                const state = getAppStore().getState();\n                if (((_a = state.widgetsRuntimeInfo[this.props.widgetId]) === null || _a === void 0 ? void 0 : _a.state) !== WidgetState.Active) {\n                    getAppStore().dispatch(appActions.activateWidget(this.props.widgetId));\n                }\n            }\n        };\n        this.onMouseDown = this.onMouseDown.bind(this);\n        this.ref = React.createRef();\n        this.state = { error: null };\n    }\n    loadWidgetClass() {\n        const { widgetId, isClassLoaded } = this.props;\n        if (widgetId && !isClassLoaded) {\n            WidgetManager.getInstance().loadWidgetClass(widgetId).catch(err => {\n                console.log(err);\n                this.setState({\n                    error: i18n.getIntl().formatMessage({ id: 'widgetLoadError' })\n                });\n            });\n        }\n    }\n    componentDidMount() {\n        this.loadWidgetClass();\n    }\n    componentDidUpdate() {\n        this.loadWidgetClass();\n    }\n    /**\n     * Must add an extra div to keep the aspect ratio.\n     * https://www.w3schools.com/howto/howto_css_aspect_ratio.asp\n     */\n    renderWidgetContent() {\n        const { widgetId, layoutId, layoutItemId, autoWidth, autoHeight, onInitResizeHandler, onInitDragHandler } = this.props;\n        let WidgetClass;\n        if (widgetId) {\n            WidgetClass = WidgetManager.getInstance().getWidgetClass(widgetId);\n        }\n        if (this.state.error) {\n            return jsx(\"div\", { className: 'widget-content' }, this.state.error);\n        }\n        return (jsx(\"div\", { className: classNames('widget-content', { 'd-none': !widgetId }) }, WidgetClass && jsx(ErrorBoundary, null,\n            jsx(WidgetClass, { widgetId: widgetId, layoutId: layoutId, layoutItemId: layoutItemId, autoWidth: autoWidth, autoHeight: autoHeight, onInitResizeHandler: onInitResizeHandler, onInitDragHandler: onInitDragHandler }))));\n    }\n    getStyle() {\n        const { forceAspectRatio, aspectRatio } = this.props;\n        // for app-loader widget only, usable in touch device\n        const overflowScrollingStyle = css `\r\n      -webkit-overflow-scrolling: touch;\r\n    `;\n        return css `\r\n      ${this.props.widgetId === 'app-loader' ? overflowScrollingStyle : ''};\r\n      overflow: ${this.props.canCrossLayoutBoundary ? 'visible' : 'hidden'};\r\n      position: relative;\r\n      aspect-ratio: ${forceAspectRatio && aspectRatio > 0 ? aspectRatio : null};\r\n\r\n      & > .widget-content {\r\n        position: relative;\r\n        height: 100%;\r\n        width: 100%;\r\n        z-index: 0;\r\n      }\r\n    `;\n    }\n    render() {\n        var _a, _b;\n        const { className, widgetStyle, widgetId, rotate } = this.props;\n        const _c = styleUtils.toCSSStyle(widgetStyle), { transform } = _c, otherStyle = __rest(_c, [\"transform\"]);\n        const rotateStyle = rotate > 0 || rotate < 0 ? `rotateZ(${rotate}deg)` : '';\n        let mergedTransform = rotateStyle;\n        if (transform) {\n            mergedTransform = `${transform} ${rotateStyle}`;\n        }\n        return (jsx(\"div\", { className: classNames(`widget-renderer layout-item-content w-100 ${(_b = (_a = widgetStyle === null || widgetStyle === void 0 ? void 0 : widgetStyle.boxShadow) === null || _a === void 0 ? void 0 : _a.presetStyle) !== null && _b !== void 0 ? _b : ''}`, className), css: this.getStyle(), style: Object.assign(Object.assign({}, otherStyle), { transform: mergedTransform }), onMouseDownCapture: this.onMouseDown, \"data-widgetid\": widgetId, ref: this.ref },\n            this.renderWidgetContent(),\n            this.props.children));\n    }\n}\nexport const WidgetRenderer = ReactRedux.connect(mapStateToWidgetProps)(_WidgetRenderer);\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, LayoutItemType, classNames, AnimationComponent, AnimationType, AnimationContext, AnimationTriggerType, getNextAnimationId, getHoverStyle, AnimationStartMode } from 'jimu-core';\nimport { MIN_LAYOUT_ITEM_SIZE } from '../types';\nimport { mapStateToLayoutItemProps } from '../utils';\nimport { getSectionInfo } from '../search';\nimport { WidgetRenderer } from './widget-renderer';\nimport { SectionRenderer } from './section-renderer';\nimport { useLiveviewPlayId } from './layout-item-hook/use-liveview-playid';\nimport { useViewportIntersection } from '../use-viewport-intersection';\nimport { ViewportVisibilityContext } from '../builder/page-context';\nfunction findInnerLayoutId(state, layoutId, layoutItemId) {\n    var _a;\n    const layoutItem = state.appConfig.layouts[layoutId].content[layoutItemId];\n    if (layoutItem.type === LayoutItemType.Widget) {\n        const widgetJson = state.appConfig.widgets[layoutItem.widgetId]; // may be a placeholder\n        const sizeModeLayout = (_a = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.layouts) === null || _a === void 0 ? void 0 : _a.DEFAULT;\n        if (sizeModeLayout) {\n            return sizeModeLayout[state.browserSizeMode];\n        }\n    }\n    return null;\n}\nexport default function LayoutItem(props) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    const stateProps = ReactRedux.useSelector((state) => mapStateToProps(state, props), ReactRedux.shallowEqual);\n    const isPrintPreview = ReactRedux.useSelector((state) => { var _a, _b; return (_b = (_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.isPrintPreview) !== null && _b !== void 0 ? _b : false; });\n    const allProps = Object.assign(Object.assign({}, props), stateProps);\n    const refObj = React.useRef();\n    const { layoutId, layoutItemId, layoutItem } = allProps;\n    const { className, children, id, isLastChild } = allProps, otherProps = __rest(allProps, [\"className\", \"children\", \"id\", \"isLastChild\"]);\n    const isWidget = (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Widget;\n    const isSection = (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Section;\n    const { effect, oneByOneEffect, hoverEffect } = !isPrintPreview ? ((_b = (_a = allProps.layoutItem) === null || _a === void 0 ? void 0 : _a.setting) !== null && _b !== void 0 ? _b : {}) : {};\n    let effectType = (_c = effect === null || effect === void 0 ? void 0 : effect[AnimationTriggerType.ScrollIntoView]) === null || _c === void 0 ? void 0 : _c.type;\n    effectType = effectType && effectType !== AnimationType.None ? effectType : null;\n    let oneByOneEffectType = (_d = oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView]) === null || _d === void 0 ? void 0 : _d.type;\n    oneByOneEffectType = oneByOneEffectType && oneByOneEffectType !== AnimationType.None ? oneByOneEffectType : null;\n    // eslint-disable-next-line no-unused-vars\n    const [mounted, setMounted] = React.useState(false); //eslint-disable-line @typescript-eslint/no-unused-vars\n    const [animationContext, setAnimationContext] = React.useState({\n        setting: oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView],\n        playId: null,\n        oid: stateProps.innerLayoutId,\n        revert: null\n    });\n    const isInViewport = useViewportIntersection(refObj.current, allProps.watchViewportVisibility);\n    React.useEffect(() => {\n        setMounted(true);\n    }, []);\n    const { setting: parentAnimationSetting } = React.useContext(AnimationContext);\n    const [asOnePlayId, asOneRevert, onAsOneAnimationEnd] = useLiveviewPlayId(effectType, (parentAnimationSetting === null || parentAnimationSetting === void 0 ? void 0 : parentAnimationSetting.type) != null && parentAnimationSetting.type !== AnimationType.None);\n    const [oneByOnePlayId, oneByOneRevert, onOnebyOneAnimationEnd] = useLiveviewPlayId(oneByOneEffectType, (parentAnimationSetting === null || parentAnimationSetting === void 0 ? void 0 : parentAnimationSetting.type) != null && parentAnimationSetting.type !== AnimationType.None);\n    React.useEffect(() => {\n        // no as one playId, set onebyone directly\n        if (asOnePlayId == null && oneByOnePlayId) {\n            setAnimationContext({\n                setting: oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView],\n                playId: oneByOnePlayId,\n                oid: stateProps.innerLayoutId,\n                revert: oneByOneRevert,\n                onContextAnimationEnd: oneByOneRevert // no need to reset animation context if it is revert\n                    ? null\n                    : () => {\n                        onOnebyOneAnimationEnd();\n                        setAnimationContext({\n                            setting: oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView],\n                            oid: stateProps.innerLayoutId,\n                            playId: -1\n                        });\n                    }\n            });\n        }\n    }, [asOnePlayId, oneByOnePlayId, onOnebyOneAnimationEnd, oneByOneEffect, oneByOneRevert, stateProps.innerLayoutId]);\n    const handleSingleAnimationStart = React.useCallback(() => {\n        var _a;\n        // maybe there is no one by one animation, but some child element has its own animation\n        const setting = oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView];\n        const revert = ((_a = setting === null || setting === void 0 ? void 0 : setting.option) === null || _a === void 0 ? void 0 : _a.start) === AnimationStartMode.AfterPrevious;\n        setAnimationContext({\n            setting,\n            playId: getNextAnimationId(),\n            oid: stateProps.innerLayoutId,\n            revert,\n            onContextAnimationEnd: revert\n                ? null\n                : () => {\n                    setAnimationContext({ setting, oid: stateProps.innerLayoutId, playId: -1 });\n                }\n        });\n    }, [oneByOneEffect, stateProps.innerLayoutId]);\n    const handleSingleAnimationEnd = React.useCallback(() => {\n        var _a;\n        const setting = oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView];\n        // only plays when start mode is \"after previous\"\n        if (((_a = setting === null || setting === void 0 ? void 0 : setting.option) === null || _a === void 0 ? void 0 : _a.start) === AnimationStartMode.AfterPrevious) {\n            setAnimationContext({\n                setting,\n                playId: getNextAnimationId(),\n                oid: stateProps.innerLayoutId,\n                revert: false,\n                onContextAnimationEnd: () => {\n                    setAnimationContext({ setting, oid: stateProps.innerLayoutId, playId: -1 });\n                }\n            });\n        }\n        if (asOnePlayId > 0) { // reset the playId if this animation is triggered by asOnePlayId\n            onAsOneAnimationEnd === null || onAsOneAnimationEnd === void 0 ? void 0 : onAsOneAnimationEnd();\n        }\n    }, [asOnePlayId, onAsOneAnimationEnd, oneByOneEffect, stateProps.innerLayoutId]);\n    if (!allProps.layoutItem || (isSection && !layoutItem.sectionId)) {\n        return null;\n    }\n    // const effectType = effect ? (visible ? effect?.[AnimationTriggerType.ScrollIntoView]?.type: AnimationType.FadeOut) : null;\n    const effectOption = (_e = effect === null || effect === void 0 ? void 0 : effect[AnimationTriggerType.ScrollIntoView]) === null || _e === void 0 ? void 0 : _e.option;\n    const rotate = (_j = (_h = (_g = (_f = layoutItem.setting) === null || _f === void 0 ? void 0 : _f.style) === null || _g === void 0 ? void 0 : _g.transform) === null || _h === void 0 ? void 0 : _h.rotate) !== null && _j !== void 0 ? _j : 0;\n    return (jsx(ViewportVisibilityContext.Provider, { value: isInViewport },\n        jsx(AnimationComponent, { id: id, parentId: layoutId, type: effectType, configType: effectOption === null || effectOption === void 0 ? void 0 : effectOption.configType, direction: effectOption === null || effectOption === void 0 ? void 0 : effectOption.direction, revert: asOneRevert, delay: props.delay, isLastChild: isLastChild, playId: asOnePlayId, onAnimationStart: handleSingleAnimationStart, onAnimationEnd: handleSingleAnimationEnd, ref: refObj, css: css `\r\n          ${getHoverStyle(hoverEffect === null || hoverEffect === void 0 ? void 0 : hoverEffect.type, hoverEffect === null || hoverEffect === void 0 ? void 0 : hoverEffect.setting)};\r\n          position: relative;\r\n          overflow: visible;\r\n          min-width: ${MIN_LAYOUT_ITEM_SIZE}px;\r\n          min-height: ${MIN_LAYOUT_ITEM_SIZE}px;\r\n        `, style: props.style, className: classNames('d-flex layout-item', className, {\n                'is-widget': isWidget,\n                'is-section': isSection\n            }), \"data-layoutitemid\": layoutItemId, \"data-layoutid\": layoutId },\n            jsx(AnimationContext.Provider, { value: animationContext },\n                isWidget && jsx(WidgetRenderer, Object.assign({ rotate: rotate }, otherProps)),\n                isSection && jsx(SectionRenderer, Object.assign({ rotate: rotate }, otherProps))),\n            props.children)));\n}\nfunction mapStateToProps(state, ownProps) {\n    var _a, _b;\n    const layoutItemProps = mapStateToLayoutItemProps(state, ownProps);\n    if (!layoutItemProps.layoutItem) {\n        return layoutItemProps;\n    }\n    if (layoutItemProps.layoutItem.type === LayoutItemType.Widget) {\n        const { layoutId, layoutItemId } = ownProps;\n        const widgetJson = state.appConfig.widgets[layoutItemProps.layoutItem.widgetId];\n        const supportInlineEditing = (_b = (_a = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.manifest) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.supportInlineEditing;\n        const innerLayoutId = findInnerLayoutId(state, layoutId, layoutItemId);\n        const result = Object.assign({ widgetId: layoutItemProps.layoutItem.widgetId, supportInlineEditing }, layoutItemProps);\n        if (innerLayoutId) {\n            result.innerLayoutId = innerLayoutId;\n        }\n        return result;\n    }\n    const sectionProps = getSectionInfo(state, layoutItemProps.layoutItem.sectionId);\n    return Object.assign(Object.assign({}, layoutItemProps), sectionProps);\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, classNames, lodash, OneByOneAnimation, IntersectionContext } from 'jimu-core';\nimport { styleUtils } from 'jimu-ui';\nimport LayoutItem from './layout-item';\nimport { mapStateToLayoutProps } from '../../utils';\nimport { DEFAULT_FIX_LAYOUT_SETTING } from '../default-setting';\nclass FixedLayoutViewer extends React.PureComponent {\n    createItem(layout, itemId, index, transformed) {\n        const layoutItem = layout.content[itemId];\n        return (jsx(LayoutItem, { key: `${layout.id}_${itemId}`, index: index, layoutId: layout.id, layoutItemId: itemId, layoutItem: layoutItem, transformedBBox: transformed\n                ? (layout.content[itemId].bbox)\n                : null, isInSection: this.props.isInSection }));\n    }\n    render() {\n        const { layout, layouts, className, style, browserSizeMode } = this.props;\n        if (!layout) {\n            return null;\n        }\n        let targetLayout = layout;\n        let transformed = false;\n        if (layouts[browserSizeMode] !== layout.id && this.layoutTransform) {\n            let fromSizeMode;\n            Object.keys(layouts).some(mode => {\n                if (layouts[mode] === layout.id) {\n                    fromSizeMode = mode;\n                    return true;\n                }\n                return false;\n            });\n            targetLayout = this.layoutTransform(layout, fromSizeMode, browserSizeMode);\n            transformed = true;\n        }\n        const layoutSetting = lodash.assign({}, DEFAULT_FIX_LAYOUT_SETTING, targetLayout.setting);\n        const layoutIds = (targetLayout.order || []);\n        const mergedClasses = classNames('layout fixed-layout d-flex', className);\n        return (jsx(\"div\", { className: mergedClasses, style: Object.assign(Object.assign(Object.assign({ position: 'relative', height: 'auto' }, style), styleUtils.toCSSStyle(layoutSetting.style)), { width: '100%', overflow: 'hidden' }), \"data-layoutid\": targetLayout.id }, layoutIds.length > 0 && (jsx(IntersectionContext.Provider, { value: { monitor: false } },\n            jsx(OneByOneAnimation, { css: css `\r\n                position: absolute;\r\n                left: 0;\r\n                right: 0;\r\n                top: 0;\r\n                bottom: 0;\r\n              `, oid: layout.id, \"data-layoutid\": layout.id }, layoutIds.map((itemId, index) => this.createItem(targetLayout, itemId, index, transformed)))))));\n    }\n}\nexport default ReactRedux.connect(mapStateToLayoutProps)(FixedLayoutViewer);\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css, classNames, Immutable, OneByOneAnimation, IntersectionContext } from 'jimu-core';\nimport { styleUtils } from 'jimu-ui';\nimport { mapStateToLayoutProps } from '../../utils';\nimport { ColumnItem } from './layout-item';\nimport { DEFAULT_COLUMN_LAYOUT_SETTING } from '../default-setting';\nimport { getLayoutStyle } from '../common/style';\nclass Layout extends React.PureComponent {\n    createItem(itemId, index, layoutSetting) {\n        const { layout } = this.props;\n        return (jsx(ColumnItem, { key: itemId, index: index, space: layoutSetting.space, layoutId: layout.id, layoutItemId: itemId, layoutItem: layout.content[itemId] }));\n    }\n    render() {\n        const { layout, className } = this.props;\n        const content = layout.order || Immutable([]);\n        const layoutSetting = Object.assign({}, DEFAULT_COLUMN_LAYOUT_SETTING, layout.setting);\n        const mergedStyle = {\n            position: 'relative',\n            overflow: 'hidden'\n        };\n        const outClass = classNames('layout column-layout d-flex w-100', className);\n        return (jsx(\"div\", { className: outClass, style: mergedStyle, \"data-layoutid\": layout.id },\n            jsx(IntersectionContext.Provider, { value: { monitor: true, layoutId: layout.id } },\n                jsx(OneByOneAnimation, { oid: layout.id, className: 'trail-container d-flex flex-column w-100', css: css `\r\n              ${getLayoutStyle(layoutSetting)};\r\n              padding: ${styleUtils.toCSSPadding(layoutSetting.padding)};\r\n            ` }, (content.asMutable()).map((layoutItem, index) => this.createItem(layoutItem, index, layoutSetting))))));\n    }\n}\nexport default ReactRedux.connect(mapStateToLayoutProps)(Layout);\n","/** @jsx jsx */\nimport { React, classNames, jsx, css, OneByOneAnimation, IntersectionContext } from 'jimu-core';\nimport RowItem from './layout-item';\nimport * as utils from '../../utils';\nimport { PageContext } from '../../builder/page-context';\nimport { ROW_STYLE } from '../utils';\nimport { DEFAULT_ROW_LAYOUT_SETTING } from '../default-setting';\nexport class Row extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.flipLeftRight = utils.isRTL();\n    }\n    collectBounds() {\n        var _a;\n        const { transformedLayout } = this.props;\n        const content = (_a = transformedLayout.order) !== null && _a !== void 0 ? _a : [];\n        this.childRects = [];\n        content.forEach(itemId => {\n            var _a, _b;\n            if (transformedLayout.content[itemId].isPending) {\n                return;\n            }\n            const bbox = (_b = (_a = transformedLayout.content) === null || _a === void 0 ? void 0 : _a[itemId]) === null || _b === void 0 ? void 0 : _b.bbox;\n            if (bbox != null) {\n                this.childRects.push({\n                    layoutId: transformedLayout.id,\n                    id: itemId,\n                    left: parseInt(bbox.left, 10),\n                    width: parseInt(bbox.width, 10),\n                    height: parseInt(bbox.height, 10)\n                });\n            }\n        });\n        return this.childRects.sort((a, b) => a.left - b.left);\n    }\n    getConfig() {\n        var _a;\n        const { layout } = this.props;\n        return (_a = layout.setting) !== null && _a !== void 0 ? _a : DEFAULT_ROW_LAYOUT_SETTING;\n    }\n    createItem(childRects, index, layoutStyle) {\n        var _a;\n        const { transformedLayout, isMultiRow } = this.props;\n        // const { isDragging, draggingItemId, dragOutOfBoundary } = this.state;\n        const config = this.getConfig();\n        const childRect = childRects[index];\n        const gutter = (_a = config.space) !== null && _a !== void 0 ? _a : 0;\n        let offset;\n        if (index === 0) {\n            offset = childRect.left;\n        }\n        else {\n            const previousBBox = childRects[index - 1];\n            offset = childRect.left - previousBBox.left - previousBBox.width;\n        }\n        return (jsx(RowItem, { key: `${childRect.layoutId}_${childRect.id}`, offset: offset, gutter: gutter, span: childRect.width, isMultiRow: isMultiRow, layoutId: transformedLayout.id, layoutItemId: childRect.id, layoutItem: transformedLayout.content[childRect.id], alignItems: layoutStyle.alignItems }));\n    }\n    render() {\n        var _a, _b;\n        const { layout, className } = this.props;\n        this.collectBounds();\n        const content = this.childRects;\n        const config = this.getConfig();\n        const layoutStyle = (_a = config.style) !== null && _a !== void 0 ? _a : {};\n        const gutter = (_b = config.space) !== null && _b !== void 0 ? _b : 0;\n        return (jsx(PageContext.Consumer, null, (props) => {\n            return (jsx(\"div\", { className: classNames('row-layout', className, {\n                    'row-rtl': this.flipLeftRight\n                }), css: ROW_STYLE, \"data-layoutid\": layout.id },\n                jsx(\"div\", { css: css `\r\n                  width: 100%;\r\n                  max-width: ${props.maxWidth > 0\n                        ? `${props.maxWidth}px`\n                        : 'none'};\r\n                ` },\n                    jsx(\"div\", { css: css `\r\n                    position: relative;\r\n                    height: 100%;\r\n                    margin-left: ${-gutter / 2}px;\r\n                    margin-right: ${-gutter / 2}px;\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                  ` }, content.length > 0 && (jsx(IntersectionContext.Provider, { value: { monitor: false } },\n                        jsx(OneByOneAnimation, { oid: layout.id, className: classNames('row h-100 m-0', {\n                                'flex-nowrap': !this.props.isMultiRow\n                            }), css: css `\r\n                          position: relative;\r\n                          height: 100%;\r\n                          overflow: ${this.props.isMultiRow ? 'auto' : 'unset'};\r\n                        ` }, content.map((_, index) => this.createItem(content, index, layoutStyle)))))))));\n        }));\n    }\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, classNames, jsx, css, ExtensionManager, extensionSpec, ReactResizeDetector, lodash, LayoutType } from 'jimu-core';\nimport { styleUtils } from 'jimu-ui';\nimport { Row } from './row';\nimport * as utils from '../../utils';\nimport { DEFAULT_ROW_LAYOUT_SETTING } from '../default-setting';\nimport { TOTAL_COLS } from '../types';\nclass RowLayout extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.layoutConRef = React.createRef();\n        this.onResize = ({ width, height }) => {\n            var _a;\n            if (this.props.browserSizeMode !== this.props.mainSizeMode) {\n                return;\n            }\n            if (width === 0 && height === 0) {\n                return;\n            }\n            const { widgetId } = this.props;\n            if (((_a = window.runtimeInfo.widgets) === null || _a === void 0 ? void 0 : _a[widgetId]) != null) {\n                window.runtimeInfo.widgets[widgetId].height = height;\n            }\n            else {\n                window.runtimeInfo.widgets[widgetId] = { height };\n            }\n        };\n        this.handleDebounceResize = lodash.debounce(this.onResize, 200);\n    }\n    findExtension() {\n        const exts = ExtensionManager.getInstance().getExtensions(\n        //eslint-disable-next-line @typescript-eslint/no-unnecessary-template-expression\n        `${extensionSpec.ExtensionPoints.LayoutTransformer}`);\n        if ((exts === null || exts === void 0 ? void 0 : exts.length) > 0) {\n            const ext = exts.find(item => item.layoutType ===\n                LayoutType.RowLayout);\n            this.layoutTransform = ext === null || ext === void 0 ? void 0 : ext.transformLayout;\n        }\n    }\n    collectRowItems() {\n        var _a;\n        const content = (_a = this.finalLayout.order) !== null && _a !== void 0 ? _a : [];\n        const rows = [];\n        let row = [];\n        let rowIndex = 0;\n        rows.push(row);\n        content.forEach((itemId) => {\n            if (this.finalLayout.content[itemId].isPending) {\n                return;\n            }\n            const bbox = this.finalLayout.content[itemId].bbox;\n            const left = parseInt(bbox.left, 10);\n            const rowNum = Math.floor(left / TOTAL_COLS);\n            if (rowNum > rowIndex) {\n                row = [];\n                rowIndex = rowNum;\n                rows.push(row);\n            }\n            row.push(itemId);\n        });\n        return rows;\n    }\n    transform() {\n        const { layout, layouts, browserSizeMode, mainSizeMode } = this.props;\n        if (this.layoutTransform == null) {\n            this.findExtension();\n        }\n        let targetLayout = layout;\n        if (layouts[browserSizeMode] !== layout.id &&\n            this.layoutTransform != null) {\n            targetLayout = this.layoutTransform(layout, mainSizeMode, browserSizeMode, utils.getAppConfig());\n        }\n        this.finalLayout = targetLayout;\n        this.numOfRows = this.collectRowItems().length;\n    }\n    createRow() {\n        const { layout, layouts } = this.props;\n        return (jsx(Row, { layouts: layouts, layout: layout, transformedLayout: this.finalLayout, isMultiRow: this.finalLayout !== layout || this.numOfRows > 1 }));\n    }\n    render() {\n        var _a, _b;\n        const { layout, className } = this.props;\n        const layoutSetting = (_a = layout.setting) !== null && _a !== void 0 ? _a : DEFAULT_ROW_LAYOUT_SETTING;\n        const style = (_b = layoutSetting.style) !== null && _b !== void 0 ? _b : DEFAULT_ROW_LAYOUT_SETTING.style;\n        this.transform();\n        return (jsx(\"div\", { className: classNames('layout d-flex', className), css: css `\r\n          width: 100%;\r\n          padding: ${styleUtils.toCSSPadding(style.padding)};\r\n        `, \"data-layoutid\": layout.id, ref: this.layoutConRef },\n            this.createRow(),\n            jsx(ReactResizeDetector, { handleHeight: true, onResize: this.handleDebounceResize, targetRef: this.layoutConRef })));\n    }\n}\nexport default ReactRedux.connect(utils.mapStateToLayoutProps)(RowLayout);\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css } from 'jimu-core';\nimport { Button } from 'jimu-ui';\nimport LayoutItem from '../../runtime/layout-item';\nimport { MaxgridOutlined } from 'jimu-icons/outlined/application/maxgrid';\nimport { CloseOutlined } from 'jimu-icons/outlined/editor/close';\nimport * as commonUtils from '../common/utils';\nconst style = css `\r\n  & > .max-grid-item-btn {\r\n    display: none;\r\n    background: var(--ref-palette-neutral-500);\r\n    width: 26px;\r\n    height: 26px;\r\n    position: absolute;\r\n    top: 0;\r\n    right: 0;\r\n  }\r\n\r\n  &:hover > .max-grid-item-btn {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n  }\r\n`;\nconst maximizedStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  top: 0;\r\n  width: 100% !important;\r\n  height: 100% !important;\r\n  z-index: 30;\r\n  background: var(--ref-palette-neutral-200);\r\n`;\nexport function GridLayoutItem(props) {\n    const [maximized, setMaximized] = React.useState(false);\n    const expandable = ReactRedux.useSelector((state) => {\n        return commonUtils.isExpandable(state, props.layoutId, props.layoutItemId);\n    });\n    const toggleMaximize = React.useCallback(() => {\n        setMaximized(!maximized);\n    }, [maximized]);\n    return (jsx(LayoutItem, Object.assign({}, props, { css: css `${style};${maximized ? maximizedStyle : ''}` }), expandable && (jsx(Button, { icon: true, type: 'tertiary', className: 'max-grid-item-btn p-0', onClick: toggleMaximize },\n        maximized && jsx(CloseOutlined, null),\n        !maximized && jsx(MaxgridOutlined, null)))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, classNames, moduleLoader, getAppStore, AnimationContext, ParentAnimationMode, GridItemType, hooks } from 'jimu-core';\nimport { Tabs, Tab, defaultMessages } from 'jimu-ui';\nimport { GridLayoutItem } from './layout-item';\nimport { Splitter } from '../common/splitter';\nimport { indexOfPlainContent, isLastChildOfRootItem, getGridItem, getLabelOfGridTab } from '../common/utils';\nexport function GridItemComponent(props) {\n    const { layout, layoutItemId, isLast, className } = props;\n    const layoutItem = React.useMemo(() => {\n        return getGridItem(layout, layoutItemId);\n    }, [layout, layoutItemId]);\n    const parentType = React.useMemo(() => {\n        if (layoutItem.parent) {\n            const parentItem = getGridItem(layout, layoutItem.parent);\n            return parentItem.gridType;\n        }\n        return null;\n    }, [layout, layoutItem]);\n    const size = +layoutItem.bbox.width;\n    const animationContext = React.useContext(AnimationContext);\n    const interval = React.useMemo(() => {\n        var _a, _b;\n        if (((_b = (_a = animationContext === null || animationContext === void 0 ? void 0 : animationContext.setting) === null || _a === void 0 ? void 0 : _a.option) === null || _b === void 0 ? void 0 : _b.parentMode) === ParentAnimationMode.AllAtOnce) {\n            return 0;\n        }\n        return 250;\n    }, [animationContext]);\n    const getStyle = React.useCallback(() => {\n        if (parentType === GridItemType.Row) {\n            return css `\r\n        height: 100%;\r\n        width: ${size}%;\r\n      `;\n        }\n        if (parentType === GridItemType.Column) {\n            return css `\r\n        width: 100%;\r\n        height: ${size}%;\r\n      `;\n        }\n        return css `\r\n      width: 100%;\r\n      height: 100%;\r\n    `;\n    }, [size, parentType]);\n    if (layoutItem.gridType === GridItemType.Row) {\n        return (jsx(RowContainer, { className: className, css: getStyle(), layout: layout, layoutItemId: layoutItemId, items: layoutItem.children }));\n    }\n    if (layoutItem.gridType === GridItemType.Column) {\n        return (jsx(ColContainer, { className: className, css: getStyle(), layout: layout, layoutItemId: layoutItemId, items: layoutItem.children }));\n    }\n    if (layoutItem.gridType === GridItemType.Tab) {\n        return (jsx(TabContainer, { className: className, css: getStyle(), layout: layout, layoutItemId: layoutItemId, items: layoutItem.children }));\n    }\n    const idx = indexOfPlainContent(layout, layoutItemId);\n    const isLastChild = isLastChildOfRootItem(layout, layoutItemId);\n    return (jsx(GridLayoutItem, { css: getStyle(), className: classNames(`d-flex ${className}`, { 'is-last': isLast }), layoutId: layout.id, layoutItemId: layoutItemId, delay: idx * interval, isLastChild: isLastChild }));\n}\nfunction RowContainer(props) {\n    const { layout, layoutItemId, items, className } = props;\n    const getAppConfigActionFnRef = React.useRef();\n    hooks.useEffectOnce(() => {\n        import('jimu-for-builder').then((m) => {\n            getAppConfigActionFnRef.current = m.getAppConfigAction;\n        });\n    });\n    const handleResizeEnd = hooks.useEventCallback((id, dx) => {\n        const appConfigAction = getAppConfigActionFnRef.current();\n        const index = items.indexOf(id);\n        const nextId = items[index + 1];\n        const layoutItem = layout.content[id];\n        const nextLayoutItem = layout.content[nextId];\n        appConfigAction.editLayoutItemProperty({\n            layoutId: layout.id,\n            layoutItemId: id\n        }, 'bbox', { width: +layoutItem.bbox.width + dx }).editLayoutItemProperty({\n            layoutId: layout.id,\n            layoutItemId: nextId\n        }, 'bbox', { width: +nextLayoutItem.bbox.width - dx }).exec();\n    });\n    const createItem = (itemId, isLast) => {\n        return (jsx(React.Fragment, { key: itemId },\n            jsx(GridItemComponent, { key: itemId, layout: layout, layoutItemId: itemId }),\n            !isLast && (jsx(Splitter, { referenceItemId: itemId, layoutId: layout.id, direction: 'row', onResizeEnd: handleResizeEnd }))));\n    };\n    return (jsx(\"div\", { className: `d-flex ${className}`, css: css `\r\n        .is-last {\r\n          width: auto;\r\n          flex-grow: 1;\r\n          flex-shrink: 1;\r\n          flex-basis: 0;\r\n        }\r\n      `, \"data-layoutid\": layout.id, \"data-layoutitemid\": layoutItemId }, items.map((item, index) => createItem(item, index === items.length - 1))));\n}\nfunction ColContainer(props) {\n    const { layout, layoutItemId, items, className } = props;\n    const getAppConfigActionFnRef = React.useRef();\n    hooks.useEffectOnce(() => {\n        import('jimu-for-builder').then((m) => {\n            getAppConfigActionFnRef.current = m.getAppConfigAction;\n        });\n    });\n    const handleResizeEnd = hooks.useEventCallback((id, dx, dy) => {\n        const appConfigAction = getAppConfigActionFnRef.current();\n        const index = items.indexOf(id);\n        const nextId = items[index + 1];\n        const layoutItem = layout.content[id];\n        const nextLayoutItem = layout.content[nextId];\n        appConfigAction.editLayoutItemProperty({\n            layoutId: layout.id,\n            layoutItemId: id\n        }, 'bbox', { width: +layoutItem.bbox.width + dy }).editLayoutItemProperty({\n            layoutId: layout.id,\n            layoutItemId: nextId\n        }, 'bbox', { width: +nextLayoutItem.bbox.width - dy }).exec();\n    });\n    const createItem = (itemId, isLast) => {\n        return (jsx(React.Fragment, { key: itemId },\n            jsx(GridItemComponent, { key: itemId, layout: layout, layoutItemId: itemId }),\n            !isLast && (jsx(Splitter, { referenceItemId: itemId, layoutId: layout.id, direction: 'col', onResizeEnd: handleResizeEnd }))));\n    };\n    return (jsx(\"div\", { className: `d-flex flex-column ${className}`, css: css `\r\n        .is-last {\r\n          height: auto;\r\n          flex-grow: 1;\r\n          flex-shrink: 1;\r\n          flex-basis: 0;\r\n        }\r\n      `, \"data-layoutid\": layout.id, \"data-layoutitemid\": layoutItemId }, items.map((item, index) => createItem(item, index === items.length - 1))));\n}\nfunction TabContainer(props) {\n    const { layout, layoutItemId, items, className } = props;\n    const translate = hooks.useTranslation(defaultMessages);\n    const getLabel = (itemId) => {\n        const appConfig = getAppStore().getState().appConfig;\n        return getLabelOfGridTab(appConfig, { layoutId: layout.id, layoutItemId: itemId }, translate);\n    };\n    const createItem = (itemId, index) => {\n        return (jsx(Tab, { key: index, id: `${index}`, title: getLabel(itemId) },\n            jsx(GridItemComponent, { layout: layout, layoutItemId: itemId })));\n    };\n    return (jsx(\"div\", { className: className, \"data-layoutid\": layout.id, \"data-layoutitemid\": layoutItemId },\n        jsx(Tabs, { type: 'tabs', fill: true, scrollable: true, className: 'w-100 h-100', css: css `\r\n          & > .tab-content {\r\n            overflow: hidden;\r\n          }\r\n        ` }, [...items].map((item, index) => createItem(item, index)))));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, classNames, jsx, css, OneByOneAnimation, ExtensionManager, extensionSpec, LayoutType, IntersectionContext } from 'jimu-core';\nimport { mapStateToLayoutProps } from '../../utils';\nimport { GridItemComponent } from './grid-item';\nimport { calPaddingStyle } from '../common/utils';\nclass GridLayout extends React.PureComponent {\n    findExtension() {\n        const exts = ExtensionManager.getInstance().getExtensions(\n        //eslint-disable-next-line @typescript-eslint/no-unnecessary-template-expression\n        `${extensionSpec.ExtensionPoints.LayoutTransformer}`);\n        if ((exts === null || exts === void 0 ? void 0 : exts.length) > 0) {\n            const ext = exts.find(item => item.layoutType === LayoutType.GridLayout);\n            this.layoutTransform = ext === null || ext === void 0 ? void 0 : ext.transformLayout;\n        }\n    }\n    render() {\n        var _a, _b;\n        const { layouts, layout, browserSizeMode, mainSizeMode, className } = this.props;\n        const viewOnly = layouts[browserSizeMode] !== layout.id;\n        let finalLayout = layout;\n        if (viewOnly) {\n            if (this.layoutTransform == null) {\n                this.findExtension();\n            }\n            if (this.layoutTransform != null) {\n                finalLayout = this.layoutTransform(layout, mainSizeMode, browserSizeMode);\n            }\n        }\n        const { rootItem: rootItemId } = (_a = finalLayout.setting) !== null && _a !== void 0 ? _a : {};\n        const rootItem = (_b = finalLayout.content) === null || _b === void 0 ? void 0 : _b[rootItemId];\n        const outClass = classNames('layout grid-layout d-flex w-100 h-100', className);\n        return (jsx(\"div\", { className: outClass, css: css `overflow: hidden;${calPaddingStyle(finalLayout.setting)}`, \"data-layoutid\": finalLayout.id },\n            jsx(IntersectionContext.Provider, { value: { monitor: false } },\n                jsx(OneByOneAnimation, { oid: finalLayout.id, \"data-layoutid\": finalLayout.id, className: 'trail-container d-flex w-100 h-100', css: css `\r\n              width: 100%;\r\n            ` }, rootItem\n                    ? jsx(GridItemComponent, { className: 'w-100 h-100', layout: finalLayout, layoutItemId: rootItemId })\n                    : this.props.children))));\n    }\n}\nexport default ReactRedux.connect(mapStateToLayoutProps)(GridLayout);\n","/** @jsx jsx */\nimport { React, jsx, css, classNames, hooks, ReactRedux, LayoutItemType } from 'jimu-core';\nimport { Button, Icon, styleUtils } from 'jimu-ui';\nimport { ItemTitle } from '../common/item-title';\nimport * as layoutUtils from '../../utils';\nimport * as searchUtils from '../../search';\nconst getStyle = (height, gap, headerConfig, panelConfig) => {\n    const config = headerConfig !== null && headerConfig !== void 0 ? headerConfig : {};\n    const pConfig = panelConfig !== null && panelConfig !== void 0 ? panelConfig : {};\n    const { padding, expandedColor, collapsedColor, border, borderLeft, borderRight, borderTop, borderBottom, borderRadius } = config;\n    const { padding: panelPadding, border: panelBorder, borderRadius: panelBD, backgroundColor } = pConfig;\n    return css `\r\n  position: relative;\r\n  touch-action: none;\r\n  user-select: none;\r\n  & + .foldable-panel {\r\n    margin-top: ${gap}px;\r\n  }\r\n  .panel-header {\r\n    padding: ${styleUtils.toCSSPadding(padding)};\r\n    border: ${styleUtils.toCSSBorder(border)};\r\n    border-left: ${styleUtils.toCSSBorder(borderLeft)};\r\n    border-right: ${styleUtils.toCSSBorder(borderRight)};\r\n    border-top: ${styleUtils.toCSSBorder(borderTop)};\r\n    border-bottom: ${styleUtils.toCSSBorder(borderBottom)};\r\n    border-radius: ${styleUtils.toCSSBorderRadius(borderRadius)};\r\n    background-color: ${expandedColor !== null && expandedColor !== void 0 ? expandedColor : 'var(--sys-color-primary-main)'};\r\n    .tool-drag-handler {\r\n      cursor: pointer;\r\n      flex-grow: 1;\r\n      flex-shrink: 1;\r\n    }\r\n  }\r\n  .panel-content {\r\n    padding: ${styleUtils.toCSSPadding(panelPadding)};\r\n    border: ${styleUtils.toCSSBorder(panelBorder)};\r\n    border-left: ${styleUtils.toCSSBorder(pConfig.borderLeft)};\r\n    border-right: ${styleUtils.toCSSBorder(pConfig.borderRight)};\r\n    border-top: ${styleUtils.toCSSBorder(pConfig.borderTop)};\r\n    border-bottom: ${styleUtils.toCSSBorder(pConfig.borderBottom)};\r\n    border-radius: ${styleUtils.toCSSBorderRadius(panelBD)};\r\n    overflow: auto;\r\n    background-color: ${backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : 'none'};\r\n    position: relative;\r\n    height: ${height};\r\n    opacity: 1;\r\n    transition: opacity 400ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;\r\n  }\r\n  &.collapsed {\r\n    .panel-header {\r\n      background-color: ${collapsedColor !== null && collapsedColor !== void 0 ? collapsedColor : 'var(--sys-color-primary-main)'};\r\n    }\r\n    .panel-content {\r\n      height: 0;\r\n      padding: unset;\r\n      border: none;\r\n      visibility: hidden;\r\n      .layout-item {\r\n        display: none;\r\n      }\r\n    }\r\n  }\r\n  `;\n};\nexport function Panel(props) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n    const { layoutId, layoutItemId, expanded, height, gap, onExpandedChange } = props;\n    const translate = hooks.useTranslation();\n    const layoutItem = ReactRedux.useSelector((state) => {\n        return searchUtils.findLayoutItem(state.appConfig, { layoutId, layoutItemId });\n    });\n    const label = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        if (layoutItem.type === LayoutItemType.Widget) {\n            const widgetId = layoutItem.widgetId;\n            const widgetJson = state.appConfig.widgets[widgetId];\n            return (_a = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.label) !== null && _a !== void 0 ? _a : '';\n        }\n        const sectionId = layoutItem.sectionId;\n        const sectionJson = state.appConfig.sections[sectionId];\n        return (_b = sectionJson === null || sectionJson === void 0 ? void 0 : sectionJson.label) !== null && _b !== void 0 ? _b : '';\n    });\n    const headerConfig = ReactRedux.useSelector((state) => {\n        var _a;\n        const layoutJson = state.appConfig.layouts[layoutId];\n        const parentWidgetId = layoutJson.parent.id;\n        const widgetJson = state.appConfig.widgets[parentWidgetId];\n        return (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.header;\n    });\n    const panelConfig = ReactRedux.useSelector((state) => {\n        var _a;\n        const layoutJson = state.appConfig.layouts[layoutId];\n        const parentWidgetId = layoutJson.parent.id;\n        const widgetJson = state.appConfig.widgets[parentWidgetId];\n        return (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.panel;\n    });\n    const isFunctionalWidget = ReactRedux.useSelector((state) => {\n        if (layoutItem.type === LayoutItemType.Widget) {\n            return layoutUtils.isFunctionalWidget(layoutItem.widgetId, state.appConfig);\n        }\n        return false;\n    });\n    const togglePosition = (_a = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.togglePosition) !== null && _a !== void 0 ? _a : 'right';\n    const toggleCollapse = React.useCallback(() => {\n        onExpandedChange(layoutItemId, !expanded);\n    }, [layoutItemId, expanded, onExpandedChange]);\n    const icon = expanded ? (_b = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.collapseIcon) === null || _b === void 0 ? void 0 : _b.svg : (_c = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.expandIcon) === null || _c === void 0 ? void 0 : _c.svg;\n    return (jsx(\"div\", { className: classNames('layout-item foldable-panel', {\n            collapsed: !expanded,\n            'functional-widget': isFunctionalWidget\n        }), \"data-layoutid\": layoutId, \"data-layoutitemid\": layoutItemId, css: getStyle(height, gap, headerConfig, panelConfig) },\n        jsx(\"div\", { className: 'panel d-flex flex-column' },\n            jsx(\"div\", { className: classNames('panel-header d-flex align-items-center', { 'flex-row-reverse': togglePosition === 'left' }), onClick: toggleCollapse, onKeyDown: null, role: 'group', \"aria-label\": label },\n                jsx(\"div\", { className: 'tool-drag-handler' }, layoutId && layoutItemId && jsx(ItemTitle, { layoutId: layoutId, layoutItemId: layoutItemId })),\n                icon && (jsx(\"div\", { className: classNames('actions', { 'ml-auto': togglePosition === 'right' }) },\n                    jsx(Button, { icon: true, type: 'tertiary', size: 'sm', \"aria-expanded\": expanded, title: translate(expanded ? 'clickToHide' : 'clickToShow'), \"aria-label\": translate(expanded ? 'clickToHide' : 'clickToShow') },\n                        jsx(Icon, { icon: icon, size: expanded\n                                ? (_e = (_d = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.collapseIcon) === null || _d === void 0 ? void 0 : _d.properties) === null || _e === void 0 ? void 0 : _e.size\n                                : (_g = (_f = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.expandIcon) === null || _f === void 0 ? void 0 : _f.properties) === null || _g === void 0 ? void 0 : _g.size, color: expanded\n                                ? (_j = (_h = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.collapseIcon) === null || _h === void 0 ? void 0 : _h.properties) === null || _j === void 0 ? void 0 : _j.color\n                                : (_l = (_k = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.expandIcon) === null || _k === void 0 ? void 0 : _k.properties) === null || _l === void 0 ? void 0 : _l.color }))))),\n            jsx(\"div\", { className: classNames('panel-content d-flex flex-grow-1 flex-shrink-1') }, props.children))));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, classNames, jsx, css, OneByOneAnimation, IntersectionContext } from 'jimu-core';\nimport { styleUtils } from 'jimu-ui';\nimport { mapStateToLayoutProps } from '../../utils';\nimport { DEFAULT_FLEX_ROW_LAYOUT_SETTING } from '../default-setting';\nimport { FlexRowItem } from './layout-item';\nimport { getLayoutStyle } from '../common/style';\nclass Layout extends React.PureComponent {\n    createItem(itemId, index) {\n        const { layout } = this.props;\n        return (jsx(FlexRowItem, { key: itemId, index: index, layoutId: layout.id, layoutItemId: itemId, layoutItem: layout.content[itemId] }));\n    }\n    isEmpty() {\n        var _a;\n        const { layout } = this.props;\n        const content = (_a = layout.order) !== null && _a !== void 0 ? _a : [];\n        const hasSomethingToRender = content.length > 0 && content.some(id => {\n            const layoutItem = layout.content[id];\n            return !layoutItem.isPending;\n        });\n        return !hasSomethingToRender;\n    }\n    render() {\n        var _a;\n        const { layout, className } = this.props;\n        const content = (_a = layout.order) !== null && _a !== void 0 ? _a : [];\n        const layoutSetting = Object.assign({}, DEFAULT_FLEX_ROW_LAYOUT_SETTING, layout.setting);\n        const isEmpty = this.isEmpty();\n        const mergedStyle = {\n            position: 'relative',\n            minWidth: layoutSetting.min\n        };\n        const outClass = classNames('layout flex-row-layout', className);\n        return (jsx(\"div\", { className: outClass, style: mergedStyle, \"data-layoutid\": layout.id },\n            jsx(IntersectionContext.Provider, { value: { monitor: true, layoutId: layout.id } },\n                jsx(OneByOneAnimation, { oid: layout.id, className: 'trail-container d-flex w-100', css: css `\r\n              position: ${isEmpty ? 'absolute' : null};\r\n              padding: ${styleUtils.toCSSPadding(layoutSetting.padding)};\r\n              ${getLayoutStyle(layoutSetting)};\r\n            ` }, content.map((layoutItem, index) => this.createItem(layoutItem, index))))));\n    }\n}\nexport default ReactRedux.connect(mapStateToLayoutProps)(Layout);\n","/** @jsx jsx */\nimport { React, ReactRedux, classNames, lodash, getAppStore, jsx, css } from 'jimu-core';\nimport { handleOnebyOneAnimation, isRTL } from '../../utils';\nimport { DEFAULT_FLOW_ITEM_SETTING } from '../default-setting';\nimport { mapStateToFlowItemProps, getWidthFromSetting } from '../layout-utils';\nimport LayoutItem from '../../runtime/layout-item';\nimport * as utils from '../common/util';\nclass FlowLayoutItem extends React.PureComponent {\n    componentDidMount() {\n        var _a;\n        const queryObject = (_a = getAppStore().getState().queryObject) !== null && _a !== void 0 ? _a : {};\n        const { layoutId, layoutItem } = this.props;\n        const domId = `${layoutId}_block_${layoutItem.id}`;\n        if (queryObject.block_id === domId) {\n            const dom = document.getElementById(domId);\n            setTimeout(() => {\n                dom.scrollIntoView({ behavior: 'smooth', block: 'start' });\n            }, 500);\n        }\n    }\n    calHeight(itemSetting) {\n        const height = utils.calHeight(this.props.layoutItem, itemSetting);\n        this.autoHeight = height === 'auto';\n        return height;\n    }\n    getStyle(itemSetting) {\n        const { index, gutter } = this.props;\n        const sign = isRTL() ? -1 : 1;\n        return [\n            css `\r\n        margin-top: ${index > 0 ? `${gutter}px` : 'unset'};\r\n        width: ${getWidthFromSetting(itemSetting)};\r\n        height: ${this.calHeight(itemSetting)};\r\n        flex-shrink: 0;\r\n      `,\n            itemSetting.offsetX || itemSetting.offsetY ? `translate(${(itemSetting.offsetX || 0) * sign}px, ${itemSetting.offsetY || 0}px)` : null\n        ];\n    }\n    render() {\n        const { layoutId, layoutItem, onClick, isEmpty } = this.props;\n        if (!layoutItem || isEmpty) {\n            return null;\n        }\n        const mergedClass = classNames('flow-layout-item', 'd-flex');\n        const itemSetting = lodash.assign({}, DEFAULT_FLOW_ITEM_SETTING, layoutItem.setting);\n        const oneByOneAnimationProps = handleOnebyOneAnimation(this.props);\n        const [cssStyle, transform] = this.getStyle(itemSetting);\n        return (jsx(LayoutItem, Object.assign({ id: `${layoutId}_block_${layoutItem.id}`, css: cssStyle, style: { transform }, layoutId: layoutId, layoutItemId: layoutItem.id, onClick: onClick, className: mergedClass, autoHeight: this.autoHeight }, oneByOneAnimationProps)));\n    }\n}\nexport default ReactRedux.connect(mapStateToFlowItemProps)(FlowLayoutItem);\n","/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, getAppStore, appActions, ScreenTransitionType, ScreenTriggerType, classNames, BrowserSizeMode, ReactResizeDetector, lodash } from 'jimu-core';\nimport { ScreenMainPanelList, ScreenSidePanel } from '../common';\nimport LayoutEntry from '../../runtime/layout-entry';\nimport { SCREEN_RATIO_IN_SMALL_SIZE, DEFAULT_HEADER_HEIGHT } from '../common/type';\nimport { updateScreenHeight } from '../common/util';\nimport { PageContext } from '../../builder/page-context';\nfunction getStyle(transitionType, isOverlay) {\n    return css `\r\n    position: relative;\r\n    width: 100%;\r\n\r\n    .main-panels {\r\n      position: absolute;\r\n      left: 0;\r\n      right: 0;\r\n      top: 0;\r\n      bottom: 0;\r\n      pointer-events: none;\r\n      z-index: 0;\r\n    }\r\n\r\n    .side-panels {\r\n      position: relative;\r\n      z-index: 1;\r\n      pointer-events: none;\r\n\r\n      > div:first-of-type > div.panel-content {\r\n        padding-top: ${Math.round(100 * SCREEN_RATIO_IN_SMALL_SIZE)}vh;\r\n        padding-top: calc(var(--vh) * ${Math.round(100 * SCREEN_RATIO_IN_SMALL_SIZE)});\r\n      }\r\n\r\n      /* > div:nth-last-of-type(2) {\r\n        min-height: 100vh;\r\n      } */\r\n    }\r\n\r\n    &.small-size .main-panels {\r\n      z-index: ${isOverlay ? 0 : 1};\r\n    }\r\n\r\n    &.small-size .side-panels {\r\n      z-index: ${isOverlay ? 1 : 0};\r\n    }\r\n\r\n    &.print-preview {\r\n      .screen-container {\r\n        height: auto;\r\n        position: relative;\r\n\r\n        .screen-main-panel {\r\n          position: relative;\r\n          opacity: 1 !important;\r\n        }\r\n      }\r\n      .screen-side-panel {\r\n        min-height: calc(var(--vh) * 100);\r\n        opacity: 1 !important;\r\n        .panel-spacing {\r\n          display: none;\r\n        }\r\n      }\r\n      .screen-placeholder {\r\n        display: none;\r\n      }\r\n    }\r\n  `;\n}\nexport function ScreenGroup(props) {\n    var _a;\n    const { layoutId, layoutItemId, layoutItem } = props;\n    const { screenGroupId } = layoutItem;\n    const screenGroup = ReactRedux.useSelector((state) => {\n        return state.appConfig.screenGroups[layoutItem.screenGroupId];\n    });\n    const isPrintPreview = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        return (_b = (_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.isPrintPreview) !== null && _b !== void 0 ? _b : false;\n    });\n    const hasPanel = ReactRedux.useSelector((state) => {\n        // screen with panel and without panel can be mixed\n        const screenIds = state.appConfig.screenGroups[layoutItem.screenGroupId].screens;\n        return screenIds.some(screenId => {\n            const screen = state.appConfig.screens[screenId];\n            return screen.panel != null;\n        });\n    });\n    const browserSizeMode = ReactRedux.useSelector((state) => {\n        return state.browserSizeMode;\n    });\n    const { pageId } = React.useContext(PageContext);\n    const headerHeight = ReactRedux.useSelector((state) => {\n        const pageJson = state.appConfig.pages[pageId];\n        if (pageJson === null || pageJson === void 0 ? void 0 : pageJson.header) {\n            const headerJson = state.appConfig.header;\n            if (headerJson === null || headerJson === void 0 ? void 0 : headerJson.sticky) {\n                const browserSizeMode = state.browserSizeMode;\n                const mainSizeMode = state.appConfig.mainSizeMode;\n                const height = headerJson.height[browserSizeMode] || headerJson.height[mainSizeMode] || DEFAULT_HEADER_HEIGHT;\n                return parseInt(height, 10);\n            }\n        }\n        return 0;\n    });\n    const { screens, stretchPanel = true, triggerType = ScreenTriggerType.Bottom, verticalSpace = '0', panelTransitionType = ScreenTransitionType.Push } = screenGroup;\n    let transitionType = isPrintPreview ? null : ((_a = screenGroup.transitionType) !== null && _a !== void 0 ? _a : ScreenTransitionType.Fade);\n    if (!isPrintPreview && browserSizeMode === BrowserSizeMode.Small && !hasPanel) {\n        transitionType = ScreenTransitionType.Cover;\n    }\n    const navInfo = ReactRedux.useSelector((state) => {\n        var _a;\n        return (_a = state.appRuntimeInfo.screenGroupNavInfos) === null || _a === void 0 ? void 0 : _a[screenGroupId];\n    });\n    const domRef = React.useRef();\n    const sidePanelRef = React.useRef();\n    const screenGroupRef = React.useRef();\n    const mainPanelRef = React.useRef();\n    const [activeIndex, setActiveIndex] = React.useState(0);\n    const isOverlay = React.useMemo(() => {\n        var _a, _b, _c;\n        if (browserSizeMode !== BrowserSizeMode.Small) {\n            return false;\n        }\n        const appConfig = getAppStore().getState().appConfig;\n        const screens = (_b = (_a = appConfig.screenGroups) === null || _a === void 0 ? void 0 : _a[screenGroupId]) === null || _b === void 0 ? void 0 : _b.screens;\n        if (screens === null || screens === void 0 ? void 0 : screens[activeIndex]) {\n            const screen = appConfig.screens[screens[activeIndex]];\n            return (_c = screen.panel) === null || _c === void 0 ? void 0 : _c.overlay;\n        }\n        return false;\n    }, [screenGroupId, activeIndex, browserSizeMode]);\n    React.useEffect(() => {\n        if ((navInfo === null || navInfo === void 0 ? void 0 : navInfo.activeIndex) != null && navInfo.activeIndex !== activeIndex) {\n            setActiveIndex(navInfo.activeIndex);\n        }\n    }, [navInfo, activeIndex]);\n    const onInteractionChange = React.useCallback((index, isIntersecting) => {\n        if (isIntersecting && index !== activeIndex) {\n            getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenGroupId, index, false));\n        }\n        else if (!isIntersecting && index > 0) {\n            getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenGroupId, index - 1, false));\n        }\n    }, [activeIndex, screenGroupId]);\n    const sidepanelResizeHandler = React.useCallback(() => {\n        if (!screenGroupRef.current) {\n            return;\n        }\n        const mainPanelContainer = screenGroupRef.current.children[0];\n        const sidePanelContainer = screenGroupRef.current.children[1];\n        // Sync the height between main panel and side panel\n        const count = sidePanelContainer.childElementCount;\n        for (let i = 0; i < count; i++) {\n            const elem = sidePanelContainer.children[i];\n            const screenId = elem.getAttribute('data-screenid');\n            const mainPanelElem = mainPanelContainer.querySelector(`[data-screenid=\"${screenId}\"]`);\n            if (mainPanelElem) {\n                if (isPrintPreview) {\n                    mainPanelElem.style.height = `${elem.clientHeight}px`;\n                }\n                else {\n                    mainPanelElem.style.height = null;\n                }\n            }\n        }\n        mainPanelContainer.style.height = `${sidePanelContainer.clientHeight}px`;\n    }, [isPrintPreview]);\n    const debounceResizeHandler = React.useMemo(() => lodash.debounce(sidepanelResizeHandler, 200), [sidepanelResizeHandler]);\n    const onSidePanelHeightChange = React.useCallback((index, height) => {\n        if (!screenGroupRef.current) {\n            return;\n        }\n        const mainPanelContainer = screenGroupRef.current.children[0];\n        const sidePanelContainer = screenGroupRef.current.children[1];\n        if (transitionType === ScreenTransitionType.Fade) {\n            mainPanelContainer.style.height = `${sidePanelContainer.clientHeight}px`;\n            return;\n        }\n        if (transitionType === ScreenTransitionType.Cover) {\n            updateScreenHeight(mainPanelContainer, sidePanelContainer, browserSizeMode);\n            return;\n        }\n        if (transitionType === ScreenTransitionType.Push) {\n            const relatedElement = mainPanelContainer.querySelector(`div.screen-main-panel[data-index=\"${index}\"]`);\n            const panelElement = sidePanelContainer.querySelector(`div.screen-side-panel[data-index=\"${index}\"]`);\n            relatedElement.style.height = `${panelElement.clientHeight}px`;\n            mainPanelContainer.style.height = `${sidePanelContainer.clientHeight}px`;\n        }\n    }, [browserSizeMode, transitionType]);\n    if (screens.length > 0) {\n        return (jsx(\"div\", { className: classNames('flow-layout-item', { 'print-preview': isPrintPreview, 'small-size': browserSizeMode === BrowserSizeMode.Small }), css: getStyle(transitionType, isOverlay), \"data-layoutitemid\": layoutItemId, \"data-layoutid\": layoutId, ref: domRef },\n            jsx(\"div\", { className: 'screen-group', ref: screenGroupRef },\n                jsx(\"div\", { className: 'main-panels', ref: mainPanelRef },\n                    jsx(ScreenMainPanelList, { rootLayoutId: layoutId, activeIndex: activeIndex, screens: screens, transitionType: transitionType, layoutEntry: LayoutEntry, headerHeight: headerHeight, isSmallSize: browserSizeMode === BrowserSizeMode.Small })),\n                jsx(\"div\", { className: 'side-panels', ref: sidePanelRef },\n                    screens.map((screenId, idx) => {\n                        return (jsx(ScreenSidePanel, { key: screenId, index: idx, isLast: idx === screens.length - 1, screenId: screenId, refElement: null, layoutEntry: LayoutEntry, isActive: idx === activeIndex, stretched: stretchPanel, triggerType: triggerType, verticalSpace: verticalSpace, transitionType: panelTransitionType, screenTransitionType: transitionType, onHeightChange: onSidePanelHeightChange, onInteractionChange: onInteractionChange, isSmallSize: browserSizeMode === BrowserSizeMode.Small, headerHeight: headerHeight }));\n                    }),\n                    jsx(ReactResizeDetector, { targetRef: sidePanelRef, handleHeight: true, onResize: debounceResizeHandler })))));\n    }\n    return null;\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, classNames, lodash, ExtensionManager, extensionSpec, LayoutItemType, OneByOneAnimation, IntersectionContext } from 'jimu-core';\nimport { styleUtils } from 'jimu-ui';\nimport LayoutItem from './layout-item';\nimport FloatingLayoutItem from './floating-layout-item';\nimport { ScreenGroup } from './screen-group';\nimport { DEFAULT_FLOW_SETTING } from '../default-setting';\nimport { mapStateToLayoutProps } from '../../utils';\nclass Layout extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-template-expression\n        const exts = ExtensionManager.getInstance().getExtensions(`${extensionSpec.ExtensionPoints.LayoutTransformer}`);\n        if (exts && exts.length > 0) {\n            const ext = exts.find(item => item.layoutType === this.props.layout.type);\n            this.layoutTransform = ext === null || ext === void 0 ? void 0 : ext.transformLayout;\n        }\n    }\n    _createItem(item, index, layoutSetting) {\n        var _a;\n        const { layout } = this.props;\n        if (item === null || item === void 0 ? void 0 : item.isPending) {\n            return null;\n        }\n        if (item.type === LayoutItemType.ScreenGroup) {\n            return (jsx(ScreenGroup, { key: `${item.id}_${index}`, itemIndex: index, layoutId: layout.id, layoutItemId: item.id, layoutItem: item }));\n        }\n        if ((_a = item.setting) === null || _a === void 0 ? void 0 : _a.isFloating) {\n            return (jsx(FloatingLayoutItem, { key: item.id, index: index, gutter: layoutSetting.gutter, layoutId: layout.id, layoutItemId: item.id, layoutItem: item }));\n        }\n        return (jsx(LayoutItem, { key: item.id, index: index, gutter: layoutSetting.gutter, layoutId: layout.id, layoutItemId: item.id, layoutItem: item }));\n    }\n    render() {\n        const { layout, className, style, layouts, browserSizeMode } = this.props;\n        if (!layout) {\n            return null;\n        }\n        let targetLayout = layout;\n        if (layouts[browserSizeMode] !== layout.id && this.layoutTransform) {\n            let fromSizeMode;\n            Object.keys(layouts).some(mode => {\n                if (layouts[mode] === layout.id) {\n                    fromSizeMode = mode;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            });\n            targetLayout = this.layoutTransform(layout, fromSizeMode, browserSizeMode);\n        }\n        const content = targetLayout.order || [];\n        const layoutSetting = lodash.assign({}, DEFAULT_FLOW_SETTING, targetLayout.setting);\n        const mergedStyle = Object.assign(Object.assign(Object.assign({}, style), styleUtils.toCSSStyle(layoutSetting.style)), { position: 'relative' });\n        const outClass = classNames('layout flow-layout w-100', className);\n        return (jsx(\"div\", { className: outClass, style: mergedStyle, \"data-layoutid\": layout.id },\n            jsx(IntersectionContext.Provider, { value: { monitor: true } },\n                jsx(OneByOneAnimation, { oid: targetLayout.id, \"data-layoutid\": targetLayout.id, className: 'trail-container d-flex flex-column align-items-center', css: css `\r\n              width: 100%;\r\n            ` }, content.map((layoutItemId, index) => this._createItem(targetLayout.content[layoutItemId], index, layoutSetting))))));\n    }\n}\nexport default ReactRedux.connect(mapStateToLayoutProps)(Layout);\n","/** @jsx jsx */\nimport { React, jsx, css, WidgetManager, ErrorBoundary, ReactRedux, WidgetState, classNames, spring, getAnimationEffect, AnimationType, DEFAULT_ANIMATION_PROPS, lodash, hooks, focusElementInKeyboardMode } from 'jimu-core';\nimport { Loading, LoadingType, PanelHeader, useTrapFocusBySelector } from 'jimu-ui';\nimport { useHandleLastVirtualNodeFocus } from '../util';\nimport upDoubleOutlined from 'jimu-icons/svg/outlined/directional/up-double.svg';\nimport closeOutlined from 'jimu-icons/svg/outlined/editor/close.svg';\nconst { animated, useSpring } = spring;\nconst style = css `\r\n  position: relative;\r\n  display: flex;\r\n  background-color: var(--ref-palette-white);\r\n  box-shadow: 0px 0px 10px 1px rgba(0, 0, 0, 0.2);\r\n  .panel-header {\r\n    > .actions > .action-collapse {\r\n      svg {\r\n        transition: transform 0.3s ease-in-out;\r\n      }\r\n      &.collapsed svg {\r\n        transform: rotate(180deg);\r\n      }\r\n    }\r\n  }\r\n  .panel-content {\r\n    position: relative;\r\n    overflow: hidden;\r\n\r\n    .widget-content {\r\n      z-index: 0;\r\n    }\r\n\r\n    .widget-mask {\r\n      position: absolute;\r\n      background: transparent;\r\n      left: 0;\r\n      right: 0;\r\n      top: 0;\r\n      bottom: 0;\r\n      z-index: 1;\r\n    }\r\n  }\r\n`;\nexport function Panel(props) {\n    const { layoutId, layoutItemId, controllerId, minimized, onClose, onToggle } = props;\n    const [mounted, setMounted] = React.useState(false);\n    const ref = React.useRef();\n    const onCloseRef = hooks.useLatest(onClose);\n    const onToggleRef = hooks.useLatest(onToggle);\n    const translate = hooks.useTranslation();\n    const widgetId = ReactRedux.useSelector((state) => {\n        const layoutItem = state.appConfig.layouts[layoutId].content[layoutItemId];\n        return layoutItem.widgetId;\n    });\n    const isOpen = ReactRedux.useSelector((state) => {\n        var _a;\n        const info = (_a = state.widgetsRuntimeInfo) === null || _a === void 0 ? void 0 : _a[widgetId];\n        return (info === null || info === void 0 ? void 0 : info.state) === WidgetState.Opened;\n    });\n    const label = ReactRedux.useSelector((state) => {\n        const widgetJson = state.appConfig.widgets[widgetId];\n        return widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.label;\n    }, ReactRedux.shallowEqual);\n    const widgetClassLoaded = ReactRedux.useSelector((state) => {\n        var _a;\n        const widgetRuntimeInfo = state.widgetsRuntimeInfo[widgetId];\n        return (_a = widgetRuntimeInfo === null || widgetRuntimeInfo === void 0 ? void 0 : widgetRuntimeInfo.isClassLoaded) !== null && _a !== void 0 ? _a : false;\n    });\n    const effect = ReactRedux.useSelector((state) => {\n        const panelJson = state.appConfig.controllerPanels[controllerId];\n        return panelJson.effect;\n    });\n    const animationObj = React.useMemo(() => {\n        var _a, _b;\n        if ((effect === null || effect === void 0 ? void 0 : effect.type) && effect.type !== AnimationType.None) {\n            return getAnimationEffect(effect.type, {\n                configType: (_a = effect.option) === null || _a === void 0 ? void 0 : _a.configType,\n                direction: (_b = effect.option) === null || _b === void 0 ? void 0 : _b.direction\n            });\n        }\n        return null;\n    }, [effect]);\n    const [effectProps, api] = useSpring(() => {\n        return DEFAULT_ANIMATION_PROPS;\n    }, [animationObj]);\n    const handleClose = React.useCallback((e) => {\n        onCloseRef.current(e, widgetId);\n        // after panel closed, focus back to button\n        const button = document.querySelector(`.widget-controller .avatar-card[data-widgetid='${widgetId}'] button`);\n        if (button) {\n            focusElementInKeyboardMode(button);\n        }\n        else {\n            const moreButton = document.querySelector(`[data-widgetid='${controllerId}'] .popup-more-button button`);\n            focusElementInKeyboardMode(moreButton);\n        }\n    }, [onCloseRef, widgetId, controllerId]);\n    const autoFocus = ReactRedux.useSelector((state) => { var _a; return (_a = state.widgetsState[widgetId]) === null || _a === void 0 ? void 0 : _a.autoFocus; });\n    useTrapFocusBySelector(ref, true, autoFocus, '.first-node', '.last-virtual-node', mounted && isOpen);\n    React.useEffect(() => {\n        if (isOpen && !mounted) { // load the class when this widget is opened the first time\n            setMounted(true);\n            WidgetManager.getInstance()\n                .loadWidgetClass(widgetId)\n                .catch((err) => {\n                console.log(err);\n            });\n        }\n    }, [isOpen, widgetId, mounted]);\n    React.useEffect(() => {\n        if (isOpen && animationObj != null) {\n            api.start(Object.assign(Object.assign({}, animationObj.animateProps()), { onRest: () => {\n                    lodash.defer(() => {\n                        ref.current.style.clipPath = null; // eliminate clipPath to show box-shadow\n                    });\n                } }));\n        }\n    }, [api, isOpen, animationObj]);\n    let WidgetClass;\n    if (mounted && widgetClassLoaded) {\n        WidgetClass = WidgetManager.getInstance().getWidgetClass(widgetId);\n    }\n    const handleLastVirtualNodeFocus = useHandleLastVirtualNodeFocus(ref.current, 'first-node', 'last-virtual-node');\n    const actions = React.useMemo(() => {\n        return [{\n                name: 'collapse',\n                className: minimized ? 'first-node action-collapse collapsed' : 'first-node action-collapse',\n                label: translate(minimized ? 'expand' : 'collapse'),\n                icon: upDoubleOutlined,\n                onClick: onToggleRef.current\n            }, {\n                name: 'close',\n                className: 'action-close',\n                label: translate('close'),\n                icon: closeOutlined,\n                onClick: handleClose\n            }];\n    }, [handleClose, minimized, onToggleRef, translate]);\n    return (jsx(animated.div, { className: classNames('controller-panel flex-column w-100 h-100', { 'd-none': !mounted || !isOpen }), css: style, ref: ref, style: animationObj != null ? effectProps : null },\n        jsx(PanelHeader, { level: 2, type: 'primary', title: label, actions: actions, moveable: false }),\n        jsx(\"div\", { className: 'panel-content d-flex flex-grow-1' },\n            !widgetClassLoaded && jsx(Loading, { type: LoadingType.Donut }),\n            WidgetClass && (jsx(\"div\", { className: 'w-100 h-100 widget-content p-1' },\n                jsx(ErrorBoundary, null,\n                    jsx(WidgetClass, { widgetId: widgetId, layoutId: layoutId, layoutItemId: layoutItemId })))),\n            jsx(\"button\", { className: 'sr-only last-virtual-node', onKeyUp: handleLastVirtualNodeFocus }))));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css, getAppStore, appActions, WidgetState, classNames } from 'jimu-core';\nimport { Panel } from './panel';\nimport { convertToStyle, panelTransformStyle } from '../util';\nexport function ControllerPanel(props) {\n    const { controllerId } = props;\n    const [minimized, setMinimized] = React.useState(false);\n    const innerLayoutId = ReactRedux.useSelector((state) => {\n        // find the layoutInfo of the opened widget\n        const controllerJson = state.appConfig.widgets[controllerId];\n        const layoutName = controllerJson.manifest.layouts[0].name;\n        const sizeModeLayouts = controllerJson.layouts[layoutName];\n        return sizeModeLayouts[state.browserSizeMode] || sizeModeLayouts[state.appConfig.mainSizeMode];\n    });\n    const items = ReactRedux.useSelector((state) => {\n        var _a;\n        // find the items of the opened widget\n        const layout = state.appConfig.layouts[innerLayoutId];\n        // innerLayoutId may be undefined\n        if (!layout) {\n            return '';\n        }\n        const widgetsJson = state.appConfig.widgets;\n        const itemIds = Object.keys((_a = layout.content) !== null && _a !== void 0 ? _a : {})\n            .filter(itemId => {\n            const layoutItem = layout.content[itemId];\n            const widgetJson = widgetsJson[layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.widgetId];\n            return (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.widgetId) != null && !layoutItem.isPending && !(widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.offPanel);\n        });\n        itemIds.sort();\n        return itemIds.join(',');\n    });\n    const hasItemOpened = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        const widgetsJson = state.appConfig.widgets;\n        const openedWidgets = Object.keys((_a = state.widgetsRuntimeInfo) !== null && _a !== void 0 ? _a : {}).filter(widgetId => {\n            var _a;\n            const info = state.widgetsRuntimeInfo[widgetId];\n            return info.state === WidgetState.Opened && !((_a = widgetsJson[widgetId]) === null || _a === void 0 ? void 0 : _a.offPanel);\n        });\n        // find the items of the opened widget\n        const layout = state.appConfig.layouts[innerLayoutId];\n        return Object.keys((_b = layout.content) !== null && _b !== void 0 ? _b : {})\n            .some(itemId => {\n            const layoutItem = layout.content[itemId];\n            return (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.widgetId) != null && !layoutItem.isPending && openedWidgets.includes(layoutItem.widgetId);\n        });\n    });\n    const itemIdList = React.useMemo(() => items.split(',').filter(id => id !== ''), [items]);\n    const panelJson = ReactRedux.useSelector((state) => {\n        return state.appConfig.controllerPanels[controllerId];\n    });\n    const handleClose = React.useCallback((e, widgetId) => {\n        e.stopPropagation();\n        getAppStore().dispatch(appActions.closeWidget(widgetId));\n    }, []);\n    const toggleMinimized = React.useCallback(() => {\n        setMinimized(!minimized);\n    }, [minimized]);\n    const style = React.useMemo(() => css `\r\n    ${convertToStyle(panelJson)}\r\n    height: ${minimized ? '36px' : panelJson === null || panelJson === void 0 ? void 0 : panelJson.height};\r\n    transition: height 0.3s ease-in-out;\r\n    transform: ${panelTransformStyle(panelJson)}\r\n  `, [panelJson, minimized]);\n    if (itemIdList.length === 0) {\n        return null;\n    }\n    return (jsx(\"div\", { className: classNames('panel-container', { 'd-none': !hasItemOpened }), css: style },\n        jsx(React.Fragment, null, itemIdList.map(itemId => (jsx(Panel, { key: itemId, controllerId: controllerId, layoutId: innerLayoutId, layoutItemId: itemId, minimized: minimized, onToggle: toggleMinimized, onClose: handleClose }))))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, PageMode, AnimationContext, AnimationType, BrowserSizeMode, getAppStore, LayoutType, getNextAnimationId } from 'jimu-core';\nimport { PageContext, PageVisibilityContext } from '../builder/page-context';\nimport LayoutEntry from './layout-entry';\nimport * as searchUtils from '../search';\nimport { computePageHeight } from '../common/page-util';\nimport { ControllerPanelGroup } from '../controller-panel/runtime/group';\nexport function PageBody(props) {\n    const { pageJson, visible, pageContext, browserSizeMode, isPrintPreview, headerFooterHeight } = props;\n    const [playId, setPlayId] = React.useState();\n    const layout = pageJson.layout;\n    const pageHeight = React.useMemo(() => {\n        return computePageHeight(pageJson, headerFooterHeight);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [headerFooterHeight]);\n    const oneByOneEffect = !isPrintPreview && pageJson.oneByOneEffect && pageJson.oneByOneEffect.type !== AnimationType.None ? pageJson.oneByOneEffect : null;\n    // const effectType = oneByOneEffect ? (visible ? oneByOneEffect.type : AnimationType.FadeOut) : null;\n    const revert = oneByOneEffect ? (!visible) : null;\n    React.useEffect(() => {\n        if (oneByOneEffect) {\n            setPlayId(getNextAnimationId());\n        }\n    }, [visible, oneByOneEffect]);\n    React.useEffect(() => {\n        var _a;\n        if (visible && layout) {\n            // add scrollable class name to body if page is scrollable\n            const appConfig = getAppStore().getState().appConfig;\n            const layoutId = layout[appConfig.mainSizeMode];\n            const layoutType = (_a = appConfig.layouts[layoutId]) === null || _a === void 0 ? void 0 : _a.type;\n            const htmlNode = document.getElementsByTagName('html')[0];\n            if (layoutType === LayoutType.FlowLayout) {\n                htmlNode.classList.add('scrollable');\n            }\n            else {\n                htmlNode.classList.remove('scrollable');\n            }\n        }\n    }, [visible, layout]);\n    let maxWidth;\n    if (pageJson.mode !== PageMode.FitWindow && pageJson.maxWidth > 0) {\n        maxWidth = pageJson.maxWidth;\n    }\n    const pageContextValue = React.useMemo(() => {\n        const state = getAppStore().getState();\n        let rootLayoutId;\n        if (pageJson.layout) {\n            rootLayoutId = searchUtils.findLayoutId(pageJson.layout, browserSizeMode, state.appConfig.mainSizeMode);\n        }\n        return Object.assign(Object.assign({}, pageContext), { maxWidth, \n            // visible,\n            viewOnly: true, rootLayoutId, pageId: pageJson.id });\n    }, [pageContext, maxWidth, pageJson.id, pageJson.layout, browserSizeMode]);\n    const animationContextValue = React.useMemo(() => {\n        return {\n            setting: oneByOneEffect,\n            revert,\n            playId: oneByOneEffect ? playId : null,\n            oid: pageContextValue.rootLayoutId,\n            onContextAnimationEnd: () => {\n                setPlayId(-1);\n            }\n        };\n    }, [oneByOneEffect, revert, playId, pageContextValue.rootLayoutId]);\n    if (!layout) {\n        return;\n    }\n    return (jsx(PageContext.Provider, { key: pageJson.id, value: pageContextValue },\n        jsx(PageVisibilityContext.Provider, { value: visible },\n            jsx(\"div\", { id: pageJson.id, \"data-pageid\": pageJson.id, className: 'page', css: css `\r\n            display: ${visible ? 'flex' : 'none'};\r\n            background-color: ${pageJson.bodyBackgroundColor || 'transparent'};\r\n            height: ${pageHeight};\r\n            flex: 1 0 auto;\r\n            z-index: 1;\r\n          ` },\n                jsx(AnimationContext.Provider, { value: animationContextValue },\n                    jsx(LayoutEntry, { layouts: layout, className: 'w-100 flex-grow-1', css: css `\r\n                margin: 0 auto;\r\n                background-color: transparent;\r\n                z-index: 0;\r\n              ` })),\n                browserSizeMode !== BrowserSizeMode.Small && jsx(ControllerPanelGroup, { pageId: pageJson.id })))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ReactResizeDetector } from 'jimu-core';\nimport { PageContext, PageVisibilityContext } from '../builder/page-context';\nimport LayoutEntry from './layout-entry';\nexport function PageHeader(props) {\n    var _a, _b, _c, _d;\n    const pageHeaderConRef = React.useRef(null);\n    const { headerJson, browserSizeMode, theme, mainSizeMode, pageContext, onHeightChange } = props;\n    const height = headerJson.height[browserSizeMode] || headerJson.height[mainSizeMode] || 50;\n    const layout = headerJson.layout;\n    let backgroundIMage;\n    if (headerJson.backgroundIMage) {\n        if (typeof (headerJson.backgroundIMage) === 'string') {\n            backgroundIMage = headerJson.backgroundIMage;\n        }\n        else if (typeof (headerJson.backgroundIMage) === 'object') {\n            backgroundIMage = headerJson.backgroundIMage.url;\n        }\n    }\n    const headerStyle = React.useMemo(() => {\n        var _a, _b, _c;\n        return css `\r\n      display: flex;\r\n      position: ${headerJson.sticky ? 'sticky' : 'relative'};\r\n      z-index: ${headerJson.sticky ? 2 : '0'};\r\n      top: 0;\r\n      width: 100%;\r\n      min-height: ${Math.round(parseFloat(height))}px;\r\n      height: auto;\r\n      overflow: hidden;\r\n      background-color: ${headerJson.backgroundColor || ((_a = theme.comp) === null || _a === void 0 ? void 0 : _a.Header.root.vars.bg) || 'transparent'};\r\n      background-image: ${backgroundIMage};\r\n      background-position: ${headerJson.backgroundPosition};\r\n      color: ${(_c = (_b = theme === null || theme === void 0 ? void 0 : theme.comp) === null || _b === void 0 ? void 0 : _b.Header.root.vars) === null || _c === void 0 ? void 0 : _c.color};\r\n      flex: 0 0 auto;\r\n    `;\n    }, [\n        height,\n        headerJson.sticky,\n        headerJson.backgroundColor,\n        backgroundIMage,\n        headerJson.backgroundPosition,\n        (_b = (_a = theme === null || theme === void 0 ? void 0 : theme.comp) === null || _a === void 0 ? void 0 : _a.Header.root.vars) === null || _b === void 0 ? void 0 : _b.bg,\n        (_d = (_c = theme === null || theme === void 0 ? void 0 : theme.comp) === null || _c === void 0 ? void 0 : _c.Header.root.vars) === null || _d === void 0 ? void 0 : _d.color\n    ]);\n    const pageContextValue = React.useMemo(() => {\n        return Object.assign(Object.assign({}, pageContext), { viewOnly: true });\n    }, [pageContext]);\n    const handleSizeChange = React.useCallback(({ width, height }) => {\n        onHeightChange(height);\n    }, [onHeightChange]);\n    return (jsx(PageContext.Provider, { value: pageContextValue },\n        jsx(PageVisibilityContext.Provider, { value: true },\n            jsx(\"div\", { className: 'header', css: headerStyle, ref: pageHeaderConRef },\n                jsx(LayoutEntry, { layouts: layout, className: 'w-100 flex-grow-1' }),\n                jsx(ReactResizeDetector, { targetRef: pageHeaderConRef, handleHeight: true, handleWidth: false, onResize: handleSizeChange })))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ReactResizeDetector } from 'jimu-core';\nimport { PageContext, PageVisibilityContext } from '../builder/page-context';\nimport LayoutEntry from './layout-entry';\nexport function PageFooter(props) {\n    var _a, _b, _c, _d;\n    const { footerJson, browserSizeMode, theme, mainSizeMode, pageContext, onHeightChange } = props;\n    const footerConRef = React.useRef();\n    const height = footerJson.height[browserSizeMode] || footerJson.height[mainSizeMode] || 50;\n    const layout = footerJson.layout;\n    let backgroundIMage;\n    if (footerJson.backgroundIMage) {\n        if (typeof (footerJson.backgroundIMage) === 'string') {\n            backgroundIMage = footerJson.backgroundIMage;\n        }\n        else if (typeof (footerJson.backgroundIMage) === 'object') {\n            backgroundIMage = footerJson.backgroundIMage.url;\n        }\n    }\n    const footerStyle = React.useMemo(() => {\n        var _a, _b, _c;\n        return css `\r\n      display: flex;\r\n      width: 100%;\r\n      min-height: ${Math.round(parseFloat(height))}px;\r\n      height: auto;\r\n      overflow: hidden;\r\n      background-color: ${footerJson.backgroundColor || ((_a = theme.comp) === null || _a === void 0 ? void 0 : _a.Footer.root.vars.bg) || 'transparent'};\r\n      background-image: ${backgroundIMage};\r\n      background-position: ${footerJson.backgroundPosition};\r\n      color: ${(_c = (_b = theme === null || theme === void 0 ? void 0 : theme.comp) === null || _b === void 0 ? void 0 : _b.Footer.root.vars) === null || _c === void 0 ? void 0 : _c.color};\r\n      z-index: 0;\r\n    `;\n    }, [\n        height,\n        footerJson.backgroundColor,\n        backgroundIMage,\n        footerJson.backgroundPosition,\n        (_b = (_a = theme === null || theme === void 0 ? void 0 : theme.comp) === null || _a === void 0 ? void 0 : _a.Footer.root.vars) === null || _b === void 0 ? void 0 : _b.bg,\n        (_d = (_c = theme === null || theme === void 0 ? void 0 : theme.comp) === null || _c === void 0 ? void 0 : _c.Footer.root.vars) === null || _d === void 0 ? void 0 : _d.color\n    ]);\n    const pageContextValue = React.useMemo(() => {\n        return Object.assign(Object.assign({}, pageContext), { viewOnly: true });\n    }, [pageContext]);\n    const handleSizeChange = React.useCallback(({ width, height }) => {\n        onHeightChange(height);\n    }, [onHeightChange]);\n    return (jsx(PageContext.Provider, { value: pageContextValue },\n        jsx(PageVisibilityContext.Provider, { value: true },\n            jsx(\"div\", { className: 'footer', css: footerStyle, ref: footerConRef },\n                jsx(LayoutEntry, { layouts: layout, className: 'w-100 flex-grow-1' }),\n                jsx(ReactResizeDetector, { targetRef: footerConRef, handleHeight: true, handleWidth: false, onResize: handleSizeChange })))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, getAppStore, appActions, i18n, jimuHistory, hooks, focusElementInKeyboardMode } from 'jimu-core';\nimport { CloseOutlined } from 'jimu-icons/outlined/editor/close';\nimport { Button } from 'jimu-ui';\nconst style = css `\r\n  display: flex;\r\n  height: 100%;\r\n  width: 100%;\r\n  background: var(--ref-palette-neutral-1100);\r\n\r\n  .jimu-btn {\r\n    padding-left: 2rem;\r\n    padding-right: 2rem;\r\n  }\r\n\r\n  .label {\r\n    white-space: nowrap;\r\n  }\r\n\r\n  @media print {\r\n    & {\r\n      display: none;\r\n    }\r\n  }\r\n`;\nexport function PrintPreviewTool() {\n    const intl = i18n.getIntl();\n    const btnRef = React.useRef();\n    React.useEffect(() => {\n        focusElementInKeyboardMode(btnRef.current);\n    }, []);\n    const formatMessage = React.useCallback((id) => {\n        return intl.formatMessage({ id });\n    }, [intl]);\n    const handleClose = hooks.useEventCallback(() => {\n        jimuHistory.changeQueryObject({ print_preview: null });\n        getAppStore().dispatch(appActions.quitPrintPreview());\n    });\n    const invokeBrowserPrint = hooks.useEventCallback(() => {\n        window.print();\n    });\n    return (jsx(\"div\", { className: 'print-preview-tool shadow-3', css: style },\n        jsx(\"div\", { className: 'd-flex justify-content-center align-items-center flex-grow-1' },\n            jsx(Button, { ref: btnRef, \"aria-label\": formatMessage('printCurrentPage'), type: 'primary', onClick: invokeBrowserPrint }, formatMessage('printCurrentPage'))),\n        jsx(Button, { className: 'ml-auto', icon: true, type: 'tertiary', \"aria-label\": formatMessage('close'), onClick: handleClose },\n            jsx(CloseOutlined, { color: 'var(--ref-palette-white)' }))));\n}\n","/** @jsx jsx */\nimport { React, ExtensionManager, extensionSpec, ReactRedux, jsx, css, LayoutType, AppDialog, getAppStore, appActions, Keyboard, jimuHistory, createSelector } from 'jimu-core';\nimport FixedLayout from '../fixed-layout/runtime/layout';\nimport { FlowLayoutTransformer } from '../flow-layout/layout-transform';\nimport { RowLayoutTransformer } from '../row-layout/layout-transform';\nimport { GridLayoutTransformer } from '../grid-layout/layout-transform';\nimport FlowLayout from '../flow-layout/runtime/layout';\nimport GridLayout from '../grid-layout/runtime/layout';\nimport ColumnLayout from '../column-layout/runtime/layout';\nimport AccordionLayout from '../accordion-layout/runtime/layout';\nimport FlexRowLayout from '../flex-row-layout/runtime/layout';\nimport { PageContext } from '../builder/page-context';\nimport { registerLayoutViewer } from '../layout-factory';\nimport { PageBody } from './page-body';\nimport { PageHeader } from './page-header';\nimport { PageFooter } from './page-footer';\nimport { withTheme } from 'jimu-theme';\nimport { Modal, ModalBody } from 'jimu-ui';\nimport { PrintPreviewTool } from './print-preview-tool';\nregisterLayoutViewer(LayoutType.FixedLayout, FixedLayout);\nregisterLayoutViewer(LayoutType.FlowLayout, FlowLayout);\nregisterLayoutViewer(LayoutType.GridLayout, GridLayout);\nregisterLayoutViewer(LayoutType.ColumnLayout, ColumnLayout);\nregisterLayoutViewer(LayoutType.AccordionLayout, AccordionLayout);\nregisterLayoutViewer(LayoutType.FlexRowLayout, FlexRowLayout);\nclass PageRenderer extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.updateHeaderHeight = (height) => {\n            this.setState({ headerHeight: height });\n        };\n        this.updateFooterHeight = (height) => {\n            this.setState({ footerHeight: height });\n        };\n        this.isMac = () => {\n            var _a, _b;\n            return ((_b = (_a = window.jimuUA) === null || _a === void 0 ? void 0 : _a.os) === null || _b === void 0 ? void 0 : _b.name) === 'macOS';\n        };\n        this.handlePrintEvent = (e) => {\n            getAppStore().dispatch(appActions.activePrintPreview());\n            jimuHistory.changeQueryObject({ print_preview: String(true) });\n            e.cancelBubble = true;\n            e.preventDefault();\n            e.stopImmediatePropagation();\n        };\n        this.state = { headerHeight: 0, footerHeight: 0 };\n        ExtensionManager.getInstance().registerExtension({\n            epName: extensionSpec.ExtensionPoints.LayoutTransformer,\n            extension: new FlowLayoutTransformer()\n        });\n        ExtensionManager.getInstance().registerExtension({\n            epName: extensionSpec.ExtensionPoints.LayoutTransformer,\n            extension: new RowLayoutTransformer()\n        });\n        ExtensionManager.getInstance().registerExtension({\n            epName: extensionSpec.ExtensionPoints.LayoutTransformer,\n            extension: new GridLayoutTransformer()\n        });\n        // these settings will not change during runtime\n        this.pageContext = {\n            theme: this.props.theme\n        };\n        if (!window.jimuConfig.isBuilder) {\n            if (this.isMac()) {\n                this.keyBindings = {\n                    'command+keyp': this.handlePrintEvent\n                };\n            }\n            else {\n                this.keyBindings = {\n                    'ctrl+keyp': this.handlePrintEvent\n                };\n            }\n        }\n    }\n    componentDidUpdate(prevProps) {\n        const previousPageId = getVisiblePageId(prevProps.pageStatus);\n        const currentPageId = getVisiblePageId(this.props.pageStatus);\n        if (previousPageId !== currentPageId) {\n            const htmlNode = document.getElementsByTagName('html')[0];\n            htmlNode.scrollTop = 0;\n        }\n    }\n    render() {\n        const { pageStatus, pages, theme, isPrintPreview, headerVisible, footerVisible } = this.props;\n        const visiblePageId = getVisiblePageId(pageStatus);\n        if (!visiblePageId || !(pages === null || pages === void 0 ? void 0 : pages[visiblePageId])) {\n            return null;\n        }\n        let width = '100%';\n        const pageJson = pages[visiblePageId] || {};\n        if (pageJson && !isNaN(+pageJson.width)) {\n            width = `${+pageJson.width}px`;\n        }\n        const mergedStyle = css `\r\n      width: ${width};\r\n      margin: 0 auto;\r\n      min-height: 100%;\r\n      overflow: auto;\r\n      position: relative;\r\n      z-index: 0;\r\n      height: 100%;\r\n      background-color: ${pageJson && pageJson.backgroundColor};\r\n\r\n      html.scrollable & {\r\n        height: auto;\r\n        overflow: unset;\r\n        min-height: 100vh;\r\n      }\r\n    `;\n        return (jsx(\"div\", { className: 'page-renderer d-flex flex-column', css: mergedStyle, ref: el => { this.pageRef = el; }, \"data-testid\": 'pageRenderer' },\n            isPrintPreview && (jsx(Modal, { isOpen: true, css: css `\r\n            max-width: 100% !important;\r\n            margin: 0 !important;\r\n\r\n            .modal-body.print-preview-content {\r\n              height: 64px;\r\n              position: fixed;\r\n              top: 0;\r\n              left: 0;\r\n              right: 0;\r\n              padding: 0;\r\n            }\r\n          `, backdrop: false },\n                jsx(ModalBody, { className: 'print-preview-content' },\n                    jsx(PrintPreviewTool, null)))),\n            this.renderDialog(),\n            headerVisible && this.renderHeader(),\n            Object.keys(pageStatus).map(pId => this.renderPageBody(pId, theme)),\n            footerVisible && this.renderFooter(),\n            jsx(Keyboard, { bindings: this.keyBindings })));\n    }\n    renderHeader() {\n        if (!this.props.header) {\n            return null;\n        }\n        const { header, browserSizeMode, theme, mainSizeMode } = this.props;\n        return (jsx(PageHeader, { headerJson: header, pageContext: this.pageContext, browserSizeMode: browserSizeMode, mainSizeMode: mainSizeMode, theme: theme, onHeightChange: this.updateHeaderHeight }));\n    }\n    renderFooter() {\n        if (!this.props.footer) {\n            return null;\n        }\n        const { footer, browserSizeMode, mainSizeMode, theme } = this.props;\n        return (jsx(PageFooter, { footerJson: footer, pageContext: this.pageContext, browserSizeMode: browserSizeMode, mainSizeMode: mainSizeMode, theme: theme, onHeightChange: this.updateFooterHeight }));\n    }\n    renderPageBody(renderedPageId, theme) {\n        const { pageStatus, pages, isPrintPreview } = this.props;\n        const pageJson = pages[renderedPageId];\n        if (!pageJson) {\n            // page is removed\n            return;\n        }\n        const visible = !!pageStatus[renderedPageId];\n        return (jsx(PageBody, { key: pageJson.id, pageJson: pageJson, pageContext: this.pageContext, browserSizeMode: this.props.browserSizeMode, visible: visible, isPrintPreview: isPrintPreview, headerFooterHeight: this.state.headerHeight + this.state.footerHeight }));\n    }\n    renderDialog() {\n        const { dialogId, urlDialogJson, splashDialogJson, isSplashClosed, isPageDlgClosed, pageDialogJson, pageDialogId } = this.props;\n        return (jsx(React.Fragment, null,\n            urlDialogJson && (jsx(PageContext.Provider, { value: Object.assign(Object.assign({}, this.pageContext), { dialogId: dialogId, viewOnly: true }) },\n                jsx(AppDialog, { dialogJson: urlDialogJson, runtime: true }))),\n            !isPageDlgClosed && pageDialogJson && (urlDialogJson === null || urlDialogJson === void 0 ? void 0 : urlDialogJson.id) !== pageDialogJson.id && (jsx(PageContext.Provider, { value: Object.assign(Object.assign({}, this.pageContext), { dialogId: pageDialogId, viewOnly: true }) },\n                jsx(AppDialog, { dialogJson: pageDialogJson, runtime: true, isOpenByPage: true }))),\n            !isSplashClosed && splashDialogJson && (urlDialogJson === null || urlDialogJson === void 0 ? void 0 : urlDialogJson.id) !== splashDialogJson.id && (jsx(PageContext.Provider, { value: Object.assign(Object.assign({}, this.pageContext), { dialogId: splashDialogJson.id, viewOnly: true }) },\n                jsx(AppDialog, { dialogJson: splashDialogJson, runtime: true })))));\n    }\n}\nPageRenderer.displayName = 'RuntimePageRenderer';\nconst mapStateToProps = createSelector([\n    (state) => state.appConfig.pages,\n    (state) => state.appConfig.dialogs,\n    (state) => state.appConfig.header,\n    (state) => state.appConfig.footer,\n    (state) => state.browserSizeMode,\n    (state) => state.appConfig.mainSizeMode,\n    (state) => {\n        var _a;\n        const realState = window.jimuConfig.isBuilder ? state.appStateInBuilder : state;\n        return (_a = realState === null || realState === void 0 ? void 0 : realState.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.dialogInfos;\n    },\n    (state) => {\n        var _a;\n        const realState = window.jimuConfig.isBuilder ? state.appStateInBuilder : state;\n        return (_a = realState === null || realState === void 0 ? void 0 : realState.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.currentPageId;\n    },\n    (state) => {\n        var _a, _b, _c;\n        const realState = window.jimuConfig.isBuilder ? state.appStateInBuilder : state;\n        const currentPageId = (_a = realState === null || realState === void 0 ? void 0 : realState.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.currentPageId;\n        return (_c = (_b = realState === null || realState === void 0 ? void 0 : realState.appConfig) === null || _b === void 0 ? void 0 : _b.pages[currentPageId]) === null || _c === void 0 ? void 0 : _c.autoOpenDialogId;\n    },\n    (state) => { var _a, _b; return (_b = (_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.isPrintPreview) !== null && _b !== void 0 ? _b : false; },\n    (_, ownProps) => getVisiblePageId(ownProps.pageStatus),\n    (_, ownProps) => ownProps.dialogId\n    // eslint-disable-next-line max-params\n], (pages, dialogs, header, footer, browserSizeMode, mainSizeMode, dialogInfos, currentPageId, pageDlgId, isPrintPreview, pageId, dialogId) => {\n    var _a, _b;\n    if (!pageId || !pages[pageId]) {\n        return {};\n    }\n    const splashDlgJson = dialogs[Object.keys(dialogs).find(dlgId => dialogs[dlgId].isSplash)];\n    return {\n        pages: pages,\n        header: header,\n        headerVisible: !!pages[pageId].header,\n        footer: footer,\n        footerVisible: !!pages[pageId].footer,\n        browserSizeMode: browserSizeMode,\n        mainSizeMode: mainSizeMode,\n        splashDialogJson: splashDlgJson,\n        isSplashClosed: (_a = dialogInfos === null || dialogInfos === void 0 ? void 0 : dialogInfos[splashDlgJson === null || splashDlgJson === void 0 ? void 0 : splashDlgJson.id]) === null || _a === void 0 ? void 0 : _a.isClosed,\n        pageDialogId: pageDlgId,\n        pageDialogJson: dialogs[pageDlgId],\n        isPageDlgClosed: (_b = dialogInfos === null || dialogInfos === void 0 ? void 0 : dialogInfos[currentPageId + '-' + pageDlgId]) === null || _b === void 0 ? void 0 : _b.isClosed,\n        urlDialogJson: dialogs[dialogId],\n        isPrintPreview\n    };\n});\nfunction getVisiblePageId(pageStatus) {\n    return Object.keys(pageStatus).find(pid => pageStatus[pid]);\n}\n// connect<IMapStateToProps, IMapDispatchToProps, ICompProps, IReduxState>(mapStateToProps, mapDispatchToProps)\nexport default ReactRedux.connect(mapStateToProps)(withTheme(PageRenderer));\n","/** @jsx jsx */\nimport { React, ReactRedux, LayoutItemType, jsx, css } from 'jimu-core';\nimport { Icon } from 'jimu-ui';\nimport sectionIcon from 'jimu-icons/svg/outlined/brand/widget-section.svg';\nexport function ItemTitle(props) {\n    var _a, _b;\n    const { layoutId, layoutItemId } = props;\n    const label = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        const layout = state.appConfig.layouts[layoutId];\n        const layoutItem = layout.content[layoutItemId];\n        if (layoutItem.type === LayoutItemType.Widget) {\n            const widgetId = layoutItem.widgetId;\n            const widgetJson = state.appConfig.widgets[widgetId];\n            return (_a = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.label) !== null && _a !== void 0 ? _a : '';\n        }\n        const sectionId = layoutItem.sectionId;\n        const sectionJson = state.appConfig.sections[sectionId];\n        return (_b = sectionJson === null || sectionJson === void 0 ? void 0 : sectionJson.label) !== null && _b !== void 0 ? _b : '';\n    });\n    const icon = ReactRedux.useSelector((state) => {\n        var _a, _b, _c, _d;\n        const layout = state.appConfig.layouts[layoutId];\n        const layoutItem = layout.content[layoutItemId];\n        if (layoutItem.type === LayoutItemType.Widget) {\n            const widgetId = layoutItem.widgetId;\n            const widgetJson = state.appConfig.widgets[widgetId];\n            if (typeof (widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.icon) === 'string') {\n                return widgetJson.icon;\n            }\n            return (_b = (_a = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.icon) === null || _a === void 0 ? void 0 : _a.svg) !== null && _b !== void 0 ? _b : '';\n        }\n        const sectionId = layoutItem.sectionId;\n        const sectionJson = state.appConfig.sections[sectionId];\n        if (typeof (sectionJson === null || sectionJson === void 0 ? void 0 : sectionJson.icon) === 'string') {\n            return sectionJson.icon;\n        }\n        return (_d = (_c = sectionJson === null || sectionJson === void 0 ? void 0 : sectionJson.icon) === null || _c === void 0 ? void 0 : _c.svg) !== null && _d !== void 0 ? _d : sectionIcon;\n    });\n    const showWidgetIcon = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        const layoutJson = state.appConfig.layouts[layoutId];\n        const parentWidgetId = layoutJson.parent.id;\n        const widgetJson = state.appConfig.widgets[parentWidgetId];\n        return (_b = (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.showWidgetIcon;\n    });\n    const widgetIconSize = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        const layoutJson = state.appConfig.layouts[layoutId];\n        const parentWidgetId = layoutJson.parent.id;\n        const widgetJson = state.appConfig.widgets[parentWidgetId];\n        return (_b = (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.widgetIconSize;\n    });\n    const widgetIconColor = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        const layoutJson = state.appConfig.layouts[layoutId];\n        const parentWidgetId = layoutJson.parent.id;\n        const widgetJson = state.appConfig.widgets[parentWidgetId];\n        return (_b = (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.widgetIconColor;\n    });\n    const textStyle = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        const layoutJson = state.appConfig.layouts[layoutId];\n        const parentWidgetId = layoutJson.parent.id;\n        const widgetJson = state.appConfig.widgets[parentWidgetId];\n        return (_b = (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.textStyle;\n    });\n    return (jsx(\"div\", { className: 'label d-flex align-items-center h-100' }, (jsx(React.Fragment, null,\n        showWidgetIcon && jsx(Icon, { icon: icon, size: widgetIconSize !== null && widgetIconSize !== void 0 ? widgetIconSize : 16, color: widgetIconColor }),\n        jsx(\"div\", { className: 'ml-2 text-truncate', css: css `\r\n            font-size: ${(_a = textStyle === null || textStyle === void 0 ? void 0 : textStyle.size) !== null && _a !== void 0 ? _a : '1rem'};\r\n            font-weight: ${(textStyle === null || textStyle === void 0 ? void 0 : textStyle.bold) ? 'bold' : 'normal'};\r\n            font-style: ${(textStyle === null || textStyle === void 0 ? void 0 : textStyle.italic) ? 'italic' : 'normal'};\r\n            text-decoration: ${(textStyle === null || textStyle === void 0 ? void 0 : textStyle.underline) ? 'underline' : ''} ${(textStyle === null || textStyle === void 0 ? void 0 : textStyle.strike) ? 'line-through' : ''};\r\n            color: ${(_b = textStyle === null || textStyle === void 0 ? void 0 : textStyle.color) !== null && _b !== void 0 ? _b : 'inherit'};\r\n          ` }, label)))));\n}\n","/** @jsx jsx */\nimport { jsx, css, hooks } from 'jimu-core';\nimport { CollapseAllOutlined } from 'jimu-icons/outlined/directional/collapse-all';\nimport { ExpandAllOutlined } from 'jimu-icons/outlined/directional/expand-all';\nimport { Button, Tooltip } from 'jimu-ui';\nconst style = css `\r\n  // position: sticky;\r\n  // top: 0;\r\n  margin-bottom: 4px;\r\n  z-index: 1;\r\n`;\nexport function ToggleAllButtonGroup(props) {\n    const { onExpandAll, onCollapseAll } = props;\n    const translate = hooks.useTranslation();\n    return (jsx(\"div\", { css: style, className: 'd-flex align-items-center justify-content-end' },\n        jsx(Tooltip, { title: translate('expandAll') },\n            jsx(Button, { type: 'tertiary', icon: true, size: 'sm', onClick: onExpandAll },\n                jsx(ExpandAllOutlined, null))),\n        jsx(Tooltip, { title: translate('collapseAll') },\n            jsx(Button, { type: 'tertiary', icon: true, size: 'sm', onClick: onCollapseAll, className: 'ml-1' },\n                jsx(CollapseAllOutlined, null)))));\n}\n","import { css } from 'jimu-core';\nexport const getLayoutStyle = (layoutSetting) => css `\r\n  height: 100%;\r\n  overflow-x: hidden;\r\n  justify-content: ${layoutSetting.justifyContent};\r\n  overflow-y: auto !important;\r\n  -ms-overflow-style: none;  /* Internet Explorer 10+ */\r\n  scrollbar-width: none;  /* Firefox */\r\n  &::-webkit-scrollbar {\r\n    display: none;  /* Safari and Chrome */\r\n  }\r\n  &:hover {\r\n    -ms-overflow-style: auto;  /* Internet Explorer 10+ */\r\n    scrollbar-width: thin;  /* Firefox */\r\n    &::-webkit-scrollbar {\r\n      display: block;  /* Safari and Chrome */\r\n    }\r\n  }\r\n  & > div.flexbox-layout-item ~ div.flexbox-layout-item {\r\n    margin-top: ${layoutSetting.space}px;\r\n  }\r\n`;\n","import { css } from 'jimu-core';\nimport { LayoutItemSizeModes } from '../../types';\nimport { getValueOfBBox } from '../../utils';\nexport function calHeight(itemSetting, bbox) {\n    var _a, _b;\n    if (((_a = itemSetting.autoProps) === null || _a === void 0 ? void 0 : _a.height) === LayoutItemSizeModes.Auto || itemSetting.heightMode === 'ratio') {\n        if (itemSetting.heightMode === 'ratio') {\n            return { height: 'auto', flex: '0 0 auto' };\n        }\n        return { height: 'auto' };\n    }\n    if (((_b = itemSetting.autoProps) === null || _b === void 0 ? void 0 : _b.height) === LayoutItemSizeModes.Stretch || itemSetting.heightMode === 'fit') {\n        return { flex: '1 1 auto' };\n    }\n    return { height: bbox.height, flexShrink: 0 };\n}\nexport function isStretchInCrossAxis(layoutItem) {\n    var _a, _b;\n    return ((_b = (_a = layoutItem.setting) === null || _a === void 0 ? void 0 : _a.autoProps) === null || _b === void 0 ? void 0 : _b.width) !== LayoutItemSizeModes.Custom;\n}\nexport function getItemStyle(style, layoutSetting, isStretch) {\n    var _a, _b, _c;\n    const isAutoHeight = ((_a = layoutSetting.autoProps) === null || _a === void 0 ? void 0 : _a.height) === LayoutItemSizeModes.Auto;\n    return css `\r\n    align-self: ${isStretch ? 'stretch' : (_c = (_b = layoutSetting.style) === null || _b === void 0 ? void 0 : _b.alignSelf) !== null && _c !== void 0 ? _c : 'auto'};\r\n    width: ${getValueOfBBox(style, 'width')};\r\n    height: ${getValueOfBBox(style, 'height')};\r\n    flex: ${style.flex};\r\n    flex-shrink: ${style.flexShrink};\r\n    min-height: ${isAutoHeight ? 'unset' : null};\r\n  `;\n}\n","import { React, css, LayoutItemType, ContainerType, FixedPosition, focusElementInKeyboardMode } from 'jimu-core';\nimport { getContentRootContainerInfo } from '../search/contents';\nimport { LayoutItemSizeModes } from '../types';\nimport { getFocusableElements } from 'jimu-ui';\nexport function findPageRelatedControllerIds(appConfig, pageId, browserSizeMode) {\n    var _a;\n    const result = Object.keys((_a = appConfig.controllerPanels) !== null && _a !== void 0 ? _a : {}).filter(controllerId => {\n        const rootInfo = getContentRootContainerInfo(appConfig, controllerId, LayoutItemType.Widget, browserSizeMode);\n        if (rootInfo == null) {\n            return false;\n        }\n        if (rootInfo.type !== ContainerType.Page) {\n            return true;\n        }\n        return rootInfo.id === pageId;\n    });\n    result.sort();\n    return result.join(',');\n}\nexport function panelTransformStyle(panelJson) {\n    if (panelJson == null) {\n        return null;\n    }\n    const { position, offsetX = 0, offsetY = 0 } = panelJson;\n    let translate;\n    if (panelJson.widthMode !== LayoutItemSizeModes.Stretch) {\n        if (offsetX !== 0) {\n            translate = `translateX(${offsetX}px)`;\n        }\n        if (position === FixedPosition.TopCenter || position === FixedPosition.MiddleCenter || position === FixedPosition.BottomCenter) {\n            translate = translate != null ? `${translate} translateX(-50%)` : 'translateX(-50%)';\n        }\n    }\n    if (panelJson.heightMode !== LayoutItemSizeModes.Stretch) {\n        if (offsetY !== 0) {\n            translate = translate != null ? `${translate} translateY(${offsetY}px)` : `translateY(${offsetY}px)`;\n        }\n        if (position === FixedPosition.MiddleLeft || position === FixedPosition.MiddleCenter || position === FixedPosition.MiddleRight) {\n            translate = translate != null ? `${translate} translateY(-50%)` : 'translateY(-50%)';\n        }\n    }\n    return translate;\n}\nexport function convertToStyle(panelJson) {\n    let posStyle;\n    switch (panelJson === null || panelJson === void 0 ? void 0 : panelJson.position) {\n        case FixedPosition.TopLeft:\n            posStyle = css `top: 0; left: 0; bottom: auto; right: auto;`;\n            break;\n        case FixedPosition.TopRight:\n            posStyle = css `top: 0; left: auto; bottom: auto; right: 0;`;\n            break;\n        case FixedPosition.BottomLeft:\n            posStyle = css `top: auto; left: 0; bottom: 0; right: auto;`;\n            break;\n        case FixedPosition.BottomRight:\n            posStyle = css `top: auto; left: auto; bottom: 0; right: 0;`;\n            break;\n        case FixedPosition.TopCenter:\n            posStyle = css `top: 0; left: 50%; bottom: auto; right: auto;`;\n            break;\n        case FixedPosition.BottomCenter:\n            posStyle = css `top: auto; left: 50%; bottom: 0; right: auto;`;\n            break;\n        case FixedPosition.MiddleLeft:\n            posStyle = css `top: 50%; left: 0; bottom: auto; right: auto;`;\n            break;\n        case FixedPosition.MiddleRight:\n            posStyle = css `top: 50%; left: auto; bottom: auto; right: 0;`;\n            break;\n        case FixedPosition.MiddleCenter:\n            posStyle = css `top: 50%; left: 50%; bottom: auto; right: auto;`;\n            break;\n        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n        default:\n            posStyle = css `top: 0; left: 0; bottom: auto; right: auto;`;\n            break;\n    }\n    let widthModeStyle;\n    let heightModeStyle;\n    if (panelJson.widthMode === LayoutItemSizeModes.Stretch) {\n        widthModeStyle = css `width:auto;left:${panelJson.left};right:${panelJson.right};`;\n    }\n    if (panelJson.heightMode === LayoutItemSizeModes.Stretch) {\n        heightModeStyle = css `height:auto;top:${panelJson.top};bottom:${panelJson.bottom};`;\n    }\n    return css `\r\n    position: fixed;\r\n    ${posStyle}\r\n    width: ${panelJson === null || panelJson === void 0 ? void 0 : panelJson.width};\r\n    height: ${panelJson === null || panelJson === void 0 ? void 0 : panelJson.height};\r\n    ${widthModeStyle};\r\n    ${heightModeStyle}\r\n    overflow: visible;\r\n    z-index: 2;\r\n  `;\n}\n/**\n *\n * @param container The container element\n * @param firstClass The first focusable element's distinct class name\n * @param lastVirtualClass The last virtual focusable element's distinct class name\n * @returns An keyboard event handler of the last virtual node, which passes the browser's focus\n * to the firstClass element (Tab) or the real last element(Shift + Tab)\n */\nexport const useHandleLastVirtualNodeFocus = (container, firstClass, lastVirtualClass) => {\n    return React.useCallback((e) => {\n        if (!container)\n            return;\n        const eventKey = e.key;\n        const shiftKey = e.shiftKey;\n        if (eventKey === 'Tab') {\n            if (shiftKey) {\n                // focus the real last focusable node except for lastVirtualClass\n                const focusableElements = getFocusableElements(container).filter(el => { var _a, _b; return !((_b = (_a = el === null || el === void 0 ? void 0 : el.classList) === null || _a === void 0 ? void 0 : _a.contains) === null || _b === void 0 ? void 0 : _b.call(_a, lastVirtualClass)); });\n                if (!focusableElements || focusableElements.length === 0)\n                    return;\n                focusElementInKeyboardMode(focusableElements[focusableElements.length - 1], true);\n            }\n            else {\n                const firstFocusableElement = container.querySelector(`.${firstClass}`);\n                focusElementInKeyboardMode(firstFocusableElement, true);\n            }\n        }\n    }, [container, firstClass, lastVirtualClass]);\n};\n","import { css } from 'jimu-core';\nimport { getValueOfBBox } from '../../utils';\nexport function getPositionStyle(mergedStyle) {\n    return [\n        css `\r\n      position: absolute;\r\n      left: ${getValueOfBBox(mergedStyle, 'left')};\r\n      right: ${getValueOfBBox(mergedStyle, 'right')};\r\n      top: ${getValueOfBBox(mergedStyle, 'top')};\r\n      bottom: ${getValueOfBBox(mergedStyle, 'bottom')};\r\n      width: ${getValueOfBBox(mergedStyle, 'width')};\r\n      height: ${getValueOfBBox(mergedStyle, 'height')};\r\n    `,\n        mergedStyle.transform\n    ];\n}\n","import { css } from 'jimu-core';\nexport const getLayoutStyle = (layoutSetting) => css `\r\n  height: 100%;\r\n  overflow: hidden;\r\n  justify-content: ${layoutSetting.justifyContent};\r\n  & > div.flex-row-layout-item ~ div.flex-row-layout-item {\r\n    margin-left: ${layoutSetting.space}px;\r\n  }\r\n`;\n","import { css } from 'jimu-core';\nimport { LayoutItemSizeModes } from '../../types';\nimport { getValueOfBBox } from '../../utils';\nexport function calWidth(itemSetting, bbox) {\n    var _a, _b;\n    if (((_a = itemSetting.autoProps) === null || _a === void 0 ? void 0 : _a.width) === LayoutItemSizeModes.Auto || itemSetting.widthMode === 'ratio') {\n        if (itemSetting.widthMode === 'ratio') {\n            return { width: 'auto', flex: '0 0 auto' };\n        }\n        return { width: 'auto' };\n    }\n    if (((_b = itemSetting.autoProps) === null || _b === void 0 ? void 0 : _b.width) === LayoutItemSizeModes.Stretch || itemSetting.widthMode === 'fit') {\n        return { flex: '1 1 auto' };\n    }\n    return { width: bbox.width, flexShrink: 0 };\n}\nexport function isStretchInCrossAxis(layoutItem) {\n    var _a, _b, _c;\n    const heightMode = (_c = (_b = (_a = layoutItem.setting) === null || _a === void 0 ? void 0 : _a.autoProps) === null || _b === void 0 ? void 0 : _b.height) !== null && _c !== void 0 ? _c : LayoutItemSizeModes.Stretch;\n    return heightMode === LayoutItemSizeModes.Stretch;\n}\nexport function getItemStyle(style, layoutSetting, isStretch) {\n    var _a, _b, _c;\n    const isAutoWidth = ((_a = layoutSetting.autoProps) === null || _a === void 0 ? void 0 : _a.width) === LayoutItemSizeModes.Auto;\n    return css `\r\n    align-self: ${isStretch ? 'stretch' : (_c = (_b = layoutSetting.style) === null || _b === void 0 ? void 0 : _b.alignSelf) !== null && _c !== void 0 ? _c : 'flex-start'};\r\n    width: ${getValueOfBBox(style, 'width')};\r\n    height: ${getValueOfBBox(style, 'height')};\r\n    flex: ${style.flex};\r\n    flex-shrink: ${style.flexShrink};\r\n    min-width: ${isAutoWidth ? 'unset' : null};\r\n  `;\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css, classNames, getAppStore, appActions } from 'jimu-core';\nimport { styleUtils, Button } from 'jimu-ui';\nimport { PageVisibilityContext } from '../../builder/page-context';\nimport { SCREEN_RATIO_IN_SMALL_SIZE } from './type';\nimport { VisibleOutlined } from 'jimu-icons/outlined/application/visible';\nimport { ThemedTooltip } from '../../builder/theme-tooltip';\nexport function ScreenMainPanel(props) {\n    const { rootLayoutId, viewHeight, headerHeight, screenId, isActive, isAbsolute, isLast, isSmallSize, layoutEntry: LayoutEntry, isDesignMode, formatMessage, builderTheme } = props;\n    const screenJson = ReactRedux.useSelector((state) => {\n        return state.appConfig.screens[screenId];\n    });\n    const panelVisible = ReactRedux.useSelector((state) => {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.screenPanelStates) === null || _b === void 0 ? void 0 : _b[screenId]) !== null && _c !== void 0 ? _c : true;\n    });\n    const { main } = screenJson;\n    const { side, size, overlay = true } = screenJson.panel || {};\n    const elementRef = React.useRef();\n    const showPanel = React.useCallback(() => {\n        getAppStore().dispatch(appActions.screenPanelVisibleChanged(screenId, true));\n    }, [screenId]);\n    function getStyle() {\n        var _a, _b, _c, _d;\n        if (isSmallSize) {\n            const isDocked = !overlay && screenJson.panel != null; // overlay === false\n            const heightInDesignMode = isDocked\n                ? `${Math.round(viewHeight * SCREEN_RATIO_IN_SMALL_SIZE)}px`\n                : `${viewHeight}px`;\n            const heightInRuntime = isDocked\n                ? `${Math.round(100 * SCREEN_RATIO_IN_SMALL_SIZE)}`\n                : '100';\n            return css `\r\n        pointer-events: none !important;\r\n        display: flex;\r\n        flex-direction: column;\r\n        width: 100%;\r\n        height: ${viewHeight}px;\r\n\r\n        > .layout {\r\n          ${styleUtils.toBackgroundEmotionStyle((_b = (_a = screenJson.main) === null || _a === void 0 ? void 0 : _a.background) !== null && _b !== void 0 ? _b : {})};\r\n          height: ${heightInDesignMode} !important;\r\n          border: none !important;\r\n          pointer-events: auto;\r\n        }\r\n\r\n        body:not(.design-mode) & {\r\n          height: ${headerHeight > 0 ? `calc(100vh - ${headerHeight}px)` : '100vh'};\r\n          height: ${headerHeight > 0 ? `calc(var(--vh) * 100 - ${headerHeight}px)` : 'calc(var(--vh) * 100)'};\r\n          > .layout {\r\n            height: ${heightInRuntime}vh !important;\r\n            height: calc(var(--vh) * ${heightInRuntime}) !important;\r\n          }\r\n        }\r\n\r\n        .spacing-area {\r\n          flex: 1;\r\n          background: transparent;\r\n          pointer-events: none;\r\n        }\r\n\r\n        .toggle-visible-btn {\r\n          position: absolute;\r\n          bottom: 0;\r\n          right: left;\r\n          pointer-events: auto;\r\n        }\r\n      `;\n        }\n        let left = '0px';\n        let right = '0px';\n        if (side !== 'none') {\n            if (!overlay && side !== 'right') {\n                left = size;\n            }\n            if (!overlay && side === 'right') {\n                right = size;\n            }\n        }\n        const btnStyle = builderTheme\n            ? css `\r\n      color: ${builderTheme.ref.palette.neutral[1200]};\r\n      background-color: ${builderTheme.ref.palette.neutral[500]};\r\n      border-color: ${builderTheme.ref.palette.neutral[600]};\r\n      &:hover {\r\n        color: ${builderTheme.ref.palette.black};\r\n        background-color: ${builderTheme.ref.palette.neutral[600]};\r\n      }\r\n    `\n            : null;\n        return css `\r\n      ${styleUtils.toBackgroundEmotionStyle((_d = (_c = screenJson.main) === null || _c === void 0 ? void 0 : _c.background) !== null && _d !== void 0 ? _d : {})};\r\n      left: ${isAbsolute ? left : null};\r\n      right: ${isAbsolute ? right : null};\r\n      margin-left: ${!isAbsolute ? left : null};\r\n      margin-right: ${!isAbsolute ? right : null};\r\n      pointer-events: auto;\r\n      display: flex;\r\n      flex-direction: column;\r\n      position: relative;\r\n\r\n      > .layout {\r\n        height: ${viewHeight}px !important;\r\n        background: transparent;\r\n        border: none !important;\r\n      }\r\n\r\n      body:not(.design-mode) & {\r\n        > .layout {\r\n          height: ${headerHeight > 0 ? `calc(100vh - ${headerHeight}px)` : '100vh'} !important;\r\n          height: ${headerHeight > 0 ? `calc(var(--vh) * 100 - ${headerHeight}px)` : 'calc(var(--vh) * 100)'} !important;\r\n        }\r\n      }\r\n\r\n      .spacing-area {\r\n        flex: 1;\r\n        background: transparent;\r\n        pointer-events: none;\r\n      }\r\n\r\n      .toggle-visible-btn {\r\n        position: absolute;\r\n        bottom: 0;\r\n        right: 0;\r\n\r\n        > button {\r\n          ${btnStyle};\r\n          svg {\r\n            margin-right: 0;\r\n            margin-left: 0;\r\n          }\r\n        }\r\n      }\r\n    `;\n    }\n    const clazzName = classNames('screen-main-panel', {\n        'is-active': isActive,\n        'last-one': isLast\n    });\n    return (jsx(PageVisibilityContext.Provider, { value: isAbsolute ? isActive : true },\n        jsx(\"div\", { id: `${rootLayoutId}_screen_${screenId}`, className: clazzName, css: getStyle(), ref: elementRef, \"data-screenid\": screenId, \"data-index\": props.index },\n            jsx(LayoutEntry, { layouts: main.layout, isInWidget: true }),\n            jsx(\"div\", { className: 'spacing-area' }),\n            isDesignMode && !panelVisible && (jsx(\"div\", { className: 'toggle-visible-btn', onClick: showPanel, \"data-testid\": 'toggleBtn' },\n                jsx(ThemedTooltip, { placement: 'auto', title: formatMessage('showInDesignView') },\n                    jsx(Button, { type: 'default', size: 'sm', className: 'rounded-1' },\n                        jsx(VisibleOutlined, { size: 'm' }))))))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ScreenTransitionType } from 'jimu-core';\nimport { ScreenMainPanel } from './screen-main-panel';\nfunction getContainerStyle(transitionType, viewHeight, headerHeight, isSmallSize, numOfScreens) {\n    if (transitionType === ScreenTransitionType.Fade) {\n        return css `\r\n      position: sticky;\r\n      height: ${viewHeight}px;\r\n      top: 0;\r\n\r\n      body:not(.design-mode) & {\r\n        height: ${headerHeight > 0 ? `calc(100vh - ${headerHeight}px)` : '100vh'};\r\n        height: ${headerHeight > 0 ? `calc(var(--vh) * 100 - ${headerHeight}px)` : 'calc(var(--vh) * 100)'};\r\n        top: ${headerHeight > 0 ? `${headerHeight}px` : 0};\r\n        .layout .exb-drop-area {\r\n          pointer-events: none !important;\r\n        }\r\n      }\r\n\r\n      .screen-main-panel {\r\n        position: absolute;\r\n        opacity: 0;\r\n        visibility: hidden;\r\n        z-index: 0;\r\n        transition: ${isSmallSize ? null : 'opacity 400ms'};\r\n        top: 0;\r\n        /* height: ${isSmallSize ? 'unset' : '100% !important'}; */\r\n\r\n        .layout .exb-drop-area {\r\n          pointer-events: none;\r\n        }\r\n\r\n        &.is-active {\r\n          opacity: 1;\r\n          visibility: visible;\r\n          pointer-events: auto;\r\n          z-index: 1;\r\n\r\n          .layout .exb-drop-area {\r\n            pointer-events: auto;\r\n          }\r\n        }\r\n      }\r\n    `;\n    }\n    if (transitionType === ScreenTransitionType.Cover) {\n        return css `\r\n      position: sticky;\r\n      height: ${viewHeight}px;\r\n      overflow: hidden;\r\n      top: 0;\r\n\r\n      body:not(.design-mode) & {\r\n        height: 100%;\r\n        overflow: unset;\r\n        position: relative;\r\n\r\n        .screen-main-panel {\r\n          top: ${headerHeight > 0 ? `${headerHeight}px` : 0};\r\n        }\r\n      }\r\n\r\n      & > div:first-of-type {\r\n        margin-top: 0 !important;\r\n      }\r\n\r\n      .screen-main-panel {\r\n        position: sticky;\r\n        top: 0;\r\n        margin-top: ${numOfScreens === 1 ? '0 !important' : null};\r\n\r\n        .spacing-area {\r\n          display: none;\r\n        }\r\n      }\r\n    `;\n    }\n    if (transitionType === ScreenTransitionType.Push) {\n        return css `\r\n      position: sticky;\r\n      height: ${viewHeight}px;\r\n      overflow: hidden;\r\n      top: 0;\r\n\r\n      body:not(.design-mode) & {\r\n        height: auto;\r\n        overflow: unset;\r\n\r\n        .screen-main-panel > .layout {\r\n          top: ${headerHeight > 0 ? `${headerHeight}px` : 0};\r\n        }\r\n      }\r\n\r\n      .screen-main-panel > .layout {\r\n        position: sticky !important;\r\n        top: 0;\r\n      }\r\n    `;\n    }\n}\nfunction getPlaceholderStyle(transitionType, viewHeight, isSmallSize) {\n    if (transitionType === ScreenTransitionType.Fade) {\n        return css `\r\n      height: calc(100% - ${viewHeight}px);\r\n      background: transparent;\r\n      pointer-events: none;\r\n\r\n      body:not(.design-mode) & {\r\n        height: calc(100% - 100vh);\r\n        height: calc(100% - var(--vh) * 100);\r\n      }\r\n    `;\n    }\n    if (transitionType === ScreenTransitionType.Cover || transitionType === ScreenTransitionType.Push) {\n        return css `\r\n      height: calc(100% - ${viewHeight}px);\r\n      background: transparent;\r\n      pointer-events: none;\r\n      display: block;\r\n\r\n      body:not(.design-mode) & {\r\n        height: calc(100% - 100vh);\r\n        height: calc(100% - var(--vh) * 100);\r\n        display: none;\r\n      }\r\n    `;\n    }\n}\nexport function ScreenMainPanelList(props) {\n    const { rootLayoutId, activeIndex, viewHeight, headerHeight, screens, transitionType, isSmallSize, layoutEntry, isDesignMode, formatMessage, builderTheme } = props;\n    return (jsx(React.Fragment, null,\n        jsx(\"div\", { className: 'screen-container', css: getContainerStyle(transitionType, viewHeight, headerHeight, isSmallSize, screens.length) }, screens.map((screenId, idx) => {\n            return (jsx(ScreenMainPanel, { key: screenId, rootLayoutId: rootLayoutId, index: idx, isActive: activeIndex === idx, screenId: screenId, viewHeight: viewHeight, headerHeight: headerHeight, isAbsolute: transitionType === ScreenTransitionType.Fade, isLast: idx === screens.length - 1, isSmallSize: isSmallSize, layoutEntry: layoutEntry, isDesignMode: isDesignMode, formatMessage: formatMessage, builderTheme: builderTheme }));\n        })),\n        jsx(\"div\", { className: 'screen-placeholder', css: getPlaceholderStyle(transitionType, viewHeight, isSmallSize) })));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css, ReactResizeDetector, ScreenTransitionType, ScreenTriggerType, classNames, getAppStore, lodash } from 'jimu-core';\nimport { styleUtils } from 'jimu-ui';\nimport { useIntersection } from '../use-intersection';\nimport { SCREEN_RATIO_IN_SMALL_SIZE } from './type';\nconst MIN_PANEL_RATIO = 0.25;\nexport function getSidePanelStyle(options) {\n    const { props, viewHeight, headerHeight, isActive, verticalSpace, stretched, transitionType, screenTransitionType, isSmallSize } = options;\n    const { side, size, offset, background, overlay = true, padding } = props.panel || {};\n    const isRTL = getAppStore().getState().appContext.isRTL;\n    const factor = isRTL ? (side === 'left' ? '-' : '') : (side === 'right' ? '-' : '');\n    const backgroundStyle = styleUtils.toBackgroundEmotionStyle(background !== null && background !== void 0 ? background : {});\n    const spacing = parseFloat(verticalSpace);\n    if (isSmallSize) {\n        // overlay === false\n        const docked = !overlay;\n        return css `\r\n      width: 100%;\r\n      background: transparent;\r\n      pointer-events: none;\r\n      position: relative;\r\n      opacity: ${transitionType === ScreenTransitionType.Fade ? (isActive ? '1' : '0.5') : null};\r\n      min-height: ${screenTransitionType === ScreenTransitionType.Cover ? `${viewHeight}px` : null};\r\n      padding-top: ${screenTransitionType !== ScreenTransitionType.Fade && docked ? `${Math.round(viewHeight * SCREEN_RATIO_IN_SMALL_SIZE)}px` : null};\r\n\r\n      &.top-spacing > .panel-content {\r\n        /* margin-top: ${Math.round(viewHeight * SCREEN_RATIO_IN_SMALL_SIZE)}px; */\r\n      }\r\n\r\n      .panel-content {\r\n        width: 100%;\r\n        ${overlay ? '' : backgroundStyle};\r\n        /* margin-top: ${transitionType === ScreenTransitionType.Push ? '${Math.round(viewHeight * SCREEN_RATIO_IN_SMALL_SIZE)}px' : 'unset'}; */\r\n\r\n        > .layout, > .layout-wrapper > .layout {\r\n          pointer-events: auto;\r\n          ${overlay ? backgroundStyle : ''};\r\n          min-height: ${Math.round(viewHeight * MIN_PANEL_RATIO)}px;\r\n          padding: ${styleUtils.toCSSPadding(padding)};\r\n        }\r\n\r\n        > .layout-wrapper > .column-layout > .trail-container,\r\n        > .column-layout > .trail-container {\r\n          overflow-y: hidden;\r\n        }\r\n\r\n        > .layout-wrapper > .placeholder-btn {\r\n          pointer-events: auto;\r\n          ${overlay ? backgroundStyle : ''};\r\n        }\r\n\r\n        .panel-spacing {\r\n          height: ${Math.round(viewHeight * spacing / 100)}px;\r\n        }\r\n      }\r\n\r\n      .panel-content-placeholder {\r\n        width: 1px;\r\n        min-height: ${viewHeight}px;\r\n      }\r\n\r\n      body:not(.design-mode) & {\r\n        min-height: ${screenTransitionType === ScreenTransitionType.Cover ? '100vh' : null};\r\n        min-height: ${screenTransitionType === ScreenTransitionType.Cover ? 'calc(var(--vh) * 100)' : null};\r\n        padding-top: ${screenTransitionType !== ScreenTransitionType.Fade && docked ? `${100 * SCREEN_RATIO_IN_SMALL_SIZE}vh` : null};\r\n        padding-top: ${screenTransitionType !== ScreenTransitionType.Fade && docked ? `calc(var(--vh) * ${100 * SCREEN_RATIO_IN_SMALL_SIZE})` : null};\r\n\r\n        > .layout, > .layout-wrapper > .layout {\r\n          min-height: ${Math.round(100 * MIN_PANEL_RATIO)}vh;\r\n          min-height: calc(var(--vh) * ${Math.round(100 * MIN_PANEL_RATIO)});\r\n        }\r\n\r\n        .panel-content-placeholder {\r\n          min-height: 100vh;\r\n          min-height: calc(var(--vh) * 100);\r\n        }\r\n\r\n        .panel-spacing {\r\n          height: ${spacing}vh;\r\n          height: calc(var(--vh) * ${spacing});\r\n        }\r\n      }\r\n    `;\n    }\n    return css `\r\n    width: 100%;\r\n    background: transparent;\r\n    pointer-events: none;\r\n    display: flex;\r\n    flex-direction: ${side === 'right' ? 'row-reverse' : 'row'};\r\n    justify-content: ${side === 'center' && overlay ? 'center' : 'flex-start'};\r\n    position: relative;\r\n    opacity: ${transitionType === ScreenTransitionType.Fade ? (isActive ? '1' : '0.5') : null};\r\n\r\n    &.top-spacing > .panel-content {\r\n      /* margin-top: ${Math.round(viewHeight * 2 / 3)}px; */\r\n    }\r\n\r\n    .panel-content {\r\n      width: ${size};\r\n      transform: ${overlay && Math.abs(parseFloat(offset)) > 0 ? `translateX(${factor}${offset})` : null};\r\n      flex: 0 auto;\r\n      min-height: ${stretched ? `${viewHeight}px` : 'unset'};\r\n      ${overlay ? '' : backgroundStyle};\r\n\r\n      > .layout,\r\n      > .layout-wrapper > .layout {\r\n        pointer-events: auto;\r\n        ${overlay ? backgroundStyle : ''};\r\n        min-height: ${Math.round(viewHeight * MIN_PANEL_RATIO)}px;\r\n        padding: ${styleUtils.toCSSPadding(padding)};\r\n      }\r\n\r\n      > .layout-wrapper > .column-layout > .trail-container,\r\n      > .column-layout > .trail-container {\r\n        overflow-y: hidden;\r\n      }\r\n\r\n      > .layout-wrapper > .placeholder-btn {\r\n        pointer-events: auto;\r\n        ${overlay ? backgroundStyle : ''};\r\n      }\r\n\r\n      .panel-spacing {\r\n        height: ${Math.round(viewHeight * spacing / 100)}px;\r\n\r\n        &.last-item {\r\n          height: ${stretched ? `${Math.round(viewHeight * spacing / 100)}` : viewHeight}px;\r\n        }\r\n      }\r\n    }\r\n\r\n    .panel-content-placeholder {\r\n      width: 1px;\r\n      min-height: ${stretched ? viewHeight : Math.round(viewHeight * MIN_PANEL_RATIO)}px;\r\n    }\r\n\r\n    body:not(.design-mode) & {\r\n      &.top-spacing > .panel-content {\r\n        /* margin-top: 66.7vh; */\r\n      }\r\n\r\n      .panel-content {\r\n        min-height: ${stretched ? (headerHeight > 0 ? `calc(100vh - ${headerHeight}px)` : '100vh') : 'unset'};\r\n        min-height: ${stretched ? (headerHeight > 0 ? `calc(var(--vh) * 100 - ${headerHeight}px)` : 'calc(var(--vh) * 100)') : 'unset'};\r\n        > .layout, > .layout-wrapper > .layout {\r\n          min-height: unset;\r\n        }\r\n\r\n        .panel-spacing {\r\n          height: ${spacing}vh;\r\n          height: calc(var(--vh) * ${spacing});\r\n\r\n          &.last-item {\r\n            height: ${stretched ? spacing : 100}vh;\r\n            height: calc(var(--vh) * ${stretched ? spacing : 100});\r\n          }\r\n        }\r\n      }\r\n      .panel-content-placeholder {\r\n        min-height: ${stretched ? '100' : Math.round(100 * MIN_PANEL_RATIO)}vh;\r\n        min-height: calc(var(--vh) * ${stretched ? '100' : Math.round(100 * MIN_PANEL_RATIO)});\r\n      }\r\n    }\r\n  `;\n}\nexport function ScreenSidePanel(props) {\n    var _a;\n    const { index, screenId, onInteractionChange, onHeightChange, viewHeight, headerHeight, layoutEntry: LayoutEntry, isActive, isSmallSize, transitionType, screenTransitionType, triggerType, stretched, verticalSpace = '0' } = props;\n    const screenJson = ReactRedux.useSelector((state) => {\n        return state.appConfig.screens[screenId];\n    });\n    const { panel } = screenJson;\n    const elementRef = React.useRef();\n    // eslint-disable-next-line no-unused-vars\n    const [loaded, setLoaded] = React.useState(false); //eslint-disable-line @typescript-eslint/no-unused-vars\n    const handleHeightChangeRef = React.useRef();\n    const intersectionChange = React.useCallback((isIntersecting) => {\n        onInteractionChange(index, isIntersecting);\n    }, [index, onInteractionChange]);\n    React.useEffect(() => {\n        handleHeightChangeRef.current = lodash.debounce(onHeightChange, 200);\n        return () => {\n            var _a;\n            (_a = handleHeightChangeRef.current) === null || _a === void 0 ? void 0 : _a.cancel();\n        };\n    }, [onHeightChange]);\n    const onSizeChange = React.useCallback(({ width, height }) => {\n        var _a;\n        (_a = handleHeightChangeRef.current) === null || _a === void 0 ? void 0 : _a.call(handleHeightChangeRef, index, height);\n    }, [index]);\n    useIntersection(elementRef.current, props.refElement, isSmallSize ? ScreenTriggerType.Lower : (triggerType !== null && triggerType !== void 0 ? triggerType : ScreenTriggerType.Bottom), intersectionChange);\n    React.useEffect(() => {\n        setLoaded(true);\n    }, []);\n    return (jsx(\"div\", { className: classNames('screen-side-panel', {\n            'top-spacing': index === 0 && (((_a = screenJson.panel) === null || _a === void 0 ? void 0 : _a.overlay) || isSmallSize)\n        }), \"data-screenid\": screenId, \"data-index\": index, ref: elementRef, css: getSidePanelStyle({\n            props: screenJson,\n            viewHeight,\n            headerHeight,\n            isActive,\n            verticalSpace,\n            stretched: stretched || panel == null,\n            transitionType,\n            screenTransitionType,\n            isSmallSize\n        }) },\n        panel && (jsx(\"div\", { className: 'panel-content' },\n            jsx(LayoutEntry, { layouts: panel.layout }),\n            jsx(\"div\", { className: classNames('panel-spacing', { 'last-item': props.isLast }) }))),\n        !panel && jsx(\"div\", { className: 'panel-content-placeholder' }),\n        jsx(ReactResizeDetector, { targetRef: elementRef, handleHeight: true, onResize: onSizeChange })));\n}\n","import { LayoutItemType, css, createSelector } from 'jimu-core';\nimport { styleUtils } from 'jimu-ui';\nimport { isRTL, getValueOfBBox } from '../utils';\nimport { findLayoutId } from '../search/contents';\nexport const mapStateToFlowItemProps = createSelector([\n    (state, ownProps) => {\n        var _a;\n        const { layoutItem } = ownProps;\n        const selection = (_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.selection;\n        if (selection) {\n            return selection.layoutId === ownProps.layoutId && selection.layoutItemId === layoutItem.id;\n        }\n        return false;\n    },\n    (state, ownProps) => {\n        var _a, _b, _c;\n        const { layoutItem } = ownProps;\n        let padding = [0, 0, 0, 0];\n        if (layoutItem.type === LayoutItemType.Widget) {\n            const widgetId = layoutItem.widgetId;\n            const widgetJson = state.appConfig.widgets[widgetId];\n            if (widgetJson) {\n                padding = styleUtils.expandStyleArray((_c = (_b = (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.padding) === null || _c === void 0 ? void 0 : _c.number);\n            }\n        }\n        return padding[0] + padding[2]; // top and bottom padding of inner row widget\n    },\n    (state, ownProps) => {\n        const { layoutItem } = ownProps;\n        let isEmpty = true;\n        if (layoutItem.type === LayoutItemType.Widget) {\n            const widgetId = layoutItem.widgetId;\n            const widgetJson = state.appConfig.widgets[widgetId];\n            if (widgetJson) {\n                const layoutName = Object.keys(widgetJson.layouts)[0];\n                const layoutId = findLayoutId(widgetJson.layouts[layoutName], state.browserSizeMode, state.appConfig.mainSizeMode);\n                const layout = state.appConfig.layouts[layoutId];\n                if (layout && Object.keys(layout.content || []).length > 0) {\n                    Object.keys(layout.content || []).some((itemId) => {\n                        const layoutItem = layout.content[itemId];\n                        if (!layoutItem.isPending) {\n                            isEmpty = false;\n                            return true;\n                        }\n                        else {\n                            return false;\n                        }\n                    });\n                }\n            }\n        }\n        return isEmpty;\n    }\n], (selected, padding, isEmpty) => ({ selected, padding, isEmpty }));\nexport function getWidthFromSetting(setting) {\n    const value = parseFloat(setting === null || setting === void 0 ? void 0 : setting.width);\n    if (value > 0) {\n        if (`${setting.width}`.includes('px')) {\n            return `${Math.round(value)}px`;\n        }\n        return `${Math.round(value)}%`;\n    }\n    return '100%';\n}\nexport function calculateFloatingPosition(layoutItem, resizingProps = {}) {\n    var _a, _b, _c;\n    const setting = layoutItem.setting;\n    const floatingArea = (_a = setting === null || setting === void 0 ? void 0 : setting.floatingArea) !== null && _a !== void 0 ? _a : 1;\n    const offsetX = `${(_b = setting === null || setting === void 0 ? void 0 : setting.offsetX) !== null && _b !== void 0 ? _b : 0}px`;\n    const offsetY = `${(_c = setting === null || setting === void 0 ? void 0 : setting.offsetY) !== null && _c !== void 0 ? _c : 0}px`;\n    const { dh, dw, initWidth, initHeight, isResizing } = resizingProps;\n    // translateX will not be modified by the emotion if it uses calc()\n    const translateX = isRTL() ? `translateX(calc(50% + ${offsetX}))` : `translateX(calc(-50% + ${offsetX}))`;\n    const pos = {};\n    switch (floatingArea) {\n        case 1: // top-left\n            pos.left = offsetX;\n            pos.top = offsetY;\n            pos.transform = null;\n            break;\n        case 2: // top-center\n            pos.left = '50%';\n            pos.top = offsetY;\n            pos.transform = translateX;\n            break;\n        case 3: // top-right\n            pos.right = offsetX;\n            pos.top = offsetY;\n            pos.transform = null;\n            break;\n        case 4: // middle-left\n            pos.left = offsetX;\n            pos.top = '50%';\n            pos.transform = `translateY(calc(-50% + ${offsetY}))`;\n            break;\n        case 5: // middle-center\n            pos.left = '50%';\n            pos.top = '50%';\n            pos.transform = `${translateX} translateY(calc(-50% + ${offsetY}))`;\n            break;\n        case 6: // middle-right\n            pos.right = offsetX;\n            pos.top = '50%';\n            pos.transform = `translateY(calc(-50% + ${offsetY}))`;\n            break;\n        case 7: // bottom-left\n            pos.left = offsetX;\n            pos.bottom = offsetY;\n            pos.transform = null;\n            break;\n        case 8: // bottom-center\n            pos.left = '50%';\n            pos.bottom = offsetY;\n            pos.transform = translateX;\n            break;\n        case 9: // bottom-right\n            pos.right = offsetX;\n            pos.bottom = offsetY;\n            pos.transform = null;\n            break;\n    }\n    return css `\r\n    position: fixed;\r\n    z-index: 1;\r\n    width: ${isResizing ? `${initWidth + dw}px` : getValueOfBBox(layoutItem.bbox, 'width')};\r\n    height: ${isResizing ? `${initHeight + dh}px` : getValueOfBBox(layoutItem.bbox, 'height')};\r\n    left: ${pos.left};\r\n    right: ${pos.right};\r\n    top: ${pos.top};\r\n    bottom: ${pos.bottom};\r\n    transform: ${pos.transform};\r\n  `;\n}\n","import { React, ReactRedux, jsx, css, classNames, getAppStore, AppMode, moduleLoader, hooks } from 'jimu-core';\nconst MIN_SIZE = 32;\nfunction restrictResizing(prevItemRect, nextItemRect, direction, dx, dy, isRTL) {\n    let x = dx;\n    let y = dy;\n    if (direction === 'row') {\n        const prevWidth = isRTL ? nextItemRect.width : prevItemRect.width;\n        const nextWidth = isRTL ? prevItemRect.width : nextItemRect.width;\n        if (dx < 0) {\n            if (prevWidth > MIN_SIZE) {\n                x = -Math.min(Math.abs(dx), prevWidth - MIN_SIZE);\n            }\n            else {\n                x = 0;\n            }\n        }\n        if (dx > 0) {\n            if (nextWidth > MIN_SIZE) {\n                x = Math.min(dx, nextWidth - MIN_SIZE);\n            }\n            else {\n                x = 0;\n            }\n        }\n    }\n    else {\n        if (dy < 0) {\n            if (prevItemRect.height > MIN_SIZE) {\n                y = -Math.min(Math.abs(dy), prevItemRect.height - MIN_SIZE);\n            }\n            else {\n                y = 0;\n            }\n        }\n        if (dy > 0) {\n            if (nextItemRect.height > MIN_SIZE) {\n                y = Math.min(dy, nextItemRect.height - MIN_SIZE);\n            }\n            else {\n                y = 0;\n            }\n        }\n    }\n    return { x, y };\n}\nfunction getSize(layoutItemElement) {\n    const layoutId = layoutItemElement.getAttribute('data-layoutid');\n    const layoutItemId = layoutItemElement.getAttribute('data-layoutitemid');\n    const appConfig = getAppStore().getState().appConfig;\n    const layoutItem = appConfig.layouts[layoutId].content[layoutItemId];\n    return +layoutItem.bbox.width;\n}\nexport function Splitter(props) {\n    var _a, _b;\n    const { referenceItemId, direction, layoutId, onResizeEnd } = props;\n    const domRef = React.useRef();\n    const interactableRef = React.useRef();\n    const interactRef = React.useRef(null);\n    const isRTL = (_b = (_a = getAppStore().getState().appContext) === null || _a === void 0 ? void 0 : _a.isRTL) !== null && _b !== void 0 ? _b : false;\n    const isDesignMode = ReactRedux.useSelector((state) => {\n        return state.appRuntimeInfo.appMode === AppMode.Design;\n    });\n    const layoutResizable = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        const layout = state.appConfig.layouts[props.layoutId];\n        return (_b = (_a = layout.setting) === null || _a === void 0 ? void 0 : _a.resizable) !== null && _b !== void 0 ? _b : true;\n    });\n    const size = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        const layout = state.appConfig.layouts[layoutId];\n        return (_b = (_a = layout.setting) === null || _a === void 0 ? void 0 : _a.splitSize) !== null && _b !== void 0 ? _b : 8;\n    });\n    const color = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        const layout = state.appConfig.layouts[layoutId];\n        return (_b = (_a = layout.setting) === null || _a === void 0 ? void 0 : _a.splitColor) !== null && _b !== void 0 ? _b : 'var(--ref-palette-neutral-500)';\n    });\n    const style = React.useMemo(() => {\n        const pxSize = `${size}px`;\n        const canResize = isDesignMode ? true : layoutResizable;\n        return css `\r\n      width: ${direction === 'col' ? '100%' : pxSize};\r\n      height: ${direction === 'col' ? pxSize : '100%'};\r\n      background: ${color};\r\n      position: relative;\r\n      overflow: visible;\r\n      z-index: 20;\r\n      flex-shrink: 0;\r\n\r\n      .handler {\r\n        position: absolute;\r\n        background: transparent;\r\n      }\r\n      .horizontal-splitter {\r\n        top: 0;\r\n        bottom: 0;\r\n        left: -5px;\r\n        right: -5px;\r\n        &:after {\r\n          content: '';\r\n          position: absolute;\r\n          inset: 0 5px 0 0;\r\n          cursor: ${canResize ? 'col-resize' : 'default'};\r\n        }\r\n      }\r\n\r\n      .vertical-splitter {\r\n        left: 0;\r\n        right: 0;\r\n        top: -5px;\r\n        bottom: -5px;\r\n        &:after {\r\n          content: '';\r\n          position: absolute;\r\n          inset: 0 0 5px 0;\r\n          cursor: ${canResize ? 'row-resize' : 'default'};\r\n        }\r\n      }\r\n    `;\n    }, [direction, layoutResizable, isDesignMode, size, color]);\n    hooks.useEffectOnce(() => {\n        let dx;\n        let dy;\n        let parentRect;\n        let prevItem;\n        let prevItemRect;\n        let prevSize;\n        let originPrevItemWidth;\n        let originPrevItemHeight;\n        let nextItem;\n        let nextItemRect;\n        let nextSize;\n        let originNextItemWidth;\n        let originNextItemHeight;\n        import('jimu-core/dnd').then(module => {\n            const interact = module.interact;\n            interactRef.current = interact;\n            if (!domRef.current) { // maInteractStaticybe unmounted in this async callback\n                return;\n            }\n            interactableRef.current = interact(domRef.current)\n                .origin('parent')\n                .draggable({\n                inertia: false,\n                autoScroll: false,\n                enabled: isDesignMode ? true : layoutResizable,\n                modifiers: [\n                    interact.modifiers.restrict({\n                        restriction: 'parent'\n                    })\n                ],\n                lockAxis: direction === 'row' ? 'x' : 'y',\n                onstart: (event) => {\n                    event.stopPropagation();\n                    dx = 0;\n                    dy = 0;\n                    parentRect = domRef.current.parentElement.getBoundingClientRect();\n                    prevItem = domRef.current.previousElementSibling;\n                    prevItemRect = prevItem.getBoundingClientRect();\n                    originPrevItemWidth = prevItem.style.width;\n                    originPrevItemHeight = prevItem.style.height;\n                    prevSize = getSize(prevItem);\n                    nextItem = domRef.current.nextElementSibling;\n                    nextItemRect = nextItem.getBoundingClientRect();\n                    originNextItemWidth = nextItem.style.width;\n                    originNextItemHeight = nextItem.style.height;\n                    nextSize = getSize(nextItem);\n                },\n                onmove: (event) => {\n                    event.stopPropagation();\n                    dx += event.dx;\n                    dy += event.dy;\n                    const { x, y } = restrictResizing(prevItemRect, nextItemRect, direction, dx, dy, isRTL);\n                    const factor = isRTL ? -1 : 1;\n                    if (direction === 'row') {\n                        prevItem.style.width = `calc(${prevSize}% + ${x * factor}px)`;\n                        nextItem.style.width = `calc(${nextSize}% - ${x * factor}px)`;\n                    }\n                    else {\n                        prevItem.style.height = `calc(${prevSize}% + ${y}px)`;\n                        nextItem.style.height = `calc(${nextSize}% - ${y}px)`;\n                    }\n                },\n                onend: (event) => {\n                    event.stopPropagation();\n                    dx += event.dx;\n                    dy += event.dy;\n                    const { x, y } = restrictResizing(prevItemRect, nextItemRect, direction, dx, dy, isRTL);\n                    const factor = isRTL ? -1 : 1;\n                    // restore style of items\n                    prevItem.style.width = originPrevItemWidth;\n                    nextItem.style.width = originNextItemWidth;\n                    prevItem.style.height = originPrevItemHeight;\n                    nextItem.style.height = originNextItemHeight;\n                    onResizeEnd(referenceItemId, Math.round(x * factor * 10000 / parentRect.width) / 100, Math.round(y * 10000 / parentRect.height) / 100);\n                }\n            });\n        });\n        return () => {\n            var _a;\n            (_a = interactableRef.current) === null || _a === void 0 ? void 0 : _a.unset();\n            interactableRef.current = null;\n        };\n    });\n    React.useEffect(() => {\n        if (interactableRef.current != null) {\n            interactRef.current(domRef.current).draggable(isDesignMode ? true : layoutResizable);\n        }\n    }, [layoutResizable, isDesignMode]);\n    return (jsx(\"div\", { ref: domRef, css: style, className: 'grid-split flex-shrink-0' },\n        jsx(\"div\", { className: classNames('handler', {\n                'horizontal-splitter': direction === 'row',\n                'vertical-splitter': direction === 'col'\n            }) })));\n}\n","import { css, LayoutType, LayoutItemType, GridItemType } from 'jimu-core';\nimport { styleUtils } from 'jimu-ui';\nexport function indexOfPlainContent(layout, layoutItemId) {\n    var _a, _b;\n    let start = 0;\n    const rootItemId = layout.setting.rootItem;\n    const rootItem = getGridItem(layout, rootItemId);\n    if (rootItem && ((_a = rootItem.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n        const candidates = [...rootItem.children];\n        while (candidates.length > 0) {\n            const firstItemId = candidates.shift();\n            const firstItem = getGridItem(layout, firstItemId);\n            const parentId = firstItem.parent;\n            const parentItem = getGridItem(layout, parentId);\n            if (\n            //eslint-disable-next-line @typescript-eslint/no-unnecessary-template-expression\n            `${firstItem.id}` === layoutItemId ||\n                (parentItem.gridType === GridItemType.Tab && parentItem.children.includes(layoutItemId))) {\n                return start;\n            }\n            if (((_b = firstItem.children) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                // it is a group\n                candidates.unshift(...firstItem.children);\n                continue;\n            }\n            // tab only increase index once\n            if (parentItem.gridType !== GridItemType.Tab ||\n                (parentItem.gridType === GridItemType.Tab && parentItem.children.indexOf(firstItemId) === 0)) {\n                start += 1;\n            }\n        }\n    }\n    return start;\n}\nexport function isLastChildOfRootItem(layout, layoutItemId) {\n    var _a;\n    let currentItem = getGridItem(layout, layoutItemId);\n    if (((_a = currentItem === null || currentItem === void 0 ? void 0 : currentItem.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n        // children's is behind currentItem\n        return false;\n    }\n    while (currentItem != null) {\n        const parentId = currentItem.parent;\n        if (parentId == null) {\n            break;\n        }\n        // check if it the last child of its parent\n        const parentItem = getGridItem(layout, parentId);\n        const len = parentItem.children.length;\n        const lastId = parentItem.children[len - 1];\n        if (+lastId !== +currentItem.id) {\n            return false;\n        }\n        currentItem = parentItem;\n    }\n    return true;\n}\nexport function isExpandable(state, layoutId, layoutItemId) {\n    var _a, _b;\n    const layout = state.appConfig.layouts[layoutId];\n    const layoutItem = layout.content[layoutItemId];\n    const canExpand = (_a = layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.expandable) !== null && _a !== void 0 ? _a : true;\n    if (!canExpand) {\n        return false;\n    }\n    // set expandable to false if it is the only item in grid\n    const rootItem = (_b = layout === null || layout === void 0 ? void 0 : layout.setting) === null || _b === void 0 ? void 0 : _b.rootItem;\n    let isOnlyItem = false;\n    if (rootItem === layoutItemId) {\n        const rootLayoutItem = getGridItem(layout, rootItem);\n        if (rootLayoutItem.children == null || rootLayoutItem.children.length === 0) {\n            isOnlyItem = true;\n        }\n    }\n    return !isOnlyItem;\n}\nexport function getGridItem(layout, layoutItemId) {\n    var _a;\n    return (_a = layout.content) === null || _a === void 0 ? void 0 : _a[layoutItemId];\n}\nfunction fetchGridNode(layout, layoutItemId) {\n    const item = getGridItem(layout, layoutItemId);\n    if (item == null) {\n        return null;\n    }\n    const { gridType = GridItemType.Plain, children } = item;\n    const result = { layoutItemId, type: gridType };\n    if ((children === null || children === void 0 ? void 0 : children.length) > 0) {\n        result.children = [...children].map((itemId) => fetchGridNode(layout, itemId));\n    }\n    return result;\n}\nexport function getGridLayoutStructure(layout) {\n    var _a;\n    if (layout.type !== LayoutType.GridLayout) {\n        return null;\n    }\n    const rootItemId = (_a = layout.setting) === null || _a === void 0 ? void 0 : _a.rootItem;\n    return fetchGridNode(layout, `${rootItemId}`);\n}\nexport function getLabelOfGridTab(appConfig, layoutInfo, translate) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const { layoutId, layoutItemId } = layoutInfo;\n    const layoutItem = appConfig.layouts[layoutId].content[layoutItemId];\n    if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Widget) {\n        const widget = appConfig.widgets[layoutItem.widgetId];\n        if (!widget) {\n            return translate('placeholder');\n        }\n        return (_b = (_a = widget === null || widget === void 0 ? void 0 : widget.label) !== null && _a !== void 0 ? _a : layoutItem.label) !== null && _b !== void 0 ? _b : layoutItem.id; // may be a placeholder\n    }\n    if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Section) {\n        const section = appConfig.sections[layoutItem.sectionId];\n        return section.label;\n    }\n    if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.gridType) === GridItemType.Row) {\n        return (_c = layoutItem.label) !== null && _c !== void 0 ? _c : translate('gridRow');\n    }\n    if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.gridType) === GridItemType.Column) {\n        return (_d = layoutItem.label) !== null && _d !== void 0 ? _d : translate('gridCol');\n    }\n    if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.gridType) === GridItemType.Tab) {\n        return (_e = layoutItem.label) !== null && _e !== void 0 ? _e : translate('tabs');\n    }\n    return (_g = (_f = layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.label) !== null && _f !== void 0 ? _f : layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.id) !== null && _g !== void 0 ? _g : '';\n}\nexport function calPaddingStyle(layoutSetting) {\n    var _a;\n    const padding = styleUtils.toCSSPadding((_a = layoutSetting === null || layoutSetting === void 0 ? void 0 : layoutSetting.style) === null || _a === void 0 ? void 0 : _a.padding);\n    if (padding) {\n        if (layoutSetting.paddingColor) {\n            const paddingTokens = padding.split(' ');\n            const paddingColor = layoutSetting.paddingColor;\n            let prefix = '';\n            const ua = window.jimuUA.browser.name.toLowerCase();\n            if (ua === 'firefox') {\n                prefix = '-moz-';\n            }\n            else if (ua === 'safari' || ua === 'chrome') {\n                prefix = '-webkit-';\n            }\n            return css `\r\n        padding: ${padding};\r\n        background-image:\r\n        ${prefix}linear-gradient(270deg, ${paddingColor} ${paddingTokens[0]}, transparent ${paddingTokens[0]}),\r\n        ${prefix}linear-gradient(180deg, ${paddingColor} ${paddingTokens[1]}, transparent ${paddingTokens[1]}),\r\n        ${prefix}linear-gradient(90deg, ${paddingColor} ${paddingTokens[2]}, transparent ${paddingTokens[2]}),\r\n        ${prefix}linear-gradient(0deg, ${paddingColor} ${paddingTokens[3]}, transparent ${paddingTokens[3]});\r\n      `;\n        }\n        return css `\r\n      padding: ${padding};\r\n    `;\n    }\n}\n","import { css } from 'jimu-core';\nimport * as utils from '../../utils';\nexport function getItemStyle(isMultiRow, sign, gutter, mergedStyle, itemSetting) {\n    var _a, _b, _c, _d;\n    if (isMultiRow) {\n        return [\n            css `\r\n        padding: ${gutter / 2}px 0;\r\n        height: ${utils.getValueOfBBox(mergedStyle, 'height')};\r\n        align-self: ${mergedStyle.alignSelf};\r\n      `,\n            itemSetting.offsetX !== 0 || itemSetting.offsetY !== 0\n                ? `translate(${((_a = itemSetting.offsetX) !== null && _a !== void 0 ? _a : 0) * sign}px, ${(_b = itemSetting.offsetY) !== null && _b !== void 0 ? _b : 0}px)`\n                : null\n        ];\n    }\n    return [\n        css `\r\n      padding: 0 ${gutter / 2}px;\r\n      height: ${utils.getValueOfBBox(mergedStyle, 'height')};\r\n      align-self: ${mergedStyle.alignSelf};\r\n    `,\n        itemSetting.offsetX !== 0 || itemSetting.offsetY !== 0\n            ? `translate(${((_c = itemSetting.offsetX) !== null && _c !== void 0 ? _c : 0) * sign}px, ${(_d = itemSetting.offsetY) !== null && _d !== void 0 ? _d : 0}px)`\n            : null\n    ];\n}\n","import { Immutable, css } from 'jimu-core';\nimport { TOTAL_COLS } from './types';\nimport { LayoutItemSizeModes } from '../types';\nexport const ROW_STYLE = css `\r\n  width: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n\r\n  .offset-1 {\r\n    margin-left: 8.33333%;\r\n    margin-right: 0;\r\n  }\r\n  .offset-2 {\r\n    margin-left: 16.66667%;\r\n    margin-right: 0;\r\n  }\r\n  .offset-3 {\r\n    margin-left: 25%;\r\n    margin-right: 0;\r\n  }\r\n  .offset-4 {\r\n    margin-left: 33.33333%;\r\n    margin-right: 0;\r\n  }\r\n  .offset-5 {\r\n    margin-left: 41.66667%;\r\n    margin-right: 0;\r\n  }\r\n  .offset-6 {\r\n    margin-left: 50%;\r\n    margin-right: 0;\r\n  }\r\n  .offset-7 {\r\n    margin-left: 58.33333%;\r\n    margin-right: 0;\r\n  }\r\n  .offset-8 {\r\n    margin-left: 66.66667%;\r\n    margin-right: 0;\r\n  }\r\n  .offset-9 {\r\n    margin-left: 75%;\r\n    margin-right: 0;\r\n  }\r\n  .offset-10 {\r\n    margin-left: 83.33333%;\r\n    margin-right: 0;\r\n  }\r\n  .offset-11 {\r\n    margin-left: 91.66667%;\r\n    margin-right: 0;\r\n  }\r\n`;\nexport function flipRowItemPos(bbox) {\n    const result = Immutable(bbox);\n    return result.set('left', TOTAL_COLS - parseInt(bbox.left, 10) - parseInt(bbox.width, 10));\n}\nexport function calItemHeight(itemSetting, bbox, isMultiRow) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n    if (isMultiRow) {\n        return {\n            height: ((_a = itemSetting.autoProps) === null || _a === void 0 ? void 0 : _a.height) === LayoutItemSizeModes.Auto ? 'auto' : bbox.height,\n            alignSelf: (_c = (_b = itemSetting.style) === null || _b === void 0 ? void 0 : _b.alignSelf) !== null && _c !== void 0 ? _c : 'flex-start'\n        };\n    }\n    // 1. aspect ratio\n    if (itemSetting.heightMode === 'ratio') {\n        return { alignSelf: (_e = (_d = itemSetting.style) === null || _d === void 0 ? void 0 : _d.alignSelf) !== null && _e !== void 0 ? _e : 'flex-start' };\n    }\n    // 2. use autoProps.height first\n    if (((_f = itemSetting.autoProps) === null || _f === void 0 ? void 0 : _f.height) === LayoutItemSizeModes.Auto) {\n        return { height: 'auto', alignSelf: (_h = (_g = itemSetting.style) === null || _g === void 0 ? void 0 : _g.alignSelf) !== null && _h !== void 0 ? _h : 'flex-start' };\n    }\n    else if (((_j = itemSetting.autoProps) === null || _j === void 0 ? void 0 : _j.height) === LayoutItemSizeModes.Custom) {\n        return { height: bbox.height, alignSelf: (_l = (_k = itemSetting.style) === null || _k === void 0 ? void 0 : _k.alignSelf) !== null && _l !== void 0 ? _l : 'flex-start' };\n    }\n    else if (((_m = itemSetting.autoProps) === null || _m === void 0 ? void 0 : _m.height) === LayoutItemSizeModes.Stretch) {\n        return { alignSelf: 'stretch' };\n    }\n    // 3. back compatible, use setting.heightMode\n    if (itemSetting.heightMode === 'fit') {\n        return { alignSelf: 'stretch' };\n    }\n    else if (parseFloat(bbox.height) > 0) {\n        return { height: bbox.height, alignSelf: (_p = (_o = itemSetting.style) === null || _o === void 0 ? void 0 : _o.alignSelf) !== null && _p !== void 0 ? _p : 'flex-start' };\n    }\n    return { alignSelf: 'stretch' };\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, hooks, classNames } from 'jimu-core';\nimport { LeftOutlined } from 'jimu-icons/outlined/directional/left';\nimport { RightOutlined } from 'jimu-icons/outlined/directional/right';\nimport { Button, defaultMessages } from 'jimu-ui';\nexport function SectionNav(props) {\n    var _a, _b, _c;\n    const { sectionId, currentIndex, numOfViews, onCurrentViewChange } = props;\n    const translate = hooks.useTranslation(defaultMessages);\n    const arrowsNav = ReactRedux.useSelector((state) => {\n        var _a;\n        return (_a = state.appConfig.sections[sectionId]) === null || _a === void 0 ? void 0 : _a.arrowsNav;\n    });\n    const dotsNav = ReactRedux.useSelector((state) => {\n        var _a;\n        return (_a = state.appConfig.sections[sectionId]) === null || _a === void 0 ? void 0 : _a.dotsNav;\n    });\n    const viewLabelString = ReactRedux.useSelector((state) => {\n        if (dotsNav === null || dotsNav === void 0 ? void 0 : dotsNav.visible) {\n            const sectionJson = state.appConfig.sections[sectionId];\n            const views = sectionJson === null || sectionJson === void 0 ? void 0 : sectionJson.views;\n            if ((views === null || views === void 0 ? void 0 : views.length) > 0) {\n                const labels = views.map((view) => state.appConfig.views[view].label);\n                return labels.join(';');\n            }\n        }\n        return '';\n    });\n    const viewLabels = React.useMemo(() => {\n        if (viewLabelString.length > 0) {\n            return viewLabelString.split(';');\n        }\n        return [];\n    }, [viewLabelString]);\n    const dotsNavPosition = (_a = dotsNav === null || dotsNav === void 0 ? void 0 : dotsNav.position) !== null && _a !== void 0 ? _a : 'b';\n    const dots = React.useMemo(() => {\n        const result = [];\n        for (let i = 0; i < numOfViews; i++) {\n            result.push(i);\n        }\n        return result;\n    }, [numOfViews]);\n    const arrowStyle = () => {\n        var _a, _b, _c, _d;\n        return css `\r\n      position: absolute;\r\n      cursor: pointer;\r\n      pointer-events: auto;\r\n\r\n      &.disabled {\r\n        cursor: default;\r\n        svg {\r\n          color: var(--ref-palette-neutral-500);\r\n        }\r\n      }\r\n\r\n      &.first {\r\n        left: ${(_a = arrowsNav.offset) !== null && _a !== void 0 ? _a : 8}px;\r\n        top: 50%;\r\n        transform: translateY(-50%);\r\n\r\n        &.vertical {\r\n          top: ${(_b = arrowsNav.offset) !== null && _b !== void 0 ? _b : 8}px;\r\n          left: 50%;\r\n          transform: translateX(-50%) rotate(90deg);\r\n        }\r\n      }\r\n      &.second {\r\n        right: ${(_c = arrowsNav.offset) !== null && _c !== void 0 ? _c : 8}px;\r\n        top: 50%;\r\n        transform: translateY(-50%);\r\n\r\n        &.vertical {\r\n          bottom: ${(_d = arrowsNav.offset) !== null && _d !== void 0 ? _d : 8}px;\r\n          left: 50%;\r\n          top: auto;\r\n          right: auto;\r\n          transform: translateX(-50%) rotate(90deg);\r\n        }\r\n      }\r\n    `;\n    };\n    const dotStyle = () => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n        return css `\r\n      position: absolute;\r\n      display: flex;\r\n      flex-direction: ${dotsNavPosition === 'l' || dotsNavPosition === 'r' ? 'column' : 'row'};\r\n      justify-content: center;\r\n      align-items: center;\r\n      overflow: visible;\r\n      pointer-events: none;\r\n      background: transparent;\r\n\r\n      .dot {\r\n        pointer-events: all;\r\n        cursor: pointer;\r\n        border: 1px solid var(--ref-palette-neutral-500);\r\n        background: var(--ref-palette-neutral-200);\r\n        width: ${(_a = dotsNav.size) !== null && _a !== void 0 ? _a : 8}px;\r\n        height: ${(_b = dotsNav.size) !== null && _b !== void 0 ? _b : 8}px;\r\n\r\n        &.active {\r\n          border-color: var(--ref-palette-white);\r\n          background: var(--sys-color-primary-main);\r\n          width: ${dotsNav.size > 0 ? dotsNav.size * 1.5 : 12}px;\r\n          height: ${dotsNav.size > 0 ? dotsNav.size * 1.5 : 12}px;\r\n        }\r\n\r\n        &.disabled {\r\n          cursor: default;\r\n        }\r\n      }\r\n\r\n      &.snap-left {\r\n        height: 100%;\r\n        top: 0;\r\n        left: ${(_c = dotsNav.offset) !== null && _c !== void 0 ? _c : 50}px;\r\n        width: ${(_d = dotsNav.size) !== null && _d !== void 0 ? _d : 8}px;\r\n\r\n        > button:not(:first-of-type) {\r\n          margin-top: ${(_e = dotsNav.spacing) !== null && _e !== void 0 ? _e : 10}px;\r\n        }\r\n      }\r\n      &.snap-right {\r\n        height: 100%;\r\n        top: 0;\r\n        right: ${(_f = dotsNav.offset) !== null && _f !== void 0 ? _f : 50}px;\r\n        width: ${(_g = dotsNav.size) !== null && _g !== void 0 ? _g : 8}px;\r\n\r\n        > button:not(:first-of-type) {\r\n          margin-top: ${(_h = dotsNav.spacing) !== null && _h !== void 0 ? _h : 10}px;\r\n        }\r\n      }\r\n      &.snap-top {\r\n        width: 100%;\r\n        top: ${(_j = dotsNav.offset) !== null && _j !== void 0 ? _j : 50}px;\r\n        height: ${(_k = dotsNav.size) !== null && _k !== void 0 ? _k : 8}px;\r\n\r\n        > button:not(:first-of-type) {\r\n          margin-left: ${(_l = dotsNav.spacing) !== null && _l !== void 0 ? _l : 10}px;\r\n        }\r\n      }\r\n      &.snap-bottom {\r\n        width: 100%;\r\n        bottom: ${(_m = dotsNav.offset) !== null && _m !== void 0 ? _m : 50}px;\r\n        height: ${(_o = dotsNav.size) !== null && _o !== void 0 ? _o : 8}px;\r\n\r\n        > button:not(:first-of-type) {\r\n          margin-left: ${(_p = dotsNav.spacing) !== null && _p !== void 0 ? _p : 10}px;\r\n        }\r\n      }\r\n    `;\n    };\n    const createDot = React.useCallback((index, isActive) => {\n        var _a;\n        return (jsx(Button, { key: index, type: 'tertiary', \"aria-label\": (_a = viewLabels[index]) !== null && _a !== void 0 ? _a : '', className: classNames('dot p-0 rounded-circle', { active: isActive, disabled: numOfViews <= 1 }), onClick: isActive ? undefined : () => { onCurrentViewChange(index); } }));\n    }, [onCurrentViewChange, numOfViews, viewLabels]);\n    const previousView = React.useCallback(() => {\n        const nextIndex = currentIndex > 0 ? currentIndex - 1 : numOfViews - 1;\n        onCurrentViewChange(nextIndex);\n    }, [currentIndex, numOfViews, onCurrentViewChange]);\n    const nextView = React.useCallback(() => {\n        const nextIndex = currentIndex < numOfViews - 1 ? currentIndex + 1 : 0;\n        onCurrentViewChange(nextIndex);\n    }, [currentIndex, numOfViews, onCurrentViewChange]);\n    const hasPreviousView = numOfViews > 1 && currentIndex !== 0;\n    const hasNextView = numOfViews > 1 && currentIndex !== numOfViews - 1;\n    return (jsx(React.Fragment, null,\n        (arrowsNav === null || arrowsNav === void 0 ? void 0 : arrowsNav.visible) && (jsx(React.Fragment, null,\n            jsx(Button, { type: 'tertiary', disabled: !hasPreviousView, className: classNames('arrows-nav first p-0', {\n                    vertical: arrowsNav.direction === 'v'\n                }), css: arrowStyle(), onClick: hasPreviousView ? previousView : null, \"aria-label\": translate('previous') },\n                jsx(LeftOutlined, { className: 'm-0', autoFlip: arrowsNav.direction !== 'v', size: (_b = arrowsNav.size) !== null && _b !== void 0 ? _b : 20 })),\n            jsx(Button, { type: 'tertiary', disabled: !hasNextView, className: classNames('arrows-nav second p-0', {\n                    vertical: arrowsNav.direction === 'v'\n                }), css: arrowStyle(), onClick: hasNextView ? nextView : null, \"aria-label\": translate('next') },\n                jsx(RightOutlined, { className: 'm-0', autoFlip: arrowsNav.direction !== 'v', size: (_c = arrowsNav.size) !== null && _c !== void 0 ? _c : 20 })))),\n        (dotsNav === null || dotsNav === void 0 ? void 0 : dotsNav.visible) && (jsx(\"div\", { className: classNames('dots-nav', {\n                'snap-left': dotsNavPosition === 'l',\n                'snap-top': dotsNavPosition === 't',\n                'snap-right': dotsNavPosition === 'r',\n                'snap-bottom': dotsNavPosition === 'b'\n            }), css: dotStyle() }, dots.map((index) => createDot(index, index === currentIndex))))));\n}\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/** @jsx jsx */\nimport { React, jsx, css, hooks, classNames, getIndexFromProgress, jimuHistory, getAppStore } from 'jimu-core';\nimport { DEFAULT_AUTOPLAY_INTERVAL } from '../types';\nimport { styleUtils } from 'jimu-ui';\nimport { SectionContent } from './section-content';\nimport { SectionNav } from './section-nav';\nimport { useAutoPlay } from './section-auto-play';\nimport defaultMessages from '../translations/default';\nfunction getStyle(forceAspectRatio, aspectRatio) {\n    return css `\r\n    overflow: visible;\r\n    position: relative;\r\n    aspect-ratio: ${forceAspectRatio && aspectRatio > 0 ? aspectRatio : null};\r\n\r\n    .section-content {\r\n      position: relative;\r\n      overflow: hidden;\r\n      width: 100%;\r\n      height: 100%;\r\n      z-index: 0;\r\n    }\r\n\r\n    .section-view {\r\n      position: absolute;\r\n    }\r\n\r\n    .hidden {\r\n      display: none !important;\r\n    }\r\n  `;\n}\nexport function SectionRendererBase(props) {\n    var _a;\n    const { views, navInfo, activeView, animationPreview, playMode, transition, sectionId, autoPlay, focusable = true, interval = DEFAULT_AUTOPLAY_INTERVAL, loop = true, className, sectionStyle, rotate, forceAspectRatio, aspectRatio, layoutEntryComponent, viewVisibilityContext } = props;\n    const currentIndexRef = React.useRef();\n    const sectionRef = React.useRef();\n    const hasFocusRef = React.useRef(false);\n    const isSectionFocusedRef = React.useRef(false);\n    const blurEventHandlerRef = React.useRef(null);\n    const [interruptAutoplay, setInterruptAutoplay] = React.useState(false);\n    const translate = hooks.useTranslation(defaultMessages);\n    const activeViewId = activeView === null || activeView === void 0 ? void 0 : activeView.id;\n    const renderInfo = React.useMemo(() => {\n        var _a;\n        let visibleViews = views;\n        let currentIndex;\n        let previousIndex;\n        let progress;\n        if (navInfo) {\n            visibleViews = (_a = navInfo.visibleViews) !== null && _a !== void 0 ? _a : views;\n            if (navInfo.useProgress) {\n                progress = navInfo.progress;\n                const r = getIndexFromProgress(progress, visibleViews.length);\n                currentIndex = r.currentIndex;\n            }\n            else {\n                currentIndex = Math.max(0, visibleViews.indexOf(navInfo.currentViewId));\n                if (navInfo.previousViewId) {\n                    previousIndex = Math.max(0, visibleViews.indexOf(navInfo.previousViewId));\n                }\n                else {\n                    previousIndex = Math.max(0, currentIndex - 1);\n                }\n            }\n        }\n        else {\n            // TODO remove nav by activeView, use navInfo only\n            currentIndex = Math.max(0, visibleViews.indexOf(activeViewId));\n            previousIndex = currentIndex;\n        }\n        currentIndexRef.current = currentIndex;\n        return { currentIndex, previousIndex, progress };\n    }, [activeViewId, navInfo, views]);\n    const _b = React.useMemo(() => {\n        return styleUtils.toCSSStyle(sectionStyle);\n    }, [sectionStyle]), { transform } = _b, otherStyle = __rest(_b, [\"transform\"]);\n    const rotateStyle = rotate > 0 || rotate < 0 ? `rotateZ(${rotate}deg)` : '';\n    let mergedTransform = rotateStyle;\n    if (transform) {\n        mergedTransform = `${transform} ${rotateStyle}`;\n    }\n    const onMouseEnter = React.useCallback(() => {\n        setInterruptAutoplay(true);\n    }, []);\n    const onMouseLeave = React.useCallback(() => {\n        setInterruptAutoplay(false);\n    }, []);\n    const onFocus = React.useCallback((e) => {\n        hasFocusRef.current = true;\n        isSectionFocusedRef.current = e.target === sectionRef.current;\n        if (blurEventHandlerRef.current != null) {\n            clearTimeout(blurEventHandlerRef.current);\n            blurEventHandlerRef.current = null;\n        }\n        if (autoPlay) {\n            setInterruptAutoplay(true);\n        }\n    }, [autoPlay]);\n    const onBlur = React.useCallback((e) => {\n        hasFocusRef.current = false;\n        if (blurEventHandlerRef.current != null) {\n            clearTimeout(blurEventHandlerRef.current);\n            blurEventHandlerRef.current = null;\n        }\n        if (autoPlay) {\n            blurEventHandlerRef.current = setTimeout(() => {\n                setInterruptAutoplay(false);\n            }, 500);\n        }\n    }, [autoPlay]);\n    const isAutoPlaying = autoPlay && !interruptAutoplay;\n    useAutoPlay({\n        sectionId,\n        interval,\n        loop,\n        autoPlay: isAutoPlaying\n    });\n    const onCurrentViewChange = React.useCallback((nextIndex) => {\n        jimuHistory.changeView(sectionId, views[nextIndex]);\n    }, [sectionId, views]);\n    const getLabelOfActiveView = () => {\n        var _a, _b, _c;\n        const viewId = views[currentIndexRef.current];\n        const appConfig = getAppStore().getState().appConfig;\n        return (_c = (_b = (_a = appConfig === null || appConfig === void 0 ? void 0 : appConfig.views) === null || _a === void 0 ? void 0 : _a[viewId]) === null || _b === void 0 ? void 0 : _b.label) !== null && _c !== void 0 ? _c : '';\n    };\n    return (jsx(\"div\", { className: classNames(`section-layout layout-item-content w-100 ${(_a = sectionStyle === null || sectionStyle === void 0 ? void 0 : sectionStyle.boxShadow) === null || _a === void 0 ? void 0 : _a.presetStyle}`, className), css: getStyle(forceAspectRatio, aspectRatio), \"data-sectionid\": sectionId, style: Object.assign(Object.assign({}, otherStyle), { transform: mergedTransform }), onMouseEnter: autoPlay ? onMouseEnter : null, onMouseLeave: autoPlay ? onMouseLeave : null, onTouchStart: autoPlay ? onMouseEnter : null, onTouchEnd: autoPlay ? onMouseLeave : null, onFocus: onFocus, onBlur: onBlur, tabIndex: focusable ? 0 : undefined, \"aria-label\": translate('activeViewTip', { viewLabel: getLabelOfActiveView() }), ref: sectionRef },\n        jsx(SectionContent, { views: views, navInfo: navInfo, animationPreview: animationPreview, playMode: playMode, currentIndex: renderInfo.currentIndex, previousIndex: renderInfo.previousIndex, progress: renderInfo.progress, loop: isAutoPlaying && loop, viewTransition: transition, layoutEntryComponent: layoutEntryComponent, viewVisibilityContext: viewVisibilityContext }),\n        jsx(SectionNav, { sectionId: sectionId, numOfViews: views.length, currentIndex: renderInfo.currentIndex, onCurrentViewChange: onCurrentViewChange })));\n}\n"],"names":[],"sourceRoot":""}