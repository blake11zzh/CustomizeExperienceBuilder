{"version":3,"file":"8979.c930746f.iframe.bundle.js","mappings":";;;;;;;AA2FA;;;AAGA;;;AAGA;;;;;;;AAOA;;;;;;;;;AASA;;;;;;;AAOA;;;;;;;;;;;AAWA;;;;AAIA;;AAGA;;;AAOA;;AAIA;;;;;;;;AAQA;;AAGA;;;;AAOA;AACA;AACA;;AAGA;;;;;AA4DA;;;;;ACpMA;;;AAGA;;AAGA;;;;AA6BA;AACA;AACA;;AAGA;;AA8CA;;;AAGA;AC5EA;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;;;;;;AAMA;;;AAGA;;;AAGA;;;AAGA;;;;;;;;AAQA;AACA;;;AAIA;;;;;;;AC7DA;;;;;;;;AAQA;AACA;AACA;;;AAIA;;;;ACrCA;;;;;AAQA;;;;AAKA;;;;;;;;;;;;AAeA;;;AAGA;;;;;;AAMA;;;AAGA;AACA;;;;;;;;;;;AAWA;AACA;;;;;;;;;;;;AAYA;;;;;;;;;;;;;AAcA;ACnGA;AACA;;;AAIA;;;ACFA;;;;;ACQA;;;AAGA;;;;;;;AAQA;;;;;AAKA;;;AAGA;;AAGA;;;;;AAKA;;;AAGA;;AAGA;;;;;AAKA;;;AAGA;;AAGA;AArDA;AAGA;AAAA;;;;AAyDA;;;;;AA3DA;AACA;AAiEA;;;AAIA;AAvEA;AAGA;AAAA;;;;AA2EA;;;;;AA5EA;AADA;AAoFA;;;AAIA;AAzFA;AAGA;AAAA;;;;AA6FA;;;;;AA/FA;AACA;AAqGA;;;AAIA;AA3GA;AAGA;AAAA;;;;AA+GA;;;;;AAhHA;AADA;AAwHA;;;AAiBA;AA3IA;AAAA;;AAkJA;AAGA;;;ACjEA;AC+DA;AACA;;;;;;AAMA;;;;;AAKA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;AAmBA;;AAEA;;;;;;;;;AASA;;;;;;;;;;;;;;AAcA;AACA;;;;;;;;;;;;;AAcA;;;AChMA;;;;;;;;;;;;;AAaA;;AAIA;;;;;;;;;ACjCA;;;;;;;;AAiFA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;;;;;;;;;;;;;AAeA;AAIA;;;AAIA;;AAKA;;;;AAIA;;AAEA;;AAEA;;;;AAKA;ACzKA;;;AAGA;;;;;;;;;;;;;;;AAgBA;;;;AAOA;AC8OA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;;;AAGA;;;;AAIA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;;;;;;;AAQA;;AAIA;;;;;;;;;;AAYA;;;;;;;;;;;;;AAcA;;AClWA;;;;;;;;;;AAWA;;AAEA;;;;;;;;;AASA;;AAGA;;;;;;;ACFA;AACA;;AAGA;;;;;;AAmgBA;;;;;;;ACrhBA;AACA;;;AAKA;AA4JA;AACA;AACA;AAEA;;;;;;AC1KA;;;;;;;;;;;;AAaA;AACA;;AAGA;AACA;;AAGA;;;AAmGA;AAEA;AAOA;AACA;AAIA;AACA;;;;;;;;AC3IA;AACA;;AAIA;AACA;AACA;;;;AAKA;;AAEA;;;AAKA;;;;;;ACXA;AACA;;;AAGA;;AAGA;;AAqVA;AAEA;;;AAGA;AACA;;;;AAIA;;;AAGA;;;AAIA;AAUA;AACA;AACA;;AC1TA;AACA;;;;;;;;AClDA;AACA;;AAGA;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;AAKA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;;;;;;;AAWA;;;;;;;;AAmMA;;;;;;;;;;;;;;;;;;;;;;;;;;AC9QA;;;ACsBA;;AClBA;AAGA;;AAGA;AAGA;;;AAGA;AA6FA;;;;;;;;;;;;;;;;AAgBA;;;;AAIA;;;AAGA;AAgFA;;;;;;;;;;;;;;;;AAgBA;;;;AAIA;;;AAGA;;;;AA0GA;;ACxXA;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;ACbA;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA;AACA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;;AAmGA;;;AAKA;;;AC/MA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;AAMA;;;;;;;;;;;;AAYA;;;AAGA;;;;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;;;;ACnHA;AACA;;;AAKA;;;AAkOA;AAEA;;;;;;;ACzOA;AACA;;;AAKA;AAmKA;AACA;AACA;AAEA;;;;;;ACtBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC0LA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACgCA;;;;;;;;;;;;;;AC6FA;;;;;;;;;;;;;;ACEA;;;;;;;AC3CA;;;;;;;;;;;;;;ACvGA;ACmIA;AACA;AACA;;;;;;;;;;;;;AAaA;;;;;;AAOA;;;;ACzLA;AACA;AACA;;AAEA;;;;ACpBA;;;;;;;AAQA;;;;;AAMA;;;;;;;;;;AAWA;ACxBA;AACA;AACA;;AAEA;AACA;;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;;;;;AAQA;AACA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;;;;;;;;;;;;;;;;;AAkBA;;;;AAIA;;;AAIA;;;;;;;;;;;;;;AC5HA;AACA;;;;;AAKA;;AAEA;;AAEA;AACA;;;AAGA;;;;AAIA;;;;AAIA;;;;;;AAMA;;;;;;;;;;;;;;;AAeA;;;;AAIA;;;;;;;;;AASA;;;;AAIA;;;;;;;;;;;;;AAaA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;;;;;;;;AAUA;;AChIA;;;;;;;;;;;;;;;;;AAkBA;;AAEA;;;;;;;;;;AAUA;;AAGA;;;;;;;ACpBA;AACA;AACA;;AAGA;;;;;;;;;;AA6QA;;AAEA;;;;;;;;;;;AAWA;;;;;;AAOA;;;AAMA;AACA;;;;;;;;;;;;;;;;;;;;;AAsBA;;AAwCA;;ACnYA;;;;;AASA;;;;;;AAOA;;AAGA;AACA;;;AAGA;AACA;;;AAIA;ACjBA;AACA;;;;;;;AAOA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;;;;;;AAOA;;;;;AAkEA;AAEA;AAIA;AACA;;AAEA;AAEA;AACA;;;AAIA;ACxIA;AACA;;;;;AAKA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;;;;;AA2EA;AAEA;AAEA;AACA;;AAEA;AAEA;AACA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1GA;AC2IA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;ACnHA;;AAEA;;;AAGA;;;;;;;;;AASA;;AAGA;;;;AAaA;AAEA;AACA;;AAEA;;;;;ACkBA;AACA;;AAEA;;;;;;;;AASA;ACzEA;;;;;;;;AAQA;AACA;AAEA;;;;AAQA;;;;;;;;;;AAYA;;;;;;AAOA","sources":["webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/toolbar-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/toolbar-group.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/menu/floating-area-chooser.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/toolbar.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/context-menu.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/shape-l.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/shape-rect.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/resize-handlers.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/layout-item-toolbar.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/select-wrapper.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/interactive/droparea-hook.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/widget-placeholder.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/widget-renderer.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/layout-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/fixed-layout/builder/action-block.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/fixed-layout/builder/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/column-layout/builder/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/row-layout/builder/layout-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/row-layout/builder/column-hint.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/row-layout/builder/row.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/row-layout/builder/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/builder/layout-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/builder/draggable-tab.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/builder/grid-item-toolbar.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/builder/grid-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/builder/action-block.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/grid-layout/builder/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/accordion-layout/builder/panel.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/accordion-layout/builder/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flex-row-layout/builder/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/animation-setting.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/fixed-layout/builder/item-position-setting.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/fixed-layout/builder/fixed-item-setting.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/builder/screen-group-setting-popper.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/builder/screen-group-setting.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/builder/floating-item-setting.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/column-layout/builder/column-item-setting.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flex-row-layout/builder/flex-row-item-setting.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/row-layout/builder/row-item-setting.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/accordion-layout/builder/accordion-item-setting.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/builder/layout-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/builder/screen-menu.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/builder/screen-side-action-block.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/builder/screen-side-panel.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/builder/screen-group.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/builder/action-block.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/flow-layout/builder/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/page-renderer-common.ts","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/page-header.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/page-footer.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/controller-panel/builder/panel.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/controller-panel/builder/layout.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/page-body.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/page-renderer.tsx","webpack://arcgis-experience-builder-design-system/../jimu-layouts/lib/builder/interactive/rnd-decorator.tsx"],"sourcesContent":["/** @jsx jsx */\nimport { React, ReactRedux, classNames, getAppStore, appActions, jsx, css, createSelector } from 'jimu-core';\nimport { Popper, Icon, Button, Tooltip } from 'jimu-ui';\nimport { builderAppSync } from 'jimu-for-builder';\nimport { ThemeSwitchComponent } from 'jimu-theme';\nimport { ToolbarContext } from './toolbar-context';\nexport const DEFAULT_ICON_SIZE = 16;\nconst flipOptions1 = {\n    fallbackPlacements: ['top', 'right']\n};\nconst flipOptions2 = {\n    fallbackAxisSideDirection: 'start'\n};\nclass _ToolbarItem extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.select = (e) => {\n            e === null || e === void 0 ? void 0 : e.stopPropagation();\n            if (this.props.onClick) {\n                const { parentRef } = this.contextProps;\n                this.props.onClick({\n                    layoutId: this.contextProps.layoutId,\n                    layoutItem: this.contextProps.layoutItem,\n                    clientRect: parentRef && parentRef.getBoundingClientRect()\n                }, e);\n                this.contextProps.onItemClick(this.props.uid);\n            }\n        };\n        this.handleDoubleClick = (e) => {\n            e.stopPropagation();\n        };\n        this.handleMouseEnter = (e) => {\n            e.stopPropagation();\n            if (this.props.onMouseEnter) {\n                this.props.onMouseEnter({\n                    layoutId: this.contextProps.layoutId,\n                    layoutItem: this.contextProps.layoutItem,\n                    clientRect: null\n                }, e);\n            }\n        };\n        this.handleMouseLeave = (e) => {\n            e.stopPropagation();\n            if (this.props.onMouseLeave) {\n                this.props.onMouseLeave({\n                    layoutId: this.contextProps.layoutId,\n                    layoutItem: this.contextProps.layoutItem,\n                    clientRect: null\n                }, e);\n            }\n        };\n    }\n    componentDidMount() {\n        const { widgetId, extName, openWhenAdded, isNewAdded } = this.props;\n        if (widgetId && extName) {\n            if (openWhenAdded && isNewAdded) {\n                this.select();\n            }\n            if (window.jimuConfig.isInBuilder) {\n                getAppStore().dispatch(appActions.widgetRuntimeInfoChange(widgetId, 'shouldExpandContextTool', false));\n            }\n            else {\n                builderAppSync.publishWidgetRuntimeInfoChangeToApp(widgetId, 'shouldExpandContextTool', false);\n            }\n        }\n    }\n    componentDidUpdate() {\n        const isVisible = this.getValue(this.props.visible, this.contextProps);\n        const isDisabled = this.getValue(this.props.disabled, this.contextProps);\n        if (!isVisible || isDisabled) {\n            this.contextProps.onItemUnSelected(this.props.uid);\n        }\n    }\n    componentWillUnmount() {\n        this.contextProps.onItemUnSelected(this.props.uid);\n    }\n    getValue(target, props) {\n        if (typeof target === 'function') {\n            return target(props);\n        }\n        return target;\n    }\n    getStyle() {\n        const { theme } = this.contextProps;\n        return css `\r\n      cursor: pointer;\r\n      width: 32px;\r\n      min-height: 32px;\r\n      display: flex;\r\n      justify-content: flex-start;\r\n      user-select: none;\r\n      background: ${theme.ref.palette.neutral[400]};\r\n\r\n      &:hover {\r\n        background: ${theme.ref.palette.neutral[500]};\r\n      }\r\n      &.selected {\r\n        background: ${theme.sys.color.primary.main};\r\n      }\r\n\r\n      &.disabled,\r\n      &.no-action {\r\n        cursor: default;\r\n        &:hover {\r\n          background: ${theme.ref.palette.neutral[400]};\r\n        }\r\n      }\r\n      &.disabled {\r\n        .jimu-btn {\r\n          cursor: default;\r\n          pointer-events: auto;\r\n        }\r\n        .jimu-btn svg, .toolbar-label {\r\n          color: ${theme.ref.palette.neutral[800]} !important;\r\n        }\r\n      }\r\n\r\n      &.msg {\r\n        width: auto;\r\n        font-size: 12px;\r\n        color: ${theme.ref.palette.black};\r\n        letter-spacing: 0.33px;\r\n        text-align: center;\r\n        padding: 0 8px;\r\n      }\r\n\r\n      .toolbar-group & {\r\n        justify-content: flex-start;\r\n      }\r\n\r\n      .popper {\r\n        border: 1px solid ${theme.ref.palette.neutral[900]};\r\n      }\r\n\r\n      .toolbar-label {\r\n        color: ${theme.ref.palette.black};\r\n      }\r\n    `;\n    }\n    separatorStyle() {\n        const { theme } = this.contextProps;\n        if (this.props.isInGroup) {\n            return css `\r\n        width: 100%;\r\n        height: 1px;\r\n        background-color: ${theme.ref.palette.neutral[600]};\r\n        align-self: center;\r\n      `;\n        }\n        return css `\r\n      div.toolbar-item + &,\r\n      div.toolbar-group + & {\r\n        display: block;\r\n      }\r\n      display: none;\r\n      width: 1px;\r\n      height: 30px;\r\n      border-left: 1px solid ${theme.ref.palette.neutral[600]};\r\n      align-self: center;\r\n    `;\n    }\n    tooltipStyle() {\n        const { theme } = this.contextProps;\n        return css `\r\n      border: none;\r\n\r\n      .tooltip {\r\n        color: ${theme.ref.palette.black};\r\n        background-color: ${theme.ref.palette.neutral[600]};\r\n        border-color: ${theme.ref.palette.neutral[400]};\r\n      }\r\n    `;\n    }\n    createButton({ textContent, iconContent, tooltip, isDisabled, noAction, isChecked, rotate, iconSize, autoFlipIcon, ref }) {\n        const title = textContent ? '' : tooltip;\n        const titleProps = isDisabled ? { title } : {};\n        const buttonComponent = jsx(Button, Object.assign({ \"aria-label\": textContent || tooltip, ref: ref, className: classNames('px-0 w-100', { 'justify-content-start': textContent }), type: 'tertiary', disableHoverEffect: true, size: 'sm', icon: iconContent && !textContent, role: 'menuitem', onClick: isDisabled || noAction ? null : this.select, disabled: isDisabled, onMouseEnter: this.handleMouseEnter, onMouseLeave: this.handleMouseLeave, onDoubleClick: this.handleDoubleClick, \"data-extname\": this.props.extName }, titleProps),\n            iconContent && (jsx(Icon, { className: classNames('tool-item-icon', { checked: isChecked }), icon: iconContent, rotate: rotate, size: iconSize, color: this.contextProps.theme.ref.palette.black, autoFlip: autoFlipIcon })),\n            textContent && jsx(\"span\", { className: 'toolbar-label text-nowrap' }, textContent));\n        if (isDisabled) {\n            return buttonComponent;\n        }\n        return jsx(Tooltip, { placement: 'bottom', title: title, flipOptions: flipOptions1, css: this.tooltipStyle() }, buttonComponent);\n    }\n    render() {\n        const { icon, autoFlipIcon, label, size, checked, disabled, visible, rotate, settingPanel, title, uid, widgetId, className, separator } = this.props;\n        if (separator) {\n            return (jsx(ToolbarContext.Consumer, null, (props) => {\n                this.contextProps = props;\n                return jsx(\"div\", { \"data-testid\": 'toolbarSeparator', css: this.separatorStyle() });\n            }));\n        }\n        const noAction = this.props.onClick == null;\n        const iconSize = size || DEFAULT_ICON_SIZE;\n        const SettingPanel = settingPanel;\n        return (jsx(ToolbarContext.Consumer, null, (props) => {\n            var _a;\n            this.contextProps = props;\n            if (widgetId && ((_a = props.layoutItem) === null || _a === void 0 ? void 0 : _a.widgetId) !== widgetId) {\n                // TODO - prevent renderring toolbar item for the previous selected widget.\n                // Should have better solution\n                return null;\n            }\n            let tooltip = '';\n            if (typeof title === 'function') {\n                tooltip = title(props);\n            }\n            else if (typeof title === 'string') {\n                tooltip = title;\n            }\n            const showSettingPanel = settingPanel && props.activeItem === uid && props.toggleOn;\n            const isChecked = showSettingPanel || this.getValue(checked, props);\n            const isDisabled = this.getValue(disabled, props);\n            const isVisible = this.getValue(visible, props);\n            const textContent = this.getValue(label, props);\n            const iconContent = this.getValue(icon, props);\n            return (jsx(\"div\", { className: classNames('toolbar-item', className, {\n                    selected: isChecked,\n                    disabled: isDisabled,\n                    msg: textContent,\n                    'no-action': noAction,\n                    'd-none': visible != null && !isVisible\n                }), css: this.getStyle(), \"data-toolstate\": this.props.toolState },\n                !SettingPanel && this.createButton({ textContent, iconContent, tooltip, isDisabled, noAction, isChecked, rotate, iconSize, autoFlipIcon, ref: null }),\n                SettingPanel && (jsx(ThemeSwitchComponent, { useTheme2: window.jimuConfig.isInBuilder },\n                    this.createButton({ textContent, iconContent, tooltip, isDisabled, noAction, isChecked, rotate, iconSize, autoFlipIcon, ref: ref => { this.reference = ref; } }),\n                    jsx(Popper, { placement: 'bottom-start', reference: this.reference, flipOptions: flipOptions2, open: showSettingPanel, disablePortal: true, autoUpdate: true },\n                        jsx(\"div\", { css: css `\r\n                        display: flex;\r\n                        pointer-events: all;\r\n                        border-radius: 2px;\r\n                        box-shadow: 0 2px 8px 1px rgba(0, 0, 0, 0.2);\r\n                      `, className: 'd-flex' }, showSettingPanel && jsx(SettingPanel, { layoutId: props.layoutId, layoutItemId: props.layoutItem.id, widgetId: props.layoutItem.widgetId })))))));\n        }));\n    }\n}\nconst mapFunc = createSelector((state, props) => {\n    var _a, _b, _c;\n    const { widgetId, extName } = props;\n    if (widgetId && extName) {\n        const widgetState = state.widgetsRuntimeInfo[widgetId];\n        const version = (_c = (_b = (_a = widgetState === null || widgetState === void 0 ? void 0 : widgetState.layoutItemTools) === null || _a === void 0 ? void 0 : _a[extName]) === null || _b === void 0 ? void 0 : _b.version) !== null && _c !== void 0 ? _c : 0;\n        return version;\n    }\n    return 0;\n}, (state, props) => {\n    var _a, _b;\n    const { widgetId, extName } = props;\n    if (widgetId && extName) {\n        const widgetsRuntimeInfo = state.widgetsRuntimeInfo;\n        return (_b = (_a = widgetsRuntimeInfo === null || widgetsRuntimeInfo === void 0 ? void 0 : widgetsRuntimeInfo[widgetId]) === null || _a === void 0 ? void 0 : _a.shouldExpandContextTool) !== null && _b !== void 0 ? _b : false;\n    }\n    return false;\n}, (toolState, isNewAdded) => ({ toolState, isNewAdded }));\nexport const ToolbarItem = ReactRedux.connect(mapFunc)(_ToolbarItem);\n","/** @jsx jsx */\nimport { React, jsx, css, lodash, focusElementInKeyboardMode } from 'jimu-core';\nimport { Icon, Dropdown, DropdownButton, DropdownMenu, Tooltip } from 'jimu-ui';\nimport { Theme2GlobalStyleClassName } from 'jimu-theme';\nimport { ToolbarItem, DEFAULT_ICON_SIZE } from './toolbar-item';\nimport { ToolbarContext } from './toolbar-context';\nconst noAction = () => null;\nexport class ToolbarGroup extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.togglePopToolItems = (e) => {\n            if (e) {\n                e.stopPropagation();\n            }\n            this.contextProps.onItemClick(this.props.uid);\n        };\n        this.onItemClick = (toolConfig, props) => {\n            const { parentRef } = this.contextProps;\n            toolConfig.onClick(Object.assign(Object.assign({}, props), { clientRect: parentRef.getBoundingClientRect() }));\n            // focus the drop down button if any item is clicked\n            lodash.defer(() => {\n                focusElementInKeyboardMode(this.dropdownBtnRef.current);\n            });\n        };\n        this.handleDoubleClick = (e) => {\n            e.stopPropagation();\n        };\n        this.dropdownBtnRef = React.createRef();\n    }\n    getBaseStyle() {\n        const { theme } = this.contextProps;\n        return css `\r\n      cursor: pointer;\r\n      display: flex;\r\n      justify-content: space-around;\r\n      align-items: center;\r\n      background-color: ${theme.ref.palette.neutral[400]};\r\n\r\n      &:hover {\r\n        background-color: ${theme.ref.palette.neutral[500]} !important;\r\n      }\r\n    `;\n    }\n    getValue(target, props) {\n        if (typeof target === 'function') {\n            return target(props);\n        }\n        return target;\n    }\n    createToolItem(toolConfig, props, index) {\n        if (!toolConfig.onClick && !toolConfig.separator) {\n            return null;\n        }\n        return (jsx(ToolbarItem, Object.assign({ key: index, uid: `${this.props.uid}_${index + 1}`, isInGroup: true }, toolConfig, { onClick: () => { this.onItemClick(toolConfig, props); } })));\n    }\n    getGroupMenu(selectedTool, visibleTools) {\n        const { theme } = this.contextProps;\n        if (selectedTool) {\n            return (jsx(Icon, { rotate: selectedTool.rotate, icon: selectedTool.icon, size: selectedTool.size || DEFAULT_ICON_SIZE, color: theme.ref.palette.black }));\n        }\n        if (visibleTools[0].icon) {\n            return (jsx(Icon, { icon: visibleTools[0].icon, size: visibleTools[0].size || DEFAULT_ICON_SIZE, color: theme.ref.palette.black }));\n        }\n        return (jsx(ToolbarItem, Object.assign({ uid: `${this.props.uid}_0`, onClick: noAction }, visibleTools[0])));\n    }\n    tooltipStyle() {\n        const { theme } = this.contextProps;\n        return css `\r\n      border: none;\r\n\r\n      .tooltip {\r\n        color: ${theme.ref.palette.black};\r\n        background-color: ${theme.ref.palette.neutral[600]};\r\n        border-color: ${theme.ref.palette.neutral[400]};\r\n      }\r\n    `;\n    }\n    render() {\n        const { tools, uid } = this.props;\n        if (!tools || tools.length === 0) {\n            return null;\n        }\n        return (jsx(ToolbarContext.Consumer, null, (props) => {\n            var _a;\n            this.contextProps = props;\n            const { visible: rootVisible, caret = true, title } = tools[0];\n            const isRootVisible = this.getValue(rootVisible, props);\n            if (rootVisible !== undefined && !isRootVisible) {\n                return null;\n            }\n            const visibleTools = tools.filter((tool) => {\n                const { visible } = tool;\n                const isVisible = this.getValue(visible, props);\n                return typeof visible === 'undefined' || isVisible;\n            });\n            if (visibleTools.length === 0) {\n                return null;\n            }\n            if (visibleTools.length === 1) {\n                return jsx(ToolbarItem, Object.assign({ uid: `${uid}_0` }, visibleTools[0]));\n            }\n            let selectedTool;\n            visibleTools.some((tool) => {\n                const { checked } = tool;\n                if (this.getValue(checked, props)) {\n                    selectedTool = tool;\n                    return true;\n                }\n                return false;\n            });\n            let tooltip = '';\n            if (typeof title === 'function') {\n                tooltip = title(props);\n            }\n            else if (typeof title === 'string') {\n                tooltip = title;\n            }\n            return (jsx(\"div\", { className: 'toolbar-group', css: this.getBaseStyle() },\n                jsx(Dropdown, { direction: 'down', size: 'sm', className: caret ? 'px-1' : '', isOpen: ((_a = props.toggleOn) !== null && _a !== void 0 ? _a : false) && props.activeItem === uid, toggle: this.togglePopToolItems },\n                    jsx(Tooltip, { placement: 'bottom', title: tooltip, css: this.tooltipStyle() },\n                        jsx(DropdownButton, { icon: true, arrow: caret, type: 'tertiary', disableHoverEffect: true, size: 'sm', ref: this.dropdownBtnRef, css: css `\r\n                      .caret-icon {\r\n                        color: ${props.theme.ref.palette.neutral[1000]};\r\n                        margin-left: 0.25rem;\r\n                      }\r\n                    `, onDoubleClick: this.handleDoubleClick }, this.getGroupMenu(selectedTool, visibleTools))),\n                    jsx(DropdownMenu, { className: `p-0 ${window.jimuConfig.isInBuilder ? Theme2GlobalStyleClassName : ''}`, css: css `min-width: 5rem;` }, visibleTools.map((toolConfig, index) => (this.createToolItem(toolConfig, props, index)))))));\n        }));\n    }\n}\n","/** @jsx jsx */\nimport { React, jsx, css, classNames, APP_FRAME_NAME_IN_BUILDER } from 'jimu-core';\nimport { getTheme, getTheme2 } from 'jimu-theme';\nimport { floatingLayoutItem } from '../common-layout-actions';\nimport { Button } from 'jimu-ui';\nexport class FloatingAreaChooser extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.topLeft = this.updateFloatingArea.bind(this, 1);\n        this.topCenter = this.updateFloatingArea.bind(this, 2);\n        this.topRight = this.updateFloatingArea.bind(this, 3);\n        this.middleLeft = this.updateFloatingArea.bind(this, 4);\n        this.middleCenter = this.updateFloatingArea.bind(this, 5);\n        this.middleRight = this.updateFloatingArea.bind(this, 6);\n        this.bottomLeft = this.updateFloatingArea.bind(this, 7);\n        this.bottomCenter = this.updateFloatingArea.bind(this, 8);\n        this.bottomRight = this.updateFloatingArea.bind(this, 9);\n    }\n    updateFloatingArea(value) {\n        const { layoutId, layoutItemId } = this.props;\n        const layoutInfo = { layoutId, layoutItemId };\n        floatingLayoutItem(layoutInfo, this.getSizeOfItem(), value);\n    }\n    getSizeOfItem() {\n        const { layoutId, layoutItemId } = this.props;\n        let appDoc;\n        if (window.jimuConfig.isBuilder) {\n            const appFrame = document.querySelector(`iframe[name=\"${APP_FRAME_NAME_IN_BUILDER}\"]`);\n            appDoc = (appFrame === null || appFrame === void 0 ? void 0 : appFrame.contentDocument) || (appFrame === null || appFrame === void 0 ? void 0 : appFrame.contentWindow.document);\n        }\n        else {\n            appDoc = document;\n        }\n        const layoutElem = appDoc.querySelector(`div.exb-rnd[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItemId}\"]`);\n        if (layoutElem) {\n            return layoutElem.getBoundingClientRect();\n        }\n        return null;\n    }\n    getStyle() {\n        let theme;\n        if (window.jimuConfig.isBuilder) {\n            theme = getTheme();\n        }\n        else {\n            theme = getTheme2();\n        }\n        const borderColor = theme.ref.palette.neutral[500];\n        return css `\r\n      background-color: ${theme.ref.palette.neutral[400]};\r\n      position: relative;\r\n      padding: 4px;\r\n\r\n      .content {\r\n        display: grid;\r\n        grid-template-columns: 1fr 1fr 1fr;\r\n        grid-row-gap: 0;\r\n        grid-column-gap: 0;\r\n        border: 1px solid ${borderColor};\r\n\r\n        & > button {\r\n          cursor: pointer;\r\n          height: 50px;\r\n          width: 50px;\r\n          position: relative;\r\n          border: none;\r\n          background-color: transparent;\r\n          border-radius: 0;\r\n\r\n          &:after {\r\n            content: '';\r\n            position: absolute;\r\n            left: 1px;\r\n            top: 1px;\r\n            right: 1px;\r\n            bottom: 1px;\r\n          }\r\n\r\n          &:hover {\r\n            &:after {\r\n              outline: 1px solid ${theme.sys.color.primary.dark};\r\n              background: ${theme.sys.color.primary.light};\r\n            }\r\n          }\r\n        }\r\n\r\n        & > button:nth-of-type(3n+1) {\r\n          border-right: 1px solid ${borderColor};\r\n        }\r\n        & > button:nth-of-type(3n) {\r\n          border-left: 1px solid ${borderColor};\r\n        }\r\n        & > button:nth-of-type(1), & > button:nth-of-type(2), & > button:nth-of-type(3) {\r\n          border-bottom: 1px solid ${borderColor};\r\n        }\r\n        & > button:nth-of-type(7), & > button:nth-of-type(8), & > button:nth-of-type(9) {\r\n          border-top: 1px solid ${borderColor};\r\n        }\r\n\r\n        .selected:after {\r\n          content: '';\r\n          position: absolute;\r\n          width: 100%;\r\n          height: 100%;\r\n          background-color: ${theme.sys.color.primary.light};\r\n          border: 1px solid ${theme.sys.color.primary.main};\r\n        }\r\n      }\r\n    `;\n    }\n    render() {\n        const { area } = this.props;\n        return (jsx(\"div\", { className: 'floating-area-chooser d-flex', css: this.getStyle() },\n            jsx(\"div\", { className: 'content w-100' },\n                jsx(Button, { className: classNames('top-left', { selected: area === 1 }), onClick: this.topLeft }),\n                jsx(Button, { className: classNames('top-center', { selected: area === 2 }), onClick: this.topCenter }),\n                jsx(Button, { className: classNames('top-right', { selected: area === 3 }), onClick: this.topRight }),\n                jsx(Button, { className: classNames('middle-left', { selected: area === 4 }), onClick: this.middleLeft }),\n                jsx(Button, { className: classNames('middle-center', { selected: area === 5 }), onClick: this.middleCenter }),\n                jsx(Button, { className: classNames('middle-right', { selected: area === 6 }), onClick: this.middleRight }),\n                jsx(Button, { className: classNames('bottom-left', { selected: area === 7 }), onClick: this.bottomLeft }),\n                jsx(Button, { className: classNames('bottom-center', { selected: area === 8 }), onClick: this.bottomCenter }),\n                jsx(Button, { className: classNames('bottom-right', { selected: area === 9 }), onClick: this.bottomRight }))));\n    }\n}\nFloatingAreaChooser.defaultProps = {\n    area: 0\n};\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css, BrowserSizeMode, createSelector, LayoutItemType } from 'jimu-core';\nimport moreOutlined from 'jimu-icons/svg/outlined/application/more-horizontal.svg';\nimport { ThemeSwitchComponent } from 'jimu-theme';\nimport { ToolbarContext } from './toolbar-context';\nimport { ToolbarGroup } from './toolbar-group';\nimport { ToolbarItem } from './toolbar-item';\nimport { findSectionInfo, findActiveViewId } from './menu/section-menu';\nimport { utils } from 'jimu-layouts/layout-runtime';\nimport { GLOBAL_DRAGGING_CLASS_NAME, GLOBAL_H5_DRAGGING_CLASS_NAME } from './interactive/drag-event-handler';\nimport { GLOBAL_RESIZING_CLASS_NAME } from './interactive/resize-event-handler';\nclass _Toolbar extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            activeItem: null\n        };\n        this.onItemClick = (value) => {\n            let isOn = this.state.toggleOn;\n            if (value === this.state.activeItem) {\n                isOn = !isOn;\n            }\n            else {\n                isOn = true;\n            }\n            this.setState({\n                activeItem: value,\n                toggleOn: isOn\n            });\n        };\n        this.onItemUnSelected = (value) => {\n            if (value === this.state.activeItem) {\n                this.setState({\n                    activeItem: null,\n                    toggleOn: false\n                });\n            }\n        };\n    }\n    getStyle() {\n        const { theme } = this.props;\n        return css `\r\n      display: flex;\r\n      pointer-events: all;\r\n      border-radius: 2px;\r\n      box-shadow: 0 2px 8px 1px rgba(0,0,0,0.20);\r\n      height: 100%;\r\n      margin: 5px 0;\r\n      background: ${theme.ref.palette.neutral[400]};\r\n\r\n      .toolbar-item, .toolbar-item {\r\n        .jimu-btn:focus, .jimu-btn:focus-visible {\r\n          z-index: 1;\r\n        }\r\n      }\r\n\r\n      .${GLOBAL_DRAGGING_CLASS_NAME} &,\r\n      .${GLOBAL_RESIZING_CLASS_NAME} &,\r\n      .${GLOBAL_H5_DRAGGING_CLASS_NAME} & {\r\n        display: none;\r\n      }\r\n    `;\n    }\n    reOrganizeTools() {\n        const { tools } = this.props;\n        const sizeMode = utils.getCurrentSizeMode();\n        if (sizeMode === BrowserSizeMode.Small) {\n            const filterTools = tools.filter(toolItem => {\n                let tool;\n                if (Array.isArray(toolItem)) {\n                    tool = toolItem[0];\n                }\n                else {\n                    tool = toolItem;\n                }\n                const { visible, separator = false } = tool;\n                const isVisible = typeof visible === 'function' ? visible(this.props) : visible;\n                return !separator && (typeof visible === 'undefined' || isVisible);\n            });\n            if (filterTools.length > 8) {\n                // Small size accepts 8 toolbar items at most.\n                const newTools = tools.slice(0, 8);\n                const groupedTools = tools.slice(8).map(tool => { return Object.assign(Object.assign({}, tool), { label: tool.title }); });\n                const tool = [\n                    {\n                        icon: moreOutlined,\n                        caret: false\n                    },\n                    ...groupedTools\n                ];\n                newTools.push(tool);\n                return newTools;\n            }\n        }\n        return tools;\n    }\n    render() {\n        const { tools, isLockLayout } = this.props;\n        if (!tools || tools.length === 0) {\n            return null;\n        }\n        const organizedTools = this.reOrganizeTools();\n        const { activeItem, toggleOn } = this.state;\n        return (jsx(ToolbarContext.Provider, { value: Object.assign(Object.assign({}, this.props), { activeItem, toggleOn, onItemClick: this.onItemClick, onItemUnSelected: this.onItemUnSelected, isLockLayout: isLockLayout }) },\n            jsx(ThemeSwitchComponent, { useTheme2: window.jimuConfig.isInBuilder },\n                jsx(\"div\", { css: this.getStyle(), className: 'layout-item-toolbar' }, organizedTools.map((toolConfig, index) => {\n                    if (Array.isArray(toolConfig)) {\n                        return jsx(ToolbarGroup, { uid: `${index}`, key: index, tools: toolConfig });\n                    }\n                    return jsx(ToolbarItem, Object.assign({ uid: `${index}`, key: index }, toolConfig));\n                })))));\n    }\n}\nconst mapFunc = createSelector((state) => { var _a, _b, _c; return (_c = (_b = (_a = state.appConfig) === null || _a === void 0 ? void 0 : _a.forBuilderAttributes) === null || _b === void 0 ? void 0 : _b.lockLayout) !== null && _c !== void 0 ? _c : false; }, (state, props) => {\n    const { layoutItem } = props;\n    if (layoutItem.type === LayoutItemType.Section) {\n        const sectionInfo = findSectionInfo(layoutItem);\n        if (sectionInfo) {\n            return findActiveViewId(sectionInfo);\n        }\n    }\n    return '';\n}, (state, props) => {\n    const { layoutItem } = props;\n    if (layoutItem.type === LayoutItemType.Section) {\n        let sectionJson;\n        if (window.jimuConfig.isBuilder) {\n            sectionJson = state.appStateInBuilder.appConfig.sections[layoutItem.sectionId];\n        }\n        else {\n            sectionJson = state.appConfig.sections[layoutItem.sectionId];\n        }\n        return sectionJson.views.length;\n    }\n    return 0;\n}, (isLockLayout, activeViewId, numOfViews) => ({ isLockLayout, activeViewId, numOfViews }));\nexport const Toolbar = ReactRedux.connect(mapFunc)(_Toolbar);\n","/** @jsx jsx */\nimport { React, jsx, css, injectIntl } from 'jimu-core';\nimport { MoreHorizontalOutlined } from 'jimu-icons/outlined/application/more-horizontal';\nimport { LayoutZIndex } from 'jimu-layouts/layout-runtime';\nimport { Toolbar } from './toolbar';\nimport defaultMessages from '../translations/default';\nclass ContextMenu extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.formatMessage = (id, values) => {\n            if (this.props.intl) {\n                return this.props.intl.formatMessage({ id, defaultMessage: defaultMessages[id] }, values);\n            }\n            return defaultMessages[id];\n        };\n    }\n    getPositionStyle() {\n        const { positionType } = this.props;\n        if (positionType === 'left') {\n            return css `\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n      `;\n        }\n        if (positionType === 'center') {\n            return css `\r\n        position: absolute;\r\n        top: 0;\r\n        left: 50%;\r\n        transform: translateX(-50%);\r\n      `;\n        }\n        return css `\r\n      position: absolute;\r\n      top: 0;\r\n      right: 0;\r\n    `;\n    }\n    getStyle() {\n        const { size, builderTheme, rotate } = this.props;\n        return css `\r\n      body:not(.design-mode) & {\r\n        display: none !important;\r\n      }\r\n\r\n      position: absolute;\r\n      top: 0;\r\n      left: 0;\r\n      width: 100%;\r\n      height: 100%;\r\n      background: transparent;\r\n      pointer-events: none;\r\n      transform: ${rotate > 0 || rotate < 0 ? `rotateZ(${rotate}deg)` : ''} ;\r\n\r\n      .content {\r\n        ${this.getPositionStyle()};\r\n        pointer-events: all;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        transition: all 100ms;\r\n        z-index: ${LayoutZIndex.HandlerTools};\r\n\r\n        .menu-hint {\r\n          background-color: ${builderTheme.ref.palette.neutral[400]};\r\n          width: ${size}px;\r\n          height: 10px;\r\n          display: flex;\r\n          justify-content: center;\r\n          align-items: center;\r\n          cursor: pointer;\r\n          line-height: 10px;\r\n        }\r\n\r\n        .menu-content {\r\n          display: none;\r\n          height: ${size}px;\r\n          transform: ${rotate > 0 || rotate < 0 ? `rotateZ(${-rotate}deg)` : ''} ;\r\n\r\n          .tool-drag-handler {\r\n            cursor: move;\r\n          }\r\n\r\n          .layout-item-toolbar {\r\n            margin: 0;\r\n          }\r\n        }\r\n\r\n        &:hover {\r\n          /* height: ${size}px; */\r\n          /* width: auto; */\r\n\r\n          .menu-hint {\r\n            display: none;\r\n          }\r\n\r\n          .menu-content {\r\n            display: flex;\r\n          }\r\n        }\r\n      }\r\n\r\n    `;\n    }\n    render() {\n        const { builderTheme, menuItems, layoutId, layoutItem, className, onMouseEnter, onMouseLeave } = this.props;\n        return (jsx(\"div\", { className: `widget-context-menu ${className}`, css: this.getStyle() },\n            jsx(\"div\", { ref: el => { this.ref = el; }, className: 'content' },\n                jsx(\"div\", { className: 'menu-hint' },\n                    jsx(MoreHorizontalOutlined, { color: builderTheme.ref.palette.black, size: 'm' })),\n                jsx(\"div\", { className: 'menu-content', onMouseLeave: onMouseLeave, onMouseEnter: onMouseEnter },\n                    jsx(Toolbar, { layoutId: layoutId, layoutItem: layoutItem, theme: builderTheme, parentRef: this.ref, tools: menuItems, formatMessage: this.formatMessage })),\n                this.props.children)));\n    }\n}\nexport default injectIntl(ContextMenu);\n","/** @jsx jsx */\nimport { jsx, css, React, hooks } from 'jimu-core';\nimport { utils } from 'jimu-layouts/layout-runtime';\nconst size = 9;\nconst style = css `\r\n  width: ${size}px;\r\n  height: ${size}px;\r\n  background: transparent;\r\n  position: absolute;\r\n`;\nexport function ShapeL(props) {\n    const { pos } = props;\n    const ref = React.useRef();\n    hooks.useEffectOnce(() => {\n        var _a;\n        const ratio = (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;\n        ref.current.width = size * ratio;\n        ref.current.height = size * ratio;\n        const ctx = ref.current.getContext('2d');\n        if (!ctx) {\n            return;\n        }\n        ctx.scale(ratio, ratio);\n        ctx.strokeStyle = '#444';\n        ctx.fillStyle = '#fff';\n        ctx.lineWidth = 2;\n        if (utils.isRTL()) {\n            if (pos === 'tl') {\n                ctx.translate(size, 0);\n                ctx.rotate(Math.PI / 2);\n            }\n            if (pos === 'br') {\n                ctx.translate(0, size);\n                ctx.rotate(-Math.PI / 2);\n            }\n            if (pos === 'bl') {\n                ctx.translate(size, size);\n                ctx.rotate(Math.PI);\n            }\n        }\n        else {\n            if (pos === 'tr') {\n                ctx.translate(size, 0);\n                ctx.rotate(Math.PI / 2);\n            }\n            if (pos === 'br') {\n                ctx.translate(size, size);\n                ctx.rotate(Math.PI);\n            }\n            if (pos === 'bl') {\n                ctx.translate(0, size);\n                ctx.rotate(-Math.PI / 2);\n            }\n        }\n        ctx.beginPath();\n        ctx.moveTo(1, 1);\n        ctx.lineTo(size - 1, 1);\n        ctx.lineTo(size - 1, size / 3);\n        ctx.lineTo(size / 3, size / 3);\n        ctx.lineTo(size / 3, size - 1);\n        ctx.lineTo(1, size - 1);\n        ctx.closePath();\n        ctx.stroke();\n        ctx.fill();\n    });\n    return jsx(\"canvas\", { css: style, ref: ref });\n}\n","/** @jsx jsx */\nimport { jsx, css, React, hooks } from 'jimu-core';\nconst long = 16;\nconst short = 4;\nconst style = css `\r\n  background: transparent;\r\n  position: absolute;\r\n`;\nexport function ShapeRect(props) {\n    const { direction } = props;\n    const ref = React.useRef();\n    hooks.useEffectOnce(() => {\n        var _a;\n        const ratio = (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;\n        if (direction === 'h') {\n            ref.current.width = long * ratio;\n            ref.current.height = short * ratio;\n        }\n        else {\n            ref.current.width = short * ratio;\n            ref.current.height = long * ratio;\n        }\n        const ctx = ref.current.getContext('2d');\n        if (!ctx) {\n            return;\n        }\n        ctx.scale(ratio, ratio);\n        ctx.strokeStyle = '#444';\n        ctx.fillStyle = '#fff';\n        ctx.lineWidth = 2;\n        if (direction === 'h') {\n            ctx.rect(1, 1, long - 2, short - 2);\n        }\n        else {\n            ctx.rect(1, 1, short - 2, long - 2);\n        }\n        ctx.stroke();\n        ctx.fill();\n    });\n    return jsx(\"canvas\", { css: style, ref: ref });\n}\n","/** @jsx jsx */\nimport { jsx, css } from 'jimu-core';\nimport { LayoutZIndex } from 'jimu-layouts/layout-runtime';\nimport { getCursor } from './resize-cursor-util';\nimport { ShapeL } from './shape-l';\nimport { ShapeRect } from './shape-rect';\nconst cornerSize = 11;\nconst handlerSize = 10;\nconst sideLong = 16;\nconst sideShort = 4;\nconst sidePosition = 10;\nconst topLeftCursor = (rotation) => css `\r\n  top: 0;\r\n  left: 0;\r\n  position: absolute;\r\n  /* cursor: nwse-resize; */\r\n  cursor: ${getCursor(rotation, 135)};\r\n  .jimu-rtl & {\r\n    /* cursor: nesw-resize; */\r\n    cursor: ${getCursor(rotation, 135 + 90)};\r\n  }\r\n  > svg {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n  }\r\n`;\nconst topRightCursor = (rotation) => css `\r\n  top: 0;\r\n  right: 0;\r\n  position: absolute;\r\n  /* cursor: nesw-resize; */\r\n  cursor: ${getCursor(rotation, 225)};\r\n  .jimu-rtl & {\r\n    /* cursor: nwse-resize; */\r\n    cursor: ${getCursor(rotation, 225 + 90)};\r\n  }\r\n`;\nconst bottomLeftCursor = (rotation) => css `\r\n  bottom: 0;\r\n  left: 0;\r\n  position: absolute;\r\n  /* cursor: nesw-resize; */\r\n  cursor: ${getCursor(rotation, 45)};\r\n  .jimu-rtl & {\r\n    /* cursor: nwse-resize; */\r\n    cursor: ${getCursor(rotation, 45 + 90)};\r\n  }\r\n`;\nconst bottomRightCursor = (rotation) => css `\r\n  bottom: 0;\r\n  right: 0;\r\n  position: absolute;\r\n  /* cursor: nwse-resize; */\r\n  cursor: ${getCursor(rotation, 315)};\r\n  .jimu-rtl & {\r\n    /* cursor: nesw-resize; */\r\n    cursor: ${getCursor(rotation, 315 + 90)};\r\n  }\r\n`;\nconst topSideCursor = (rotation) => css `\r\n  height: ${handlerSize}px;\r\n  left: ${sidePosition}px;\r\n  right: ${sidePosition}px;\r\n  top: 0px;\r\n  position: absolute;\r\n  /* cursor: ns-resize; */\r\n  cursor: ${getCursor(rotation, 180)};\r\n\r\n  canvas {\r\n    left: 50%;\r\n    top: 0;\r\n    width: ${sideLong}px;\r\n    height: ${sideShort}px;\r\n    margin-left: ${-sideLong / 2}px;\r\n    margin-top: 1px;\r\n  }\r\n`;\nconst rightSideCursor = (rotation) => css `\r\n  width: ${handlerSize}px;\r\n  top: ${sidePosition}px;\r\n  bottom: ${sidePosition}px;\r\n  right: 0;\r\n  position: absolute;\r\n  /* cursor: ew-resize; */\r\n  cursor: ${getCursor(rotation, 270)};\r\n\r\n  canvas {\r\n    top: 50%;\r\n    right: 0;\r\n    width: ${sideShort}px;\r\n    height: ${sideLong}px;\r\n    margin-top: ${-sideLong / 2}px;\r\n    margin-right: 1px;\r\n  }\r\n`;\nconst bottomSideCursor = (rotation) => css `\r\n  height: ${handlerSize}px;\r\n  left: ${sidePosition}px;\r\n  right: ${sidePosition}px;\r\n  bottom: 0;\r\n  position: absolute;\r\n  /* cursor: ns-resize; */\r\n  cursor: ${getCursor(rotation, 0)};\r\n\r\n  canvas {\r\n    left: 50%;\r\n    bottom: 0;\r\n    width: ${sideLong}px;\r\n    height: ${sideShort}px;\r\n    margin-left: ${-sideLong / 2}px;\r\n    margin-bottom: 1px;\r\n  }\r\n`;\nconst leftSideCursor = (rotation) => css `\r\n  width: ${handlerSize}px;\r\n  top: ${sidePosition}px;\r\n  bottom: ${sidePosition}px;\r\n  left: 0;\r\n  position: absolute;\r\n  /* cursor: ew-resize; */\r\n  cursor: ${getCursor(rotation, 90)};\r\n\r\n  canvas {\r\n    top: 50%;\r\n    left: 0;\r\n    width: ${sideShort}px;\r\n    height: ${sideLong}px;\r\n    margin-top: ${-sideLong / 2}px;\r\n    margin-left: 1px;\r\n  }\r\n`;\nfunction getResizableSides(props) {\n    const { left = true, top = true, right = true, bottom = true } = props;\n    return {\n        top,\n        right,\n        bottom,\n        left,\n        topRight: top && right,\n        bottomRight: bottom && right,\n        bottomLeft: bottom && left,\n        topLeft: top && left\n    };\n}\nexport function ResizeHandlers(props) {\n    const { rotation = 0 } = props;\n    const { top, right, bottom, left, topLeft, topRight, bottomRight, bottomLeft } = getResizableSides(props);\n    const rectHandle = css `\r\n    width: ${cornerSize}px;\r\n    height: ${cornerSize}px;\r\n    padding: 1px;\r\n    z-index: ${LayoutZIndex.HandlerTools};\r\n  `;\n    const cornerHandlerStyle = rectHandle;\n    return (jsx(\"div\", { className: 'w-100 h-100 action-area' },\n        top && (jsx(\"span\", { key: '2', \"data-testid\": 'top', className: 'rnd-resize-top handle no-drag-action', css: topSideCursor(rotation) },\n            jsx(ShapeRect, { direction: 'h' }))),\n        right && (jsx(\"span\", { key: '4', \"data-testid\": 'right', className: 'rnd-resize-right handle no-drag-action', css: rightSideCursor(rotation) },\n            jsx(ShapeRect, { direction: 'v' }))),\n        bottom && (jsx(\"span\", { key: '6', \"data-testid\": 'bottom', className: 'rnd-resize-bottom handle no-drag-action', css: bottomSideCursor(rotation) },\n            jsx(ShapeRect, { direction: 'h' }))),\n        left && (jsx(\"span\", { key: '8', \"data-testid\": 'left', className: 'rnd-resize-left handle no-drag-action', css: leftSideCursor(rotation) },\n            jsx(ShapeRect, { direction: 'v' }))),\n        topLeft && (jsx(\"span\", { key: '1', \"data-testid\": 'topLeft', className: 'rnd-resize-top rnd-resize-left handle no-drag-action', css: [cornerHandlerStyle, topLeftCursor(rotation)] },\n            jsx(ShapeL, { pos: 'tl' }))),\n        topRight && (jsx(\"span\", { key: '3', \"data-testid\": 'topRight', className: 'rnd-resize-top rnd-resize-right handle no-drag-action', css: [cornerHandlerStyle, topRightCursor(rotation)] },\n            jsx(ShapeL, { pos: 'tr' }))),\n        bottomRight && (jsx(\"span\", { key: '5', \"data-testid\": 'bottomRight', className: 'rnd-resize-bottom rnd-resize-right handle no-drag-action', css: [cornerHandlerStyle, bottomRightCursor(rotation)] },\n            jsx(ShapeL, { pos: 'br' }))),\n        bottomLeft && (jsx(\"span\", { key: '7', \"data-testid\": 'bottomLeft', className: 'rnd-resize-bottom rnd-resize-left handle no-drag-action', css: [cornerHandlerStyle, bottomLeftCursor(rotation)] },\n            jsx(ShapeL, { pos: 'bl' })))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, hooks, ExtensionManager, extensionSpec, LayoutItemType, getAppStore } from 'jimu-core';\nimport { Popper } from 'jimu-ui';\nimport { Toolbar } from './toolbar';\nimport { placeholderService } from 'jimu-for-builder';\nimport { deleteMenuItem, pendingMenuItem, duplicateMenuItem, floatingMenuItem, sinkingMenuItem, isExpressMode } from './menu/common-menu';\nimport { sectionMenuItems } from './menu/section-menu';\nconst commonWidgetMenuItems = [duplicateMenuItem, floatingMenuItem, sinkingMenuItem, pendingMenuItem, deleteMenuItem];\nconst commonSectionMenuItems = [].concat(sectionMenuItems, commonWidgetMenuItems);\nlet count = 0;\nfunction getExtensionTools(layoutId, widgetId) {\n    if (!widgetId) {\n        return [];\n    }\n    const exts = ExtensionManager.getInstance().getExtensions(extensionSpec.ExtensionPoints.ContextTool);\n    return exts\n        .filter(ext => ext.widgetId === widgetId)\n        .map(ext => {\n        var _a;\n        return {\n            widgetId,\n            icon: ext.getIcon(),\n            title: ext.getTitle.bind(ext),\n            onClick: ext.onClick.bind(ext),\n            checked: ext.checked && ext.checked.bind(ext),\n            disabled: ext.disabled ? (typeof ext.disabled === 'function' ? ext.disabled.bind(ext) : ext.disabled) : null,\n            visible: ext.visible ? (typeof ext.visible === 'function' ? ext.visible.bind(ext) : ext.visible) : null,\n            openWhenAdded: (_a = ext.openWhenAdded) !== null && _a !== void 0 ? _a : false,\n            settingPanel: ext.getSettingPanel({\n                layoutId,\n                layoutItem: { widgetId },\n                clientRect: null\n            }),\n            index: ext.index,\n            extName: ext.name\n        };\n    })\n        .sort((a, b) => {\n        return a.index - b.index;\n    });\n}\nexport function LayoutItemToolbar(props) {\n    const { layoutId, layoutItem, placement = 'top-start', refElement, shiftOptions, flipOptions, formatMessage, builderTheme, toolItems = [], showDefaultTools = true } = props;\n    const [extensionClassLoaded, setExtenClassLoaded] = React.useState(false);\n    let extTools = [];\n    let allTools = [];\n    const isSection = layoutItem.type === LayoutItemType.Section;\n    const defaultTools = React.useMemo(() => {\n        const commonToolItems = isSection ? commonSectionMenuItems : commonWidgetMenuItems;\n        let defaultTools = showDefaultTools ? [...toolItems, ...commonToolItems] : toolItems;\n        if (isExpressMode()) {\n            const placeholderInfo = placeholderService.getPlaceholderInfo(getAppStore().getState().appConfig, { layoutId, layoutItemId: layoutItem.id });\n            if (placeholderInfo) {\n                defaultTools = [deleteMenuItem];\n            }\n        }\n        return defaultTools;\n    }, [isSection, layoutItem.id, layoutId, toolItems, showDefaultTools]);\n    hooks.useEffectOnce(() => {\n        if (layoutItem.widgetId) {\n            const state = getAppStore().getState();\n            const widgetJson = state.appConfig.widgets[layoutItem.widgetId];\n            ExtensionManager.getInstance().registerWidgetExtensions(widgetJson, false).then((result) => {\n                if (result.length > 0) {\n                    setExtenClassLoaded(true);\n                }\n            });\n        }\n    });\n    if (extensionClassLoaded) {\n        extTools = getExtensionTools(layoutId, layoutItem.widgetId);\n    }\n    if (extTools.length > 0) {\n        if (defaultTools.length > 0) {\n            allTools = [].concat(defaultTools, { separator: true }, extTools);\n        }\n        else {\n            allTools = extTools;\n        }\n    }\n    else if (defaultTools.length > 0) {\n        allTools = defaultTools;\n    }\n    if (!refElement || allTools.length === 0) {\n        return null;\n    }\n    return (jsx(Popper, { placement: placement, reference: refElement, open: true, unstyled: true, shiftOptions: shiftOptions, flipOptions: flipOptions, version: count++, trapFocus: false, autoFocus: false, css: css `\r\n        background: transparent;\r\n        box-shadow: none;\r\n      ` },\n        jsx(\"div\", null,\n            jsx(Toolbar, { layoutId: layoutId, layoutItem: layoutItem, theme: builderTheme, parentRef: refElement, tools: allTools, formatMessage: formatMessage }))));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css, classNames, polished, injectIntl, jimuHistory, getAppStore, appActions, lodash, Keyboard, AppMode, LayoutParentType, createSelector, utils } from 'jimu-core';\nimport { PageContext, LayoutZIndex } from 'jimu-layouts/layout-runtime';\nimport { ScreenGroupContext } from './page-context';\nimport { getAppConfigAction, appBuilderSync } from 'jimu-for-builder';\nimport { GLOBAL_DRAGGING_CLASS_NAME, GLOBAL_H5_DRAGGING_CLASS_NAME } from './interactive/drag-event-handler';\nimport defaultMessages from '../translations/default';\nimport { ResizeHandlers } from './resize-handlers';\nimport { LayoutItemToolbar } from './layout-item-toolbar';\nimport { canDeleteInExpressMode } from './util';\nimport { LockOutlined } from 'jimu-icons/outlined/editor/lock';\nexport class SelectWrapper extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.formatMessage = (id, values) => {\n            if (this.props.intl != null) {\n                return this.props.intl.formatMessage({ id, defaultMessage: defaultMessages[id] }, values);\n            }\n            return defaultMessages[id];\n        };\n        this.isMac = () => {\n            var _a, _b;\n            return ((_b = (_a = window.jimuUA) === null || _a === void 0 ? void 0 : _a.os) === null || _b === void 0 ? void 0 : _b.name) === 'macOS';\n        };\n        this.copyItem = () => {\n            const { layoutId, layoutItem, lockLayout } = this.props;\n            if (!lockLayout) {\n                const rect = this.ref.getBoundingClientRect();\n                const width = rect.width;\n                const height = rect.height;\n                getAppStore().dispatch(appActions.clipboardChanged({\n                    layoutId,\n                    width,\n                    height,\n                    layoutItemId: layoutItem.id\n                }));\n            }\n        };\n        this.deleteSelectedItem = () => {\n            const { selected, layoutId, layoutItem, lockLayout, isFunctionalWidget, isDesignMode } = this.props;\n            if (!selected || (!isDesignMode && !utils.isExpressMode())) {\n                return;\n            }\n            // express mode can not delete some contents\n            if (utils.isExpressMode()) {\n                const appConfig = getAppConfigAction().appConfig;\n                const canDelete = canDeleteInExpressMode({ layoutId, layoutItemId: layoutItem.id }, appConfig);\n                if (!canDelete) {\n                    return;\n                }\n            }\n            // only normal widgets can de deleted in lock layout mode\n            if (!lockLayout || isFunctionalWidget) {\n                const layoutInfo = {\n                    layoutId,\n                    layoutItemId: layoutItem.id\n                };\n                appBuilderSync.publishConfirmDeleteToApp(layoutInfo);\n            }\n        };\n        this.state = { selected: false, updateIndex: 0 };\n        this.screenGroupInfo = '';\n        if (this.isMac()) {\n            this.keyBindings = {\n                delete: this.deleteSelectedItem,\n                backspace: this.deleteSelectedItem,\n                'command+keyc': this.copyItem\n            };\n        }\n        else {\n            this.keyBindings = {\n                delete: this.deleteSelectedItem,\n                backspace: this.deleteSelectedItem,\n                'ctrl+keyc': this.copyItem\n            };\n        }\n    }\n    componentDidMount() {\n        let boundaryElement;\n        const info = this.screenGroupInfo.split(':');\n        if (info.length > 1) {\n            const layoutId = info[0];\n            const layoutItemId = info[1];\n            boundaryElement = document.querySelector(`div.builder-layout-item[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItemId}\"]`);\n        }\n        this.shiftOptions = {\n            boundary: boundaryElement !== null && boundaryElement !== void 0 ? boundaryElement : 'viewport',\n            crossAxis: true\n        };\n        this.flipOptions = {\n            fallbackPlacements: ['top-start', 'bottom-start', 'right-start', 'left-start']\n        };\n        if (this.props.selected) {\n            this.setState({ selected: true }); // Used to update the toolbar when widget is dragged from widget list\n        }\n    }\n    componentDidUpdate(prevProps) {\n        this.scrollIntoView();\n        if (this.props.selected && !prevProps.isDesignMode && this.props.isDesignMode) {\n            // this.ref is not undefined now, it's time to show the toolbar\n            this.setState({ updateIndex: this.state.updateIndex + 1 });\n        }\n    }\n    doScroll() {\n        const { layoutId, layoutItem } = this.props;\n        const element = document.querySelector(`div.exb-rnd[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItem.id}\"]`);\n        if (element != null) {\n            element.scrollIntoView({ behavior: 'auto', block: 'center' });\n        }\n    }\n    scrollIntoView() {\n        var _a, _b;\n        const { selected, autoScroll } = this.props;\n        if (!selected || !autoScroll) {\n            return;\n        }\n        const { layoutId } = this.props;\n        let viewChanged = false;\n        let screenChanged = false;\n        const appConfig = getAppConfigAction().appConfig;\n        const layoutJson = appConfig.layouts[layoutId];\n        if (((_a = layoutJson.parent) === null || _a === void 0 ? void 0 : _a.type) === LayoutParentType.View) {\n            const viewJson = appConfig.views[layoutJson.parent.id];\n            if ((viewJson === null || viewJson === void 0 ? void 0 : viewJson.parent) != null) {\n                jimuHistory.changeView(viewJson.parent, viewJson.id);\n                viewChanged = true;\n            }\n        }\n        if (((_b = layoutJson.parent) === null || _b === void 0 ? void 0 : _b.type) === LayoutParentType.Screen) {\n            const screenJson = appConfig.screens[layoutJson.parent.id];\n            if ((screenJson === null || screenJson === void 0 ? void 0 : screenJson.parent) != null) {\n                const screens = appConfig.screenGroups[screenJson.parent].screens;\n                const activeIndex = screens.indexOf(screenJson.id);\n                getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenJson.parent, activeIndex, true));\n                screenChanged = true;\n            }\n        }\n        if (!viewChanged && !screenChanged) {\n            this.doScroll();\n        }\n        else {\n            lodash.defer(() => {\n                this.doScroll();\n            });\n        }\n    }\n    getStyle() {\n        const { isFunctionalWidget, isSection, selected, isBlock, rotate = 0 } = this.props;\n        const defaultColor = polished.rgba(this.pageContext.builderTheme.ref.palette.neutral[900], 0.6);\n        const hoverColor = this.pageContext.builderTheme.sys.color.primary.main;\n        const selectedColor = hoverColor;\n        const outlineStyle = (!isFunctionalWidget || isSection) ? 'dashed' : 'solid';\n        return css `\r\n      .${GLOBAL_H5_DRAGGING_CLASS_NAME} &,\r\n      .${GLOBAL_DRAGGING_CLASS_NAME} & {\r\n        > .action-area {\r\n          display: none !important;\r\n        }\r\n        > div.selected-tip {\r\n          .tip-content {\r\n            outline-color: ${defaultColor};\r\n          }\r\n        }\r\n      }\r\n\r\n      transform: ${rotate > 0 || rotate < 0 ? `rotateZ(${rotate}deg)` : ''};\r\n      padding: inherit;\r\n      position: absolute;\r\n      left: 0;\r\n      bottom: 0;\r\n      top: 0;\r\n      right: 0;\r\n      z-index: ${selected ? LayoutZIndex.HandlerTools : 'auto'};\r\n      pointer-events: none;\r\n\r\n      & > div.selected-tip {\r\n        display: block;\r\n        padding: inherit;\r\n        position: absolute;\r\n        left: 0;\r\n        bottom: 0;\r\n        top: 0;\r\n        right: 0;\r\n        pointer-events: none;\r\n        .tip-content {\r\n          height: 100%;\r\n          padding: 1px;\r\n          &:after {\r\n            content: '';\r\n            width: 100%;\r\n            height: 100%;\r\n            outline: ${isBlock && !selected ? 'none' : `1px ${outlineStyle} ${defaultColor}`};\r\n            display: block;\r\n            outline-color: ${!isFunctionalWidget || isSection ? defaultColor : 'transparent'};\r\n          }\r\n        }\r\n      }\r\n\r\n      .exb-rnd.selected > & > div.selected-tip {\r\n        display: block;\r\n        .tip-content {\r\n          &:after {\r\n            outline-color: ${selectedColor};\r\n          }\r\n        }\r\n      }\r\n\r\n      & > .action-area {\r\n        position: relative;\r\n        .handle {\r\n          position: absolute;\r\n          pointer-events: all;\r\n        }\r\n      }\r\n\r\n      .lock-layout-tip {\r\n        background: ${this.pageContext.builderTheme.ref.palette.neutral[800]};\r\n        border: 1px solid ${this.pageContext.builderTheme.ref.palette.neutral[600]};\r\n        box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.5);\r\n        width: 20px;\r\n        height: 20px;\r\n        position: absolute;\r\n        left: -10px;\r\n        top: -10px;\r\n\r\n        svg {\r\n          margin-bottom: 6px;\r\n          margin-left: 4px;\r\n        }\r\n      }\r\n    `;\n    }\n    getKeyboardComponent() {\n        return jsx(Keyboard, { bindings: this.keyBindings });\n    }\n    isResizable() {\n        const { resizable = true, selected, isExpressMode } = this.props;\n        return !utils.isExpressMode() && selected && !this.pageContext.viewOnly && !this.props.lockLayout && !isExpressMode && resizable;\n    }\n    showToolbar() {\n        const { forbidToolbar, selected } = this.props;\n        return !forbidToolbar && !this.pageContext.viewOnly && !utils.isExpressMode() && selected;\n    }\n    render() {\n        return (jsx(ScreenGroupContext.Consumer, null, (info) => {\n            this.screenGroupInfo = info;\n            return (jsx(PageContext.Consumer, null, (pageContext) => {\n                this.pageContext = pageContext;\n                if (!this.props.isDesignMode && !utils.isExpressMode()) {\n                    return null;\n                }\n                const { layoutId, layoutItem, resizable = true, draggable = true, selected, toolItems, showDefaultTools, left, top, right, bottom, rotate, isDesignMode } = this.props;\n                const lockBBox = !draggable && !resizable;\n                return (jsx(\"div\", { \"data-testid\": 'select-wrapper', ref: (el) => { this.ref = el; }, css: this.getStyle(), className: classNames('select-wrapper', {\n                        selected,\n                        'no-embed-layout': !this.props.hasEmbeddedLayout\n                    }) },\n                    !pageContext.viewOnly && (jsx(\"div\", { className: 'selected-tip' },\n                        jsx(\"div\", { className: 'tip-content' }))),\n                    this.showToolbar() && (jsx(LayoutItemToolbar, { layoutId: layoutId, layoutItem: layoutItem, refElement: this.ref, shiftOptions: this.shiftOptions, flipOptions: this.flipOptions, builderTheme: this.pageContext.builderTheme, formatMessage: this.formatMessage, toolItems: isDesignMode ? toolItems : undefined, showDefaultTools: isDesignMode ? showDefaultTools : false })),\n                    this.isResizable() && (jsx(ResizeHandlers, { left: left, right: right, top: top, bottom: bottom, rotation: rotate, builderTheme: pageContext.builderTheme })),\n                    lockBBox && selected && !utils.isExpressMode() && (jsx(\"div\", { className: 'lock-layout-tip rounded-circle' },\n                        jsx(LockOutlined, { size: 's', color: pageContext.builderTheme.ref.palette.black }))),\n                    selected && this.getKeyboardComponent()));\n            }));\n        }));\n    }\n}\nconst mapStateToProps = createSelector([\n    (state) => { var _a, _b, _c; return (_c = (_b = (_a = state.appConfig) === null || _a === void 0 ? void 0 : _a.forBuilderAttributes) === null || _b === void 0 ? void 0 : _b.lockLayout) !== null && _c !== void 0 ? _c : false; },\n    (state) => state.appRuntimeInfo.appMode === AppMode.Design,\n    (state) => state.appRuntimeInfo.appMode === AppMode.Express,\n    (state, props) => { var _a, _b; return props.isSection ? (_b = (_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.sectionNavInfos) === null || _b === void 0 ? void 0 : _b[props.layoutItem.sectionId] : null; }\n], (lockLayout, isDesignMode, isExpressMode, sectionNavInfo) => ({ lockLayout, isDesignMode, isExpressMode, sectionNavInfo }));\nexport default ReactRedux.connect(mapStateToProps)(injectIntl(SelectWrapper));\n","/** @jsx jsx */\nimport { React, ReactRedux, classNames, jsx, css, polished, AppMode } from 'jimu-core';\nimport { PageContext, LayoutContext } from 'jimu-layouts/layout-runtime';\nimport { initInteractive } from './droparea-effect-interactjs';\nimport { initH5 } from './droparea-effect-h5';\nexport function DropArea(props) {\n    const refObj = React.useRef();\n    const layoutId = ReactRedux.useSelector((state) => {\n        return props.layouts[state.browserSizeMode];\n    });\n    const isDesignMode = ReactRedux.useSelector((state) => {\n        return state.appRuntimeInfo.appMode === AppMode.Design;\n    });\n    const pageContext = React.useContext(PageContext);\n    const layoutContext = React.useContext(LayoutContext);\n    const contextRef = React.useRef();\n    contextRef.current = { props, layoutId, pageContext, layoutContext };\n    React.useEffect(() => {\n        let interactble;\n        if (refObj.current) {\n            interactble = initInteractive(refObj.current, contextRef);\n        }\n        return () => {\n            if (interactble) {\n                interactble.unset();\n            }\n        };\n    }, []);\n    React.useEffect(() => {\n        if (refObj.current) {\n            initH5(refObj.current, contextRef);\n        }\n    }, []);\n    const { className, style, highlightDragover } = props;\n    const mergedClass = classNames('exb-drop-area d-flex', className);\n    const getStyle = () => {\n        return css `\r\n      background: transparent;\r\n      padding: inherit;\r\n      pointer-events: ${isDesignMode ? 'auto' : 'none !important'};\r\n\r\n      & > .highlight-content {\r\n        display: none;\r\n        pointer-events: none;\r\n        position: relative;\r\n      }\r\n\r\n      &.drop-target > .highlight-content {\r\n        display: flex;\r\n      }\r\n\r\n      &.drop-active {\r\n        background: ${polished.rgba(pageContext.builderTheme.sys.color.primary.dark, 0.2)};\r\n      }\r\n    `;\n    };\n    return (jsx(\"div\", { className: mergedClass, css: getStyle(), style: style, ref: el => { refObj.current = el; } }, highlightDragover && (jsx(\"div\", { className: 'w-100 highlight-content' }, props.children))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, polished, BrowserSizeMode, Immutable, injectIntl, getAppStore, ReactRedux, LayoutItemType, createSelector, classNames, utils, AppType } from 'jimu-core';\nimport { Loading, Button, LoadingType } from 'jimu-ui';\nimport { PlaceholderSync } from 'jimu-ui/advanced/placeholder-sync';\nimport { appBuilderSync, getAppConfigAction, placeholderService } from 'jimu-for-builder';\nimport { WidgetListPopper } from 'jimu-ui/advanced/setting-components';\nimport { PageContext, LayoutContext } from 'jimu-layouts/layout-runtime';\nimport { DropArea } from './interactive/droparea-hook';\nimport { PlusOutlined } from 'jimu-icons/outlined/editor/plus';\nimport { ThemedTooltip } from './theme-tooltip';\nimport { withBuilderTheme } from 'jimu-theme';\nimport { canDropAtPlaceholder, dropAtPlaceholder, addWidgetInPlaceholder, addSectionInPlaceholder } from './util';\nconst ThemeWidgetListPopper = withBuilderTheme(WidgetListPopper);\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  top: 0;\r\n  bottom: 0;\r\n  right: 0;\r\n  right: 0;\r\n  display: flex;\r\n  z-index: 0;\r\n`;\nexport class _WidgetPlaceholder extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.toggleModal = (e) => {\n            e.stopPropagation();\n            if (getAppStore().getState().browserSizeMode === BrowserSizeMode.Small) {\n                appBuilderSync.publishSidePanelToApp({ type: 'widget', isPlaceholder: true, isItemAccepted: this.isItemAccepted, onSelect: this.setContent });\n                return;\n            }\n            this.setState(prevState => ({\n                showModal: !prevState.showModal\n            }));\n        };\n        this.closeModal = () => {\n            if (this.state.showModal) {\n                this.setState({ showModal: false });\n            }\n        };\n        this.toggleDragoverEffect = (isDragover, draggingItem) => {\n            if (this.ref && isDragover && this.isItemAccepted(draggingItem)) {\n                this.ref.classList.add('dragover');\n            }\n            else {\n                this.ref.classList.remove('dragover');\n            }\n        };\n        this.onDrop = (draggingItem) => {\n            if (!this.isItemAccepted(draggingItem)) {\n                return;\n            }\n            const { layoutId, layoutItemId } = this.props;\n            dropAtPlaceholder({ layoutId, layoutItemId }, draggingItem);\n        };\n        this.setContent = (item) => {\n            const { layoutId, layoutItemId } = this.props;\n            if (item.itemType === LayoutItemType.Widget) {\n                addWidgetInPlaceholder({ layoutId, layoutItemId }, item).then(() => {\n                    this.setState({\n                        isBusy: false\n                    });\n                });\n            }\n            else if (item.itemType === LayoutItemType.Section) {\n                addSectionInPlaceholder({ layoutId, layoutItemId });\n            }\n            this.setState({\n                showModal: false,\n                isBusy: true\n            });\n        };\n        this.handleSyncChange = (newPlaceholderId) => {\n            const { browserSizeMode, layoutId, layoutItemId } = this.props;\n            const appConfigAction = getAppConfigAction();\n            appConfigAction\n                .syncPlaceholder({ layoutId, layoutItemId }, newPlaceholderId, browserSizeMode)\n                .exec();\n        };\n        this.isItemAccepted = (item) => {\n            return this.layoutContext.isItemAccepted(item, true) && canDropAtPlaceholder(item);\n        };\n        this.fakeLayouts = Immutable({\n            [BrowserSizeMode.Large]: `${this.props.layoutId}_${this.props.layoutItemId}_tlarge`,\n            [BrowserSizeMode.Medium]: `${this.props.layoutId}_${this.props.layoutItemId}_tmedium`,\n            [BrowserSizeMode.Small]: `${this.props.layoutId}_${this.props.layoutItemId}_tsmall`\n        });\n        this.state = { showModal: false, isBusy: false };\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.currentDialogId !== this.props.currentDialogId) {\n            this.setState({ showModal: false });\n        }\n    }\n    getStyle(builderTheme) {\n        return css `\r\n      position: absolute;\r\n      left: 0;\r\n      top: 0;\r\n      overflow: hidden;\r\n      container-type: inline-size;\r\n\r\n      &.is-template {\r\n        border: 1px dashed ${builderTheme.sys.color.primary.dark};\r\n      }\r\n\r\n      &.dragover .drop-tip {\r\n        background: ${polished.rgba(builderTheme.sys.color.primary.dark, 0.5)} !important;\r\n      }\r\n\r\n      .add-btn {\r\n        z-index: 1;\r\n      }\r\n\r\n      .mask {\r\n        position: absolute;\r\n        left:0;\r\n        top:0;\r\n        right:0;\r\n        bottom:0;\r\n        z-index:2;\r\n        background: transparent;\r\n      }\r\n\r\n      .placeholder-id {\r\n        background: var(--ref-palette-white);\r\n        color: var(--sys-color-surface-background-hint);\r\n        font-size: min(32px, 12.5cqw, 12.5cqh);\r\n        width: min(25cqw, 25cqh);\r\n        height: min(25cqw, 25cqh);\r\n        max-width: 64px;\r\n        max-height: 64px;\r\n        gap: 10px;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n      }\r\n\r\n      &.aspect-ratio-wrapper {\r\n        padding-top: ${(this.props.aspectRatio || 0) * 100}%;\r\n      }\r\n\r\n      &.aspect-ratio-wrapper > .exb-drop-area {\r\n        position: absolute;\r\n        padding: 0;\r\n      }\r\n\r\n      &.aspect-ratio-wrapper > .add-btn {\r\n        position: absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        transform: translate(-50%, -50%);\r\n      }\r\n    `;\n    }\n    getPopupStyle() {\n        const { builderTheme } = this.pageContext;\n        return css `\r\n      background-color: ${builderTheme.ref.palette.neutral[400]};\r\n      max-height: 400px;\r\n      overflow: auto;\r\n    `;\n    }\n    getModalStyle() {\n        const { builderTheme } = this.pageContext;\n        return css `\r\n      .modal-content {\r\n        background-color: ${builderTheme.ref.palette.neutral[400]};\r\n      }\r\n\r\n      .modal-header {\r\n        color: ${builderTheme.ref.palette.black};\r\n        .close {\r\n          color: ${builderTheme.ref.palette.neutral[1100]};\r\n          &:hover {\r\n            color: ${builderTheme.ref.palette.black};\r\n          }\r\n        }\r\n      }\r\n    `;\n    }\n    render() {\n        const { isTemplate, isMainSizeMode } = this.props;\n        const isExpressBuilder = utils.isExpressMode();\n        return (jsx(PageContext.Consumer, null, (pageContext) => {\n            this.pageContext = pageContext;\n            return (jsx(LayoutContext.Consumer, null, (layoutContext) => {\n                var _a;\n                this.layoutContext = layoutContext;\n                return (jsx(\"div\", { className: classNames('layout-widget layout-item-content no-widget h-100 w-100 d-flex justify-content-center align-items-center', { 'is-template': isTemplate }), ref: el => { this.ref = el; }, css: this.getStyle(pageContext.builderTheme) },\n                    !isTemplate && (jsx(React.Fragment, null,\n                        jsx(DropArea, { css: dropareaStyle, className: 'drop-tip', layouts: this.fakeLayouts, isPlaceholder: true, highlightDragover: false, onToggleDragoverEffect: this.toggleDragoverEffect, onDrop: this.onDrop }),\n                        this.state.isBusy && jsx(Loading, { type: LoadingType.Primary }),\n                        !this.state.isBusy && (jsx(\"div\", { ref: el => { this.btnRef = el; }, className: classNames('add-btn', { 'd-none': this.pageContext.viewOnly || (isExpressBuilder && !isMainSizeMode) }) },\n                            jsx(ThemedTooltip, { title: (_a = this.props.intl) === null || _a === void 0 ? void 0 : _a.formatMessage({ id: 'addWidget' }) },\n                                jsx(Button, { icon: true, css: css `width: 36px; height: 36px; padding: 0.5rem;`, onClick: this.toggleModal, \"aria-haspopup\": true },\n                                    jsx(PlusOutlined, null))))),\n                        !this.state.isBusy && this.state.showModal &&\n                            jsx(ThemeWidgetListPopper, { referenceElement: this.btnRef, isAccepted: this.isItemAccepted, onSelect: this.setContent, onClose: this.closeModal }),\n                        this.pageContext.viewOnly && jsx(\"div\", { className: 'mask' }))),\n                    isTemplate && (jsx(React.Fragment, null,\n                        this.props.placeholderId > 0 && (jsx(\"div\", { className: 'placeholder-id rounded-circle' }, this.props.placeholderId)),\n                        !this.pageContext.viewOnly && (jsx(PlaceholderSync, { layoutId: this.props.layoutId, layoutItemId: this.props.layoutItemId, sizemode: this.props.browserSizeMode, onSyncChange: this.handleSyncChange, className: 'sync-select' }))))));\n            }));\n        }));\n    }\n}\nconst mapFunc = createSelector((state) => { var _a; return (_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.currentDialogId; }, (state) => state.browserSizeMode, (state) => state.browserSizeMode === state.appConfig.mainSizeMode, (state) => { var _a; return ((_a = state.appInfo) === null || _a === void 0 ? void 0 : _a.type) === AppType.Template; }, (state, props) => {\n    const { layoutId, layoutItemId } = props;\n    const placeholderInfo = placeholderService.getPlaceholderInfo(state.appConfig, { layoutId, layoutItemId });\n    if (placeholderInfo && placeholderInfo.layoutInfo.layoutId === layoutId) {\n        return placeholderInfo.id;\n    }\n    return -1;\n}, (currentDialogId, browserSizeMode, isMainSizeMode, isTemplate, placeholderId) => ({ currentDialogId, browserSizeMode, isMainSizeMode, isTemplate: isTemplate, placeholderId }));\nconst WrappedComponent = ReactRedux.connect(mapFunc)(_WidgetPlaceholder);\nexport const WidgetPlaceholder = injectIntl(WrappedComponent);\n","/** @jsx jsx */\nimport { React, jsx, css } from 'jimu-core';\nimport { LayoutZIndex, WidgetRenderer } from 'jimu-layouts/layout-runtime';\nimport { WidgetPlaceholder } from './widget-placeholder';\nimport { GLOBAL_DRAGGING_CLASS_NAME } from './interactive/drag-event-handler';\nexport class WidgetRendererInBuilder extends React.PureComponent {\n    mask() {\n        return jsx(\"div\", { className: 'widget-mask' });\n    }\n    getStyle() {\n        // Set z-index higher than droparea (z-index: 10) when widget is inline editing\n        return css `\r\n      .${GLOBAL_DRAGGING_CLASS_NAME} & {\r\n        overflow: visible !important;\r\n      }\r\n      z-index: ${this.props.isInlineEditing ? LayoutZIndex.HandlerTools : 0};\r\n\r\n      .widget-mask {\r\n        position: absolute;\r\n        background: transparent;\r\n        left: 0;\r\n        right: 0;\r\n        top: 0;\r\n        bottom: 0;\r\n        z-index: 1;\r\n      }\r\n\r\n      body:not(.design-mode) & .widget-mask {\r\n        display: none !important;\r\n      }\r\n    `;\n    }\n    getPlaceholderStyle() {\n        return css `\r\n      body:not(.design-mode) & {\r\n        display: none !important;\r\n      }\r\n    `;\n    }\n    render() {\n        const { widgetId, isInlineEditing, isFunctionalWidget, hasEmbeddedLayout } = this.props;\n        // if (!widgetId) {\n        //   return <WidgetPlaceholder css={this.getPlaceholderStyle()} {...this.props} />\n        // }\n        const showMask = !isInlineEditing && isFunctionalWidget && !hasEmbeddedLayout;\n        return (jsx(WidgetRenderer, Object.assign({ className: 'w-100', css: this.getStyle() }, this.props),\n            !widgetId && jsx(WidgetPlaceholder, Object.assign({ css: this.getPlaceholderStyle() }, this.props)),\n            showMask && widgetId && this.mask()));\n    }\n}\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/** @jsx jsx */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { React, jsx, css, ReactRedux, appActions, getAppStore, classNames, utils, hooks, LayoutItemType, AnimationContext, AnimationComponent, AnimationTriggerType, AnimationType, AnimationPlayMode, polished, getNextAnimationId, getHoverStyle, AnimationStartMode, createSelector } from 'jimu-core';\nimport { utils as layoutUtils, PageContext, ViewportVisibilityContext, CONTEXT_MENU_ICON_SIZE, CONTEXT_MENU_ITEM_SIZE, searchUtils, MIN_LAYOUT_ITEM_SIZE, CLICK_TOLERANCE } from 'jimu-layouts/layout-runtime';\nimport ContextMenu from './context-menu';\nimport { isDragging, GLOBAL_H5_DRAGGING_CLASS_NAME, GLOBAL_DRAGGING_CLASS_NAME } from './interactive/drag-event-handler';\nimport { isResizing } from './interactive/resize-event-handler';\nimport { pendingMenuItem, deleteMenuItem, settingMenuItem, draggingMenuItem, isDesignMode } from './menu/common-menu';\nimport SelectWrapper from './select-wrapper';\nimport { WidgetRendererInBuilder } from './widget-renderer';\nimport { SectionRendererInBuilder } from './section-renderer';\nimport { findActiveViewId } from './menu/section-menu';\nimport { useAsOnePlayId } from './layout-item-hook/use-asone-playid';\nimport { useOneByOnePlayId } from './layout-item-hook/use-onebyone-playid';\nimport { useViewportIntersection } from '../use-viewport-intersection';\nimport { useDndBinding } from './layout-item-dnd-hook';\nconst defaultConstextMenus = [settingMenuItem, draggingMenuItem, pendingMenuItem, deleteMenuItem];\nconst dragMenus = [draggingMenuItem];\nfunction findInnerLayoutId(state, layoutId, layoutItemId) {\n    const layoutItem = state.appConfig.layouts[layoutId].content[layoutItemId];\n    if (layoutItem.type === LayoutItemType.Widget) {\n        const widgetJson = state.appConfig.widgets[layoutItem.widgetId]; // may be a placeholder\n        if ((widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.layouts) != null) { // widget may have multiple inner layout, like sidebar\n            const names = Object.keys(widgetJson.layouts);\n            if (names.length === 1) {\n                const sizeModeLayout = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.layouts[names[0]];\n                if (sizeModeLayout) {\n                    return sizeModeLayout[state.browserSizeMode];\n                }\n            }\n            else {\n                const output = [];\n                names.forEach((name) => {\n                    const sizeModeLayout = widgetJson.layouts[name];\n                    output.push(sizeModeLayout[state.browserSizeMode]);\n                });\n                return output;\n            }\n        }\n    }\n    return null;\n}\nexport default function LayoutItemInBuilder(props) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    const stateProps = ReactRedux.useSelector((state) => mapStateToProps(state, props), ReactRedux.shallowEqual);\n    const allProps = Object.assign(Object.assign({}, stateProps), props);\n    const pageContext = React.useContext(PageContext);\n    const refObj = React.useRef();\n    const oneByOnePlayIdRef = React.useRef(0);\n    let mousedownX;\n    let mousedownY;\n    const { effect, oneByOneEffect, hoverEffect } = (_b = (_a = allProps.layoutItem) === null || _a === void 0 ? void 0 : _a.setting) !== null && _b !== void 0 ? _b : {};\n    // eslint-disable-next-line no-unused-vars\n    const { animationPreview, hoverPreview, previewId, playMode, layoutType } = allProps;\n    const getCurrentRootLayoutId = React.useCallback(() => pageContext.rootLayoutId, [pageContext.rootLayoutId]);\n    const isInViewport = useViewportIntersection(refObj.current, allProps.watchViewportVisibility);\n    let effectType = (_c = effect === null || effect === void 0 ? void 0 : effect[AnimationTriggerType.ScrollIntoView]) === null || _c === void 0 ? void 0 : _c.type;\n    effectType = effectType && effectType !== AnimationType.None ? effectType : null;\n    let oneByOneEffectType = (_d = oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView]) === null || _d === void 0 ? void 0 : _d.type;\n    oneByOneEffectType = oneByOneEffectType && oneByOneEffectType !== AnimationType.None ? oneByOneEffectType : null;\n    const [animationContext, setAnimationContext] = React.useState({\n        setting: oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView],\n        playId: null,\n        oid: stateProps.innerLayoutId,\n        revert: null,\n        playMode: null\n    });\n    const { setting: parentAnimationSetting } = React.useContext(AnimationContext);\n    const [asOnePlayId, asOneRevert, onAsOneAnimationEnd] = useAsOnePlayId({\n        type: effectType,\n        isPreview: animationPreview,\n        previewId: playMode !== AnimationPlayMode.OneByOne ? previewId : null,\n        hasParentAnimation: (parentAnimationSetting === null || parentAnimationSetting === void 0 ? void 0 : parentAnimationSetting.type) != null && parentAnimationSetting.type !== AnimationType.None\n    });\n    const [oneByOnePlayId, oneByOneRevert, onOnebyOneAnimationEnd] = useOneByOnePlayId({\n        type: oneByOneEffectType,\n        isPreview: animationPreview,\n        previewId: playMode !== AnimationPlayMode.AsOne ? previewId : null,\n        hasParentAnimation: (parentAnimationSetting === null || parentAnimationSetting === void 0 ? void 0 : parentAnimationSetting.type) != null && parentAnimationSetting.type !== AnimationType.None\n    });\n    const { registerWidgetInitDragHandler, registerWidgetInitResizeHandler, setRefElement } = useDndBinding({\n        restrict: props.restrict,\n        layoutId: props.layoutId,\n        layoutItemId: props.layoutItemId,\n        layoutType,\n        layoutItemType: (_e = stateProps.layoutItem) === null || _e === void 0 ? void 0 : _e.type,\n        useDragHandler: props.useDragHandler,\n        resizeObserver: props.resizeObserver,\n        getCurrentRootLayoutId,\n        onDragStart: props.onDragStart,\n        onDragging: props.onDragging,\n        onDragEnd: props.onDragEnd,\n        onResizeStart: props.onResizeStart,\n        onResizing: props.onResizing,\n        onResizeEnd: props.onResizeEnd\n    });\n    hooks.useEffectOnce(() => {\n        setRefElement(refObj.current);\n    });\n    React.useEffect(() => {\n        // no as one playId, play inner animations one by one by setting animation context\n        if (asOnePlayId == null && oneByOnePlayId > oneByOnePlayIdRef.current) {\n            oneByOnePlayIdRef.current = oneByOnePlayId;\n            setAnimationContext({\n                setting: oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView],\n                playId: oneByOnePlayId,\n                oid: stateProps.innerLayoutId,\n                revert: oneByOneRevert,\n                playMode,\n                onContextAnimationEnd: oneByOneRevert\n                    ? null\n                    : () => {\n                        // clear animation preview setting if it is preview as one\n                        onOnebyOneAnimationEnd === null || onOnebyOneAnimationEnd === void 0 ? void 0 : onOnebyOneAnimationEnd();\n                        if (animationPreview) {\n                            getAppStore().dispatch(appActions.clearAnimationPreview());\n                        }\n                        setAnimationContext({\n                            setting: oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView],\n                            oid: stateProps.innerLayoutId,\n                            playId: -1\n                        });\n                    }\n            });\n        }\n    }, [asOnePlayId, oneByOnePlayId, onOnebyOneAnimationEnd, oneByOneEffect, oneByOneRevert, playMode, animationPreview, stateProps.innerLayoutId]);\n    const shouldAnimationPassdown = () => {\n        var _a;\n        // Animation may be trigger by:\n        // 1. preview the layout item's animation\n        //    1.1 if preview as one, the animation should stop here\n        //    1.2 if preview as a whole, the animation should pass down\n        // 2. parent animation is playing, this item is played as a child\n        //    2.1 if the parent is previewed as onebyone, the animation should stop here\n        //    2.2 otherwise, the animation should pass down\n        if (animationPreview) {\n            // case 1.1 and 1.2, preview one by one can not trigger this item's animation\n            return playMode !== AnimationPlayMode.AsOne;\n        }\n        // Parent is playing. check if it is previewed as a whole\n        const previewInfo = (_a = getAppStore().getState().appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.animationPreview;\n        return previewInfo == null || previewInfo.playMode !== AnimationPlayMode.OneByOne;\n    };\n    const handleSingleAnimationStart = () => {\n        var _a;\n        if (shouldAnimationPassdown()) {\n            // maybe there is no one by one animation, but some child element has its own animation\n            const setting = oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView];\n            const revert = ((_a = setting === null || setting === void 0 ? void 0 : setting.option) === null || _a === void 0 ? void 0 : _a.start) === AnimationStartMode.AfterPrevious; // check one by one start mode\n            setAnimationContext({\n                setting,\n                playId: getNextAnimationId(),\n                oid: stateProps.innerLayoutId,\n                revert,\n                playMode,\n                onContextAnimationEnd: revert // no need to reset animation context if it is revert\n                    ? null\n                    : () => {\n                        // clear playId\n                        setAnimationContext({ setting, oid: stateProps.innerLayoutId, playId: -1 });\n                    }\n            });\n        }\n    };\n    const handleSingleAnimationEnd = () => {\n        var _a;\n        if (shouldAnimationPassdown()) {\n            const setting = oneByOneEffect === null || oneByOneEffect === void 0 ? void 0 : oneByOneEffect[AnimationTriggerType.ScrollIntoView];\n            // only plays when start mode is \"after previous\"\n            if (((_a = setting === null || setting === void 0 ? void 0 : setting.option) === null || _a === void 0 ? void 0 : _a.start) === AnimationStartMode.AfterPrevious) {\n                setAnimationContext({\n                    setting,\n                    playId: getNextAnimationId(),\n                    oid: stateProps.innerLayoutId,\n                    revert: false,\n                    playMode,\n                    onContextAnimationEnd: () => {\n                        // clear playId\n                        setAnimationContext({ setting, oid: stateProps.innerLayoutId, playId: -1 });\n                    }\n                });\n            }\n        }\n        // clear animation preview setting if it is preview as one\n        onAsOneAnimationEnd === null || onAsOneAnimationEnd === void 0 ? void 0 : onAsOneAnimationEnd();\n        if (animationPreview) {\n            getAppStore().dispatch(appActions.clearAnimationPreview());\n        }\n    };\n    /**\n     * Enable inline editing mode for the widget\n     *\n     * @memberof LayoutItemInBuilder\n     */\n    function doubleClick(e) {\n        const { layoutId, layoutItemId } = props;\n        const { supportInlineEditing, widgetId } = stateProps;\n        if (props.onDoubleClick) {\n            props.onDoubleClick(e, { layoutId, layoutItemId });\n        }\n        const { browserSizeMode, mainBrowserSizeMode } = stateProps;\n        if (pageContext.viewOnly || (utils.isExpressMode() && (browserSizeMode !== mainBrowserSizeMode || !isFunctionalWidget))) {\n            return;\n        }\n        e.stopPropagation();\n        if (supportInlineEditing) {\n            getAppStore().dispatch(appActions.setWidgetIsInlineEditingState(widgetId, true));\n        }\n    }\n    function onItemClick(e) {\n        if (Math.abs(e.screenX - mousedownX) > CLICK_TOLERANCE || Math.abs(e.screenY - mousedownY) > CLICK_TOLERANCE) {\n            e.stopPropagation();\n            return;\n        }\n        const { viewOnly } = pageContext;\n        const { browserSizeMode, mainBrowserSizeMode } = stateProps;\n        if (viewOnly || (utils.isExpressMode() && (browserSizeMode !== mainBrowserSizeMode || !isFunctionalWidget))) {\n            // propagate normally in view mode\n            return;\n        }\n        e.stopPropagation();\n        // workaround: redirect a fake click event to window for popover to listen to\n        // Some calcite components listen to window click event to open or close the popover\n        const fakeEvent = new CustomEvent('click', { detail: 1 });\n        fakeEvent.composedPath = () => e.nativeEvent.composedPath();\n        window.dispatchEvent(fakeEvent);\n        if (isResizing() || isDragging()) {\n            // Prevent switching selection when resizing an item\n            return;\n        }\n        if (props.onClick) {\n            const { layoutId, layoutItemId } = allProps;\n            props.onClick(e, { layoutId, layoutItemId });\n        }\n        switchSetting();\n    }\n    function onMouseDown(e) {\n        mousedownX = e.screenX;\n        mousedownY = e.screenY;\n    }\n    function createContextMenu(rotate) {\n        const { builderTheme } = pageContext;\n        return (jsx(ContextMenu, { builderTheme: builderTheme, layoutId: props.layoutId, layoutItem: stateProps.layoutItem, positionType: 'center', size: CONTEXT_MENU_ITEM_SIZE, rotate: rotate, iconSize: CONTEXT_MENU_ICON_SIZE, className: 'widget-context-menu', menuItems: props.contextMenuItems || (stateProps.useDragHandler ? dragMenus : defaultConstextMenus) }));\n    }\n    function switchSetting() {\n        const { layoutId, layoutItemId } = props;\n        if (!stateProps.selected) {\n            getAppStore().dispatch(appActions.selectionChanged({\n                layoutId,\n                layoutItemId\n            }));\n        }\n    }\n    function getStyle(rotate) {\n        var _a;\n        const draggable = canDrag();\n        const isInlineEditing = (_a = stateProps.isInlineEditing) !== null && _a !== void 0 ? _a : false;\n        const defaultColor = polished.rgba(pageContext.builderTheme.ref.palette.neutral[900], 0.6);\n        const hoverColor = pageContext.builderTheme.sys.color.primary.main;\n        const outlineStyle = (!isFunctionalWidget || isSection) && !selected ? 'dashed' : 'solid';\n        let hoverStyle = null;\n        if (!isDesignMode()) {\n            hoverStyle = getHoverStyle(hoverEffect === null || hoverEffect === void 0 ? void 0 : hoverEffect.type, hoverEffect === null || hoverEffect === void 0 ? void 0 : hoverEffect.setting);\n        }\n        return css `\r\n      ${hoverStyle};\r\n      position: relative;\r\n      overflow: visible;\r\n      cursor: ${draggable ? 'move' : 'default'};\r\n      touch-action: ${(isInlineEditing || !selected) ? 'auto' : 'none'};\r\n      user-select: ${isInlineEditing ? 'auto' : 'none'};\r\n      min-width: ${MIN_LAYOUT_ITEM_SIZE}px;\r\n      min-height: ${MIN_LAYOUT_ITEM_SIZE}px;\r\n\r\n      & > div.widget-context-menu {\r\n        display: none;\r\n      }\r\n\r\n      &:hover > div.widget-context-menu {\r\n        display: flex;\r\n      }\r\n\r\n      .${GLOBAL_H5_DRAGGING_CLASS_NAME} &.functional-widget {\r\n        pointer-events: none;\r\n      }\r\n      .${GLOBAL_H5_DRAGGING_CLASS_NAME} &.functional-widget .exb-drop-area {\r\n        pointer-events: all;\r\n      }\r\n\r\n      .${GLOBAL_H5_DRAGGING_CLASS_NAME} &,\r\n      .${GLOBAL_DRAGGING_CLASS_NAME} & {\r\n        > div.highlight-tip {\r\n          .tip-content {\r\n            outline-color: ${defaultColor};\r\n          }\r\n        }\r\n      }\r\n\r\n      body:not(.design-mode) &,\r\n      body.lock-layout & {\r\n        cursor: default;\r\n      }\r\n\r\n      body:not(.design-mode) & > div.highlight-tip {\r\n        display: none !important;\r\n      }\r\n\r\n      & > div.highlight-tip {\r\n        display: block;\r\n        padding: inherit;\r\n        position: absolute;\r\n        left: 0;\r\n        bottom: 0;\r\n        top: 0;\r\n        right: 0;\r\n        pointer-events: none;\r\n        transform: ${rotate > 0 || rotate < 0 ? `rotateZ(${rotate}deg)` : ''};\r\n        .tip-content {\r\n          height: 100%;\r\n          padding: 1px;\r\n          &:after {\r\n            content: '';\r\n            width: 100%;\r\n            height: 100%;\r\n            outline: ${isBlock && !selected\n            ? 'none'\n            : `1px ${outlineStyle} ${defaultColor}`};\r\n            display: block;\r\n            outline-color: ${!isFunctionalWidget || isSection\n            ? defaultColor\n            : 'transparent'};\r\n          }\r\n        }\r\n      }\r\n\r\n      &:hover > div.highlight-tip,\r\n      &.hovered > div.highlight-tip {\r\n        display: block;\r\n        .tip-content {\r\n          &:after {\r\n            outline-color: ${hoverColor};\r\n          }\r\n        }\r\n      }\r\n\r\n      &.functional-widget:not(.selected):hover > div.highlight-tip,\r\n      &.functional-widget:not(.selected).hovered > div.highlight-tip {\r\n        .tip-content {\r\n          &:after {\r\n            outline-width: 2px;\r\n          }\r\n        }\r\n      }\r\n    `;\n    }\n    function canDrag() {\n        var _a;\n        const { selected, draggable = true } = allProps;\n        const isInlineEditing = (_a = stateProps.isInlineEditing) !== null && _a !== void 0 ? _a : false;\n        const isTouchDevice = utils.isTouchDevice();\n        return (draggable && // draggable !== false\n            !pageContext.viewOnly &&\n            !isInlineEditing &&\n            (!isTouchDevice || selected));\n    }\n    const { layoutId, layoutItemId, top, left, right, bottom, resizable, draggable, isBlock, autoScroll, layoutItem, isFunctionalWidget, selected, isInlineEditing, hasEmbeddedLayout, hasExtension } = allProps;\n    if (!layoutItem) {\n        return null;\n    }\n    const { className, forbidContextMenu, onClick, onDoubleClick, children, id, isLastChild } = allProps, otherProps = __rest(allProps, [\"className\", \"forbidContextMenu\", \"onClick\", \"onDoubleClick\", \"children\", \"id\", \"isLastChild\"]);\n    const isWidget = layoutItem.type === LayoutItemType.Widget;\n    const isSection = layoutItem.type === LayoutItemType.Section;\n    const showContextMenu = !forbidContextMenu &&\n        !pageContext.viewOnly &&\n        (layoutItem.widgetId || layoutItem.sectionId) &&\n        (!isFunctionalWidget || isSection);\n    const effectOption = (_f = effect === null || effect === void 0 ? void 0 : effect[AnimationTriggerType.ScrollIntoView]) === null || _f === void 0 ? void 0 : _f.option;\n    const rotate = (_k = (_j = (_h = (_g = layoutItem.setting) === null || _g === void 0 ? void 0 : _g.style) === null || _h === void 0 ? void 0 : _h.transform) === null || _j === void 0 ? void 0 : _j.rotate) !== null && _k !== void 0 ? _k : 0;\n    return (jsx(ViewportVisibilityContext.Provider, { value: isDesignMode() ? true : isInViewport },\n        jsx(AnimationComponent, { id: id, parentId: layoutId, type: effectType, configType: effectOption === null || effectOption === void 0 ? void 0 : effectOption.configType, direction: effectOption === null || effectOption === void 0 ? void 0 : effectOption.direction, revert: asOneRevert, delay: props.delay, isLastChild: isLastChild, playId: asOnePlayId, hoverEffect: hoverEffect, hoverPlayId: previewId, onAnimationStart: handleSingleAnimationStart, onAnimationEnd: handleSingleAnimationEnd, css: getStyle(rotate), style: props.style, ref: refObj, className: classNames('builder-layout-item exb-rnd', className, {\n                selected,\n                'is-widget': isWidget,\n                'is-section': isSection,\n                'functional-widget': isWidget && isFunctionalWidget,\n                'no-drag-action': !canDrag()\n            }), onDoubleClick: doubleClick, onClick: onItemClick, onMouseDown: onMouseDown, \"data-layoutitemid\": layoutItemId, \"data-layoutid\": layoutId },\n            jsx(AnimationContext.Provider, { value: animationContext },\n                isWidget && jsx(WidgetRendererInBuilder, Object.assign({ rotate: rotate, onInitDragHandler: registerWidgetInitDragHandler, onInitResizeHandler: registerWidgetInitResizeHandler }, otherProps)),\n                isSection && jsx(SectionRendererInBuilder, Object.assign({ rotate: rotate }, otherProps))),\n            (showContextMenu || stateProps.useDragHandler) && !pageContext.viewOnly && !stateProps.isInController && createContextMenu(rotate),\n            !pageContext.viewOnly && selected && (jsx(SelectWrapper, { layoutId: layoutId, layoutItem: layoutItem, top: top, left: left, right: right, bottom: bottom, resizable: resizable, draggable: draggable, selected: selected, autoScroll: autoScroll, forbidToolbar: props.forbidToolbar, toolItems: props.toolItems, showDefaultTools: props.showDefaultTools, isInlineEditing: isInlineEditing, isFunctionalWidget: isFunctionalWidget, hasEmbeddedLayout: hasEmbeddedLayout, isSection: isSection, isBlock: isBlock, hasExtension: isWidget && hasExtension, widgetJson: stateProps.widgetJson, widgetState: stateProps.widgetState, rotate: rotate })),\n            !pageContext.viewOnly && (jsx(\"div\", { className: 'highlight-tip' },\n                jsx(\"div\", { className: 'tip-content' }))),\n            props.children)));\n}\nconst mapStateToProps = createSelector([\n    (state, ownProps) => state.browserSizeMode,\n    (state, ownProps) => state.appConfig.mainSizeMode,\n    (state, ownProps) => layoutUtils.mapStateToLayoutItemProps(state, ownProps),\n    (state, ownProps) => { var _a; return (_a = state.appConfig.layouts[ownProps.layoutId]) === null || _a === void 0 ? void 0 : _a.type; },\n    (state, ownProps) => {\n        const layoutItem = searchUtils.findLayoutItem(state.appConfig, { layoutId: ownProps.layoutId, layoutItemId: ownProps.layoutItemId });\n        if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Widget) {\n            const innerLayoutId = findInnerLayoutId(state, ownProps.layoutId, ownProps.layoutItemId);\n            return innerLayoutId;\n        }\n        return null;\n    },\n    (state, ownProps) => {\n        const layoutItem = searchUtils.findLayoutItem(state.appConfig, { layoutId: ownProps.layoutId, layoutItemId: ownProps.layoutItemId });\n        if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Widget) {\n            return layoutUtils.mapStateToWidgetProps(state, ownProps);\n        }\n        return null;\n    },\n    (state, ownProps) => {\n        const layoutItem = searchUtils.findLayoutItem(state.appConfig, { layoutId: ownProps.layoutId, layoutItemId: ownProps.layoutItemId });\n        if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Section) {\n            return searchUtils.getSectionInfo(state, layoutItem.sectionId);\n        }\n        return null;\n    },\n    (state, ownProps) => {\n        const layoutItem = searchUtils.findLayoutItem(state.appConfig, { layoutId: ownProps.layoutId, layoutItemId: ownProps.layoutItemId });\n        if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Section) {\n            const sectionProps = searchUtils.getSectionInfo(state, layoutItem.sectionId);\n            const activeViewId = findActiveViewId(sectionProps);\n            return state.appConfig.views[activeViewId];\n        }\n        return null;\n    }\n    // eslint-disable-next-line max-params\n], (browserSizeMode, mainBrowserSizeMode, layoutItemProps, layoutType, innerLayoutId, widgetProps, sectionProps, activeView) => {\n    return Object.assign(Object.assign(Object.assign({ browserSizeMode,\n        mainBrowserSizeMode,\n        layoutType,\n        innerLayoutId,\n        activeView }, layoutItemProps), (widgetProps !== null && widgetProps !== void 0 ? widgetProps : {})), (sectionProps !== null && sectionProps !== void 0 ? sectionProps : {}));\n});\n","/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, AppMode, getAppStore, BrowserSizeMode } from 'jimu-core';\nimport { Button } from 'jimu-ui';\nimport { TemplateSelector } from 'jimu-ui/advanced/setting-components';\nimport { appBuilderSync } from 'jimu-for-builder';\nimport { getHeaderTemplates, getFullScreenPageTemplates, getFooterTemplates, getWindowTemplates } from 'jimu-for-builder/templates';\nimport { TemplateOutlined } from 'jimu-icons/outlined/application/template';\nimport { ThemedTooltip } from '../../builder/theme-tooltip';\nconst buttonStyle = css `\r\n  pointer-events: all;\r\n`;\nfunction getStyle(builderTheme) {\n    return css `\r\n    position: relative;\r\n    height: 200px;\r\n    padding: 1rem;\r\n    pointer-events: none;\r\n    z-index: 1;\r\n    .btn-text {\r\n      line-height: 32px;\r\n    }\r\n    .btn {\r\n      background: ${builderTheme.ref.palette.neutral[600]};\r\n      &:hover {\r\n        background: ${builderTheme.ref.palette.neutral[700]};\r\n      }\r\n    }\r\n    .action-item {\r\n      width: 32px;\r\n    }\r\n    .action-separator {\r\n      width: 300px;\r\n      height: 1px;\r\n      background-color: ${builderTheme.ref.palette.neutral[1100]};\r\n    }\r\n  `;\n}\nexport function ActionBlock(props) {\n    const { pageContext, onPageTemplateSelected } = props;\n    const { builderTheme, formatMessage, isHeader, isFooter } = pageContext;\n    const [showTemplatePopper, setShowTemplatePopper] = React.useState(false);\n    const templateRef = React.useRef(null);\n    const show = ReactRedux.useSelector((state) => {\n        var _a, _b, _c;\n        const lockLayout = (_c = (_b = (_a = state.appConfig) === null || _a === void 0 ? void 0 : _a.forBuilderAttributes) === null || _b === void 0 ? void 0 : _b.lockLayout) !== null && _c !== void 0 ? _c : false;\n        const isDesignMode = state.appRuntimeInfo.appMode === AppMode.Design;\n        return isDesignMode && !lockLayout;\n    });\n    const toggleTemplatePopper = e => {\n        e.stopPropagation();\n        if (getAppStore().getState().browserSizeMode === BrowserSizeMode.Small) {\n            if (pageContext.isDialog) {\n                appBuilderSync.publishSidePanelToApp({ type: 'templateBlock', templateMethod: 'getWindowTemplates', onSelect: onPageTemplateSelected });\n            }\n            else {\n                const name = isHeader ? 'getHeaderTemplates' : (isFooter ? 'getFooterTemplates' : 'getFullScreenPageTemplates');\n                const templateType = name === 'getFullScreenPageTemplates' ? 'template' : 'templateBlock';\n                appBuilderSync.publishSidePanelToApp({ type: templateType, templateMethod: name, onSelect: onPageTemplateSelected });\n            }\n            return;\n        }\n        setShowTemplatePopper(!showTemplatePopper);\n    };\n    const closeTemplatePopover = () => {\n        setShowTemplatePopper(false);\n    };\n    let tooltip;\n    if (pageContext.isHeader) {\n        tooltip = formatMessage('chooseHeaderTemplate');\n    }\n    else if (pageContext.isFooter) {\n        tooltip = formatMessage('chooseFooterTemplate');\n    }\n    else {\n        tooltip = formatMessage('chooseTemplate', {\n            type: pageContext.isDialog\n                ? formatMessage('dialog').toLocaleLowerCase()\n                : formatMessage('page').toLocaleLowerCase()\n        });\n    }\n    if (!show) {\n        return null;\n    }\n    return (jsx(\"div\", { className: 'd-flex w-100 flex-column justify-content-center align-items-center', css: getStyle(builderTheme) },\n        jsx(\"div\", { className: 'd-flex flex-column justify-content-center align-items-center' },\n            jsx(ThemedTooltip, { placement: 'bottom', title: tooltip },\n                jsx(\"div\", { className: 'action-item', ref: templateRef },\n                    jsx(Button, { icon: true, onClick: toggleTemplatePopper, css: buttonStyle, className: 'rounded-circle' },\n                        jsx(TemplateOutlined, { autoFlip: true, size: 'm', color: builderTheme.ref.palette.neutral[1100] })))),\n            jsx(\"div\", { className: 'action-separator mt-4' }),\n            jsx(\"h5\", { className: 'btn-text mt-2' }, formatMessage('dropWidgetToAdd'))),\n        showTemplatePopper && !pageContext.isDialog && (jsx(TemplateSelector, { templates: isHeader ? getHeaderTemplates() : (isFooter ? getFooterTemplates() : getFullScreenPageTemplates(false)), referenceElement: templateRef.current, onItemSelect: onPageTemplateSelected, onClose: closeTemplatePopover })),\n        showTemplatePopper && pageContext.isDialog && (jsx(TemplateSelector, { templates: getWindowTemplates(false), referenceElement: templateRef.current, onItemSelect: onPageTemplateSelected, onClose: closeTemplatePopover }))));\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/** @jsx jsx */\nimport { React, ReactRedux, lodash, classNames, jsx, css, polished, Immutable, getAppStore, appActions, ExtensionManager, extensionSpec, OneByOneAnimation, IntersectionContext, LayoutType } from 'jimu-core';\nimport { LayoutServiceProvider, getAppConfigAction } from 'jimu-for-builder';\nimport { styleUtils, Loading, LoadingType } from 'jimu-ui';\nimport { DEFAULT_FIX_LAYOUT_SETTING } from '../default-setting';\nimport { utils, PageContext, CLICK_TOLERANCE } from 'jimu-layouts/layout-runtime';\nimport FixedLayoutItem from './layout-item';\nimport { LIMITED_BOUNDARY_CLASS_NAME, isDragging } from '../../builder/interactive/drag-event-handler';\nimport { DropArea } from '../../builder/interactive/droparea-hook';\nimport { addItemToLayout } from '../../builder/common-layout-actions';\nimport { isDesignMode, isExpressMode } from '../../builder/menu/common-menu';\nimport { isResizing } from '../../builder/interactive/resize-event-handler';\nimport { sortLayoutItems } from './util';\nimport { generateResizingBBoxStyle, applySnapResult, flipBBox } from '../fixed-layout-util';\nimport { moveGuide, getBBoxUnits, drawPosition, getGridlinesOfLayout } from './move-guide';\nimport { ActionBlock } from './action-block';\nimport { CanvasPane } from '../../builder/interactive/canvas-pane';\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  top: 0;\r\n  right: 0;\r\n  background: transparent;\r\n`;\nconst guideOverlay = css `\r\n  ${dropareaStyle};\r\n  pointer-events: none;\r\n`;\nclass Layout extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.handleActivate = (e) => {\n            if (!isDesignMode() && !isExpressMode()) {\n                return;\n            }\n            if (Math.abs(e.screenX - this.mousedownX) > CLICK_TOLERANCE ||\n                Math.abs(e.screenY - this.mousedownY) > CLICK_TOLERANCE) {\n                e.stopPropagation();\n                return;\n            }\n            const { isInSection, isInWidget } = this.props;\n            if (!this.pageContext.viewOnly && !isInSection && !isInWidget && !isResizing() && !isDragging()) {\n                e.stopPropagation();\n                getAppStore().dispatch(appActions.selectionChanged(null));\n            }\n        };\n        this.handleMouseDown = (e) => {\n            this.mousedownX = e.screenX;\n            this.mousedownY = e.screenY;\n        };\n        this.updateDeviceRatio = () => {\n            this.canvasPane.setSize(this.ref.clientWidth, this.ref.clientHeight, window.devicePixelRatio);\n        };\n        this.handleResizeStart = (id) => {\n            const { layout } = this.props;\n            this.rndingLayoutId = id;\n            const draggingChild = this.ref.querySelector(`div.exb-rnd[data-layoutid=\"${layout.id}\"][data-layoutitemid=\"${id}\"]`);\n            this.domRect = this.ref.getBoundingClientRect();\n            this.bboxGridlines = getGridlinesOfLayout(this.props.layout, this.domRect.width, this.domRect.height, id);\n            const rect = draggingChild.getBoundingClientRect();\n            const units = this.getPositionUnit(id);\n            this.resizingRect = Object.assign({ units }, utils.relativeClientRect(rect, this.domRect));\n        };\n        // eslint-disable-next-line max-params\n        this.handleResizing = (id, dx, dy, dw, dh, shiftKey, speed) => {\n            this.canvasPane.clear();\n            if (speed > 500) {\n                this.setState({\n                    offsetX: dx,\n                    offsetY: dy,\n                    dw: dw,\n                    dh: dh\n                });\n                return;\n            }\n            const rndDelta = this.getResizingDelta(id, dx, dy, dw, dh, shiftKey);\n            this.setState({\n                offsetX: rndDelta.x,\n                offsetY: rndDelta.y,\n                dw: rndDelta.w,\n                dh: rndDelta.h\n            });\n        };\n        // eslint-disable-next-line max-params\n        this.handleResizeEnd = (id, dx, dy, dw, dh, shiftKey, layoutItem, itemSetting) => {\n            var _a, _b;\n            this.rndingLayoutId = null;\n            const { layout } = this.props;\n            const delta = this.getResizingDelta(id, dx, dy, dw, dh, shiftKey);\n            this.canvasPane.clear();\n            const newPos = generateResizingBBoxStyle(this.resizingRect, this.domRect, {\n                dx: delta.x,\n                dy: delta.y,\n                dw: delta.w,\n                dh: delta.h\n            });\n            const appConfigAction = getAppConfigAction();\n            const layoutInfo = { layoutId: layout.id, layoutItemId: id };\n            const { bbox, setting } = applySnapResult(Immutable(layoutItem.bbox), layoutItem.setting, this.domRect, newPos);\n            let newBBox = bbox;\n            if ((itemSetting === null || itemSetting === void 0 ? void 0 : itemSetting.hCenter) && ((_a = layoutItem.bbox) === null || _a === void 0 ? void 0 : _a.left) === '50%') {\n                newBBox = newBBox.set('left', '50%');\n            }\n            if ((itemSetting === null || itemSetting === void 0 ? void 0 : itemSetting.vCenter) && ((_b = layoutItem.bbox) === null || _b === void 0 ? void 0 : _b.top) === '50%') {\n                newBBox = newBBox.set('top', '50%');\n            }\n            appConfigAction\n                .editLayoutItemProperty(layoutInfo, 'bbox', this.flipLeftRight ? flipBBox(newBBox) : newBBox)\n                .editLayoutItemProperty(layoutInfo, 'setting', setting);\n            if (appConfigAction.appConfig.useAutoSortInFixedLayout) {\n                const sortedLayout = sortLayoutItems(appConfigAction.appConfig.layouts[layoutInfo.layoutId]);\n                appConfigAction.editLayoutProperty(layoutInfo.layoutId, 'order', sortedLayout.order);\n            }\n            appConfigAction.exec();\n            this.bboxGridlines = null;\n            this.setState({\n                offsetX: 0,\n                offsetY: 0,\n                dw: 0,\n                dh: 0\n            });\n        };\n        this.handleMoveItemByKey = (id, dx, dy) => {\n            var _a, _b, _c;\n            const { layout } = this.props;\n            let itemWidth;\n            let itemHeight;\n            let bbox = layout.content[id].bbox;\n            let setting = (_a = layout.content[id].setting) !== null && _a !== void 0 ? _a : Immutable({});\n            const isAlignCenter = ((_b = setting === null || setting === void 0 ? void 0 : setting.hCenter) !== null && _b !== void 0 ? _b : false) || ((_c = setting === null || setting === void 0 ? void 0 : setting.vCenter) !== null && _c !== void 0 ? _c : false);\n            if (isAlignCenter) {\n                const element = this.ref.querySelector(`div[data-layoutitemid=\"${id}\"]`);\n                itemWidth = element.clientWidth;\n                itemHeight = element.clientHeight;\n            }\n            if (dx !== 0) {\n                // modify left and right\n                if (utils.isPercentage(bbox.left)) {\n                    const pValue = parseFloat(bbox.left);\n                    if (setting === null || setting === void 0 ? void 0 : setting.hCenter) {\n                        bbox = bbox.set('left', `${(50 - (itemWidth * 100 / 2) / this.ref.clientWidth + dx * 0.1).toFixed(1)}%`);\n                    }\n                    else {\n                        bbox = bbox.set('left', `${(pValue + dx * 0.1).toFixed(1)}%`);\n                    }\n                }\n                else {\n                    const pValue = parseFloat(bbox.left);\n                    if (setting === null || setting === void 0 ? void 0 : setting.hCenter) {\n                        bbox = bbox.set('left', `${(this.ref.clientWidth - itemWidth) / 2 + dx}px`);\n                    }\n                    else {\n                        bbox = bbox.set('left', `${pValue + dx}px`);\n                    }\n                }\n                if (utils.isPercentage(bbox.right)) {\n                    const pValue = parseFloat(bbox.right);\n                    if (setting === null || setting === void 0 ? void 0 : setting.hCenter) {\n                        bbox = bbox.set('right', `${(50 + (itemWidth * 100 / 2) / this.ref.clientWidth - dx * 0.1).toFixed(1)}%`);\n                    }\n                    else {\n                        bbox = bbox.set('right', `${(pValue - dx * 0.1).toFixed(1)}%`);\n                    }\n                }\n                else {\n                    const pValue = parseFloat(bbox.right);\n                    if (setting === null || setting === void 0 ? void 0 : setting.hCenter) {\n                        bbox = bbox.set('right', `${(this.ref.clientWidth + itemWidth) / 2 - dx}px`);\n                    }\n                    else {\n                        bbox = bbox.set('right', `${pValue - dx}px`);\n                    }\n                }\n                if (setting === null || setting === void 0 ? void 0 : setting.hCenter) {\n                    setting = setting.set('hCenter', false);\n                }\n            }\n            if (dy !== 0) {\n                // modify top and bottom\n                if (utils.isPercentage(bbox.top)) {\n                    const pValue = parseFloat(bbox.top);\n                    if (setting === null || setting === void 0 ? void 0 : setting.vCenter) {\n                        bbox = bbox.set('top', `${(50 - (itemHeight * 100 / 2) / this.ref.clientHeight + dy * 0.1).toFixed(1)}%`);\n                    }\n                    else {\n                        bbox = bbox.set('top', `${(pValue + dy * 0.1).toFixed(1)}%`);\n                    }\n                }\n                else {\n                    const pValue = parseFloat(bbox.top);\n                    if (setting === null || setting === void 0 ? void 0 : setting.vCenter) {\n                        bbox = bbox.set('top', `${(this.ref.clientHeight - itemHeight) / 2 + dy}px`);\n                    }\n                    else {\n                        bbox = bbox.set('top', `${pValue + dy}px`);\n                    }\n                }\n                if (utils.isPercentage(bbox.bottom)) {\n                    const pValue = parseFloat(bbox.bottom);\n                    if (setting === null || setting === void 0 ? void 0 : setting.vCenter) {\n                        bbox = bbox.set('bottom', `${(50 + (itemHeight * 100 / 2) / this.ref.clientHeight - dy * 0.1).toFixed(1)}%`);\n                    }\n                    else {\n                        bbox = bbox.set('bottom', `${(pValue - dy * 0.1).toFixed(1)}%`);\n                    }\n                }\n                else {\n                    const pValue = parseFloat(bbox.bottom);\n                    if (setting === null || setting === void 0 ? void 0 : setting.hCenter) {\n                        bbox = bbox.set('bottom', `${(this.ref.clientHeight + itemHeight) / 2 - dy}px`);\n                    }\n                    else {\n                        bbox = bbox.set('bottom', `${pValue - dy}px`);\n                    }\n                }\n                if (setting === null || setting === void 0 ? void 0 : setting.vCenter) {\n                    setting = setting.set('vCenter', false);\n                }\n            }\n            const appConfigAction = getAppConfigAction();\n            if (isAlignCenter) {\n                appConfigAction.editLayoutItemProperty({\n                    layoutId: layout.id,\n                    layoutItemId: id\n                }, 'setting', setting);\n            }\n            appConfigAction.editLayoutItemProperty({\n                layoutId: layout.id,\n                layoutItemId: id\n            }, 'bbox', bbox);\n            if (appConfigAction.appConfig.useAutoSortInFixedLayout) {\n                const sortedLayout = sortLayoutItems(appConfigAction.appConfig.layouts[layout.id]);\n                appConfigAction.editLayoutProperty(layout.id, 'order', sortedLayout.order);\n            }\n            appConfigAction.exec();\n        };\n        // eslint-disable-next-line max-params\n        this.handleDragOver = (draggingItem, draggingElement, containerRect, itemRect, clientX, clientY, speed) => {\n            var _a, _b, _c;\n            this.canvasPane.clear();\n            if (!this.state.isDragover || speed > 500) {\n                return;\n            }\n            // const gridlines = this.calculateGridlines(draggingItem, itemRect)\n            let deltaX = 0;\n            let deltaY = 0;\n            let excludeItemId;\n            let layoutItem;\n            let units;\n            if (((_a = draggingItem.layoutInfo) === null || _a === void 0 ? void 0 : _a.layoutId) === this.props.layout.id) {\n                excludeItemId = draggingItem.layoutInfo.layoutItemId;\n                units = this.getPositionUnit(excludeItemId);\n                layoutItem = this.props.layout.content[excludeItemId];\n            }\n            else {\n                units = getBBoxUnits({}, this.flipLeftRight);\n            }\n            const hasRotation = draggingItem.rotation > 0 || draggingItem.rotation < 0;\n            const rndDelta = moveGuide(layoutItem, this.domRect, itemRect, this.bboxGridlines, {\n                delta: { x: 0, w: 0, y: 0, h: 0 },\n                shiftKey: false,\n                canvasPane: hasRotation ? null : this.canvasPane,\n                theme: hasRotation ? null : this.pageContext.builderTheme\n            });\n            // snap draggingElement\n            if (draggingElement != null && (rndDelta.x !== 0 || rndDelta.y !== 0)) {\n                const tx = (_b = parseFloat(draggingElement.getAttribute('data-translatex'))) !== null && _b !== void 0 ? _b : 0;\n                const ty = (_c = parseFloat(draggingElement.getAttribute('data-translatey'))) !== null && _c !== void 0 ? _c : 0;\n                draggingElement.style.transform = `translate(${tx + rndDelta.x}px, ${ty + rndDelta.y}px)`;\n            }\n            deltaX = rndDelta.x;\n            deltaY = rndDelta.y;\n            this.canvasPane.setColor(this.pageContext.builderTheme.sys.color.primary.main);\n            const rect = {\n                width: itemRect.width,\n                height: itemRect.height,\n                left: itemRect.left + deltaX,\n                top: itemRect.top + deltaY,\n                units\n            };\n            drawPosition(rect, this.domRect, this.canvasPane);\n            if (draggingItem.layoutInfo == null || draggingItem.isPending) {\n                this.canvasPane.setColor(polished.rgba(this.pageContext.builderTheme.sys.color.primary.light, 0.2));\n                const rect = {\n                    left: itemRect.left + deltaX,\n                    top: itemRect.top + deltaY,\n                    width: itemRect.width,\n                    height: itemRect.height\n                };\n                this.canvasPane.drawRect(rect);\n            }\n        };\n        this.handleToggleDragoverEffect = (value, draggingItem) => {\n            var _a;\n            this.canvasPane.clear();\n            if (value) {\n                this.domRect = this.ref.getBoundingClientRect();\n                let excludeId;\n                if (((_a = draggingItem.layoutInfo) === null || _a === void 0 ? void 0 : _a.layoutId) === this.props.layout.id) {\n                    excludeId = draggingItem.layoutInfo.layoutItemId;\n                }\n                this.bboxGridlines = getGridlinesOfLayout(this.props.layout, this.domRect.width, this.domRect.height, excludeId);\n            }\n            this.setState({\n                isDragover: value\n            });\n        };\n        this.handleDragEnter = (draggingItem) => null;\n        this.handleDragLeave = () => null;\n        this.handleDrop = (draggingItem, containerRect, itemRect) => {\n            let units;\n            if (draggingItem.layoutInfo == null ||\n                draggingItem.layoutInfo.layoutId !== this.props.layout.id) {\n                units = getBBoxUnits({}, this.flipLeftRight);\n            }\n            else {\n                units = this.getPositionUnit(draggingItem.layoutInfo.layoutItemId);\n            }\n            const { snappedRect, delta } = this.calSnappedRect(draggingItem, containerRect, Object.assign({ units }, itemRect), draggingItem.layoutInfo);\n            this.canvasPane.clear();\n            const rect = {\n                left: itemRect.left + delta.x,\n                top: itemRect.top + delta.y,\n                width: itemRect.width,\n                height: itemRect.height,\n                right: containerRect.width - (itemRect.left + delta.x + itemRect.width),\n                bottom: containerRect.height - (itemRect.top + delta.y + itemRect.height)\n            };\n            this.addWidgetToLayout(draggingItem, containerRect, rect, snappedRect).catch(err => { console.error(err); });\n            this.bboxGridlines = null;\n        };\n        this.toggleShowWidgetList = (e) => {\n            e.stopPropagation();\n            this.setState({ showWidgetList: !this.state.showWidgetList });\n        };\n        this.closeWidgetList = () => {\n            if (this.state.showWidgetList) {\n                this.setState({ showWidgetList: false });\n            }\n        };\n        this.handlePageTemplateSelected = (templatePageJson) => {\n            const appConfigAction = getAppConfigAction();\n            this.setState({ isLoadingTemplate: true });\n            if (this.pageContext.isHeader) {\n                appConfigAction.applyHeaderTemplate(templatePageJson).then(() => {\n                    appConfigAction.exec();\n                    lodash.defer(() => {\n                        this.setState({ isLoadingTemplate: false });\n                    });\n                }).catch(err => { console.error(err); });\n            }\n            else if (this.pageContext.isFooter) {\n                appConfigAction.applyFooterTemplate(templatePageJson).then(() => {\n                    appConfigAction.exec();\n                    lodash.defer(() => {\n                        this.setState({ isLoadingTemplate: false });\n                    });\n                }).catch(err => { console.error(err); });\n            }\n            else if (this.pageContext.isDialog) {\n                appConfigAction.applyDialogTemplate(this.pageContext.dialogId, templatePageJson).then(() => {\n                    appConfigAction.exec();\n                    lodash.defer(() => {\n                        this.setState({ isLoadingTemplate: false });\n                    });\n                }).catch(err => { console.error(err); });\n            }\n            else {\n                appConfigAction.applyPageBodyTemplate(this.pageContext.pageId, templatePageJson)\n                    .then(() => {\n                    appConfigAction.exec();\n                    lodash.defer(() => {\n                        this.setState({ isLoadingTemplate: false });\n                    });\n                }).catch(err => { console.error(err); });\n            }\n        };\n        if (this.props.layout == null) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-template-expression\n        const exts = ExtensionManager.getInstance().getExtensions(`${extensionSpec.ExtensionPoints.LayoutTransformer}`);\n        if ((exts === null || exts === void 0 ? void 0 : exts.length) > 0) {\n            const ext = exts.find(item => item.layoutType === this.props.layout.type);\n            this.layoutTransform = ext === null || ext === void 0 ? void 0 : ext.transformLayout;\n        }\n        this.flipLeftRight = utils.isRTL();\n        this.state = {\n            offsetX: 0,\n            offsetY: 0,\n            dw: 0,\n            dh: 0,\n            isDragover: false,\n            showWidgetList: false,\n            isLoadingTemplate: false\n        };\n    }\n    componentDidMount() {\n        var _a, _b, _c;\n        this.canvasPane = new CanvasPane(this.canvasRef, this.pageContext.builderTheme);\n        this.updateDeviceRatio();\n        // monitor devicePixelRatio change\n        const mqString = `(resolution: ${window.devicePixelRatio}dppx)`;\n        this.mediaQueryList = (_a = window.matchMedia) === null || _a === void 0 ? void 0 : _a.call(window, mqString);\n        const { name, version } = window.jimuUA.browser;\n        if (name.toLowerCase() === 'safari' && parseInt(version) < 14) {\n            (_b = this.mediaQueryList) === null || _b === void 0 ? void 0 : _b.addEventListener('change', this.updateDeviceRatio);\n        }\n        else {\n            (_c = this.mediaQueryList) === null || _c === void 0 ? void 0 : _c.addEventListener('change', this.updateDeviceRatio);\n        }\n    }\n    componentWillUnmount() {\n        var _a, _b;\n        const { name, version } = window.jimuUA.browser;\n        if (name.toLowerCase() === 'safari' && parseInt(version) < 14) {\n            (_a = this.mediaQueryList) === null || _a === void 0 ? void 0 : _a.removeEventListener('change', this.updateDeviceRatio);\n        }\n        else {\n            (_b = this.mediaQueryList) === null || _b === void 0 ? void 0 : _b.removeEventListener('change', this.updateDeviceRatio);\n        }\n    }\n    componentDidUpdate() {\n        this.updateDeviceRatio();\n    }\n    isResizingItem() {\n        return this.state.dh !== 0 || this.state.dw !== 0;\n    }\n    getResizingDelta(id, dx, dy, dw, dh, shiftKey) {\n        const layoutItem = this.props.layout.content[id];\n        const rndDelta = moveGuide(layoutItem, this.domRect, this.resizingRect, this.bboxGridlines, {\n            delta: { x: dx, w: dw, y: dy, h: dh },\n            shiftKey,\n            canvasPane: this.canvasPane,\n            theme: this.pageContext.builderTheme\n        });\n        return rndDelta;\n    }\n    calSnappedRect(draggingItem, containerRect, itemRect, layoutInfo) {\n        let layoutItem;\n        if ((layoutInfo === null || layoutInfo === void 0 ? void 0 : layoutInfo.layoutId) === this.props.layout.id) {\n            layoutItem = this.props.layout.content[layoutInfo.layoutItemId];\n        }\n        const delta = moveGuide(layoutItem, this.domRect, itemRect, this.bboxGridlines, {\n            delta: { x: 0, y: 0, w: 0, h: 0 },\n            shiftKey: false,\n        });\n        const snappedRect = {\n            left: itemRect.left + delta.x,\n            top: itemRect.top + delta.y,\n            width: itemRect.width,\n            height: itemRect.height\n        };\n        snappedRect.right = containerRect.width - ((+snappedRect.left) + (+snappedRect.width));\n        snappedRect.bottom = containerRect.height - ((+snappedRect.top) + (+snappedRect.height));\n        if (itemRect.width > containerRect.width) {\n            snappedRect.width = containerRect.width;\n            snappedRect.left = 0;\n        }\n        if (itemRect.height > containerRect.height) {\n            snappedRect.height = containerRect.height;\n            snappedRect.top = 0;\n        }\n        // Use percentage size by default\n        snappedRect.left = utils.toRatio(snappedRect.left, containerRect.width);\n        snappedRect.top = utils.toRatio(snappedRect.top, containerRect.height);\n        snappedRect.width = utils.toRatio(snappedRect.width, containerRect.width);\n        snappedRect.height = utils.toRatio(snappedRect.height, containerRect.height);\n        snappedRect.right = utils.toRatio(snappedRect.right, containerRect.width);\n        snappedRect.bottom = utils.toRatio(snappedRect.bottom, containerRect.height);\n        return { snappedRect, delta };\n    }\n    addWidgetToLayout(draggingItem, containerRect, itemRect, snapResult, appConfig) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { layout, browserSizeMode } = this.props;\n            const appConfigAction = getAppConfigAction(appConfig);\n            const result = yield addItemToLayout(appConfigAction.appConfig, draggingItem, layout.id);\n            const { layoutInfo, updatedAppConfig } = result;\n            const service = LayoutServiceProvider.getInstance().getServiceByType(LayoutType.FixedLayout);\n            const outAppConfig = service.processAfterItemAdded(updatedAppConfig, draggingItem, layoutInfo, {\n                currentSizeMode: browserSizeMode,\n                containerRect,\n                itemRect,\n                insertIndex: null,\n                others: { snapResult }\n            });\n            utils.changeLayout(outAppConfig, layoutInfo);\n        });\n    }\n    getPositionUnit(layoutItemId) {\n        const layoutItem = this.props.layout.content[layoutItemId];\n        const bbox = layoutItem.bbox;\n        return getBBoxUnits(bbox, this.flipLeftRight);\n    }\n    createItem(targetLayout, layoutItemId, key) {\n        const { itemResizable, itemDraggable, itemSelectable, showDefaultTools } = this.props;\n        const { offsetX, offsetY, dw, dh } = this.state;\n        const deltaX = layoutItemId === this.rndingLayoutId ? offsetX : 0;\n        const deltaY = layoutItemId === this.rndingLayoutId ? offsetY : 0;\n        const deltaW = layoutItemId === this.rndingLayoutId ? dw : 0;\n        const deltaH = layoutItemId === this.rndingLayoutId ? dh : 0;\n        const initRect = layoutItemId === this.rndingLayoutId ? this.resizingRect : undefined;\n        const containerRect = layoutItemId === this.rndingLayoutId ? this.domRect : undefined;\n        const layoutItem = targetLayout.content[layoutItemId];\n        return (jsx(FixedLayoutItem, { key: `${targetLayout.id}_${layoutItemId}`, index: key, layoutItem: layoutItem, offsetX: deltaX, offsetY: deltaY, dw: deltaW, dh: deltaH, initRect: initRect, containerRect: containerRect, layoutId: targetLayout.id, layoutItemId: layoutItemId, draggable: itemDraggable, resizable: itemResizable, selectable: itemSelectable, showDefaultTools: showDefaultTools, isLayoutLockChildren: this.layoutSetting.lockChildren, onResizeStart: this.handleResizeStart, onResizing: this.handleResizing, onResizeEnd: this.handleResizeEnd, onMoveByKey: this.handleMoveItemByKey, isInSection: this.props.isInSection }));\n    }\n    render() {\n        const { layout, className, style, layouts, isPageItem, mainSizeMode, browserSizeMode } = this.props;\n        if (layout == null) {\n            return null;\n        }\n        return (jsx(PageContext.Consumer, null, (props) => {\n            var _a, _b;\n            this.pageContext = props;\n            let targetLayout = layout;\n            const viewOnly = layouts[browserSizeMode] !== layout.id;\n            if (viewOnly && this.layoutTransform != null) {\n                targetLayout = this.layoutTransform(layout, mainSizeMode, browserSizeMode);\n            }\n            this.layoutSetting = lodash.assign({}, DEFAULT_FIX_LAYOUT_SETTING, viewOnly ? {} : layout.setting);\n            const content = (_a = targetLayout.order) !== null && _a !== void 0 ? _a : [];\n            const mergedClasses = classNames('layout fixed-layout', className, {\n                [LIMITED_BOUNDARY_CLASS_NAME]: (_b = layout.setting) === null || _b === void 0 ? void 0 : _b.lockDescendants\n            });\n            const isResizing = this.state.dh !== 0 || this.state.dw !== 0;\n            const mergedStyle = Object.assign(Object.assign(Object.assign({ height: 'auto', position: 'relative' }, style), styleUtils.toCSSStyle(this.layoutSetting.style)), { width: '100%', overflow: 'hidden' });\n            const guideVisibleStyle = {\n                display: this.state.isDragover || isResizing ? 'block' : 'none',\n                zIndex: content.length + 1\n            };\n            const showActionBlock = !this.state.isLoadingTemplate &&\n                utils.isEmptyLayout(targetLayout) &&\n                !props.viewOnly &&\n                layout.id === props.rootLayoutId;\n            return (jsx(\"div\", { className: mergedClasses, ref: el => { this.ref = el; }, onClick: this.handleActivate, onMouseDown: this.handleMouseDown, style: mergedStyle, \"data-layoutid\": targetLayout.id },\n                jsx(IntersectionContext.Provider, { value: { monitor: false } },\n                    jsx(OneByOneAnimation, { oid: targetLayout.id, \"data-layoutid\": targetLayout.id, className: 'trail-container', css: css `\r\n                    position: absolute;\r\n                    left: 0;\r\n                    right: 0;\r\n                    top: 0;\r\n                    bottom: 0;\r\n                  ` },\n                        jsx(DropArea, { css: dropareaStyle, layouts: this.props.layouts, highlightDragover: !isPageItem, onDragEnter: this.handleDragEnter, onDragLeave: this.handleDragLeave, onDragOver: this.handleDragOver, onDrop: this.handleDrop, onToggleDragoverEffect: this.handleToggleDragoverEffect, isRepeat: this.props.isRepeat }),\n                        content.map((layoutItemId, index) => this.createItem(targetLayout, layoutItemId, index)))),\n                showActionBlock && (jsx(ActionBlock, { pageContext: this.pageContext, onPageTemplateSelected: this.handlePageTemplateSelected })),\n                this.state.isLoadingTemplate && (jsx(Loading, { type: LoadingType.Primary })),\n                jsx(\"canvas\", { css: guideOverlay, style: guideVisibleStyle, ref: el => { this.canvasRef = el; } })));\n        }));\n    }\n}\nLayout.displayName = 'FixedLayout';\n// const DroppableLayout = withDrop()(Layout);\nexport default ReactRedux.connect(utils.mapStateToLayoutProps)(Layout);\n","/** @jsx jsx */\nimport { React, ReactRedux, classNames, jsx, css, OneByOneAnimation, IntersectionContext, LayoutType, polished } from 'jimu-core';\nimport { LayoutServiceProvider, getAppConfigAction } from 'jimu-for-builder';\nimport { styleUtils } from 'jimu-ui';\nimport { utils, PageContext } from 'jimu-layouts/layout-runtime';\nimport { DropArea } from '../../builder/interactive/droparea-hook';\nimport { addItemToLayout } from '../../builder/common-layout-actions';\nimport { calInsertPositionForColumn } from './dnd-helper';\nimport { DEFAULT_COLUMN_LAYOUT_SETTING } from '../default-setting';\nimport { ColumnItem } from './layout-item';\nimport { CanvasPane } from '../../builder/interactive/canvas-pane';\nimport { getLayoutStyle } from '../common/style';\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  top: 0;\r\n  right: 0;\r\n  background: transparent;\r\n`;\nconst guideOverlay = css `\r\n  ${dropareaStyle};\r\n  z-index: 20;\r\n  pointer-events: none;\r\n`;\nconst dropIndicatorSize = 10;\nclass Layout extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            isDragover: false\n        };\n        this.handleItemResizeStart = (id) => {\n            const { layout } = this.props;\n            this.domRect = this.ref.getBoundingClientRect();\n            const draggingChild = this.ref.querySelector(`div.exb-rnd[data-layoutid=\"${layout.id}\"][data-layoutitemid=\"${id}\"]`);\n            const rect = draggingChild.getBoundingClientRect();\n            this.resizingRect = utils.relativeClientRect(rect, this.domRect);\n        };\n        this.handleItemResizing = () => null;\n        this.handleItemResizeEnd = (id, x, y, dw, dh, layoutItem) => {\n            const { layout } = this.props;\n            const bbox = layout.content[id].bbox;\n            let width;\n            if (utils.isPercentage(bbox.width)) {\n                width = `${((this.resizingRect.width + dw) * 100 / this.domRect.width).toFixed(4)}%`;\n            }\n            else {\n                width = `${Math.round(this.resizingRect.width + dw)}px`;\n            }\n            const newPos = {\n                width,\n                height: Math.round(this.resizingRect.height + dh)\n            };\n            this.childRects = [];\n            this.domRect = null;\n            const appConfigAction = getAppConfigAction();\n            appConfigAction\n                .editLayoutItemProperty({\n                layoutId: this.props.layout.id,\n                layoutItemId: id\n            }, 'bbox', newPos)\n                .exec();\n        };\n        this.handleDragOver = (draggingItem, draggingElement, containerRect, itemRect) => {\n            var _a;\n            let rect = itemRect;\n            this.canvasPane.clear();\n            if (((_a = this.childRects) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n                const { insertY, refId } = calInsertPositionForColumn(containerRect, rect, this.childRects);\n                this.referenceId = refId;\n                rect = {\n                    top: insertY - dropIndicatorSize / 2 + this.ref.scrollTop,\n                    width: containerRect.width - dropIndicatorSize,\n                    left: dropIndicatorSize / 2,\n                    height: dropIndicatorSize\n                };\n            }\n            else {\n                rect = {\n                    top: containerRect.height / 2 - dropIndicatorSize / 2,\n                    width: containerRect.width - dropIndicatorSize,\n                    left: dropIndicatorSize / 2,\n                    height: dropIndicatorSize\n                };\n            }\n            this.canvasPane.setColor(polished.rgba(this.builderTheme.sys.color.primary.light, 0.5));\n            this.canvasPane.drawRect(rect);\n        };\n        this.handleToggleDragoverEffect = (value) => {\n            if (value) {\n                this.referenceId = null;\n                this.collectBounds(null);\n            }\n            this.setState({\n                isDragover: value\n            });\n        };\n        this.handleDrop = (draggingItem, containerRect, itemRect) => {\n            this.canvasPane.clear();\n            const { layout } = this.props;\n            let insertIndex = 0;\n            if (this.referenceId != null) {\n                insertIndex = layout.order.indexOf(this.referenceId);\n            }\n            else if (layout.order != null) {\n                insertIndex = layout.order.length;\n            }\n            const appConfigAction = getAppConfigAction();\n            addItemToLayout(appConfigAction.appConfig, draggingItem, layout.id).then((result) => {\n                const { layoutInfo, updatedAppConfig } = result;\n                const service = LayoutServiceProvider.getInstance().getServiceByType(LayoutType.ColumnLayout);\n                const outAppConfig = service.processAfterItemAdded(updatedAppConfig, draggingItem, layoutInfo, {\n                    currentSizeMode: null,\n                    containerRect,\n                    itemRect,\n                    insertIndex\n                });\n                utils.changeLayout(outAppConfig, layoutInfo);\n            }).finally(null);\n            this.referenceId = null;\n            this.childRects = [];\n        };\n    }\n    componentDidMount() {\n        this.canvasPane = new CanvasPane(this.canvasRef);\n        this.canvasPane.setSize(this.ref.clientWidth, this.ref.clientHeight);\n    }\n    componentDidUpdate() {\n        this.canvasPane.setSize(this.ref.clientWidth, this.ref.clientHeight);\n    }\n    collectBounds(id) {\n        const { layout } = this.props;\n        this.childRects = [];\n        this.domRect = this.ref.getBoundingClientRect();\n        const draggableChildren = this.ref.parentNode.querySelectorAll(`div[data-layoutid=\"${layout.id}\"] > .trail-container > div.exb-rnd`);\n        if ((draggableChildren === null || draggableChildren === void 0 ? void 0 : draggableChildren.length) > 0) {\n            draggableChildren.forEach((node) => {\n                const itemId = node.getAttribute('data-layoutitemid');\n                if (id !== itemId && layout.order.includes(itemId)) {\n                    const rect = utils.relativeClientRect(node.getBoundingClientRect(), this.domRect);\n                    rect.id = itemId;\n                    this.childRects.push(rect);\n                }\n            });\n        }\n        return this.childRects.sort((a, b) => a.top - b.top);\n    }\n    createItem(itemId, index, layoutSetting) {\n        const { layout, itemDraggable, itemResizable, itemSelectable, showDefaultTools } = this.props;\n        return (jsx(ColumnItem, { key: itemId, index: index, space: layoutSetting.space, layoutId: layout.id, layoutItemId: itemId, layoutItem: layout.content[itemId], draggable: itemDraggable, resizable: itemResizable, selectable: itemSelectable, showDefaultTools: showDefaultTools, onResizeStart: this.handleItemResizeStart, onResizing: this.handleItemResizing, onResizeEnd: this.handleItemResizeEnd }));\n    }\n    isEmpty() {\n        var _a;\n        const { layout } = this.props;\n        const content = (_a = layout.order) !== null && _a !== void 0 ? _a : [];\n        const hasSomethingToRender = content.length > 0 && content.some(id => {\n            const layoutItem = layout.content[id];\n            return !layoutItem.isPending;\n        });\n        return !hasSomethingToRender;\n    }\n    render() {\n        var _a;\n        const { layout, className } = this.props;\n        const content = (_a = layout.order) !== null && _a !== void 0 ? _a : [];\n        const layoutSetting = Object.assign({}, DEFAULT_COLUMN_LAYOUT_SETTING, layout.setting);\n        const isEmpty = this.isEmpty();\n        return (jsx(PageContext.Consumer, null, (pageContext) => {\n            this.builderTheme = pageContext.builderTheme;\n            this.theme = pageContext.theme;\n            const mergedStyle = {\n                position: 'relative',\n                minWidth: layoutSetting.min\n            };\n            const outClass = classNames('layout column-layout', className);\n            const guideVisibleStyle = {\n                display: this.state.isDragover ? 'block' : 'none'\n            };\n            return (jsx(\"div\", { className: outClass, ref: (el) => { this.ref = el; }, style: mergedStyle, \"data-layoutid\": layout.id },\n                jsx(IntersectionContext.Provider, { value: { monitor: true, layoutId: layout.id } },\n                    jsx(OneByOneAnimation, { oid: layout.id, className: 'trail-container d-flex flex-column w-100', css: css `\r\n                    position: ${isEmpty ? 'absolute' : null};\r\n                    padding: ${styleUtils.toCSSPadding(layoutSetting.padding)};\r\n                    ${getLayoutStyle(layoutSetting)};\r\n                  ` },\n                        jsx(DropArea, { css: dropareaStyle, layouts: this.props.layouts, highlightDragover: true, onDragOver: this.handleDragOver, onDrop: this.handleDrop, onToggleDragoverEffect: this.handleToggleDragoverEffect }),\n                        content.map((layoutItem, index) => this.createItem(layoutItem, index, layoutSetting)))),\n                isEmpty && this.props.children,\n                jsx(\"canvas\", { css: guideOverlay, style: guideVisibleStyle, ref: (el) => { this.canvasRef = el; } })));\n        }));\n    }\n}\nexport default ReactRedux.connect(utils.mapStateToLayoutProps)(Layout);\n","/** @jsx jsx */\nimport { React, jsx, css, classNames, LayoutItemType, lodash, getAppStore, WidgetType, BrowserSizeMode, Immutable, polished } from 'jimu-core';\nimport { LayoutZIndex, utils, LayoutItemSizeModes } from 'jimu-layouts/layout-runtime';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { calItemHeight } from '../utils';\nimport { mergeWidgetsIntoColumn } from '../../builder/common-layout-actions';\nimport { DropArea } from '../../builder/interactive/droparea-hook';\nimport LayoutItemInBuilder from '../../builder/layout-item';\nimport { DEFAULT_ROW_ITEM_SETTING } from '../default-setting';\nimport * as commonUtils from '../common/util';\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  max-height: 40px;\r\n  height: 20%;\r\n  right: 0;\r\n  z-index: ${LayoutZIndex.BoundaryDropArea};\r\n  display: flex;\r\n  pointer-events: all;\r\n  display: flex;\r\n\r\n  &.drop-active {\r\n    background: transparent !important;\r\n  }\r\n\r\n  body:not(.design-mode) & {\r\n    display: none !important;\r\n  }\r\n`;\nconst topDropareaStyle = css `\r\n  ${dropareaStyle};\r\n  top: 0;\r\n`;\nconst bottomDropareaStyle = css `\r\n  ${dropareaStyle};\r\n  bottom: 0;\r\n`;\nexport default class RowItem extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.state = {\n            isResizing: false,\n            dh: 0\n        };\n        this.handleResizeStart = (id, initW, initH) => {\n            this.initWidth = initW;\n            this.initHeight = initH;\n            this.props.onResizeStart(id);\n            this.setState({\n                isResizing: true\n            });\n        };\n        this.handleResizing = (id, x, y, dw, dh) => {\n            this.props.onResizing(id, x, y, dw, dh);\n            this.setState({\n                dh,\n                isResizing: true\n            });\n        };\n        this.handleResizeEnd = (id, x, y, dw, dh, shiftKey) => {\n            const { layoutItem } = this.props;\n            this.props.onResizeEnd(id, x, y, dw, dh, layoutItem);\n            this.setState({\n                isResizing: false,\n                dh: 0\n            });\n        };\n        this.handleDropAtTop = (draggingItem, containerRect, itemRect) => {\n            this.dropAtBoundary(draggingItem, containerRect, itemRect, 'top');\n        };\n        this.handleDropAtBottom = (draggingItem, containerRect, itemRect) => {\n            this.dropAtBoundary(draggingItem, containerRect, itemRect, 'bottom');\n        };\n        this.dropAtBoundary = (draggingItem, containerRect, itemRect, side) => {\n            let appConfigAction = getAppConfigAction();\n            mergeWidgetsIntoColumn(appConfigAction.appConfig, draggingItem, containerRect, itemRect, {\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItemId\n            }, side).then(({ updatedAppConfig }) => {\n                appConfigAction = getAppConfigAction(updatedAppConfig);\n                appConfigAction.exec();\n            }).finally(null);\n        };\n        this.fakeTopLayouts = Immutable({\n            [BrowserSizeMode.Large]: `${this.props.layoutId}_${this.props.layoutItemId}_tlarge`,\n            [BrowserSizeMode.Medium]: `${this.props.layoutId}_${this.props.layoutItemId}_tmedium`,\n            [BrowserSizeMode.Small]: `${this.props.layoutId}_${this.props.layoutItemId}_tsmall`\n        });\n        this.fakeBottomLayouts = Immutable({\n            [BrowserSizeMode.Large]: `${this.props.layoutId}_${this.props.layoutItemId}_blarge`,\n            [BrowserSizeMode.Medium]: `${this.props.layoutId}_${this.props.layoutItemId}_bmedium`,\n            [BrowserSizeMode.Small]: `${this.props.layoutId}_${this.props.layoutItemId}_bsmall`\n        });\n    }\n    isFunctionalWidget() {\n        var _a, _b, _c;\n        const { layoutItem } = this.props;\n        if (layoutItem.type === LayoutItemType.Widget) {\n            let isLayoutWidget = false;\n            const widget = (_b = (_a = getAppStore().getState().appConfig) === null || _a === void 0 ? void 0 : _a.widgets) === null || _b === void 0 ? void 0 : _b[layoutItem.widgetId];\n            if (((_c = widget === null || widget === void 0 ? void 0 : widget.manifest) === null || _c === void 0 ? void 0 : _c.properties) != null) {\n                isLayoutWidget =\n                    widget.manifest.widgetType === WidgetType.Layout ||\n                        widget.manifest.properties.hasEmbeddedLayout;\n            }\n            return !isLayoutWidget;\n        }\n        return false; // layoutItem.type is LayoutItemType.Section\n    }\n    getStyle(itemSetting) {\n        const { gutter, layoutItem, isMultiRow } = this.props;\n        const { dh, isResizing } = this.state;\n        const bbox = layoutItem.bbox;\n        const sign = utils.isRTL() ? -1 : 1;\n        const mergedStyle = calItemHeight(itemSetting, bbox, isMultiRow);\n        if (isResizing && dh !== 0) {\n            mergedStyle.height = this.initHeight + dh;\n        }\n        return commonUtils.getItemStyle(isMultiRow, sign, gutter, mergedStyle, itemSetting);\n    }\n    render() {\n        var _a;\n        const { order, span, offset, layoutId, layoutItem, draggable, resizable, selectable } = this.props;\n        if (layoutItem == null || layoutItem.isPending) {\n            return null;\n        }\n        const itemSetting = lodash.assign({}, DEFAULT_ROW_ITEM_SETTING, layoutItem.setting);\n        const isRatio = utils.shouldUseAspectRatio(itemSetting);\n        const heightMode = (_a = itemSetting.autoProps) === null || _a === void 0 ? void 0 : _a.height;\n        const mergedClass = classNames('row-layout-item d-flex', `col-${span}`, `offset-${offset}`, `order-${order}`, {\n            'fix-height': heightMode === LayoutItemSizeModes.Custom\n        });\n        const canDropAtBoundary = this.isFunctionalWidget();\n        const highlightStyle = css `\r\n      width: 100%;\r\n      height: 10px;\r\n      background: ${polished.rgba(this.props.builderTheme.sys.color.primary.light, 0.5)};\r\n    `;\n        const ratio = utils.parseAspectRatio(itemSetting.aspectRatio);\n        const oneByOneAnimationProps = utils.handleOnebyOneAnimation(this.props);\n        const [cssStyle, transform] = this.getStyle(itemSetting);\n        return (jsx(LayoutItemInBuilder, Object.assign({ css: cssStyle, style: { transform }, layoutId: layoutId, layoutItemId: layoutItem.id, onResizeStart: this.handleResizeStart, onResizing: this.handleResizing, onResizeEnd: this.handleResizeEnd, left: true, right: true, top: false, bottom: heightMode === LayoutItemSizeModes.Custom && !isRatio, draggable: draggable, resizable: resizable, selectable: selectable, onClick: this.props.onClick, className: mergedClass, forceAspectRatio: isRatio, aspectRatio: ratio, autoHeight: heightMode === LayoutItemSizeModes.Auto }, oneByOneAnimationProps),\n            jsx(React.Fragment, null,\n                canDropAtBoundary &&\n                    jsx(DropArea, { css: css `\r\n                ${topDropareaStyle};\r\n              `, layouts: this.fakeTopLayouts, highlightDragover: true, onDrop: this.handleDropAtTop },\n                        jsx(\"div\", { css: highlightStyle })),\n                canDropAtBoundary &&\n                    jsx(DropArea, { css: css `\r\n                ${bottomDropareaStyle};\r\n              `, layouts: this.fakeBottomLayouts, highlightDragover: true, onDrop: this.handleDropAtBottom },\n                        jsx(\"div\", { css: css `${highlightStyle};position: absolute; bottom:0;` })))));\n    }\n}\n","/** @jsx jsx */\nimport { jsx, css, polished } from 'jimu-core';\nexport function ColumnHint(props) {\n    const { builderTheme, visible, gutter = 0 } = props;\n    return (jsx(\"div\", { css: css `\r\n        pointer-events: none;\r\n        top: 0;\r\n        right: 0;\r\n        bottom: 0;\r\n        left: 0px;\r\n        position: absolute;\r\n        z-index: 1;\r\n        display: ${visible ? 'flex' : 'none'};\r\n      ` }, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(key => {\n        return (jsx(\"div\", { key: key, css: css `\r\n              width: 8.333333%;\r\n            ` },\n            jsx(\"div\", { css: css `\r\n                padding-left: ${gutter / 2}px;\r\n                padding-right: ${gutter / 2}px;\r\n                height: 100%;\r\n                width: 100%;\r\n                overflow: hidden;\r\n              ` },\n                jsx(\"div\", { css: css `\r\n                  transform: translateY(-5%);\r\n                  border: 1px dashed ${polished.rgba(builderTheme.ref.palette.neutral[900], 0.6)};\r\n                  height: 110%;\r\n                  width: 100%;\r\n                ` }))));\n    })));\n}\n","/** @jsx jsx */\nimport { React, classNames, polished, jsx, css, OneByOneAnimation, IntersectionContext, LayoutType } from 'jimu-core';\nimport { LayoutServiceProvider, getAppConfigAction } from 'jimu-for-builder';\nimport RowItemForBuilder from './layout-item';\nimport { PageContext, utils, LayoutZIndex } from 'jimu-layouts/layout-runtime';\nimport { DEFAULT_ROW_LAYOUT_SETTING } from '../default-setting';\nimport { DropArea } from '../../builder/interactive/droparea-hook';\nimport { addItemToLayout } from '../../builder/common-layout-actions';\nimport { CanvasPane } from '../../builder/interactive/canvas-pane';\nimport { snapLeft, resizeItem, moveItem, insertItem } from './utils';\nimport { TOTAL_COLS } from '../types';\nimport { flipRowItemPos, ROW_STYLE } from '../utils';\nimport { ColumnHint } from './column-hint';\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  right: 0;\r\n  top: 0;\r\n  bottom: 0;\r\n`;\nconst guideOverlay = css `\r\n  ${dropareaStyle};\r\n  bottom: 0;\r\n  top: 0;\r\n  z-index: ${LayoutZIndex.DragMoveTip};\r\n  pointer-events: none;\r\n`;\nexport class Row extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.state = {\n            // dragEnterred: false,\n            isResizing: false,\n            updatingRects: null,\n            isDragoverCenter: false\n        };\n        this.handleItemResizeStart = (id) => {\n            this.domRect = this.ref.getBoundingClientRect();\n            this.setState({\n                isResizing: true\n            });\n        };\n        this.handleItemResizing = (id, x, y, dw, dh) => {\n            const colWidth = this.domRect.width / TOTAL_COLS;\n            const deltaX = Math.round(x / colWidth);\n            const deltaW = Math.round(dw / colWidth);\n            const resizingRects = resizeItem(id, deltaX, deltaW, this.childRects);\n            this.setState({\n                updatingRects: resizingRects\n            });\n        };\n        this.handleItemResizeEnd = (id, x, y, dw, dh, layoutItem) => {\n            const { layout } = this.props;\n            const colWidth = this.domRect.width / TOTAL_COLS;\n            const deltaX = Math.round(x / colWidth);\n            const deltaW = Math.round(dw / colWidth);\n            const appConfigAction = getAppConfigAction();\n            const resizingRects = resizeItem(id, deltaX, deltaW, this.childRects);\n            resizingRects.forEach((rectItem) => {\n                const bbox = layout.content[rectItem.id].bbox;\n                let updatedHeight = bbox.height;\n                if (rectItem.id === id) {\n                    if (utils.isPercentage(bbox.height)) {\n                        updatedHeight = `${(parseFloat(rectItem.height) + (dh * 100 / this.domRect.height)).toFixed(4)}%`;\n                    }\n                    else {\n                        updatedHeight = `${Math.round(parseFloat(rectItem.height) + dh)}px`;\n                    }\n                }\n                const rect = {\n                    left: rectItem.left,\n                    width: rectItem.width,\n                    height: updatedHeight\n                };\n                appConfigAction.editLayoutItemProperty({\n                    layoutId: layout.id,\n                    layoutItemId: rectItem.id\n                }, 'bbox', rect);\n            });\n            appConfigAction.exec();\n            this.setState({\n                isResizing: false,\n                updatingRects: null\n            });\n        };\n        this.handleToggleDragoverCenterEffect = (value) => {\n            this.referenceId = null;\n            if (value) {\n                this.collectBounds();\n            }\n            this.setState({\n                isDragoverCenter: value\n            });\n        };\n        this.handleDragOver = (draggingItem, draggingElement, containerRect, itemRect, clientX, clientY) => {\n            var _a;\n            // const { layout } = this.props;\n            const layoutInfo = (_a = draggingItem.layoutInfo) !== null && _a !== void 0 ? _a : { layoutId: null };\n            const updatedRects = this.reCalculateRects(draggingItem, containerRect, itemRect, clientX);\n            let targetRect;\n            updatedRects.some((childRect) => {\n                if (childRect.id == null || (childRect.layoutId === layoutInfo.layoutId && childRect.id === layoutInfo.layoutItemId)) {\n                    targetRect = childRect;\n                    return true;\n                }\n                return false;\n            });\n            let available = true;\n            let insertPos = targetRect.left;\n            this.flippedChildRects.some((childRect) => {\n                if (childRect.layoutId === targetRect.layoutId && childRect.id === targetRect.id) {\n                    return false;\n                }\n                if (childRect.left <= targetRect.left && (childRect.left + childRect.width) > targetRect.left) {\n                    available = false;\n                }\n                if (!available) {\n                    const updatedChildRect = updatedRects.find(item => item.layoutId === childRect.layoutId && item.id === childRect.id);\n                    if (updatedChildRect.left + updatedChildRect.width <= targetRect.left) {\n                        insertPos = childRect.left + childRect.width;\n                    }\n                    else {\n                        insertPos = childRect.left;\n                    }\n                    return true;\n                }\n                return false;\n            });\n            this.dragInsertPos = insertPos;\n            this.canvasPane.clear();\n            if (available) {\n                this.canvasPane.drawRect({\n                    left: insertPos * this.colWidth + this.space / 2,\n                    top: 0,\n                    width: targetRect.width * this.colWidth - this.space,\n                    height: itemRect.height // use the real height of dragging item\n                });\n            }\n            else {\n                const restrainedInsertPos = Math.min(containerRect.width - this.space / 2, Math.max(0, insertPos * this.colWidth - this.space / 2));\n                this.canvasPane.drawRect({\n                    left: restrainedInsertPos,\n                    top: 0,\n                    width: 10,\n                    height: containerRect.height\n                });\n            }\n        };\n        this.handleDragEnter = () => {\n            this.canvasPane.setSize(this.ref.clientWidth, this.ref.clientHeight);\n            this.canvasPane.setColor(polished.rgba(this.builderTheme.sys.color.primary.light, 0.5));\n        };\n        this.handleDragLeave = () => {\n            this.canvasPane.clear();\n        };\n        this.handleDrop = (draggingItem, containerRect, itemRect\n        // clientX: number,\n        // clientY: number,\n        ) => {\n            const { layout } = this.props;\n            const appConfigAction = getAppConfigAction();\n            const { addedItemRect, insertIndex, appConfig } = this.calDropPosition(appConfigAction.appConfig, draggingItem, containerRect, itemRect, false);\n            if (addedItemRect != null) {\n                addItemToLayout(appConfig, draggingItem, layout.id).then((result) => {\n                    const { layoutInfo, updatedAppConfig } = result;\n                    const service = LayoutServiceProvider.getInstance().getServiceByType(LayoutType.RowLayout);\n                    const outAppConfig = service.processAfterItemAdded(updatedAppConfig, draggingItem, layoutInfo, {\n                        currentSizeMode: null,\n                        containerRect,\n                        itemRect: addedItemRect,\n                        insertIndex\n                    });\n                    utils.changeLayout(outAppConfig, layoutInfo);\n                }).finally(null);\n            }\n            else {\n                utils.changeLayout(appConfig, draggingItem.layoutInfo);\n            }\n            this.canvasPane.clear();\n            // this.hideColGuide();\n        };\n        // this.childrenRef = {};\n        this.flipLeftRight = utils.isRTL();\n    }\n    componentDidMount() {\n        this.canvasPane = new CanvasPane(this.guideDragOverRef);\n    }\n    getConfig() {\n        var _a;\n        const { layout } = this.props;\n        return (_a = layout.setting) !== null && _a !== void 0 ? _a : DEFAULT_ROW_LAYOUT_SETTING;\n    }\n    reCalculateRects(draggingItem, containerRect, itemRect, clientX) {\n        var _a, _b;\n        const layoutInfo = (_a = draggingItem.layoutInfo) !== null && _a !== void 0 ? _a : { layoutId: null };\n        const { layout } = this.props;\n        const config = this.getConfig();\n        this.space = (_b = config.space) !== null && _b !== void 0 ? _b : 0;\n        // this.paddings = styleUtils.expandStyleArray(lodash.getValue(config, 'style.padding.number', [0]));\n        // width should add the marginLeft and marginRight, which equals to this.space\n        const rowWidth = this.maxPageWidth > 0 ? Math.min(this.maxPageWidth, containerRect.width) : containerRect.width;\n        const cursorLeft = clientX - (containerRect.width - rowWidth) / 2;\n        const itemLeft = itemRect.left - (containerRect.width - rowWidth) / 2;\n        this.colWidth = rowWidth / TOTAL_COLS;\n        const cursorLeftInRow1 = Math.round(cursorLeft / this.colWidth);\n        const itemLeftInRow = Math.round(itemLeft / this.colWidth);\n        const span = Math.max(1, Math.ceil(itemRect.width / this.colWidth)); // at least 1\n        const cursorLeftInRow = snapLeft(layout.id, draggingItem, itemLeftInRow, span, cursorLeftInRow1, this.flippedChildRects);\n        if (draggingItem.id == null && this.isInRow(layoutInfo)) { // move in the same layout, exclude the pending item\n            return moveItem(layoutInfo.layoutItemId, cursorLeftInRow, this.flippedChildRects);\n        }\n        // drag from different layout or from widget list\n        return insertItem({\n            width: span,\n            height: itemRect.height,\n            layoutId: layoutInfo.layoutId,\n            id: layoutInfo.layoutItemId\n        }, cursorLeftInRow, this.flippedChildRects);\n    }\n    calDropPosition(appConfig, draggingItem, containerRect, itemRect, isPaste) {\n        var _a;\n        // const clientX = itemRect.left;\n        const rowWidth = this.maxPageWidth > 0 ? Math.min(this.maxPageWidth, containerRect.width) : containerRect.width;\n        // const cursorLeft = clientX - (containerRect.width - rowWidth) / 2;\n        // const itemLeft = itemRect.left - (containerRect.width - rowWidth) / 2;\n        const layoutInfo = (_a = draggingItem.layoutInfo) !== null && _a !== void 0 ? _a : { layoutId: null };\n        const { layout } = this.props;\n        const colWidth = rowWidth / TOTAL_COLS;\n        // let cursorLeftInRow = Math.round(cursorLeft / colWidth);\n        const cursorLeftInRow = this.dragInsertPos;\n        // const itemLeftInRow = Math.round(itemLeft / this.colWidth);\n        const span = Math.max(1, Math.ceil(itemRect.width / colWidth)); // at least 1\n        // cursorLeftInRow = snapLeft(layout.id, draggingItem, itemLeftInRow, span, cursorLeftInRow, this.flippedChildRects);\n        const appConfigAction = getAppConfigAction(appConfig);\n        let updatedRects;\n        if (!isPaste && draggingItem.id == null && this.isInRow(layoutInfo)) { // move in the same row\n            updatedRects = moveItem(layoutInfo.layoutItemId, cursorLeftInRow, this.flippedChildRects);\n        }\n        else { // drag from different layout or from widget list\n            updatedRects = insertItem({\n                width: span,\n                height: itemRect.height,\n                layoutId: layoutInfo.layoutId,\n                id: layoutInfo.layoutItemId\n            }, cursorLeftInRow, this.flippedChildRects);\n        }\n        let addedItemRect;\n        let insertIndex;\n        updatedRects.forEach((rectItem, index) => {\n            var _a;\n            let rect = {\n                left: rectItem.left,\n                width: rectItem.width,\n                height: rectItem.height\n            };\n            if (this.flipLeftRight) {\n                rect = flipRowItemPos(rect);\n            }\n            if (rectItem.layoutId === layout.id) { // item that is in the same layout\n                appConfigAction.editLayoutItemProperty({\n                    layoutId: rectItem.layoutId,\n                    layoutItemId: rectItem.id\n                }, 'bbox', rect);\n                if (rectItem.id === ((_a = draggingItem.layoutInfo) === null || _a === void 0 ? void 0 : _a.layoutItemId) && draggingItem.id != null) {\n                    // set pending to false\n                    appConfigAction.setLayoutItemToPending({\n                        layoutId: rectItem.layoutId,\n                        layoutItemId: rectItem.id\n                    }, false);\n                }\n            }\n            else {\n                const firstIndexInRow = 0;\n                addedItemRect = rect;\n                insertIndex = firstIndexInRow + index;\n            }\n        });\n        return { addedItemRect, insertIndex, appConfig: appConfigAction.appConfig };\n    }\n    isInRow(layoutInfo) {\n        const { layout } = this.props;\n        return (layoutInfo === null || layoutInfo === void 0 ? void 0 : layoutInfo.layoutId) === layout.id;\n    }\n    collectBounds() {\n        var _a;\n        const { transformedLayout } = this.props;\n        const content = (_a = transformedLayout.order) !== null && _a !== void 0 ? _a : [];\n        this.childRects = [];\n        content.forEach((itemId) => {\n            var _a, _b;\n            if (transformedLayout.content[itemId].isPending) {\n                return;\n            }\n            const bbox = (_b = (_a = transformedLayout.content) === null || _a === void 0 ? void 0 : _a[itemId]) === null || _b === void 0 ? void 0 : _b.bbox;\n            if (bbox != null) {\n                this.childRects.push({\n                    layoutId: transformedLayout.id,\n                    id: itemId,\n                    left: parseInt(bbox.left, 10),\n                    width: parseInt(bbox.width, 10),\n                    height: bbox.height\n                });\n            }\n        });\n        this.childRects.sort((a, b) => a.left - b.left);\n        if (this.flipLeftRight) {\n            this.flippedChildRects = [];\n            this.childRects.forEach((item) => {\n                let rect = {\n                    left: item.left,\n                    width: item.width,\n                    height: item.height\n                };\n                rect = flipRowItemPos(rect);\n                this.flippedChildRects.push({\n                    layoutId: item.layoutId,\n                    id: item.id,\n                    left: rect.left,\n                    width: rect.width,\n                    height: rect.height\n                });\n            });\n            this.flippedChildRects.sort((a, b) => a.left - b.left);\n        }\n        else {\n            this.flippedChildRects = this.childRects;\n        }\n        return this.childRects;\n    }\n    createItem(childRects, index) {\n        var _a;\n        const { transformedLayout, itemDraggable, itemResizable, itemSelectable, isMultiRow } = this.props;\n        const config = this.getConfig();\n        const childRect = childRects[index];\n        const gutter = (_a = config.space) !== null && _a !== void 0 ? _a : 0;\n        let offset;\n        if (index === 0) {\n            offset = childRect.left;\n        }\n        else {\n            const previousBBox = childRects[index - 1];\n            offset = childRect.left - previousBBox.left - previousBBox.width;\n        }\n        return (jsx(RowItemForBuilder, { key: `${childRect.layoutId}_${childRect.id}`, order: index + 1, offset: offset, span: childRect.width, gutter: gutter, isMultiRow: isMultiRow, builderTheme: this.builderTheme, layoutId: transformedLayout.id, layoutItemId: childRect.id, layoutItem: transformedLayout.content[childRect.id], draggable: itemDraggable, resizable: itemResizable, selectable: itemSelectable, \n            // itemDisplaySetting={itemDisplaySetting}\n            onResizeStart: this.handleItemResizeStart, onResizing: this.handleItemResizing, onResizeEnd: this.handleItemResizeEnd }));\n    }\n    render() {\n        var _a;\n        const { transformedLayout, className } = this.props;\n        const { isResizing, isDragoverCenter } = this.state;\n        const config = this.getConfig();\n        const isDragover = isDragoverCenter;\n        let content;\n        if (isResizing && this.state.updatingRects != null) {\n            content = this.state.updatingRects;\n        }\n        else {\n            this.collectBounds();\n            content = this.childRects;\n        }\n        const gutter = (_a = config.space) !== null && _a !== void 0 ? _a : 0;\n        return (jsx(PageContext.Consumer, null, (props) => {\n            this.maxPageWidth = props.maxWidth;\n            this.builderTheme = props.builderTheme;\n            return (jsx(\"div\", { className: classNames('row-layout', className, { 'row-rtl': this.flipLeftRight }), css: ROW_STYLE, \"data-layoutid\": transformedLayout.id },\n                jsx(\"div\", { css: css `\r\n                width: 100%;\r\n                max-width: ${props.maxWidth > 0 ? `${props.maxWidth}px` : 'none'};\r\n              ` },\n                    jsx(\"div\", { ref: el => { this.ref = el; }, css: css `\r\n                    position: relative;\r\n                    height: 100%;\r\n                    margin-left: ${-gutter / 2}px;\r\n                    margin-right: ${-gutter / 2}px;\r\n                    display: flex;\r\n                    flex-direction: column;\r\n                    .row {\r\n                      overflow: ${this.props.isMultiRow ? 'auto' : 'unset'};\r\n                    }\r\n                    & > .jimu-widget-placeholder {\r\n                      width: calc(100% - ${gutter}px);\r\n                      align-self: center;\r\n                    }\r\n                  ` },\n                        jsx(IntersectionContext.Provider, { value: { monitor: false } },\n                            jsx(OneByOneAnimation, { className: classNames('row m-0', {\n                                    'flex-nowrap': !this.props.isMultiRow,\n                                    'h-100': content.length > 0\n                                }), oid: transformedLayout.id, \"data-layoutid\": transformedLayout.id },\n                                jsx(DropArea, { css: dropareaStyle, layouts: this.props.layouts, highlightDragover: false, onDragEnter: this.handleDragEnter, onDragLeave: this.handleDragLeave, onDragOver: this.handleDragOver, onDrop: this.handleDrop, onToggleDragoverEffect: this.handleToggleDragoverCenterEffect }),\n                                content.map((_, index) => this.createItem(content, index)))),\n                        content.length === 0 && this.props.children,\n                        jsx(ColumnHint, { visible: isDragover || isResizing, builderTheme: props.builderTheme, gutter: gutter }),\n                        jsx(\"canvas\", { css: css `\r\n                      ${guideOverlay};\r\n                      display: ${isDragover ? 'block' : 'none'};\r\n                    `, ref: el => { this.guideDragOverRef = el; } })))));\n        }));\n    }\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, classNames, jsx, css, ExtensionManager, extensionSpec, ReactResizeDetector, lodash } from 'jimu-core';\nimport { styleUtils } from 'jimu-ui';\nimport { utils } from 'jimu-layouts/layout-runtime';\nimport { DEFAULT_ROW_LAYOUT_SETTING } from '../default-setting';\nimport { TOTAL_COLS } from '../types';\nimport { Row } from './row';\nclass RowLayout extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.layoutConRef = React.createRef();\n        this.onResize = ({ width, height }) => {\n            var _a;\n            if (this.props.browserSizeMode !== this.props.mainSizeMode) {\n                return;\n            }\n            if (height === 0) {\n                return;\n            }\n            const { widgetId } = this.props;\n            if (((_a = window.runtimeInfo.widgets) === null || _a === void 0 ? void 0 : _a[widgetId]) != null) {\n                window.runtimeInfo.widgets[widgetId].height = height;\n            }\n            else {\n                window.runtimeInfo.widgets[widgetId] = { height };\n            }\n        };\n        this.handleDebounceResize = lodash.debounce(this.onResize, 200);\n    }\n    findExtension() {\n        const exts = ExtensionManager.getInstance().getExtensions(\n        //eslint-disable-next-line @typescript-eslint/no-unnecessary-template-expression\n        `${extensionSpec.ExtensionPoints.LayoutTransformer}`);\n        if ((exts === null || exts === void 0 ? void 0 : exts.length) > 0) {\n            const ext = exts.find(item => item.layoutType === 'ROW');\n            this.layoutTransform = ext === null || ext === void 0 ? void 0 : ext.transformLayout;\n        }\n    }\n    collectRowItems() {\n        var _a;\n        const { layout, layouts, browserSizeMode, mainSizeMode } = this.props;\n        if (this.layoutTransform == null) {\n            this.findExtension();\n        }\n        let targetLayout = layout;\n        const viewOnly = layouts[browserSizeMode] !== layout.id;\n        if (viewOnly && this.layoutTransform != null) {\n            targetLayout = this.layoutTransform(layout, mainSizeMode, browserSizeMode, utils.getAppConfig());\n        }\n        this.finalLayout = targetLayout;\n        const content = (_a = targetLayout.order) !== null && _a !== void 0 ? _a : [];\n        const rows = [];\n        let row = [];\n        let rowIndex = 0;\n        rows.push(row);\n        content.forEach((itemId) => {\n            if (targetLayout.content[itemId].isPending) {\n                return;\n            }\n            const bbox = targetLayout.content[itemId].bbox;\n            const left = parseInt(bbox.left, 10);\n            const rowNum = Math.floor(left / TOTAL_COLS);\n            if (rowNum > rowIndex) {\n                row = [];\n                rowIndex = rowNum;\n                rows.push(row);\n            }\n            row.push(itemId);\n        });\n        return rows;\n    }\n    createRow() {\n        const { layout, layouts } = this.props;\n        return (jsx(Row, { layouts: layouts, layout: layout, transformedLayout: this.finalLayout, isMultiRow: this.numOfRows > 1 }, this.props.children));\n    }\n    render() {\n        var _a, _b;\n        const { layout, className } = this.props;\n        const layoutSetting = (_a = layout.setting) !== null && _a !== void 0 ? _a : DEFAULT_ROW_LAYOUT_SETTING;\n        const style = (_b = layoutSetting.style) !== null && _b !== void 0 ? _b : DEFAULT_ROW_LAYOUT_SETTING.style;\n        this.numOfRows = this.collectRowItems().length;\n        return (jsx(\"div\", { className: classNames('layout d-flex', className), css: css `\r\n          width: 100%;\r\n          padding: ${styleUtils.toCSSPadding(style.padding)};\r\n        `, \"data-layoutid\": layout.id, ref: this.layoutConRef },\n            this.createRow(),\n            jsx(ReactResizeDetector, { targetRef: this.layoutConRef, handleHeight: true, onResize: this.handleDebounceResize })));\n    }\n}\nexport default ReactRedux.connect(utils.mapStateToLayoutProps)(RowLayout);\n","/** @jsx jsx */\nimport { React, jsx, css, getAppStore, appActions, ReactRedux, ReactResizeDetector, BrowserSizeMode, Immutable, polished, LayoutItemType, WidgetType, classNames, AppMode, hooks } from 'jimu-core';\nimport { Button, Tooltip } from 'jimu-ui';\nimport { WidgetListPopper } from 'jimu-ui/advanced/setting-components';\nimport { getAppConfigAction, appBuilderSync } from 'jimu-for-builder';\nimport { addItemToGrid } from './utils';\nimport LayoutItem from '../../builder/layout-item';\nimport { DropArea } from '../../builder/interactive/droparea-hook';\nimport { CanvasPane } from '../../builder/interactive/canvas-pane';\nimport { ThemedTooltip } from '../../builder/theme-tooltip';\nimport { canDropAtPlaceholder, dropAtPlaceholder, addWidgetInPlaceholder, addSectionInPlaceholder } from '../../builder/util';\nimport { gridItemMenu } from './grid-item-menu';\nimport { sectionMenuItems } from '../../builder/menu/section-menu';\nimport { SideType } from './types';\nimport { MaxgridOutlined } from 'jimu-icons/outlined/application/maxgrid';\nimport { getTheme, getTheme2, withBuilderTheme } from 'jimu-theme';\nimport { LockOutlined } from 'jimu-icons/outlined/editor/lock';\nimport { UnlockOutlined } from 'jimu-icons/outlined/editor/unlock';\nimport defaultMessage from '../../translations/default';\nimport { CloseOutlined } from 'jimu-icons/outlined/editor/close';\nimport { PlusOutlined } from 'jimu-icons/outlined/editor/plus';\nimport { utils } from 'jimu-layouts/layout-runtime';\nimport * as commonUtils from '../common/utils';\nconst ThemeWidgetListPopper = withBuilderTheme(WidgetListPopper);\nconst sectionMenu = [].concat(sectionMenuItems, gridItemMenu);\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  right: 0;\r\n  top: 0;\r\n  bottom: 0;\r\n  z-index: 10;\r\n  display: flex;\r\n`;\nconst guideOverlay = css `\r\n  ${dropareaStyle};\r\n  pointer-events: none;\r\n`;\nconst getStyle = (isPlaceholder) => {\n    const theme = getTheme2();\n    return css `\r\n    & > .max-grid-item-btn {\r\n      display: none;\r\n      background: var(--ref-palette-neutral-500);\r\n      width: 26px;\r\n      height: 26px;\r\n      position: absolute;\r\n      top: 0;\r\n      right: 0;\r\n    }\r\n\r\n    & > .layout-widget > .add-btn {\r\n      display: ${isPlaceholder ? 'none' : 'block'};\r\n    }\r\n\r\n    & > .add-btn {\r\n      z-index: 20;\r\n      position: absolute;\r\n      top: 50%;\r\n      left: 50%;\r\n      transform: translate(-50%, -50%);\r\n    }\r\n\r\n    .lock-mask {\r\n      position: absolute;\r\n      right: 0;\r\n      bottom: 0;\r\n      width: 100%;\r\n      height: 100%;\r\n      z-index: 20;\r\n      pointer-events: none;\r\n      transition: all 400ms;\r\n\r\n      .mask {\r\n        width: 100%;\r\n        height: 100%;\r\n        background: ${theme.ref.palette.white};\r\n        opacity: 0.1;\r\n      }\r\n\r\n      .lock-btn {\r\n        background: ${polished.rgba(theme.ref.palette.white, 0.6)};\r\n        border-color: ${theme.ref.palette.black} !important;\r\n        box-shadow: 0px 0px 8px 0px rgba(0, 0, 0, 0.3);\r\n        width: 38px;\r\n        height: 38px;\r\n        position: absolute;\r\n        left: 50%;\r\n        top: 50%;\r\n        transform: translate(-50%, -50%);\r\n        transition: all 400ms;\r\n        pointer-events: all;\r\n      }\r\n\r\n      &.unlock {\r\n        width: 32px;\r\n        height: 32px;\r\n\r\n        .mask {\r\n          background: transparent;\r\n        }\r\n\r\n        .lock-btn {\r\n          width: 26px;\r\n          height: 26px;\r\n        }\r\n      }\r\n    }\r\n\r\n    body:not(.design-mode) &:hover > .max-grid-item-btn {\r\n      display: flex;\r\n      justify-content: center;\r\n      align-items: center;\r\n    }\r\n  `;\n};\nconst maximizedStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  top: 0;\r\n  width: 100% !important;\r\n  height: 100% !important;\r\n  z-index: 30;\r\n  background: var(--ref-palette-neutral-200);\r\n`;\nexport function GridLayoutItem(props) {\n    const { layoutId, layoutItemId, onDragStart, onDragging, onDragEnd, delay, isLastChild, className } = props;\n    const [maximized, setMaximized] = React.useState(false);\n    const [showWidgetListPopper, setShowWidgetListPopper] = React.useState(false);\n    const [locked, setLocked] = React.useState(true);\n    const canvasPaneRef = React.useRef();\n    const canvasRef = React.useRef();\n    const resizeRef = React.useRef();\n    const isEnter = React.useRef(false);\n    const btnRef = React.useRef();\n    const theme2 = getTheme2();\n    const translate = hooks.useTranslation(defaultMessage);\n    const expandable = ReactRedux.useSelector((state) => {\n        return commonUtils.isExpandable(state, layoutId, layoutItemId);\n    });\n    const isLockLayout = ReactRedux.useSelector((state) => {\n        var _a, _b, _c;\n        const lockLayout = (_c = (_b = (_a = state.appConfig) === null || _a === void 0 ? void 0 : _a.forBuilderAttributes) === null || _b === void 0 ? void 0 : _b.lockLayout) !== null && _c !== void 0 ? _c : false;\n        const isDesignMode = state.appRuntimeInfo.appMode === AppMode.Design;\n        return !isDesignMode || lockLayout;\n    });\n    const hasEmbeddedLayout = ReactRedux.useSelector((state) => {\n        var _a, _b, _c;\n        const layoutItem = state.appConfig.layouts[layoutId].content[layoutItemId];\n        if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Section) {\n            return true;\n        }\n        if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Widget) {\n            const widgetJson = state.appConfig.widgets[layoutItem.widgetId];\n            if (((_a = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.manifest) === null || _a === void 0 ? void 0 : _a.widgetType) === WidgetType.Layout || ((_c = (_b = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.manifest) === null || _b === void 0 ? void 0 : _b.properties) === null || _c === void 0 ? void 0 : _c.hasEmbeddedLayout)) {\n                return widgetJson.layouts != null;\n            }\n        }\n        return false;\n    });\n    const isPlaceholder = ReactRedux.useSelector((state) => {\n        const layoutItem = state.appConfig.layouts[layoutId].content[layoutItemId];\n        return (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Widget && (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.widgetId) == null;\n    });\n    const isSection = ReactRedux.useSelector((state) => {\n        const layoutItem = state.appConfig.layouts[layoutId].content[layoutItemId];\n        return (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Section;\n    });\n    const fakeLayouts = React.useMemo(() => {\n        return Immutable({\n            [BrowserSizeMode.Large]: `${layoutId}_${layoutItemId}_tlarge`,\n            [BrowserSizeMode.Medium]: `${layoutId}_${layoutItemId}_tmedium`,\n            [BrowserSizeMode.Small]: `${layoutId}_${layoutItemId}_tsmall`\n        });\n    }, [layoutId, layoutItemId]);\n    hooks.useEffectOnce(() => {\n        const theme = getTheme();\n        canvasPaneRef.current = new CanvasPane(canvasRef.current, theme);\n    });\n    const handleResize = hooks.useEventCallback(({ width, height }) => {\n        if (!width || !height) {\n            return;\n        }\n        canvasPaneRef.current.setSize(width, height, window.devicePixelRatio);\n    });\n    const handleToggleDragoverEffect = hooks.useEventCallback((isIn) => {\n        isEnter.current = isIn;\n        // to make sure only one grid layout can have drop-target\n        document.querySelectorAll('div.grid-layout').forEach(element => {\n            const gridId = element.getAttribute('data-layoutid');\n            if (gridId === layoutId) {\n                if (isIn && !element.classList.contains('drop-target')) {\n                    element.classList.add('drop-target');\n                }\n            }\n            else if (element.classList.contains('drop-target')) {\n                element.classList.remove('drop-target');\n            }\n        });\n        canvasPaneRef.current.clear();\n    });\n    const onDragOver = React.useCallback((draggingItem, draggingElement, containerRect, itemRect, clientX, clientY) => {\n        if (!isEnter.current) {\n            return;\n        }\n        const { width, height } = containerRect;\n        canvasPaneRef.current.clear();\n        const theme = getTheme();\n        canvasPaneRef.current.setColor(polished.rgba(theme.sys.color.primary.light, 0.2));\n        if (isPlaceholder && canDropAtPlaceholder(draggingItem)) {\n            // normal widgetdrop at this placeholder directly\n            canvasPaneRef.current.drawRect({ left: 0, top: 0, width, height });\n            return;\n        }\n        let rect;\n        if (clientY <= height * 0.2) {\n            rect = { left: 0, top: 0, width, height: height / 2 };\n        }\n        else if (clientY >= height * 0.8) {\n            rect = { left: 0, top: height / 2, width, height: height / 2 };\n        }\n        else {\n            if (clientX <= width * 0.2) {\n                rect = { left: 0, top: 0, width: width / 2, height };\n            }\n            else if (clientX >= width * 0.8) {\n                rect = { left: width / 2, top: 0, width: width / 2, height };\n            }\n            else {\n                rect = { left: width * 0.2, top: height * 0.2, width: width * 0.6, height: height * 0.6 };\n            }\n        }\n        canvasPaneRef.current.drawRect(rect);\n    }, [isPlaceholder]);\n    const onDrop = React.useCallback((draggingItem, containerRect, itemRect, clientX, clientY) => {\n        let appConfigAction = getAppConfigAction();\n        if (isPlaceholder && canDropAtPlaceholder(draggingItem)) {\n            // normal widgetdrop at this placeholder directly\n            dropAtPlaceholder({ layoutId, layoutItemId }, draggingItem);\n            return;\n        }\n        const { width, height } = containerRect;\n        let side;\n        if (clientY <= height * 0.2) {\n            side = SideType.Top;\n        }\n        else if (clientY >= height * 0.8) {\n            side = SideType.Bottom;\n        }\n        else {\n            if (clientX <= width * 0.2) {\n                if (utils.isRTL()) {\n                    side = SideType.Right;\n                }\n                else {\n                    side = SideType.Left;\n                }\n            }\n            else if (clientX >= width * 0.8) {\n                if (utils.isRTL()) {\n                    side = SideType.Left;\n                }\n                else {\n                    side = SideType.Right;\n                }\n            }\n            else {\n                side = SideType.Center;\n            }\n        }\n        const layoutInfo = {\n            layoutId\n        };\n        addItemToGrid(appConfigAction.appConfig, draggingItem, layoutInfo, layoutItemId, side).then((result) => {\n            const { appConfig, layoutInfo: newLayoutInfo } = result;\n            appConfigAction = getAppConfigAction(appConfig);\n            appConfigAction.exec();\n            getAppStore().dispatch(appActions.selectionChanged(newLayoutInfo));\n        });\n    }, [isPlaceholder, layoutId, layoutItemId]);\n    const setWidget = React.useCallback((item) => {\n        if (item.itemType === LayoutItemType.Section) {\n            addSectionInPlaceholder({ layoutId, layoutItemId });\n        }\n        else {\n            addWidgetInPlaceholder({ layoutId, layoutItemId }, item);\n        }\n        setShowWidgetListPopper(false);\n    }, [layoutId, layoutItemId]);\n    const toggleShowWidgetListPopper = React.useCallback((e) => {\n        e.stopPropagation();\n        if (getAppStore().getState().browserSizeMode === BrowserSizeMode.Small) {\n            appBuilderSync.publishSidePanelToApp({ type: 'widget', isPlaceholder: true, isItemAccepted: canDropAtPlaceholder, onSelect: setWidget });\n            return;\n        }\n        setShowWidgetListPopper(!showWidgetListPopper);\n    }, [showWidgetListPopper, setWidget]);\n    const toggleMaximize = React.useCallback(() => {\n        setMaximized(!maximized);\n    }, [maximized]);\n    const toggleLockMode = React.useCallback(() => {\n        setLocked(!locked);\n    }, [locked]);\n    return (jsx(LayoutItem, { layoutId: layoutId, layoutItemId: layoutItemId, resizable: false, className: className, showDefaultTools: false, toolItems: isSection ? sectionMenu : gridItemMenu, delay: delay, isLastChild: isLastChild, onDragStart: onDragStart, onDragging: onDragging, onDragEnd: onDragEnd, css: css `${getStyle(isPlaceholder)};${maximized ? maximizedStyle : ''}` },\n        (!hasEmbeddedLayout || locked) && !isLockLayout && (jsx(DropArea, { css: dropareaStyle, layouts: fakeLayouts, highlightDragover: true, onDragOver: onDragOver, onDrop: onDrop, onToggleDragoverEffect: handleToggleDragoverEffect })),\n        isPlaceholder && (jsx(\"div\", { className: 'add-btn' },\n            jsx(ThemedTooltip, { title: translate('addWidget') },\n                jsx(Button, { icon: true, ref: btnRef, css: css `width: 36px; height: 36px; padding: 0.5rem;`, onClick: toggleShowWidgetListPopper, \"aria-haspopup\": true },\n                    jsx(PlusOutlined, null))))),\n        isPlaceholder && showWidgetListPopper &&\n            jsx(ThemeWidgetListPopper, { referenceElement: btnRef.current, isAccepted: canDropAtPlaceholder, onSelect: setWidget, onClose: () => { setShowWidgetListPopper(false); } }),\n        jsx(\"canvas\", { css: guideOverlay, ref: canvasRef }),\n        jsx(\"div\", { css: css `\r\n        position: absolute;\r\n        left: 0;\r\n        right: 0;\r\n        top: 0;\r\n        bottom: 0;\r\n        background: transparent;\r\n        pointer-events: none;\r\n      `, ref: resizeRef }),\n        jsx(ReactResizeDetector, { handleWidth: true, handleHeight: true, onResize: handleResize, targetRef: resizeRef }),\n        expandable && (jsx(Button, { icon: true, type: 'tertiary', className: 'max-grid-item-btn p-0', onClick: toggleMaximize, title: maximized ? translate('restore') : translate('maximize') },\n            maximized && jsx(CloseOutlined, null),\n            !maximized && jsx(MaxgridOutlined, null))),\n        hasEmbeddedLayout && !isLockLayout && (jsx(\"div\", { className: classNames('lock-mask', { unlock: !locked }) },\n            jsx(\"div\", { className: 'mask' }),\n            jsx(Tooltip, { title: locked ? translate('unlockGridItem') : translate('lockGridItem') },\n                jsx(Button, { className: 'lock-btn rounded-circle', size: 'sm', type: 'tertiary', icon: true, onClick: toggleLockMode },\n                    !locked && jsx(UnlockOutlined, { size: 14, color: theme2.ref.palette.black }),\n                    locked && jsx(LockOutlined, { size: 20, color: theme2.ref.palette.black })))))));\n}\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, BrowserSizeMode, Immutable, getAppStore, appActions, hooks } from 'jimu-core';\nimport { interact } from 'jimu-core/dnd';\nimport { Tab, defaultMessages } from 'jimu-ui';\nimport { PageContext, LayoutContext, utils } from 'jimu-layouts/layout-runtime';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { bindDragHandler } from '../../builder/interactive/drag-event-handler';\nimport { initInteractive } from '../../builder/interactive/droparea-effect-interactjs';\nimport { initH5 } from '../../builder/interactive/droparea-effect-h5';\nimport { addItemToGrid } from './utils';\nimport { SideType } from './types';\nimport { getLabelOfGridTab } from '../common/utils';\nconst style = css `\r\n  .nav-link.grid-tab.highlight-pre {\r\n    position: relative;\r\n    &:after {\r\n      content: '';\r\n      position: absolute;\r\n      left: 0;\r\n      top: 0;\r\n      width: 50%;\r\n      height: 100%;\r\n      background-color: var(--sys-color-primary-light);\r\n    }\r\n  }\r\n\r\n  .nav-link.grid-tab.highlight-next {\r\n    position: relative;\r\n    &:after {\r\n      content: '';\r\n      position: absolute;\r\n      right: 0;\r\n      top: 0;\r\n      width: 50%;\r\n      height: 100%;\r\n      background-color: var(--sys-color-primary-light);\r\n    }\r\n  }\r\n`;\nexport function DraggableTab(props) {\n    const { layoutId, layoutItemId, onDragStart, title } = props, otherProps = __rest(props, [\"layoutId\", \"layoutItemId\", \"onDragStart\", \"title\"]);\n    const btnRef = React.useRef();\n    const isInRef = React.useRef(false);\n    const translate = hooks.useTranslation(defaultMessages);\n    const pageContext = React.useContext(PageContext);\n    const layoutContext = React.useContext(LayoutContext);\n    const itemType = ReactRedux.useSelector((state) => {\n        const appConfig = state.appConfig;\n        const layoutItem = appConfig.layouts[layoutId].content[layoutItemId];\n        return layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type;\n    });\n    const label = ReactRedux.useSelector((state) => {\n        return getLabelOfGridTab(state.appConfig, { layoutId, layoutItemId }, translate);\n    });\n    const getCurrentRootLayoutId = React.useCallback(() => pageContext.rootLayoutId, [pageContext.rootLayoutId]);\n    const handleDragStart = hooks.useEventCallback(() => {\n        onDragStart(layoutItemId);\n    });\n    const handleOnDragOver = hooks.useEventCallback((draggingItem, draggingElement, containerRect, itemRect, clientX, clientY) => {\n        if (!isInRef.current) {\n            return;\n        }\n        if (clientX <= containerRect.width / 2) {\n            btnRef.current.classList.add('highlight-pre');\n            btnRef.current.classList.remove('highlight-next');\n        }\n        else {\n            btnRef.current.classList.remove('highlight-pre');\n            btnRef.current.classList.add('highlight-next');\n        }\n    });\n    const handleOnDrop = hooks.useEventCallback((draggingItem, containerRect, itemRect, clientX, clientY) => {\n        const layoutInfo = {\n            layoutId\n        };\n        let appConfigAction = getAppConfigAction();\n        let isBeforeReferenceItem = false;\n        if (clientX <= containerRect.width / 2) {\n            isBeforeReferenceItem = !utils.isRTL();\n        }\n        else {\n            isBeforeReferenceItem = utils.isRTL();\n        }\n        // insert after this item\n        addItemToGrid(appConfigAction.appConfig, draggingItem, layoutInfo, layoutItemId, SideType.Center).then((result) => {\n            const { appConfig, layoutInfo: newLayoutInfo } = result;\n            appConfigAction = getAppConfigAction(appConfig);\n            if (isBeforeReferenceItem) {\n                const refItem = appConfig.layouts[layoutId].content[layoutItemId];\n                const parentId = refItem.parent;\n                const parentItem = appConfig.layouts[layoutId].content[parentId];\n                const childIds = [...parentItem.children];\n                childIds.splice(childIds.indexOf(layoutItemId), 2, newLayoutInfo.layoutItemId, layoutItemId);\n                appConfigAction.editLayoutItemProperty({ layoutId, layoutItemId: parentId }, 'children', childIds);\n            }\n            appConfigAction.exec();\n            getAppStore().dispatch(appActions.selectionChanged(newLayoutInfo));\n        });\n    });\n    const handleToggleDragoverEffect = hooks.useEventCallback((isIn) => {\n        isInRef.current = isIn;\n        if (!isIn) {\n            btnRef.current.classList.remove('highlight-pre');\n            btnRef.current.classList.remove('highlight-next');\n        }\n    });\n    React.useEffect(() => {\n        btnRef.current.setAttribute('data-layoutid', layoutId);\n        btnRef.current.setAttribute('data-layoutitemid', layoutItemId);\n        const dragInteractable = interact(btnRef.current).origin('parent');\n        const interactable = bindDragHandler(dragInteractable, {\n            layoutId,\n            layoutItemId,\n            itemType,\n            useDragHandler: false,\n            onDragStart: handleDragStart,\n            rootLayoutId: getCurrentRootLayoutId,\n            restrict: () => true\n        });\n        interactable.draggable({\n            modifiers: [\n                interact.modifiers.restrictRect({\n                    restriction: btnRef.current.parentElement.parentElement //`div.grid-layout[data-layoutid=${layoutId}]`\n                })\n            ]\n        });\n        const contextRef = {\n            current: {\n                props: {\n                    layouts: Immutable({\n                        [BrowserSizeMode.Large]: `${layoutId}_${layoutItemId}_tlarge`,\n                        [BrowserSizeMode.Medium]: `${layoutId}_${layoutItemId}_tmedium`,\n                        [BrowserSizeMode.Small]: `${layoutId}_${layoutItemId}_tsmall`\n                    }),\n                    highlightDragover: true,\n                    onDragOver: handleOnDragOver,\n                    onDrop: handleOnDrop,\n                    onToggleDragoverEffect: handleToggleDragoverEffect\n                },\n                layoutId,\n                pageContext,\n                layoutContext\n            }\n        };\n        const dropInteractable = initInteractive(btnRef.current, contextRef, '.grid-tab');\n        initH5(btnRef.current, contextRef);\n        return () => {\n            dragInteractable.unset();\n            dropInteractable.unset();\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [layoutId, layoutItemId]); // rebind event handler if layoutId/layoutItemId changes, e.g. use custom small size mode\n    return jsx(Tab, Object.assign({}, otherProps, { title: label, innerRef: btnRef, innerClassName: 'grid-tab', css: style }));\n}\n","/** @jsx jsx */\nimport { jsx, css, GridItemType, hooks } from 'jimu-core';\nimport { Popper, defaultMessages } from 'jimu-ui';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { isLockLayout } from '../../builder/menu/common-menu';\nimport { Toolbar } from '../../builder/toolbar';\nimport { getTheme2 } from 'jimu-theme';\nimport rowIcon from 'jimu-icons/svg/outlined/data/row.svg';\nlet count = 0;\nconst shiftOptions = {\n    rootBoundary: 'viewport',\n    crossAxis: true\n};\nconst flipOptions = {\n    boundary: document.body,\n    fallbackPlacements: ['top-start', 'bottom-start', 'right-start', 'left-start']\n};\nexport const gridRowColTools = [\n    {\n        icon: rowIcon,\n        title: (props) => {\n            const { layoutItem, formatMessage } = props;\n            const type = layoutItem.gridType;\n            let labelId;\n            if (type === GridItemType.Row) {\n                labelId = 'distributeSpaceH';\n            }\n            else if (type === GridItemType.Column) {\n                labelId = 'distributeSpaceV';\n            }\n            return formatMessage(labelId);\n        },\n        visible: (props) => {\n            const { layoutItem } = props;\n            const type = layoutItem.gridType;\n            return (type === GridItemType.Row || type === GridItemType.Column) && !isLockLayout();\n        },\n        onClick: (props) => {\n            const { layoutId } = props;\n            const layoutItem = props.layoutItem;\n            const appConfigAction = getAppConfigAction();\n            const num = layoutItem.children.length;\n            const size = 100 / num;\n            layoutItem.children.forEach(childId => {\n                appConfigAction.editLayoutItemProperty({ layoutId: layoutId, layoutItemId: childId }, 'bbox', { width: size });\n            });\n            appConfigAction.exec();\n        },\n        onMouseEnter: (props) => {\n            const { layoutId, layoutItem } = props;\n            const gridElement = document.querySelector(`div.grid-layout[data-layoutid=\"${layoutId}\"]`);\n            const groupElement = gridElement.querySelector(`div[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItem.id}\"]`);\n            groupElement.classList.add('menu-active');\n        },\n        onMouseLeave: (props) => {\n            const { layoutId, layoutItem } = props;\n            const gridElement = document.querySelector(`div.grid-layout[data-layoutid=\"${layoutId}\"]`);\n            const groupElement = gridElement.querySelector(`div[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItem.id}\"]`);\n            groupElement.classList.remove('menu-active');\n        }\n    }\n];\nexport function GridItemToolbar(props) {\n    const { layoutId, layoutItem, refElement } = props;\n    const translate = hooks.useTranslation(defaultMessages);\n    if (!refElement) {\n        return null;\n    }\n    return (jsx(Popper, { placement: 'top-start', reference: refElement, open: true, unstyled: true, shiftOptions: shiftOptions, flipOptions: flipOptions, version: count++, trapFocus: false, autoFocus: false, css: css `\r\n        background: transparent;\r\n        box-shadow: none;\r\n      ` },\n        jsx(\"div\", null,\n            jsx(Toolbar, { layoutId: layoutId, layoutItem: layoutItem, theme: getTheme2(), parentRef: refElement, tools: gridRowColTools, formatMessage: translate }))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, classNames, ReactRedux, AppMode, AnimationContext, ParentAnimationMode, LayoutItemType, GridItemType, hooks } from 'jimu-core';\nimport { interact } from 'jimu-core/dnd';\nimport { Tabs } from 'jimu-ui';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { GridLayoutItem } from './layout-item';\nimport { Splitter } from '../common/splitter';\nimport { createDraggingPlaceholder, bindDragHandler } from '../../builder/interactive/drag-event-handler';\nimport { DraggableTab } from './draggable-tab';\nimport { indexOfPlainContent, isLastChildOfRootItem, getGridItem } from '../common/utils';\nimport { GridItemToolbar } from './grid-item-toolbar';\nimport { getTheme2 } from 'jimu-theme';\nexport function GridItemComponent(props) {\n    const { layout, layoutItemId, isLast, onDragStart, onDragging, onDragEnd, className } = props;\n    const layoutItem = React.useMemo(() => {\n        return getGridItem(layout, layoutItemId);\n    }, [layout, layoutItemId]);\n    const parentType = React.useMemo(() => {\n        if (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.parent) {\n            const parentItem = getGridItem(layout, layoutItem.parent);\n            return parentItem.gridType;\n        }\n        return null;\n    }, [layoutItem, layout]);\n    const splitSpace = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        const size = (_b = (_a = layout.setting) === null || _a === void 0 ? void 0 : _a.splitSize) !== null && _b !== void 0 ? _b : 8;\n        let numOfChildren = 0;\n        if (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.parent) {\n            const parentItem = getGridItem(layout, layoutItem.parent);\n            numOfChildren = parentItem.children.length;\n        }\n        const total = size * (numOfChildren - 1);\n        return total / numOfChildren;\n    });\n    const animationContext = React.useContext(AnimationContext);\n    const interval = React.useMemo(() => {\n        var _a, _b;\n        if (((_b = (_a = animationContext === null || animationContext === void 0 ? void 0 : animationContext.setting) === null || _a === void 0 ? void 0 : _a.option) === null || _b === void 0 ? void 0 : _b.parentMode) === ParentAnimationMode.AllAtOnce) {\n            return 0;\n        }\n        return 250;\n    }, [animationContext]);\n    const getStyle = React.useCallback(() => {\n        let size;\n        if (splitSpace > 0) {\n            size = `calc(${+layoutItem.bbox.width}% - ${splitSpace.toFixed(2)}px)`;\n        }\n        else {\n            size = `${+layoutItem.bbox.width}%`;\n        }\n        if (parentType === GridItemType.Row) {\n            return css `\r\n        height: 100%;\r\n        width: ${size};\r\n      `;\n        }\n        if (parentType === GridItemType.Column) {\n            return css `\r\n        width: 100%;\r\n        height: ${size};\r\n      `;\n        }\n        return css `\r\n      width: 100%;\r\n      height: 100%;\r\n    `;\n    }, [layoutItem.bbox.width, splitSpace, parentType]);\n    if (layoutItem.gridType === GridItemType.Row) {\n        return (jsx(RowContainer, { className: className, css: getStyle(), layout: layout, layoutItemId: layoutItemId, items: layoutItem.children }));\n    }\n    if (layoutItem.gridType === GridItemType.Column) {\n        return (jsx(ColContainer, { className: className, css: getStyle(), layout: layout, layoutItemId: layoutItemId, items: layoutItem.children }));\n    }\n    if (layoutItem.gridType === GridItemType.Tab) {\n        return (jsx(TabContainer, { className: className, css: getStyle(), layout: layout, layoutItemId: layoutItemId, items: layoutItem.children, onDragStart: onDragStart, onDragEnd: onDragEnd }));\n    }\n    const idx = indexOfPlainContent(layout, layoutItemId);\n    const isLastChild = isLastChildOfRootItem(layout, layoutItemId);\n    return (jsx(GridLayoutItem, { css: getStyle(), className: classNames(`d-flex ${className}`, { 'is-last': isLast }), layoutId: layout.id, layoutItemId: layoutItemId, delay: idx * interval, isLastChild: isLastChild, onDragStart: onDragStart, onDragging: onDragging, onDragEnd: onDragEnd }));\n}\nfunction RowContainer(props) {\n    const { layout, layoutItemId, items, className } = props;\n    const domRef = React.useRef();\n    const isDesignMode = ReactRedux.useSelector((state) => {\n        var _a;\n        return ((_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.appMode) === AppMode.Design;\n    });\n    const selected = ReactRedux.useSelector((state) => {\n        const selection = state.appRuntimeInfo.selection;\n        return (selection === null || selection === void 0 ? void 0 : selection.layoutId) === layout.id && (selection === null || selection === void 0 ? void 0 : selection.layoutItemId) === layoutItemId;\n    });\n    const handleResizeEnd = hooks.useEventCallback((id, dx) => {\n        const appConfigAction = getAppConfigAction();\n        const index = items.indexOf(id);\n        const nextId = items[index + 1];\n        const layoutItem = layout.content[id];\n        const nextLayoutItem = layout.content[nextId];\n        appConfigAction.editLayoutItemProperty({\n            layoutId: layout.id,\n            layoutItemId: id\n        }, 'bbox', { width: +layoutItem.bbox.width + dx }, true).editLayoutItemProperty({\n            layoutId: layout.id,\n            layoutItemId: nextId\n        }, 'bbox', { width: +nextLayoutItem.bbox.width - dx }, true).exec();\n    });\n    const handleDragStart = hooks.useEventCallback((id) => {\n        var _a;\n        const targetElement = domRef.current.querySelector(`div[data-layoutitemid=\"${id}\"]`);\n        let splitter;\n        let neighborItem;\n        if ((_a = targetElement.nextElementSibling) === null || _a === void 0 ? void 0 : _a.classList.contains('grid-split')) {\n            splitter = targetElement.nextElementSibling;\n            neighborItem = splitter.nextElementSibling;\n        }\n        else {\n            splitter = targetElement.previousElementSibling;\n            neighborItem = splitter.previousElementSibling;\n        }\n        const parentRect = targetElement.parentElement.getBoundingClientRect();\n        const targetRect = targetElement.getBoundingClientRect();\n        targetElement.style.width = `${targetElement.clientWidth}px`;\n        targetElement.style.height = `${targetElement.clientHeight}px`;\n        targetElement.style.left = `${targetRect.left - parentRect.left}px`;\n        targetElement.style.top = `${targetRect.top - parentRect.top}px`;\n        targetElement.style.position = 'absolute';\n        neighborItem.style.width = `${targetElement.clientWidth + splitter.clientWidth + neighborItem.clientWidth}px`;\n        splitter.style.display = 'none';\n    });\n    const handleDragEnd = hooks.useEventCallback((id) => {\n        var _a;\n        const targetElement = domRef.current.querySelector(`div[data-layoutitemid=\"${id}\"]`);\n        let splitter;\n        let neighborItem;\n        if ((_a = targetElement.nextElementSibling) === null || _a === void 0 ? void 0 : _a.classList.contains('grid-split')) {\n            splitter = targetElement.nextElementSibling;\n            neighborItem = splitter.nextElementSibling;\n        }\n        else {\n            splitter = targetElement.previousElementSibling;\n            neighborItem = splitter.previousElementSibling;\n        }\n        targetElement.style.width = null;\n        targetElement.style.height = null;\n        targetElement.style.left = null;\n        targetElement.style.top = null;\n        targetElement.style.position = null;\n        neighborItem.style.width = null;\n        splitter.style.display = null;\n    });\n    const createItem = (itemId, isLast) => {\n        return (jsx(React.Fragment, { key: itemId },\n            jsx(GridItemComponent, { key: itemId, className: 'grid-row-item', layout: layout, layoutItemId: itemId, onDragStart: handleDragStart, onDragEnd: handleDragEnd }),\n            !isLast && (jsx(Splitter, { referenceItemId: itemId, layoutId: layout.id, direction: 'row', onResizeEnd: handleResizeEnd }))));\n    };\n    const theme2 = getTheme2();\n    // position relative only works when an item need to be dragged, so that its origin is top left of the row\n    // otherwise, position should not set in order to make the maximize work.\n    return (jsx(\"div\", { className: `d-flex ${className}`, css: css `\r\n        position: ${isDesignMode ? 'relative' : 'initial'};\r\n        .is-last {\r\n          width: auto;\r\n          flex-grow: 1;\r\n          flex-shrink: 1;\r\n          flex-basis: 0;\r\n        }\r\n        &.menu-active > .grid-row-item {\r\n          &:after {\r\n            content: '';\r\n            position: absolute;\r\n            left: 0;\r\n            top: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            opacity: 0.3;\r\n            background: ${theme2.sys.color.primary.main};\r\n          }\r\n        }\r\n        &.menu-active > .grid-row-item:nth-of-type(4n-1):after {\r\n          background: ${theme2.sys.color.error.dark};\r\n          opacity: 0.6;\r\n        }\r\n      `, \"data-layoutid\": layout.id, \"data-layoutitemid\": layoutItemId, ref: domRef },\n        items.map((item, index) => createItem(item, index === items.length - 1)),\n        selected && (jsx(GridItemToolbar, { layoutId: layout.id, layoutItem: layout.content[layoutItemId], refElement: domRef.current }))));\n}\nfunction ColContainer(props) {\n    const { layout, layoutItemId, items, className } = props;\n    const domRef = React.useRef();\n    const isDesignMode = ReactRedux.useSelector((state) => {\n        var _a;\n        return ((_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.appMode) === AppMode.Design;\n    });\n    const selected = ReactRedux.useSelector((state) => {\n        const selection = state.appRuntimeInfo.selection;\n        return (selection === null || selection === void 0 ? void 0 : selection.layoutId) === layout.id && (selection === null || selection === void 0 ? void 0 : selection.layoutItemId) === layoutItemId;\n    });\n    const handleResizeEnd = hooks.useEventCallback((id, dx, dy) => {\n        const appConfigAction = getAppConfigAction();\n        const index = items.indexOf(id);\n        const nextId = items[index + 1];\n        const layoutItem = layout.content[id];\n        const nextLayoutItem = layout.content[nextId];\n        appConfigAction.editLayoutItemProperty({\n            layoutId: layout.id,\n            layoutItemId: id\n        }, 'bbox', { width: +layoutItem.bbox.width + dy }, true).editLayoutItemProperty({\n            layoutId: layout.id,\n            layoutItemId: nextId\n        }, 'bbox', { width: +nextLayoutItem.bbox.width - dy }, true).exec();\n    });\n    const handleDragStart = hooks.useEventCallback((id) => {\n        var _a;\n        const targetElement = domRef.current.querySelector(`div[data-layoutitemid=\"${id}\"]`);\n        let splitter;\n        let neighborItem;\n        if ((_a = targetElement.nextElementSibling) === null || _a === void 0 ? void 0 : _a.classList.contains('grid-split')) {\n            splitter = targetElement.nextElementSibling;\n            neighborItem = splitter.nextElementSibling;\n        }\n        else {\n            splitter = targetElement.previousElementSibling;\n            neighborItem = splitter.previousElementSibling;\n        }\n        const parentRect = targetElement.parentElement.getBoundingClientRect();\n        const targetRect = targetElement.getBoundingClientRect();\n        targetElement.style.width = `${targetElement.clientWidth}px`;\n        targetElement.style.height = `${targetElement.clientHeight}px`;\n        targetElement.style.left = `${targetRect.left - parentRect.left}px`;\n        targetElement.style.top = `${targetRect.top - parentRect.top}px`;\n        targetElement.style.position = 'absolute';\n        neighborItem.style.height = `${targetElement.clientHeight + splitter.clientHeight + neighborItem.clientHeight}px`;\n        splitter.style.display = 'none';\n    });\n    const handleDragEnd = hooks.useEventCallback((id) => {\n        var _a;\n        const targetElement = domRef.current.querySelector(`div[data-layoutitemid=\"${id}\"]`);\n        let splitter;\n        let neighborItem;\n        if ((_a = targetElement.nextElementSibling) === null || _a === void 0 ? void 0 : _a.classList.contains('grid-split')) {\n            splitter = targetElement.nextElementSibling;\n            neighborItem = splitter.nextElementSibling;\n        }\n        else {\n            splitter = targetElement.previousElementSibling;\n            neighborItem = splitter.previousElementSibling;\n        }\n        targetElement.style.width = null;\n        targetElement.style.height = null;\n        targetElement.style.left = null;\n        targetElement.style.top = null;\n        targetElement.style.position = null;\n        neighborItem.style.height = null;\n        splitter.style.display = null;\n    });\n    const createItem = (itemId, isLast) => {\n        return (jsx(React.Fragment, { key: itemId },\n            jsx(GridItemComponent, { key: itemId, className: 'grid-col-item', layout: layout, layoutItemId: itemId, onDragStart: handleDragStart, onDragEnd: handleDragEnd }),\n            !isLast && (jsx(Splitter, { referenceItemId: itemId, layoutId: layout.id, direction: 'col', onResizeEnd: handleResizeEnd }))));\n    };\n    const theme2 = getTheme2();\n    return (jsx(\"div\", { className: `d-flex flex-column ${className}`, css: css `\r\n        position: ${isDesignMode ? 'relative' : 'initial'};\r\n        .is-last {\r\n          height: auto;\r\n          flex-grow: 1;\r\n          flex-shrink: 1;\r\n          flex-basis: 0;\r\n        }\r\n        &.menu-active > .grid-col-item {\r\n          &:after {\r\n            content: '';\r\n            position: absolute;\r\n            left: 0;\r\n            top: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            opacity: 0.3;\r\n            background: ${theme2.sys.color.primary.main};\r\n          }\r\n        }\r\n        &.menu-active > .grid-col-item:nth-of-type(4n-1):after {\r\n          background: ${theme2.sys.color.error.dark};\r\n          opacity: 0.6;\r\n        }\r\n      `, \"data-layoutid\": layout.id, \"data-layoutitemid\": layoutItemId, ref: domRef },\n        items.map((item, index) => createItem(item, index === items.length - 1)),\n        selected && (jsx(GridItemToolbar, { layoutId: layout.id, layoutItem: layout.content[layoutItemId], refElement: domRef.current }))));\n}\nfunction TabContainer(props) {\n    var _a;\n    const { layout, layoutItemId, items, className, onDragStart, onDragEnd } = props;\n    const isDesignMode = ReactRedux.useSelector((state) => {\n        var _a;\n        return ((_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.appMode) === AppMode.Design;\n    });\n    const [activeTab, setActiveTab] = React.useState(0);\n    const domRef = React.useRef();\n    const originRectRef = React.useRef();\n    const dragPlaceholderRef = React.useRef();\n    const isRootItem = ((_a = layout.setting) === null || _a === void 0 ? void 0 : _a.rootItem) === layoutItemId;\n    hooks.useEffectOnce(() => {\n        let interactable = interact(domRef.current).origin('parent');\n        interactable = bindDragHandler(interactable, {\n            layoutId: layout.id,\n            layoutItemId,\n            useDragHandler: false,\n            itemType: LayoutItemType.Widget,\n            rootLayoutId: null,\n            restrict: null,\n            onDragStart,\n            onDragEnd\n        });\n        interactable.draggable({\n            modifiers: [\n                interact.modifiers.restrictRect({\n                    restriction: `div.grid-layout[data-layoutid=\"${layout.id}\"]`\n                })\n            ]\n        });\n        return () => {\n            if (interactable) {\n                interactable.unset();\n                interactable = null;\n            }\n        };\n    });\n    React.useEffect(() => {\n        if (domRef.current) {\n            if (isRootItem) {\n                interact(domRef.current).draggable(false);\n            }\n            else {\n                interact(domRef.current).draggable(true);\n            }\n        }\n    }, [isRootItem]);\n    const active = React.useMemo(() => {\n        var _a;\n        const layoutItem = getGridItem(layout, layoutItemId);\n        return (_a = layoutItem.activeTab) !== null && _a !== void 0 ? _a : 0;\n    }, [layout, layoutItemId]);\n    React.useEffect(() => {\n        setActiveTab(active);\n    }, [active]);\n    const handleTabChange = hooks.useEventCallback((id) => {\n        const index = items.indexOf(id);\n        setActiveTab(index);\n    });\n    const handleTabDragStart = hooks.useEventCallback((id) => {\n        const idx = items.indexOf(id);\n        if (idx === items.length - 1) {\n            setActiveTab(items.length - 2);\n        }\n        else {\n            setActiveTab(idx + 1);\n        }\n    });\n    const handleDragStart = hooks.useEventCallback((id) => {\n        const targetElement = domRef.current.querySelector(`div[data-layoutitemid=\"${id}\"]`);\n        const targetRect = targetElement.getBoundingClientRect();\n        originRectRef.current = targetRect;\n        const elem = createDraggingPlaceholder(targetRect);\n        dragPlaceholderRef.current = document.body.appendChild(elem);\n        const idx = items.indexOf(id);\n        if (idx === items.length - 1) {\n            setActiveTab(items.length - 2);\n        }\n        else {\n            setActiveTab(idx + 1);\n        }\n    });\n    const handleDragging = hooks.useEventCallback((id, dx, dy) => {\n        // set display to none will cause the moving item out of view\n        const ox = dx - originRectRef.current.left;\n        const oy = dy - originRectRef.current.top;\n        dragPlaceholderRef.current.style.transform = `translate(${Math.round(ox)}px, ${Math.round(oy)}px) translateZ(0)`;\n    });\n    const handleDragEnd = hooks.useEventCallback((id) => {\n        document.body.removeChild(dragPlaceholderRef.current);\n        dragPlaceholderRef.current = null;\n    });\n    const createItem = (itemId, index) => {\n        return (jsx(DraggableTab, { key: itemId, id: itemId, title: `${index}`, layoutId: layout.id, layoutItemId: itemId, onDragStart: handleTabDragStart },\n            jsx(GridItemComponent, { layout: layout, layoutItemId: itemId, onDragStart: handleDragStart, onDragging: handleDragging, onDragEnd: handleDragEnd })));\n    };\n    return (jsx(\"div\", { className: classNames(className, 'exb-rnd'), \"data-layoutid\": layout.id, \"data-layoutitemid\": layoutItemId, css: css `${isDesignMode ? 'relative' : 'initial'};`, ref: domRef },\n        jsx(Tabs, { type: 'tabs', fill: true, scrollable: true, className: 'w-100 h-100', value: items[activeTab], onChange: handleTabChange, css: css `\r\n          & > .tab-content {\r\n            overflow: hidden;\r\n          }\r\n        ` }, [...items].map((item, index) => createItem(item, index)))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, AppMode, getAppStore, BrowserSizeMode, hooks, LayoutItemType, GridItemType } from 'jimu-core';\nimport { Button } from 'jimu-ui';\nimport { TemplateSelector, WidgetListPopper } from 'jimu-ui/advanced/setting-components';\nimport { getAppConfigAction, appBuilderSync } from 'jimu-for-builder';\nimport { getGridTemplates, getFullScreenGridPageTemplates } from 'jimu-for-builder/templates';\nimport { withBuilderTheme } from 'jimu-theme';\nimport { ThemedTooltip } from '../../builder/theme-tooltip';\nimport { updateLayoutAndSelection } from '../../builder/common-layout-actions';\nimport { PlusOutlined } from 'jimu-icons/outlined/editor/plus';\nimport { GridTemplateOutlined } from 'jimu-icons/outlined/application/grid-template';\nconst ThemeWidgetListPopper = withBuilderTheme(WidgetListPopper);\nconst buttonStyle = css `\r\n  pointer-events: auto;\r\n`;\nfunction getStyle(isGridPage) {\n    return css `\r\n    body.lock-layout &,\r\n    body:not(.design-mode) & {\r\n      display: none !important;\r\n    }\r\n\r\n    display: flex;\r\n    height: ${isGridPage ? '200px' : '100%'};\r\n    padding: 1rem;\r\n    pointer-events: none;\r\n    position: relative;\r\n    z-index: 1;\r\n    .btn-text {\r\n      line-height: 32px;\r\n    }\r\n    .btn {\r\n      margin-right: 8px;\r\n    }\r\n    .action-item {\r\n      width: 32px;\r\n    }\r\n    .action-separator {\r\n      width: 300px;\r\n      height: 1px;\r\n      background-color: var(--ref-palette-neutral-400);\r\n    }\r\n  `;\n}\nexport function ActionBlock(props) {\n    const { layoutId, pageContext, onTemplateSelected, onPageTemplateSelected } = props;\n    const { formatMessage, rootLayoutId } = pageContext;\n    const [showTemplatePopper, setShowTemplatePopper] = React.useState(false);\n    const [showPageTemplatePopper, setShowPageTemplatePopper] = React.useState(false);\n    const [showWidgetPopper, setShowWidgetPopper] = React.useState(false);\n    const isGridPage = layoutId === rootLayoutId;\n    const placeholderRef = React.useRef(null);\n    const templateRef = React.useRef(null);\n    const pageTemplateRef = React.useRef(null);\n    const show = ReactRedux.useSelector((state) => {\n        var _a, _b, _c;\n        const lockLayout = (_c = (_b = (_a = state.appConfig) === null || _a === void 0 ? void 0 : _a.forBuilderAttributes) === null || _b === void 0 ? void 0 : _b.lockLayout) !== null && _c !== void 0 ? _c : false;\n        const isDesignMode = state.appRuntimeInfo.appMode === AppMode.Design;\n        return isDesignMode && !lockLayout;\n    });\n    hooks.useEffectOnce(() => {\n        if (!isGridPage && getAppStore().getState().browserSizeMode !== BrowserSizeMode.Small) {\n            setShowTemplatePopper(true);\n        }\n    });\n    const templateTooltip = formatMessage('chooseTemplate', {\n        type: formatMessage('grid').toLocaleLowerCase()\n    });\n    const pageTemplateTooltip = formatMessage('chooseTemplate', {\n        type: formatMessage('page').toLocaleLowerCase()\n    });\n    const toggleTemplatePopper = (e) => {\n        e.stopPropagation();\n        if (getAppStore().getState().browserSizeMode === BrowserSizeMode.Small) {\n            appBuilderSync.publishSidePanelToApp({ type: 'template', templateMethod: 'getGridTemplates', onSelect: handleTemplateSelected });\n            return;\n        }\n        setShowTemplatePopper(!showTemplatePopper);\n    };\n    const closeTemplatePopper = () => {\n        setShowTemplatePopper(false);\n    };\n    const togglePageTemplatePopper = (e) => {\n        e.stopPropagation();\n        if (getAppStore().getState().browserSizeMode === BrowserSizeMode.Small) {\n            appBuilderSync.publishSidePanelToApp({ type: 'template', templateMethod: 'getFullScreenGridPageTemplates', onSelect: handlePageTemplateSelected });\n            return;\n        }\n        setShowPageTemplatePopper(!showPageTemplatePopper);\n    };\n    const closePageTemplatePopper = () => {\n        setShowPageTemplatePopper(false);\n    };\n    const toggleWidgetPopper = (e) => {\n        e.stopPropagation();\n        if (getAppStore().getState().browserSizeMode === BrowserSizeMode.Small) {\n            appBuilderSync.publishSidePanelToApp({ type: 'widget', isPlaceholder: false, isItemAccepted: () => true, onSelect: handleWidgetSelected });\n            return;\n        }\n        setShowWidgetPopper(!showWidgetPopper);\n    };\n    const closeWidgetPopper = () => {\n        setShowWidgetPopper(false);\n    };\n    const handleTemplateSelected = (template) => {\n        setShowTemplatePopper(false);\n        onTemplateSelected(template);\n    };\n    const handlePageTemplateSelected = (template) => {\n        setShowPageTemplatePopper(false);\n        onPageTemplateSelected(template);\n    };\n    const handleWidgetSelected = (item) => {\n        setShowWidgetPopper(false);\n        const appConfigAction = getAppConfigAction();\n        let res;\n        if (item.itemType === LayoutItemType.Section) {\n            res = new Promise(resolve => {\n                resolve(appConfigAction.addNewSectionToLayout(layoutId));\n            });\n        }\n        else {\n            res = appConfigAction.addNewWidgetToLayout(layoutId, { uri: item.uri, itemId: item.itemId });\n        }\n        res.then(layoutItemId => {\n            const rootLayoutInfo = { layoutId, layoutItemId };\n            appConfigAction\n                .editLayoutProperty(layoutId, 'setting.rootItem', layoutItemId)\n                .editLayoutItemProperty(rootLayoutInfo, 'bbox', { width: 100 })\n                .editLayoutItemProperty(rootLayoutInfo, 'gridType', GridItemType.Plain);\n            updateLayoutAndSelection(appConfigAction.appConfig, rootLayoutInfo);\n        });\n    };\n    if (!show) {\n        return null;\n    }\n    return (jsx(\"div\", { className: 'w-100 flex-column justify-content-center align-items-center', css: getStyle(isGridPage) },\n        jsx(\"div\", { className: 'd-flex justify-content-center align-items-center' },\n            !isGridPage && (jsx(React.Fragment, null,\n                jsx(ThemedTooltip, { placement: 'bottom', title: formatMessage('addWidget') },\n                    jsx(Button, { icon: true, ref: placeholderRef, css: buttonStyle, onClick: toggleWidgetPopper, \"aria-haspopup\": true },\n                        jsx(PlusOutlined, { size: 16 }))),\n                jsx(ThemedTooltip, { placement: 'bottom', title: templateTooltip },\n                    jsx(\"div\", { className: 'action-item' },\n                        jsx(Button, { ref: templateRef, icon: true, onClick: toggleTemplatePopper, css: buttonStyle, \"aria-haspopup\": true },\n                            jsx(GridTemplateOutlined, { autoFlip: true, size: 16 })))))),\n            isGridPage && (jsx(ThemedTooltip, { placement: 'bottom', title: pageTemplateTooltip },\n                jsx(\"div\", { className: 'action-item' },\n                    jsx(Button, { ref: pageTemplateRef, icon: true, onClick: togglePageTemplatePopper, css: buttonStyle, className: 'rounded-circle', \"aria-haspopup\": true },\n                        jsx(GridTemplateOutlined, { autoFlip: true, size: 16 })))))),\n        isGridPage && (jsx(React.Fragment, null,\n            jsx(\"div\", { className: 'action-separator mt-4' }),\n            jsx(\"div\", null,\n                jsx(\"h5\", { className: 'btn-text mt-2' }, formatMessage('dropWidgetToAdd'))))),\n        showTemplatePopper && (jsx(TemplateSelector, { templates: getGridTemplates(), referenceElement: templateRef.current, onItemSelect: handleTemplateSelected, onClose: closeTemplatePopper })),\n        showWidgetPopper && (jsx(ThemeWidgetListPopper, { referenceElement: placeholderRef.current, isAccepted: () => true, onSelect: handleWidgetSelected, onClose: closeWidgetPopper })),\n        showPageTemplatePopper && (jsx(TemplateSelector, { templates: getFullScreenGridPageTemplates(false), referenceElement: pageTemplateRef.current, onItemSelect: handlePageTemplateSelected, onClose: closePageTemplatePopper }))));\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/** @jsx jsx */\nimport { React, ReactRedux, classNames, jsx, css, polished, getAppStore, appActions, BrowserSizeMode, Immutable, OneByOneAnimation, ExtensionManager, extensionSpec, LayoutType, lodash, IntersectionContext } from 'jimu-core';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { utils, PageContext } from 'jimu-layouts/layout-runtime';\nimport { DropArea } from '../../builder/interactive/droparea-hook';\nimport { GLOBAL_DRAGGING_CLASS_NAME, GLOBAL_H5_DRAGGING_CLASS_NAME } from '../../builder/interactive/drag-event-handler';\nimport { addItemToGrid, splitGrid } from './utils';\nimport { getGridItem, calPaddingStyle } from '../common/utils';\nimport { GridItemComponent } from './grid-item';\nimport { SideType } from './types';\nimport { ActionBlock } from './action-block';\nimport { getTheme2 } from 'jimu-theme';\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  top: 0;\r\n  right: 0;\r\n  background: transparent;\r\n  display: flex;\r\n`;\nconst getStyle = (layoutSetting) => {\n    const theme2 = getTheme2();\n    const padding = calPaddingStyle(layoutSetting);\n    return css `\r\n    overflow: hidden;\r\n    position: relative;\r\n    ${padding}\r\n\r\n    .grid-root-drop-area {\r\n      position: absolute;\r\n      background: rgba(0, 0, 0, 0.4);\r\n      border: 2px solid rgba(255, 255, 255, 0.04);\r\n      box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.3);\r\n      border-radius: 7px;\r\n      display: none !important;\r\n      z-index: 30;\r\n\r\n      &.top {\r\n        top: 2px;\r\n        left: 50%;\r\n        width: 60px;\r\n        height: 10px;\r\n        transform: translateX(-50%);\r\n      }\r\n\r\n      &.bottom {\r\n        bottom: 2px;\r\n        left: 50%;\r\n        width: 60px;\r\n        height: 10px;\r\n        transform: translateX(-50%);\r\n      }\r\n\r\n      &.right {\r\n        right: 2px;\r\n        top: 50%;\r\n        height: 60px;\r\n        width: 10px;\r\n        transform: translateY(-50%);\r\n      }\r\n\r\n      &.left {\r\n        left: 2px;\r\n        top: 50%;\r\n        height: 60px;\r\n        width: 10px;\r\n        transform: translateY(-50%);\r\n      }\r\n    }\r\n\r\n    .${GLOBAL_H5_DRAGGING_CLASS_NAME} &.drop-target > .grid-root-drop-area,\r\n    .${GLOBAL_DRAGGING_CLASS_NAME} &.drop-target > .grid-root-drop-area {\r\n      display: flex !important;\r\n    }\r\n\r\n    .highlight-area {\r\n      background: ${polished.rgba(theme2.sys.color.primary.dark, 0.2)};\r\n      position: absolute;\r\n      opacity: 0.6;\r\n      pointer-events: none;\r\n      display: none;\r\n\r\n      &.active {\r\n        display: block;\r\n      }\r\n\r\n      &.top {\r\n        top: 0;\r\n        width: 100%;\r\n        height: 50%;\r\n      }\r\n      &.bottom {\r\n        bottom: 0;\r\n        width: 100%;\r\n        height: 50%;\r\n      }\r\n      &.left {\r\n        left: 0;\r\n        width: 50%;\r\n        height: 100%;\r\n      }\r\n      &.right {\r\n        right: 0;\r\n        width: 50%;\r\n        height: 100%;\r\n      }\r\n      &.center {\r\n        top: 0;\r\n        left: 0;\r\n        width: 100%;\r\n        height: 100%;\r\n      }\r\n    }\r\n  `;\n};\nclass GridLayout extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.handleDragOver = () => null;\n        this.handleDragEnter = () => null;\n        this.handleDragLeave = () => null;\n        this.handleDrop = (draggingItem, containerRect, itemRect) => {\n            const { layout } = this.props;\n            const layoutInfo = {\n                layoutId: layout.id\n            };\n            let appConfigAction = getAppConfigAction();\n            addItemToGrid(appConfigAction.appConfig, draggingItem, layoutInfo, null, SideType.Center).then((result) => {\n                const { appConfig, layoutInfo: newLayoutInfo } = result;\n                appConfigAction = getAppConfigAction(appConfig);\n                appConfigAction.exec();\n                getAppStore().dispatch(appActions.selectionChanged(newLayoutInfo));\n            });\n        };\n        this.handleTemplateSelected = (templateGridJson) => __awaiter(this, void 0, void 0, function* () {\n            const appConfigAction = getAppConfigAction();\n            const { layout } = this.props;\n            yield appConfigAction.applyGridTemplate(layout.parent.id, templateGridJson);\n            appConfigAction.exec();\n        });\n        this.handlePageTemplateSelected = (templatePageJson) => {\n            const appConfigAction = getAppConfigAction();\n            this.setState({ isLoadingTemplate: true });\n            appConfigAction.applyPageBodyTemplate(this.pageContext.pageId, templatePageJson)\n                .then(() => {\n                appConfigAction.exec();\n                lodash.defer(() => {\n                    this.setState({ isLoadingTemplate: false });\n                });\n            }).finally(null);\n        };\n        this.highlight = (side) => {\n            this.tipRef.current.classList.add('active', side);\n        };\n        this.clearHighlight = (side) => {\n            this.tipRef.current.classList.remove('active', side);\n        };\n        const { layout } = this.props;\n        this.fakeLayouts = Immutable({\n            [BrowserSizeMode.Large]: `${layout.id}_tlarge`,\n            [BrowserSizeMode.Medium]: `${layout.id}_tmedium`,\n            [BrowserSizeMode.Small]: `${layout.id}_tsmall`\n        });\n        this.tipRef = React.createRef();\n    }\n    findExtension() {\n        const exts = ExtensionManager.getInstance().getExtensions(\n        //eslint-disable-next-line @typescript-eslint/no-unnecessary-template-expression\n        `${extensionSpec.ExtensionPoints.LayoutTransformer}`);\n        if ((exts === null || exts === void 0 ? void 0 : exts.length) > 0) {\n            const ext = exts.find(item => item.layoutType === LayoutType.GridLayout);\n            this.layoutTransform = ext === null || ext === void 0 ? void 0 : ext.transformLayout;\n        }\n    }\n    handleDropAtSide(draggingItem, side) {\n        this.clearHighlight(side);\n        const layoutId = this.props.layout.id;\n        let appConfigAction = getAppConfigAction();\n        this.tipRef.current.parentElement.classList.remove('drop-target');\n        splitGrid(appConfigAction.appConfig, draggingItem, layoutId, side).then(({ appConfig, itemId }) => {\n            appConfigAction = getAppConfigAction(appConfig);\n            appConfigAction.exec();\n            getAppStore().dispatch(appActions.selectionChanged({\n                layoutId,\n                layoutItemId: itemId\n            }));\n        });\n    }\n    render() {\n        var _a, _b, _c;\n        const { layouts, layout, browserSizeMode, mainSizeMode, className } = this.props;\n        const viewOnly = layouts[browserSizeMode] !== layout.id;\n        let finalLayout = layout;\n        if (viewOnly) {\n            if (this.layoutTransform == null) {\n                this.findExtension();\n            }\n            if (this.layoutTransform != null) {\n                finalLayout = this.layoutTransform(layout, mainSizeMode, browserSizeMode);\n            }\n        }\n        const { rootItem: rootItemId } = (_a = finalLayout.setting) !== null && _a !== void 0 ? _a : {};\n        const rootItem = getGridItem(finalLayout, rootItemId);\n        const outClass = classNames('layout grid-layout d-flex w-100 h-100', className);\n        const childrenSize = (_c = (_b = rootItem === null || rootItem === void 0 ? void 0 : rootItem.children) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\n        return (jsx(PageContext.Consumer, null, (props) => {\n            this.pageContext = props;\n            return (jsx(\"div\", { className: outClass, css: getStyle(finalLayout.setting), \"data-layoutid\": finalLayout.id },\n                jsx(IntersectionContext.Provider, { value: { monitor: false } },\n                    jsx(OneByOneAnimation, { oid: finalLayout.id, \"data-layoutid\": finalLayout.id, className: 'trail-container d-flex w-100 h-100', css: css `\r\n                    width: 100%;\r\n                  ` },\n                        rootItem == null && (jsx(DropArea, { css: dropareaStyle, layouts: this.props.layouts, highlightDragover: true, onDragEnter: this.handleDragEnter, onDragLeave: this.handleDragLeave, onDragOver: this.handleDragOver, onDrop: this.handleDrop },\n                            jsx(\"div\", { css: css `\r\n                          width: 100%;\r\n                          background: var(--cyan-500);\r\n                        ` }))),\n                        rootItem == null && !viewOnly && (jsx(ActionBlock, { layoutId: layout.id, pageContext: props, onTemplateSelected: this.handleTemplateSelected, onPageTemplateSelected: this.handlePageTemplateSelected })),\n                        rootItem\n                            ? jsx(GridItemComponent, { className: 'w-100 h-100', layout: finalLayout, layoutItemId: rootItemId })\n                            : this.props.children)),\n                childrenSize > 1 && ([SideType.Top, SideType.Right, SideType.Bottom, SideType.Left].map(side => (jsx(DropArea, { key: side, className: `${side} grid-root-drop-area shadow-sm`, layouts: this.fakeLayouts, onDrop: (draggingItem) => { this.handleDropAtSide(draggingItem, side); }, onDragEnter: () => { this.highlight(side); }, onDragLeave: () => { this.clearHighlight(side); } })))),\n                jsx(\"div\", { ref: this.tipRef, className: 'highlight-area' })));\n        }));\n    }\n}\nexport default ReactRedux.connect(utils.mapStateToLayoutProps)(GridLayout);\n","/** @jsx jsx */\nimport { React, jsx, css, classNames, utils, hooks, ReactRedux, LayoutItemType } from 'jimu-core';\nimport { interact } from 'jimu-core/dnd';\nimport { Button, Icon, styleUtils } from 'jimu-ui';\nimport { bindDragHandler, GLOBAL_DRAGGING_CLASS_NAME, GLOBAL_H5_DRAGGING_CLASS_NAME } from '../../builder/interactive/drag-event-handler';\nimport { bindResizeHandler } from '../../builder/interactive/resize-event-handler';\nimport { isLockLayout, isDesignMode } from '../../builder/menu/common-menu';\nimport SelectWrapper from '../../builder/select-wrapper';\nimport { ItemTitle } from '../common/item-title';\nimport { LayoutItemSizeModes, utils as layoutUtils, PageContext, searchUtils, CLICK_TOLERANCE } from 'jimu-layouts/layout-runtime';\nimport { accordionItemMenus } from './menus';\nconst getStyle = (options) => {\n    const { height, gap, headerConfig, panelConfig, isFunctionalWidget, isInlineEditing, isSection } = options;\n    const config = headerConfig !== null && headerConfig !== void 0 ? headerConfig : {};\n    const pConfig = panelConfig !== null && panelConfig !== void 0 ? panelConfig : {};\n    const { padding, expandedColor, collapsedColor, border, borderLeft, borderRight, borderTop, borderBottom, borderRadius } = config;\n    const { padding: panelPadding, border: panelBorder, borderRadius: panelBD, backgroundColor } = pConfig;\n    return css `\r\n  position: relative;\r\n  touch-action: none;\r\n  user-select: ${isInlineEditing ? 'auto' : 'none'};\r\n  & + .foldable-panel {\r\n    margin-top: ${gap}px;\r\n  }\r\n  .panel-header {\r\n    padding: ${styleUtils.toCSSPadding(padding)};\r\n    border: ${styleUtils.toCSSBorder(border)};\r\n    border-left: ${styleUtils.toCSSBorder(borderLeft)};\r\n    border-right: ${styleUtils.toCSSBorder(borderRight)};\r\n    border-top: ${styleUtils.toCSSBorder(borderTop)};\r\n    border-bottom: ${styleUtils.toCSSBorder(borderBottom)};\r\n    border-radius: ${styleUtils.toCSSBorderRadius(borderRadius)};\r\n    background-color: ${expandedColor !== null && expandedColor !== void 0 ? expandedColor : 'var(--sys-color-primary-main)'};\r\n    .tool-drag-handler {\r\n      cursor: pointer;\r\n      flex-grow: 1;\r\n      flex-shrink: 1;\r\n    }\r\n  }\r\n  .panel-content {\r\n    padding: ${styleUtils.toCSSPadding(panelPadding)};\r\n    border: ${styleUtils.toCSSBorder(panelBorder)};\r\n    border-left: ${styleUtils.toCSSBorder(pConfig.borderLeft)};\r\n    border-right: ${styleUtils.toCSSBorder(pConfig.borderRight)};\r\n    border-top: ${styleUtils.toCSSBorder(pConfig.borderTop)};\r\n    border-bottom: ${styleUtils.toCSSBorder(pConfig.borderBottom)};\r\n    border-radius: ${styleUtils.toCSSBorderRadius(panelBD)};\r\n    overflow: auto;\r\n    background-color: ${backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : 'none'};\r\n    position: relative;\r\n    height: ${height};\r\n    opacity: 1;\r\n    transition: opacity 400ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;\r\n  }\r\n  &.collapsed {\r\n    .panel-header {\r\n      background-color: ${collapsedColor !== null && collapsedColor !== void 0 ? collapsedColor : 'var(--sys-color-primary-main)'};\r\n    }\r\n    .panel-content {\r\n      height: 0;\r\n      padding: unset;\r\n      border: none;\r\n      visibility: hidden;\r\n      .layout-item {\r\n        display: none;\r\n      }\r\n    }\r\n  }\r\n  .${GLOBAL_H5_DRAGGING_CLASS_NAME} &.functional-widget {\r\n     pointer-events: none;\r\n   }\r\n   .${GLOBAL_H5_DRAGGING_CLASS_NAME} &.functional-widget .exb-drop-area {\r\n     pointer-events: all;\r\n   }\r\n\r\n   .${GLOBAL_H5_DRAGGING_CLASS_NAME} &,\r\n   .${GLOBAL_DRAGGING_CLASS_NAME} & {\r\n     > div.highlight-tip {\r\n       .tip-content {\r\n         outline-color: var(--ref-palette-neutral-900);\r\n       }\r\n     }\r\n   }\r\n   body:not(.design-mode) &,\r\n      body.lock-layout & {\r\n        cursor: default;\r\n      }\r\n\r\n      body:not(.design-mode) & > div.highlight-tip {\r\n        display: none !important;\r\n      }\r\n\r\n      & > div.highlight-tip {\r\n        display: block;\r\n        padding: inherit;\r\n        position: absolute;\r\n        left: 0;\r\n        bottom: 0;\r\n        top: 0;\r\n        right: 0;\r\n        pointer-events: none;\r\n        .tip-content {\r\n          height: 100%;\r\n          padding: 1px;\r\n          &:after {\r\n            content: '';\r\n            width: 100%;\r\n            height: 100%;\r\n            outline: 1px dashed var(--ref-palette-neutral-900);\r\n            display: block;\r\n            outline-color: ${!isFunctionalWidget || isSection\n        ? 'var(--ref-palette-neutral-900)'\n        : 'transparent'};\r\n          }\r\n        }\r\n      }\r\n\r\n      &:hover > div.highlight-tip,\r\n      &.hovered > div.highlight-tip {\r\n        display: block;\r\n        .tip-content {\r\n          &:after {\r\n            outline-color: var(--sys-color-primary-main);\r\n          }\r\n        }\r\n      }\r\n\r\n      &.functional-widget:not(.selected):hover > div.highlight-tip,\r\n      &.functional-widget:not(.selected).hovered > div.highlight-tip {\r\n        .tip-content {\r\n          &:after {\r\n            outline-width: 2px;\r\n          }\r\n        }\r\n      }\r\n  `;\n};\nexport function Panel(props) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n    const { layoutId, layoutItemId, expanded, selected, resizable, isResizing, isInlineEditing, height, gap, onExpandedChange, onClick, onDoubleClick, onResizeStart, onResizeEnd, onResizing } = props;\n    const dragElementRef = React.useRef(null);\n    const resizeElementRef = React.useRef(null);\n    const mousedownPositionRef = React.useRef({ x: 0, y: 0 });\n    const translate = hooks.useTranslation();\n    const { viewOnly } = React.useContext(PageContext);\n    const layoutItem = ReactRedux.useSelector((state) => {\n        return searchUtils.findLayoutItem(state.appConfig, { layoutId, layoutItemId });\n    });\n    const label = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        if (layoutItem.type === LayoutItemType.Widget) {\n            const widgetId = layoutItem.widgetId;\n            const widgetJson = state.appConfig.widgets[widgetId];\n            return (_a = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.label) !== null && _a !== void 0 ? _a : '';\n        }\n        const sectionId = layoutItem.sectionId;\n        const sectionJson = state.appConfig.sections[sectionId];\n        return (_b = sectionJson === null || sectionJson === void 0 ? void 0 : sectionJson.label) !== null && _b !== void 0 ? _b : '';\n    });\n    const isFunctionalWidget = ReactRedux.useSelector((state) => {\n        if (layoutItem.type === LayoutItemType.Widget) {\n            return layoutUtils.isFunctionalWidget(layoutItem.widgetId, state.appConfig);\n        }\n        return false;\n    });\n    const headerConfig = ReactRedux.useSelector((state) => {\n        var _a;\n        const layoutJson = state.appConfig.layouts[layoutId];\n        const parentWidgetId = layoutJson.parent.id;\n        const widgetJson = state.appConfig.widgets[parentWidgetId];\n        return (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.header;\n    });\n    const panelConfig = ReactRedux.useSelector((state) => {\n        var _a;\n        const layoutJson = state.appConfig.layouts[layoutId];\n        const parentWidgetId = layoutJson.parent.id;\n        const widgetJson = state.appConfig.widgets[parentWidgetId];\n        return (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.panel;\n    });\n    const isSection = ReactRedux.useSelector((state) => {\n        return layoutItem.type === LayoutItemType.Section;\n    });\n    React.useEffect(() => {\n        const handleResizeStart = (id, initWidth, initHeight) => {\n            // the initHeight should minus the height of the header\n            const panelHeader = resizeElementRef.current.querySelector('.panel-header');\n            let contentHeight = initHeight;\n            if (panelHeader) {\n                contentHeight = initHeight - panelHeader.clientHeight;\n            }\n            onResizeStart(id, initWidth, contentHeight);\n        };\n        let dragInteractable = interact(dragElementRef.current).origin('parent');\n        dragInteractable = bindDragHandler(dragInteractable, {\n            layoutId,\n            layoutItemId,\n            onDragging: null,\n            useDragHandler: true,\n            itemType: null,\n            rootLayoutId: () => '',\n            restrict: () => false\n        });\n        let resizeInteractable = interact(resizeElementRef.current).origin('parent');\n        resizeInteractable = bindResizeHandler(resizeInteractable, {\n            layoutItemId,\n            restrictEdges: false,\n            onResizeStart: handleResizeStart,\n            onResizing,\n            onResizeEnd\n        });\n        return () => {\n            dragInteractable === null || dragInteractable === void 0 ? void 0 : dragInteractable.unset();\n            resizeInteractable === null || resizeInteractable === void 0 ? void 0 : resizeInteractable.unset();\n        };\n    }, [layoutId, layoutItemId, onResizeStart, onResizing, onResizeEnd]);\n    React.useEffect(() => {\n        interact(dragElementRef.current).resizable(resizable);\n    }, [resizable]);\n    const toggleCollapse = React.useCallback((e) => {\n        // prevent toggle when dragging\n        const { x, y } = mousedownPositionRef.current;\n        if (Math.abs(e.screenX - x) > CLICK_TOLERANCE || Math.abs(e.screenY - y) > CLICK_TOLERANCE) {\n            e.stopPropagation();\n            return;\n        }\n        onExpandedChange(layoutItemId, !expanded);\n    }, [layoutItemId, expanded, onExpandedChange]);\n    const handlePanelClick = React.useCallback((e) => {\n        if (viewOnly ||\n            ((isLockLayout() || !isDesignMode()) &&\n                !isFunctionalWidget &&\n                layoutItem.type !== LayoutItemType.Section)) {\n            // propagate normally in view mode\n            return;\n        }\n        e.stopPropagation();\n        onClick();\n    }, [viewOnly, isFunctionalWidget, layoutItem.type, onClick]);\n    /**\n     * Enable inline editing mode for the widget\n     *\n     * @memberof LayoutItemInBuilder\n     */\n    const handleDoubleClick = React.useCallback((e) => {\n        if (viewOnly) {\n            return;\n        }\n        e.stopPropagation();\n        onDoubleClick();\n    }, [viewOnly, onDoubleClick]);\n    const handleMouseDown = React.useCallback((e) => {\n        mousedownPositionRef.current = { x: e.screenX, y: e.screenY };\n    }, []);\n    function canDrag() {\n        const isTouchDevice = utils.isTouchDevice();\n        return (!viewOnly &&\n            !isInlineEditing &&\n            (!isTouchDevice || selected));\n    }\n    const togglePosition = (_a = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.togglePosition) !== null && _a !== void 0 ? _a : 'right';\n    const isAutoHeight = ((_c = (_b = layoutItem.setting) === null || _b === void 0 ? void 0 : _b.autoProps) === null || _c === void 0 ? void 0 : _c.height) === LayoutItemSizeModes.Auto;\n    const useAspectRatio = layoutUtils.shouldUseAspectRatio((_d = layoutItem.setting) !== null && _d !== void 0 ? _d : {});\n    let calHeight = height;\n    if (isResizing) {\n        calHeight = height;\n    }\n    else if (isAutoHeight || useAspectRatio) {\n        calHeight = 'auto';\n    }\n    const icon = expanded ? (_e = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.collapseIcon) === null || _e === void 0 ? void 0 : _e.svg : (_f = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.expandIcon) === null || _f === void 0 ? void 0 : _f.svg;\n    return (jsx(\"div\", { className: classNames('builder-layout-item exb-rnd foldable-panel', {\n            selected,\n            collapsed: !expanded,\n            'no-drag-action': !canDrag(),\n            'functional-widget': isFunctionalWidget\n        }), \"data-layoutid\": layoutId, \"data-layoutitemid\": layoutItemId, ref: dragElementRef, onClick: handlePanelClick, onDoubleClick: handleDoubleClick, onKeyDown: null, css: getStyle({ height: calHeight, gap, headerConfig, panelConfig, isFunctionalWidget, isInlineEditing, isSection }) },\n        jsx(\"div\", { className: 'panel d-flex flex-column', ref: resizeElementRef },\n            jsx(\"div\", { className: classNames('panel-header d-flex align-items-center', { 'flex-row-reverse': togglePosition === 'left' }), onClick: toggleCollapse, onMouseDown: handleMouseDown, onKeyDown: null, role: 'group', \"aria-label\": label },\n                jsx(\"div\", { className: 'tool-drag-handler' }, layoutId && layoutItemId && jsx(ItemTitle, { layoutId: layoutId, layoutItemId: layoutItemId })),\n                icon && (jsx(\"div\", { className: classNames('actions', { 'ml-auto': togglePosition === 'right' }) },\n                    jsx(Button, { icon: true, type: 'tertiary', size: 'sm', \"aria-expanded\": expanded, title: translate(expanded ? 'clickToHide' : 'clickToShow'), \"aria-label\": translate(expanded ? 'clickToHide' : 'clickToShow') },\n                        jsx(Icon, { icon: icon, size: expanded\n                                ? (_h = (_g = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.collapseIcon) === null || _g === void 0 ? void 0 : _g.properties) === null || _h === void 0 ? void 0 : _h.size\n                                : (_k = (_j = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.expandIcon) === null || _j === void 0 ? void 0 : _j.properties) === null || _k === void 0 ? void 0 : _k.size, color: expanded\n                                ? (_m = (_l = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.collapseIcon) === null || _l === void 0 ? void 0 : _l.properties) === null || _m === void 0 ? void 0 : _m.color\n                                : (_p = (_o = headerConfig === null || headerConfig === void 0 ? void 0 : headerConfig.expandIcon) === null || _o === void 0 ? void 0 : _o.properties) === null || _p === void 0 ? void 0 : _p.color }))))),\n            jsx(\"div\", { className: classNames('panel-content d-flex flex-grow-1 flex-shrink-1') }, props.children),\n            selected && (jsx(SelectWrapper, { layoutId: layoutId, layoutItem: layoutItem, top: false, left: false, right: false, bottom: expanded && !isAutoHeight && !useAspectRatio, resizable: expanded && !isAutoHeight && !useAspectRatio, draggable: true, selected: true, forbidToolbar: false, toolItems: accordionItemMenus, showDefaultTools: true, isInlineEditing: false, isFunctionalWidget: true, hasEmbeddedLayout: false, isSection: false, hasExtension: false }))),\n        jsx(\"div\", { className: 'highlight-tip' },\n            jsx(\"div\", { className: 'tip-content' }))));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, classNames, jsx, css, LayoutType, createSelector } from 'jimu-core';\nimport { LayoutServiceProvider, getAppConfigAction } from 'jimu-for-builder';\nimport { utils, PageContext } from 'jimu-layouts/layout-runtime';\nimport { calInsertPositionForColumn } from '../../column-layout/builder/dnd-helper';\nimport { DropArea } from '../../builder/interactive/droparea-hook';\nimport { addItemToLayout } from '../../builder/common-layout-actions';\nimport { AccordionItem } from './layout-item';\nimport { CanvasPane } from '../../builder/interactive/canvas-pane';\nimport { ToggleAllButtonGroup } from '../common/toggle-all';\nimport { styleUtils } from 'jimu-ui';\nimport { getParentWidgetJson } from '../util';\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  top: 0;\r\n  right: 0;\r\n  background: transparent;\r\n`;\nconst guideOverlay = css `\r\n  ${dropareaStyle};\r\n  z-index: 20;\r\n  pointer-events: none;\r\n`;\nconst dropIndicatorSize = 10;\nfunction findTheMissingItem(less, more) {\n    return more.find(item => !less.includes(item));\n}\nclass Layout extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.handleExpandedChange = (layoutItemId, expanded) => {\n            if (expanded) {\n                if (this.props.singleMode) {\n                    this.setState({\n                        expandedItems: [layoutItemId]\n                    });\n                }\n                else if (!this.state.expandedItems.includes(layoutItemId)) {\n                    this.setState({\n                        expandedItems: [...this.state.expandedItems, layoutItemId]\n                    });\n                }\n            }\n            else {\n                if (this.state.expandedItems.includes(layoutItemId)) {\n                    this.setState({\n                        expandedItems: this.state.expandedItems.filter((id) => id !== layoutItemId)\n                    });\n                }\n            }\n        };\n        this.expandAll = () => {\n            const { layout } = this.props;\n            this.setState({\n                expandedItems: [...layout.order]\n            });\n        };\n        this.collapseAll = () => {\n            this.setState({\n                expandedItems: []\n            });\n        };\n        this.handleItemResizeStart = (id, initWidth, initHeight) => {\n            const { layout } = this.props;\n            const bbox = layout.content[id].bbox;\n            if (utils.isPercentage(bbox.height)) {\n                this.domRect = this.ref.getBoundingClientRect();\n            }\n            this.resizingRect = { width: initWidth, height: initHeight };\n        };\n        this.handleItemResizeEnd = (id, x, y, dw, dh) => {\n            const { layout } = this.props;\n            const bbox = layout.content[id].bbox;\n            let height;\n            if (utils.isPercentage(bbox.height)) {\n                height = `${(((this.resizingRect.height + dh) * 100) / this.domRect.height).toFixed(2)}%`;\n            }\n            else {\n                height = `${Math.round(this.resizingRect.height + dh)}px`;\n            }\n            this.childRects = [];\n            this.domRect = null;\n            const appConfigAction = getAppConfigAction();\n            appConfigAction\n                .editLayoutItemProperty({\n                layoutId: this.props.layout.id,\n                layoutItemId: id\n            }, 'bbox', { height })\n                .exec();\n        };\n        this.handleDragOver = (draggingItem, draggingElement, containerRect, itemRect) => {\n            var _a, _b;\n            let rect = (_a = itemRect.handlerRect) !== null && _a !== void 0 ? _a : itemRect;\n            this.canvasPane.clear();\n            if (((_b = this.childRects) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                const { insertY, refId } = calInsertPositionForColumn(containerRect, rect, this.childRects);\n                this.referenceId = refId;\n                rect = {\n                    top: insertY - dropIndicatorSize / 2,\n                    width: containerRect.width - dropIndicatorSize,\n                    left: dropIndicatorSize / 2,\n                    height: dropIndicatorSize\n                };\n            }\n            else {\n                rect = {\n                    top: containerRect.height / 2 - dropIndicatorSize / 2,\n                    width: containerRect.width - dropIndicatorSize,\n                    left: dropIndicatorSize / 2,\n                    height: dropIndicatorSize\n                };\n            }\n            this.canvasPane.setColor(this.builderTheme.sys.color.primary.light);\n            this.canvasPane.drawRect(rect);\n        };\n        this.handleToggleDragoverEffect = (value) => {\n            if (value) {\n                this.referenceId = null;\n                this.collectBounds(null);\n            }\n            this.setState({\n                isDragover: value\n            });\n        };\n        this.handleDrop = (draggingItem, containerRect, itemRect) => {\n            this.canvasPane.clear();\n            const { layout } = this.props;\n            let insertIndex = 0;\n            if (this.referenceId != null) {\n                insertIndex = layout.order.indexOf(this.referenceId);\n            }\n            else if (layout.order != null) {\n                insertIndex = layout.order.length;\n            }\n            const appConfigAction = getAppConfigAction();\n            addItemToLayout(appConfigAction.appConfig, draggingItem, layout.id)\n                .then((result) => {\n                const { layoutInfo, updatedAppConfig } = result;\n                const service = LayoutServiceProvider.getInstance().getServiceByType(LayoutType.AccordionLayout);\n                const outAppConfig = service.processAfterItemAdded(updatedAppConfig, draggingItem, layoutInfo, {\n                    currentSizeMode: null,\n                    containerRect,\n                    itemRect,\n                    insertIndex\n                });\n                utils.changeLayout(outAppConfig, layoutInfo);\n            })\n                .finally(null);\n            this.referenceId = null;\n            this.childRects = [];\n        };\n        this.state = {\n            isDragover: false,\n            expandedItems: this.props.expandByDefault.includes(',') ? this.props.expandByDefault.split(',') : []\n        };\n    }\n    componentDidMount() {\n        this.canvasPane = new CanvasPane(this.canvasRef);\n        this.canvasPane.setSize(this.ref.clientWidth, this.ref.scrollHeight);\n    }\n    componentDidUpdate(prevProps) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        this.canvasPane.setSize(this.ref.clientWidth, this.ref.scrollHeight);\n        if (prevProps.singleMode !== this.props.singleMode && this.props.singleMode) {\n            if (this.state.expandedItems.length > 1) {\n                this.setState({\n                    expandedItems: [this.state.expandedItems[0]]\n                });\n            }\n        }\n        else if (((_a = prevProps.layout.order) === null || _a === void 0 ? void 0 : _a.length) !== ((_b = this.props.layout.order) === null || _b === void 0 ? void 0 : _b.length)) {\n            const prevLength = (_d = (_c = prevProps.layout.order) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;\n            const currentLength = (_f = (_e = this.props.layout.order) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0;\n            // item added, the new item should be opened by default\n            if (prevLength < currentLength) {\n                const addedItem = findTheMissingItem((_g = prevProps.layout.order) !== null && _g !== void 0 ? _g : [], this.props.layout.order);\n                if (this.props.singleMode) {\n                    this.setState({\n                        expandedItems: [addedItem]\n                    });\n                }\n                else {\n                    this.setState({\n                        expandedItems: [...this.state.expandedItems, addedItem]\n                    });\n                }\n            }\n            if (prevLength > currentLength) {\n                // item removed, remove the item from expandedItems\n                const deletedItem = findTheMissingItem((_h = this.props.layout.order) !== null && _h !== void 0 ? _h : [], prevProps.layout.order);\n                if ((_j = this.state.expandedItems) === null || _j === void 0 ? void 0 : _j.includes(deletedItem)) {\n                    const remaining = this.state.expandedItems.filter(item => item !== deletedItem);\n                    this.setState({\n                        expandedItems: remaining\n                    });\n                }\n            }\n        }\n    }\n    collectBounds(id) {\n        const { layout } = this.props;\n        this.childRects = [];\n        this.domRect = this.ref.getBoundingClientRect();\n        const draggableChildren = this.ref.querySelectorAll(':scope > div.exb-rnd');\n        if ((draggableChildren === null || draggableChildren === void 0 ? void 0 : draggableChildren.length) > 0) {\n            draggableChildren.forEach((node) => {\n                const itemId = node.getAttribute('data-layoutitemid');\n                if (id !== itemId && layout.order.includes(itemId)) {\n                    const rect = utils.relativeClientRect(node.getBoundingClientRect(), this.domRect);\n                    rect.id = itemId;\n                    this.childRects.push(rect);\n                }\n            });\n        }\n        return this.childRects.sort((a, b) => a.top - b.top);\n    }\n    isEmpty() {\n        var _a;\n        const { layout } = this.props;\n        const content = (_a = layout.order) !== null && _a !== void 0 ? _a : [];\n        const hasSomethingToRender = content.length > 0 && content.some(id => {\n            const layoutItem = layout.content[id];\n            return !layoutItem.isPending;\n        });\n        return !hasSomethingToRender;\n    }\n    createItem(itemId, index, layoutSetting) {\n        const { layout, showDefaultTools, gap } = this.props;\n        const layoutItem = layout.content[itemId];\n        if (layoutItem.isPending) {\n            return null;\n        }\n        return (jsx(AccordionItem, { key: itemId, layoutId: layout.id, layoutItemId: itemId, gap: gap, expanded: this.state.expandedItems.includes(itemId), layoutItem: layout.content[itemId], draggable: true, resizable: true, showDefaultTools: showDefaultTools, onExpandedChange: this.handleExpandedChange, onResizeStart: this.handleItemResizeStart, onResizeEnd: this.handleItemResizeEnd }));\n    }\n    render() {\n        var _a;\n        const { layout, className, showToggleAll, padding } = this.props;\n        const content = (_a = layout.order) !== null && _a !== void 0 ? _a : [];\n        const layoutSetting = Object.assign({}, layout.setting);\n        return (jsx(PageContext.Consumer, null, (pageContext) => {\n            this.builderTheme = pageContext.builderTheme;\n            const guideVisibleStyle = {\n                display: this.state.isDragover ? 'block' : 'none'\n            };\n            return (jsx(\"div\", { className: classNames('layout foldable-layout w-100', className), css: css `position: relative;`, \"data-layoutid\": layout.id },\n                jsx(\"div\", { className: 'h-100 w-100 d-flex flex-column', ref: (el) => {\n                        this.ref = el;\n                    }, css: css `\r\n                  overflow: auto;\r\n                  overflow-x: hidden;\r\n                  padding: ${styleUtils.toCSSPadding(padding)}\r\n                ` },\n                    showToggleAll && jsx(ToggleAllButtonGroup, { onExpandAll: this.expandAll, onCollapseAll: this.collapseAll }),\n                    jsx(DropArea, { css: dropareaStyle, layouts: this.props.layouts, highlightDragover: true, onDragOver: this.handleDragOver, onDrop: this.handleDrop, onToggleDragoverEffect: this.handleToggleDragoverEffect }),\n                    content.map((layoutItem, index) => this.createItem(layoutItem, index, layoutSetting)),\n                    this.isEmpty() && this.props.children,\n                    jsx(\"canvas\", { css: guideOverlay, style: guideVisibleStyle, ref: (el) => {\n                            this.canvasRef = el;\n                        } }))));\n        }));\n    }\n}\nconst mapStateToProps = createSelector([\n    (state, ownProps) => utils.mapStateToLayoutProps(state, ownProps),\n    (state, ownProps) => {\n        var _a, _b;\n        const widgetJson = getParentWidgetJson(ownProps.layouts, state);\n        return (_b = (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.singleMode) !== null && _b !== void 0 ? _b : false;\n    },\n    (state, ownProps) => {\n        var _a, _b;\n        const widgetJson = getParentWidgetJson(ownProps.layouts, state);\n        return (_b = (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.showToggleAll) !== null && _b !== void 0 ? _b : false;\n    },\n    (state, ownProps) => {\n        var _a, _b;\n        const widgetJson = getParentWidgetJson(ownProps.layouts, state);\n        return (_b = (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.gap) !== null && _b !== void 0 ? _b : 4;\n    },\n    (state, ownProps) => {\n        var _a;\n        const widgetJson = getParentWidgetJson(ownProps.layouts, state);\n        return (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.padding;\n    },\n    (state, ownProps) => {\n        var _a, _b, _c;\n        const layoutId = ownProps.layouts[state.browserSizeMode] || ownProps.layouts[state.appConfig.mainSizeMode];\n        const layoutJson = state.appConfig.layouts[layoutId];\n        const widgetJson = getParentWidgetJson(ownProps.layouts, state);\n        const list = (_b = (_a = widgetJson.config) === null || _a === void 0 ? void 0 : _a.expandedItems) !== null && _b !== void 0 ? _b : [];\n        const result = [];\n        if (list.length > 0) {\n            Object.keys((_c = layoutJson.content) !== null && _c !== void 0 ? _c : {}).forEach((layoutItemId) => {\n                const layoutItem = layoutJson.content[layoutItemId];\n                if (list.includes(layoutItem.widgetId)) {\n                    result.push(layoutItemId);\n                }\n            });\n        }\n        return result.join(',');\n    }\n], (layoutProps, singleMode, showToggleAll, gap, padding, expandedItems) => {\n    return Object.assign({ singleMode,\n        showToggleAll,\n        gap,\n        padding, expandByDefault: expandedItems }, layoutProps);\n});\nexport default ReactRedux.connect(mapStateToProps)(Layout);\n","/** @jsx jsx */\nimport { React, ReactRedux, classNames, jsx, css, OneByOneAnimation, IntersectionContext, LayoutType, polished } from 'jimu-core';\nimport { LayoutServiceProvider, getAppConfigAction } from 'jimu-for-builder';\nimport { styleUtils } from 'jimu-ui';\nimport { utils, PageContext } from 'jimu-layouts/layout-runtime';\nimport { DropArea } from '../../builder/interactive/droparea-hook';\nimport { isExpressMode } from '../../builder/menu/common-menu';\nimport { addItemToLayout } from '../../builder/common-layout-actions';\nimport { calInsertPosition } from './util';\nimport { DEFAULT_FLEX_ROW_LAYOUT_SETTING } from '../default-setting';\nimport { FlexRowItem } from './layout-item';\nimport { CanvasPane } from '../../builder/interactive/canvas-pane';\nimport { getLayoutStyle } from '../common/style';\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  top: 0;\r\n  right: 0;\r\n  background: transparent;\r\n`;\nconst guideOverlay = css `\r\n  ${dropareaStyle};\r\n  z-index: 20;\r\n  pointer-events: none;\r\n`;\nconst dropIndicatorSize = 10;\nclass Layout extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            isDragover: false\n        };\n        this.handleItemResizeStart = (id) => {\n            const { layout } = this.props;\n            this.domRect = this.ref.getBoundingClientRect();\n            const draggingChild = this.ref.querySelector(`div.exb-rnd[data-layoutid=\"${layout.id}\"][data-layoutitemid=\"${id}\"]`);\n            const rect = draggingChild.getBoundingClientRect();\n            this.resizingRect = utils.relativeClientRect(rect, this.domRect);\n        };\n        this.handleItemResizeEnd = (id, x, y, dw, dh, layoutItem) => {\n            const { layout } = this.props;\n            const bbox = layout.content[id].bbox;\n            let width;\n            if (utils.isPercentage(bbox.width)) {\n                width = `${((this.resizingRect.width + dw) * 100 / this.domRect.width).toFixed(4)}%`;\n            }\n            else {\n                width = `${Math.round(this.resizingRect.width + dw)}px`;\n            }\n            const newPos = {\n                width,\n                height: Math.round(this.resizingRect.height + dh)\n            };\n            this.childRects = [];\n            this.domRect = null;\n            const appConfigAction = getAppConfigAction();\n            appConfigAction\n                .editLayoutItemProperty({\n                layoutId: this.props.layout.id,\n                layoutItemId: id\n            }, 'bbox', newPos)\n                .exec();\n        };\n        this.handleDragOver = (draggingItem, draggingElement, containerRect, itemRect) => {\n            var _a;\n            let rect = itemRect;\n            this.canvasPane.clear();\n            if (((_a = this.childRects) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n                const { insertX, refId } = calInsertPosition(containerRect, rect, this.childRects);\n                this.referenceId = refId;\n                rect = {\n                    left: insertX - dropIndicatorSize / 2 + this.ref.scrollLeft,\n                    height: containerRect.height - dropIndicatorSize,\n                    top: dropIndicatorSize / 2,\n                    width: dropIndicatorSize\n                };\n            }\n            else {\n                rect = {\n                    left: containerRect.width / 2 - dropIndicatorSize / 2,\n                    height: containerRect.height - dropIndicatorSize,\n                    top: dropIndicatorSize / 2,\n                    width: dropIndicatorSize\n                };\n            }\n            this.canvasPane.setColor(polished.rgba(this.builderTheme.sys.color.primary.light, 0.5));\n            this.canvasPane.drawRect(rect);\n        };\n        this.handleToggleDragoverEffect = (value, draggingItem) => {\n            var _a;\n            if (value) {\n                this.referenceId = null;\n                this.collectBounds(((_a = draggingItem.layoutInfo) === null || _a === void 0 ? void 0 : _a.layoutId) === this.props.layout.id ? draggingItem.layoutInfo.layoutItemId : null);\n            }\n            this.setState({\n                isDragover: value\n            });\n        };\n        this.handleDrop = (draggingItem, containerRect, itemRect) => {\n            var _a;\n            this.canvasPane.clear();\n            const { layout } = this.props;\n            let insertIndex = 0;\n            if (this.referenceId != null) {\n                insertIndex = layout.order.indexOf(this.referenceId);\n                if (((_a = draggingItem.layoutInfo) === null || _a === void 0 ? void 0 : _a.layoutId) === layout.id) { // change order\n                    const originIndex = layout.order.indexOf(draggingItem.layoutInfo.layoutItemId);\n                    if (originIndex < insertIndex) {\n                        insertIndex = insertIndex - 1;\n                    }\n                }\n            }\n            else if (layout.order != null) {\n                insertIndex = layout.order.length;\n            }\n            const appConfigAction = getAppConfigAction();\n            addItemToLayout(appConfigAction.appConfig, draggingItem, layout.id).then((result) => {\n                const { layoutInfo, updatedAppConfig } = result;\n                const service = LayoutServiceProvider.getInstance().getServiceByType(LayoutType.FlexRowLayout);\n                const outAppConfig = service.processAfterItemAdded(updatedAppConfig, draggingItem, layoutInfo, {\n                    currentSizeMode: null,\n                    containerRect,\n                    itemRect,\n                    insertIndex\n                });\n                utils.changeLayout(outAppConfig, layoutInfo);\n            }).finally(null);\n            this.referenceId = null;\n            this.childRects = [];\n        };\n    }\n    componentDidMount() {\n        this.canvasPane = new CanvasPane(this.canvasRef);\n        this.canvasPane.setSize(this.ref.clientWidth, this.ref.clientHeight);\n    }\n    componentDidUpdate() {\n        this.canvasPane.setSize(this.ref.clientWidth, this.ref.clientHeight);\n    }\n    collectBounds(id) {\n        const { layout } = this.props;\n        this.childRects = [];\n        this.domRect = this.ref.getBoundingClientRect();\n        const draggableChildren = this.ref.parentNode.querySelectorAll(`div[data-layoutid=\"${layout.id}\"] > .trail-container > div.exb-rnd`);\n        if ((draggableChildren === null || draggableChildren === void 0 ? void 0 : draggableChildren.length) > 0) {\n            draggableChildren.forEach((node) => {\n                const itemId = node.getAttribute('data-layoutitemid');\n                if (id !== itemId && layout.order.includes(itemId)) {\n                    const rect = utils.relativeClientRect(node.getBoundingClientRect(), this.domRect);\n                    rect.id = itemId;\n                    this.childRects.push(rect);\n                }\n            });\n        }\n        return this.childRects.sort((a, b) => utils.isRTL() ? b.left - a.left : a.left - b.left);\n    }\n    createItem(itemId, index) {\n        const { layout, itemDraggable, itemResizable, itemSelectable, showDefaultTools } = this.props;\n        return (jsx(FlexRowItem, { key: itemId, index: index, layoutId: layout.id, layoutItemId: itemId, layoutItem: layout.content[itemId], draggable: itemDraggable, resizable: itemResizable, selectable: itemSelectable, showDefaultTools: showDefaultTools, onResizeStart: this.handleItemResizeStart, onResizeEnd: this.handleItemResizeEnd }));\n    }\n    isEmpty() {\n        var _a;\n        const { layout } = this.props;\n        const content = (_a = layout.order) !== null && _a !== void 0 ? _a : [];\n        const hasSomethingToRender = content.length > 0 && content.some(id => {\n            const layoutItem = layout.content[id];\n            return !layoutItem.isPending;\n        });\n        return !hasSomethingToRender;\n    }\n    render() {\n        var _a;\n        const { layout, className } = this.props;\n        const content = (_a = layout.order) !== null && _a !== void 0 ? _a : [];\n        const layoutSetting = Object.assign({}, DEFAULT_FLEX_ROW_LAYOUT_SETTING, layout.setting);\n        const isEmpty = this.isEmpty();\n        return (jsx(PageContext.Consumer, null, (pageContext) => {\n            this.builderTheme = pageContext.builderTheme;\n            this.theme = pageContext.theme;\n            const mergedStyle = {\n                position: 'relative',\n                minWidth: layoutSetting.min\n            };\n            const outClass = classNames('layout flex-row-layout', className);\n            const guideVisibleStyle = {\n                display: this.state.isDragover ? 'block' : 'none'\n            };\n            return (jsx(\"div\", { className: outClass, ref: (el) => { this.ref = el; }, style: mergedStyle, \"data-layoutid\": layout.id },\n                jsx(IntersectionContext.Provider, { value: { monitor: true, layoutId: layout.id } },\n                    jsx(OneByOneAnimation, { oid: layout.id, className: 'trail-container d-flex w-100', css: css `\r\n                    position: ${isEmpty ? 'absolute' : null};\r\n                    padding: ${styleUtils.toCSSPadding(layoutSetting.padding)};\r\n                    ${getLayoutStyle(layoutSetting)};\r\n                  ` },\n                        jsx(DropArea, { css: dropareaStyle, layouts: this.props.layouts, highlightDragover: true, onDragOver: this.handleDragOver, onDrop: this.handleDrop, onToggleDragoverEffect: this.handleToggleDragoverEffect }),\n                        content.map((layoutItem, index) => this.createItem(layoutItem, index)))),\n                isEmpty && !isExpressMode() && this.props.children,\n                jsx(\"canvas\", { css: guideOverlay, style: guideVisibleStyle, ref: (el) => { this.canvasRef = el; } })));\n        }));\n    }\n}\nexport default ReactRedux.connect(utils.mapStateToLayoutProps)(Layout);\n","/** @jsx jsx */\nimport { React, Immutable, jsx, css, ReactRedux, LayoutItemType, WidgetType, AnimationType, AnimationTriggerType, AnimationPlayMode, HoverType, getAppStore, TransitionType, getNextAnimationId, createSelector } from 'jimu-core';\nimport { AdvancedButtonGroup, Button } from 'jimu-ui';\nimport { SettingSection, SettingRow } from 'jimu-ui/advanced/setting-components';\nimport { AnimationSettingComponent, TransitionSetting } from 'jimu-ui/advanced/style-setting-components';\nimport { builderAppSync, getAppConfigAction } from 'jimu-for-builder';\nimport { searchUtils } from 'jimu-layouts/layout-runtime';\nimport { findActiveViewId } from './menu/section-menu';\nclass LayoutItemAnimationSetting extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.modalStyle = {\n            position: 'absolute',\n            top: '0',\n            bottom: '0',\n            width: '100%',\n            height: 'auto',\n            paddingBottom: '1px'\n        };\n        this.onTransitionSettingChange = (setting) => {\n            const { layoutId, layoutItemId } = this.props;\n            const appConfigAction = getAppConfigAction();\n            const appConfig = appConfigAction.appConfig;\n            const layoutItem = appConfig.layouts[layoutId].content[layoutItemId];\n            appConfigAction.editSectionProperty(layoutItem.sectionId, 'transition', setting).exec();\n            if ((setting === null || setting === void 0 ? void 0 : setting.type) !== TransitionType.None) {\n                this.previewTransition();\n            }\n        };\n        this.onHoverEffectChange = (effect) => {\n            var _a, _b;\n            const { layoutId, layoutItemId } = this.props;\n            const appConfigAction = getAppConfigAction();\n            const appConfig = appConfigAction.appConfig;\n            const layoutItem = appConfig.layouts[layoutId].content[layoutItemId];\n            const setting = (_a = layoutItem.setting) !== null && _a !== void 0 ? _a : Immutable({});\n            if (((_b = setting.hoverEffect) === null || _b === void 0 ? void 0 : _b.type) !== effect.type) {\n                appConfigAction.editLayoutItemProperty({ layoutId, layoutItemId }, 'setting.hoverEffect', effect).exec();\n            }\n            if (effect.type !== HoverType.None) {\n                builderAppSync.publishHoverPreviewToApp({\n                    layoutInfo: {\n                        layoutId: layoutId,\n                        layoutItemId: layoutItemId\n                    },\n                    id: getNextAnimationId()\n                });\n            }\n        };\n        this.onEffectSettingChange = (mode, effectSetting) => {\n            const trigger = AnimationTriggerType.ScrollIntoView;\n            const { layoutId, layoutItemId, setting } = this.props;\n            const oldSetting = setting || Immutable({});\n            const propName = mode === AnimationPlayMode.OneByOne ? 'oneByOneEffect' : 'effect';\n            this.props.onSettingChange({\n                layoutId,\n                layoutItemId\n            }, oldSetting.setIn([propName, trigger], effectSetting));\n            if ((effectSetting === null || effectSetting === void 0 ? void 0 : effectSetting.type) !== AnimationType.None) {\n                builderAppSync.publishAnimationPreviewToApp({\n                    layoutInfo: {\n                        layoutId: layoutId,\n                        layoutItemId: layoutItemId\n                    },\n                    playMode: mode,\n                    id: getNextAnimationId()\n                });\n            }\n        };\n        this.onSectionOneByOneEffectSettingChange = (effectSetting) => {\n            this.onEffectSettingChange(AnimationPlayMode.OneByOne, effectSetting);\n        };\n        this.previewAnimation = (mode) => {\n            if (this.hasAnimationEffect()) {\n                builderAppSync.publishAnimationPreviewToApp({\n                    layoutInfo: {\n                        layoutId: this.props.layoutId,\n                        layoutItemId: this.props.layoutItemId\n                    },\n                    playMode: mode,\n                    id: getNextAnimationId()\n                });\n            }\n        };\n        this.previewTransition = (withOneByOne = false) => {\n            var _a, _b, _c;\n            const { sectionId } = this.props;\n            const sectionProps = searchUtils.getSectionInfo(getAppStore().getState().appStateInBuilder, sectionId);\n            const { views } = sectionProps;\n            if ((views === null || views === void 0 ? void 0 : views.length) > 1) {\n                let navInfo = (_c = (_b = (_a = getAppStore().getState().appStateInBuilder) === null || _a === void 0 ? void 0 : _a.appRuntimeInfo) === null || _b === void 0 ? void 0 : _b.sectionNavInfos) === null || _c === void 0 ? void 0 : _c[sectionId];\n                if (!navInfo) {\n                    const activeViewId = findActiveViewId(sectionProps);\n                    const currentIndex = views.indexOf(activeViewId);\n                    const previousIndex = currentIndex > 0 ? currentIndex - 1 : currentIndex + 1;\n                    navInfo = Immutable({\n                        currentViewId: activeViewId,\n                        previousViewId: views[previousIndex]\n                    });\n                }\n                builderAppSync.publishSectionNavInfoToApp(sectionId, navInfo\n                    .set('playId', getNextAnimationId())\n                    .set('withOneByOne', withOneByOne).asMutable());\n            }\n        };\n        this.previewTransitionAndOnebyOne = () => {\n            this.previewTransition(true);\n        };\n        this.previewOneByOneInSection = () => {\n            this.previewAnimation(AnimationPlayMode.OneByOne);\n        };\n        this.previewHover = () => {\n            if (this.hasHoverEffect()) {\n                builderAppSync.publishHoverPreviewToApp({\n                    layoutInfo: {\n                        layoutId: this.props.layoutId,\n                        layoutItemId: this.props.layoutItemId\n                    },\n                    id: getNextAnimationId()\n                });\n            }\n        };\n        this.onPlayModeChange = (mode) => {\n            const { layoutId, layoutItemId } = this.props;\n            getAppConfigAction().editLayoutItemProperty({ layoutId, layoutItemId }, 'setting.effectPlayMode', mode).exec();\n        };\n        this.switchToIn = () => {\n            this.setState({\n                animationType: 'in'\n            });\n        };\n        this.switchToTransition = () => {\n            this.setState({\n                animationType: 'transition'\n            });\n        };\n        this.switchToHover = () => {\n            this.setState({\n                animationType: 'hover'\n            });\n        };\n        this.state = {\n            animationType: 'in'\n        };\n    }\n    hasAnimationEffect() {\n        var _a, _b;\n        const { setting } = this.props;\n        const effect = (_a = setting === null || setting === void 0 ? void 0 : setting.effect) === null || _a === void 0 ? void 0 : _a[AnimationTriggerType.ScrollIntoView];\n        const oneByOneEffect = (_b = setting === null || setting === void 0 ? void 0 : setting.oneByOneEffect) === null || _b === void 0 ? void 0 : _b[AnimationTriggerType.ScrollIntoView];\n        return (effect && effect.type !== AnimationType.None) || (oneByOneEffect && oneByOneEffect.type !== AnimationType.None);\n    }\n    hasHoverEffect() {\n        const { setting } = this.props;\n        const effect = setting === null || setting === void 0 ? void 0 : setting.hoverEffect;\n        return effect && effect.type !== HoverType.None;\n    }\n    render() {\n        var _a, _b;\n        const { formatMessage, supportOneByOne, isSection, transitionType, transitionDirection, setting } = this.props;\n        const { animationType } = this.state;\n        const asoneEffect = (_a = setting === null || setting === void 0 ? void 0 : setting.effect) === null || _a === void 0 ? void 0 : _a[AnimationTriggerType.ScrollIntoView];\n        const oneByOneEffect = (_b = setting === null || setting === void 0 ? void 0 : setting.oneByOneEffect) === null || _b === void 0 ? void 0 : _b[AnimationTriggerType.ScrollIntoView];\n        return (jsx(SettingSection, { role: 'group', \"aria-label\": formatMessage('animation'), title: formatMessage('animation') },\n            isSection && (jsx(SettingRow, null,\n                jsx(AdvancedButtonGroup, { className: 'w-100', css: css `\r\n              border-bottom: 1px solid var(--sys-color-primary-main);\r\n              .jimu-btn {\r\n                width: 50%;\r\n                border-radius: 2px 2px 0 0;\r\n              }\r\n            ` },\n                    jsx(Button, { active: animationType === 'in', onClick: this.switchToIn }, formatMessage('in')),\n                    jsx(Button, { className: 'ml-1', active: animationType === 'transition', onClick: this.switchToTransition }, formatMessage('transition'))))),\n            animationType === 'in' && jsx(SettingRow, null,\n                jsx(AnimationSettingComponent, { effectSetting: asoneEffect, oneByOneSetting: oneByOneEffect, onSettingChange: this.onEffectSettingChange, previewEnabled: true, supportAsOne: true, supportOneByOne: supportOneByOne, onPreviewClicked: this.previewAnimation, formatMessage: formatMessage })),\n            animationType === 'transition' && jsx(SettingRow, { flow: 'wrap' },\n                jsx(TransitionSetting, { transition: { type: transitionType, direction: transitionDirection }, transitionLabel: formatMessage('view'), oneByOneEffect: oneByOneEffect, onOneByOneChange: this.onSectionOneByOneEffectSettingChange, onTransitionChange: this.onTransitionSettingChange, onPreviewTransitionClicked: this.previewTransition, onPreviewOneByOneClicked: this.previewOneByOneInSection, onPreviewAsAWhoneClicked: this.previewTransitionAndOnebyOne, formatMessage: formatMessage }))));\n    }\n}\nconst mapFunction = createSelector([\n    (state, ownProps) => {\n        var _a, _b;\n        const { layoutId, layoutItemId } = ownProps;\n        const layoutItem = (_b = (_a = state.appStateInBuilder) === null || _a === void 0 ? void 0 : _a.appConfig) === null || _b === void 0 ? void 0 : _b.layouts[layoutId].content[layoutItemId];\n        return layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.setting;\n    },\n    (state, ownProps) => {\n        var _a, _b;\n        const { layoutId, layoutItemId } = ownProps;\n        const layoutItem = (_b = (_a = state.appStateInBuilder) === null || _a === void 0 ? void 0 : _a.appConfig) === null || _b === void 0 ? void 0 : _b.layouts[layoutId].content[layoutItemId];\n        return (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Widget;\n    },\n    (state, ownProps) => {\n        var _a, _b, _c, _d, _e, _f;\n        const { layoutId, layoutItemId } = ownProps;\n        const layoutItem = (_b = (_a = state.appStateInBuilder) === null || _a === void 0 ? void 0 : _a.appConfig) === null || _b === void 0 ? void 0 : _b.layouts[layoutId].content[layoutItemId];\n        if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Widget) {\n            const widget = (_c = state.appStateInBuilder) === null || _c === void 0 ? void 0 : _c.appConfig.widgets[layoutItem.widgetId];\n            const forbidOneByOne = (_e = (_d = widget === null || widget === void 0 ? void 0 : widget.manifest) === null || _d === void 0 ? void 0 : _d.properties) === null || _e === void 0 ? void 0 : _e.forbidOneByOneEffect;\n            return ((_f = widget === null || widget === void 0 ? void 0 : widget.manifest) === null || _f === void 0 ? void 0 : _f.widgetType) === WidgetType.Layout && !forbidOneByOne;\n        }\n        return false;\n    },\n    (state, ownProps) => {\n        var _a, _b, _c;\n        const { layoutId, layoutItemId } = ownProps;\n        const layoutItem = (_b = (_a = state.appStateInBuilder) === null || _a === void 0 ? void 0 : _a.appConfig) === null || _b === void 0 ? void 0 : _b.layouts[layoutId].content[layoutItemId];\n        if ((layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.type) === LayoutItemType.Section) {\n            return (_c = state.appStateInBuilder) === null || _c === void 0 ? void 0 : _c.appConfig.sections[layoutItem.sectionId];\n        }\n    }\n], (setting, isWidget, supportOneByOne, section) => {\n    var _a, _b;\n    return ({\n        setting,\n        isWidget,\n        supportOneByOne,\n        isSection: section != null,\n        transitionType: (_a = section === null || section === void 0 ? void 0 : section.transition) === null || _a === void 0 ? void 0 : _a.type,\n        transitionDirection: (_b = section === null || section === void 0 ? void 0 : section.transition) === null || _b === void 0 ? void 0 : _b.direction,\n        sectionId: section === null || section === void 0 ? void 0 : section.id\n    });\n});\nexport default ReactRedux.connect(mapFunction)(LayoutItemAnimationSetting);\n","/** @jsx jsx */\nimport { React, jsx, css, lodash, classNames, APP_FRAME_NAME_IN_BUILDER, Immutable } from 'jimu-core';\nimport { InputUnit } from 'jimu-ui/advanced/style-setting-components';\nimport { DistanceUnits, utils as uiUtils, Tooltip } from 'jimu-ui';\nimport { DEFAULT_FIX_LAYOUT_ITEM_SETTING } from '../default-setting';\nimport { utils, LayoutItemSizeModes } from 'jimu-layouts/layout-runtime';\nimport { generateBBoxStyle } from '../fixed-layout-util';\nimport { ArrowStretchedOutlined } from 'jimu-icons/outlined/directional/arrow-stretched';\nconst availableUnits = [DistanceUnits.PIXEL, DistanceUnits.PERCENTAGE];\nexport class ItemPositionSetting extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.updateBBox = (prop, value) => {\n            const bbox = this.props.layoutItem.bbox;\n            const { distance, unit } = value;\n            const originalValue = bbox[prop];\n            let newValue = distance.toFixed(2);\n            if (utils.isPercentage(originalValue) && unit === DistanceUnits.PIXEL) {\n                // change from percentage to pixel\n                const containerRect = this.getSizeOfContainer();\n                if (containerRect != null) {\n                    if (prop === 'left' || prop === 'right' || prop === 'width') {\n                        newValue = Math.round((parseFloat(originalValue) * containerRect.width) / 100);\n                    }\n                    else {\n                        newValue = Math.round((parseFloat(originalValue) * containerRect.height) / 100);\n                    }\n                }\n            }\n            else if (!utils.isPercentage(originalValue) && unit === DistanceUnits.PERCENTAGE) {\n                // change from pixel to percentage\n                const containerRect = this.getSizeOfContainer();\n                if (containerRect != null) {\n                    if (prop === 'left' || prop === 'right' || prop === 'width') {\n                        newValue = ((parseFloat(originalValue) * 100) / containerRect.width).toFixed(2);\n                    }\n                    else {\n                        newValue = ((parseFloat(originalValue) * 100) / containerRect.height).toFixed(2);\n                    }\n                }\n            }\n            this.props.onPosChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, bbox.set(prop, value.unit === DistanceUnits.PERCENTAGE ? `${newValue}%` : `${newValue}px`));\n        };\n        this.flipLeftRight = utils.isRTL();\n    }\n    getStyle() {\n        return css `\r\n      .position-setting {\r\n        background-color: var(--ref-palette-neutral-500);\r\n        position: relative;\r\n        width: 100%;\r\n        padding-top: 60%;\r\n        overflow: visible;\r\n      }\r\n\r\n      .content {\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        bottom: 0;\r\n        right: 0;\r\n        padding: 7px;\r\n      }\r\n\r\n      .w-half {\r\n        width: calc(50% - 16px);\r\n        position: relative;\r\n        z-index: 0;\r\n      }\r\n      .h-half {\r\n        height: calc(50% - 16px);\r\n        position: relative;\r\n        z-index: 0;\r\n      }\r\n      .pos-label {\r\n        z-index: 1;\r\n      }\r\n\r\n      .box-column {\r\n        width: 32px;\r\n        overflow: visible;\r\n      }\r\n\r\n      .box-item {\r\n        width: 24px;\r\n        height: 24px;\r\n        background-color: var(--ref-palette-neutral-800);\r\n        margin: 4px 0;\r\n        position: relative;\r\n        overflow: visible;\r\n\r\n        &.stretch {\r\n          background-color: transparent;\r\n          border: 1px solid var(--ref-palette-neutral-800);\r\n        }\r\n        .h-arrow, .v-arrow {\r\n          display: none;\r\n          .arrow-icon {\r\n            color: var(--ref-palette-neutral-800);\r\n            width: 100%;\r\n            height: 100%;\r\n          }\r\n          position: absolute;\r\n          width: 100%;\r\n        }\r\n        .h-arrow {\r\n          top: 50%;\r\n          transform: translateY(-50%);\r\n        }\r\n        .v-arrow {\r\n          left: 50%;\r\n          transform: translateX(-50%);\r\n        }\r\n        &.stretch-w .h-arrow,\r\n        &.stretch-h .v-arrow {\r\n          display: block;\r\n        }\r\n      }\r\n\r\n      .anchor {\r\n        position: absolute;\r\n        width: 16px;\r\n        height: 16px;\r\n        background: transparent;\r\n        overflow: visible;\r\n\r\n        &.selected {\r\n          width: 10px;\r\n          height: 10px;\r\n          opacity: 1;\r\n          background: var(--sys-color-primary-dark);\r\n          border: 2px solid var(--sys-color-primary-main) !important;\r\n          border-radius: 3px !important;\r\n        }\r\n        &.top.left {\r\n          border-radius: 3px 0 0 0;\r\n        }\r\n        &.top.right {\r\n          border-radius: 0 3px 0 0;\r\n        }\r\n        &.bottom.right {\r\n          border-radius: 0 0 3px 0;\r\n        }\r\n        &.bottom.left {\r\n          border-radius: 0 0 0 3px;\r\n        }\r\n        &.left {\r\n          left: 6px;\r\n          border-left: 2px solid var(--ref-palette-neutral-800);\r\n          &.selected:before {\r\n            position: absolute;\r\n            right: -10px;\r\n            top: 50%;\r\n            transform: translateY(-50%);\r\n            content: '';\r\n            height: 2px;\r\n            width: 10px;\r\n            background-color: var(--sys-color-primary-main);\r\n          }\r\n        }\r\n        &.top {\r\n          top: 6px;\r\n          border-top: 2px solid var(--ref-palette-neutral-800);\r\n          &.selected:after {\r\n            position: absolute;\r\n            bottom: -10px;\r\n            left: 50%;\r\n            transform: translateX(-50%);\r\n            content: '';\r\n            width: 2px;\r\n            height: 10px;\r\n            background-color: var(--sys-color-primary-main);\r\n          }\r\n        }\r\n        &.bottom {\r\n          bottom: 6px;\r\n          border-bottom: 2px solid var(--ref-palette-neutral-800);\r\n          &.selected:after {\r\n            position: absolute;\r\n            top: -10px;\r\n            left: 50%;\r\n            transform: translateX(-50%);\r\n            content: '';\r\n            width: 2px;\r\n            height: 10px;\r\n            background-color: var(--sys-color-primary-main);\r\n          }\r\n        }\r\n        &.right {\r\n          right: 6px;\r\n          border-right: 2px solid var(--ref-palette-neutral-800);\r\n          &.selected:before {\r\n            position: absolute;\r\n            left: -10px;\r\n            top: 50%;\r\n            transform: translateY(-50%);\r\n            content: '';\r\n            height: 2px;\r\n            width: 10px;\r\n            background-color: var(--sys-color-primary-main);\r\n          }\r\n        }\r\n      }\r\n\r\n      .from-left {\r\n        border-left: 2px solid var(--sys-color-primary-main);\r\n        &.is-auto {\r\n          border-left-color: var(--ref-palette-neutral-800);\r\n        }\r\n        &.allow-change:hover {\r\n          border-left-color: var(--sys-color-primary-main);\r\n        }\r\n      }\r\n      .from-top {\r\n        border-top: 2px solid var(--sys-color-primary-main);\r\n        &.is-auto {\r\n          border-top-color: var(--ref-palette-neutral-800);\r\n        }\r\n        &.allow-change:hover {\r\n          border-top-color: var(--sys-color-primary-main);\r\n        }\r\n      }\r\n      .from-right {\r\n        border-right: 2px solid var(--sys-color-primary-main);\r\n        &.is-auto {\r\n          border-right-color: var(--ref-palette-neutral-800);\r\n        }\r\n        &.allow-change:hover {\r\n          border-right-color: var(--sys-color-primary-main);\r\n        }\r\n      }\r\n      .from-bottom {\r\n        border-bottom: 2px solid var(--sys-color-primary-main);\r\n        &.is-auto {\r\n          border-bottom-color: var(--ref-palette-neutral-800);\r\n        }\r\n        &.allow-change:hover {\r\n          border-bottom-color: var(--sys-color-primary-main);\r\n        }\r\n      }\r\n      /* .line-h.is-auto,\r\n      .line-v.is-auto {\r\n        border-color: var(--ref-palette-neutral-800);\r\n      } */\r\n      .line-h {\r\n        position: absolute;\r\n        width: 100%;\r\n        top: 50%;\r\n        transform: translateY(-50%);\r\n        height: 12px;\r\n        display: flex;\r\n        flex-direction: column;\r\n        justify-content: center;\r\n        z-index: 0;\r\n\r\n        &.allow-change {\r\n          cursor: pointer;\r\n          &:hover:after {\r\n            border-top-color: var(--sys-color-primary-main);\r\n          }\r\n        }\r\n        &:after {\r\n          content: '';\r\n          height: 0;\r\n          width: 100%;\r\n          border-top: 2px solid var(--sys-color-primary-main);\r\n        }\r\n        &.is-auto:after {\r\n          border-top-style: dashed;\r\n          border-top-color: var(--ref-palette-neutral-800);\r\n        }\r\n      }\r\n      .line-v {\r\n        position: absolute;\r\n        height: 100%;\r\n        width: 12px;\r\n        left: 50%;\r\n        transform: translateX(-50%);\r\n        display: flex;\r\n        justify-content: center;\r\n        z-index: 0;\r\n\r\n        &.allow-change {\r\n          cursor: pointer;\r\n          &:hover:after {\r\n            border-left-color: var(--sys-color-primary-main);\r\n          }\r\n        }\r\n        &:after {\r\n          content: '';\r\n          width: 0;\r\n          height: 100%;\r\n          border-left: 2px solid var(--sys-color-primary-main);\r\n        }\r\n        &.is-auto:after {\r\n          border-left-style: dashed;\r\n          border-left-color: var(--ref-palette-neutral-800);\r\n        }\r\n      }\r\n\r\n      .auto-label {\r\n        width: 16px;\r\n        height: 16px;\r\n        background: var(--sys-color-primary-main);\r\n        border: 1px solid var(--ref-palette-neutral-500);\r\n        font-size: 12px;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        color: var(--ref-palette-neutral-400);\r\n      }\r\n\r\n      .style-setting--input-unit {\r\n        &:hover {\r\n          input.jimu-numeric-input-input {\r\n            background-color: var(--ref-palette-neutral-300);\r\n          }\r\n          .style-setting--unit-selector {\r\n            background-color: var(--ref-palette-neutral-300);\r\n          }\r\n        }\r\n        border-radius: 2px;\r\n        width: 52px;\r\n        height: 24px;\r\n\r\n        input.jimu-numeric-input-input {\r\n          height: 24px;\r\n          font-size: 12px;\r\n          padding: 0;\r\n          text-align: center;\r\n          border: none;\r\n          background-color: var(--ref-palette-neutral-500);\r\n          &:focus {\r\n            background-color: var(--ref-palette-neutral-300);\r\n          }\r\n        }\r\n        .style-setting--unit-selector {\r\n          background-color: var(--ref-palette-neutral-500);\r\n          color: var(--ref-palette-neutral-900);\r\n          height: 24px;\r\n          width: auto;\r\n          min-width: 0;\r\n          padding: 0;\r\n          margin-left: 0;\r\n          font-size: 12px;\r\n          border: none;\r\n        }\r\n      }\r\n\r\n      .origin-tip {\r\n        margin-top: 8px;\r\n        font-size: 12px;\r\n        color: var(--ref-palette-neutral-900);\r\n      }\r\n    `;\n    }\n    inputUnit(prop) {\n        const { layoutItem, formatMessage } = this.props;\n        const value = uiUtils.stringOfLinearUnit(layoutItem.bbox[prop]);\n        return (jsx(\"div\", { className: 'pos-label', role: 'group', \"aria-label\": formatMessage(prop) },\n            jsx(InputUnit, { units: availableUnits, min: -Infinity, max: Infinity, value: value, onChange: (value) => { this.updateBBox(prop, value); } })));\n    }\n    getSizeOfContainer() {\n        const layoutElem = this.querySelector(`div.fixed-layout[data-layoutid=\"${this.props.layoutId}\"]`);\n        return layoutElem === null || layoutElem === void 0 ? void 0 : layoutElem.getBoundingClientRect();\n    }\n    getSizeOfItem() {\n        const { layoutId, layoutItem } = this.props;\n        const layoutElem = this.querySelector(`div.exb-rnd[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItem.id}\"]`);\n        return layoutElem === null || layoutElem === void 0 ? void 0 : layoutElem.getBoundingClientRect();\n    }\n    querySelector(selector) {\n        var _a;\n        const appFrame = document.querySelector(`iframe[name=\"${APP_FRAME_NAME_IN_BUILDER}\"]`);\n        if (appFrame != null) {\n            const appFrameDoc = (_a = appFrame.contentDocument) !== null && _a !== void 0 ? _a : appFrame.contentWindow.document;\n            return appFrameDoc.querySelector(selector);\n        }\n        return null;\n    }\n    switchAuto(side, otherSize, originValue) {\n        var _a, _b;\n        const { layoutId, layoutItem } = this.props;\n        const setting = (_a = layoutItem.setting) !== null && _a !== void 0 ? _a : Immutable({});\n        let bbox = ((_b = layoutItem.bbox) !== null && _b !== void 0 ? _b : Immutable({}));\n        if (originValue && bbox[side] == null) {\n            const containerRect = this.getSizeOfContainer();\n            const rect = this.getSizeOfItem();\n            switch (side) {\n                case 'left':\n                    bbox = bbox.set(side, utils.toRatio(rect.left, containerRect.width));\n                    break;\n                case 'right':\n                    bbox = bbox.set(side, utils.toRatio(containerRect.width - rect.right, containerRect.width));\n                    break;\n                case 'top':\n                    bbox = bbox.set(side, utils.toRatio(rect.top, containerRect.height));\n                    break;\n                case 'bottom':\n                    bbox = bbox.set(side, utils.toRatio(containerRect.height - rect.bottom, containerRect.height));\n                    break;\n            }\n            this.props.onPosChange({\n                layoutId,\n                layoutItemId: layoutItem.id\n            }, bbox);\n        }\n        this.props.onSettingChange({\n            layoutId,\n            layoutItemId: layoutItem.id\n        }, setting.setIn(['autoProps', side], !originValue).setIn(['autoProps', otherSize], originValue));\n    }\n    checkAutoProps(itemSetting) {\n        const box = generateBBoxStyle(this.props.layoutItem.bbox, itemSetting);\n        const leftAuto = box.left == null || (itemSetting.hCenter && box.left === '50%');\n        const rightAuto = box.right == null || (itemSetting.hCenter && box.left === '50%');\n        const topAuto = box.top == null || (itemSetting.vCenter && box.top === '50%');\n        const bottomAuto = box.bottom == null || (itemSetting.vCenter && box.top === '50%');\n        return { leftAuto, rightAuto, topAuto, bottomAuto };\n    }\n    checkOrigin(leftAuto, rightAuto, topAuto, bottomAuto) {\n        let left = leftAuto;\n        let right = rightAuto;\n        let top = topAuto;\n        let bottom = bottomAuto;\n        if (leftAuto === rightAuto) {\n            left = utils.isRTL();\n            right = !left;\n        }\n        if (topAuto === bottomAuto) {\n            top = false;\n            bottom = true;\n        }\n        return { top, bottom, left, right };\n    }\n    /**\n     * When width is custom, only one of the left and right can set to custom.\n     * @param prop\n     * @param relatedProp\n     * @param side\n     */\n    allowChangeAutoProps(side) {\n        var _a;\n        const itemSetting = this.props.layoutItem.setting;\n        const autoProps = (_a = itemSetting === null || itemSetting === void 0 ? void 0 : itemSetting.autoProps) !== null && _a !== void 0 ? _a : {};\n        const sizeMode = utils.getLayoutItemSizeMode(side, this.props.layoutItem.bbox, autoProps);\n        if (sizeMode === LayoutItemSizeModes.Stretch ||\n            (side === 'width' && (itemSetting === null || itemSetting === void 0 ? void 0 : itemSetting.hCenter)) ||\n            (side === 'height' && (itemSetting === null || itemSetting === void 0 ? void 0 : itemSetting.vCenter))) {\n            return false;\n        }\n        return true;\n    }\n    getOrigin(left, top, right, bottom) {\n        const { formatMessage } = this.props;\n        if (!left && !top) {\n            return this.flipLeftRight ? formatMessage('TR') : formatMessage('TL');\n        }\n        if (!right && !top) {\n            return this.flipLeftRight ? formatMessage('TL') : formatMessage('TR');\n        }\n        if (!right && !bottom) {\n            return this.flipLeftRight ? formatMessage('BL') : formatMessage('BR');\n        }\n        if (!left && !bottom) {\n            return this.flipLeftRight ? formatMessage('BR') : formatMessage('BL');\n        }\n        return '';\n    }\n    render() {\n        const { layoutItem, widthMode, heightMode, formatMessage } = this.props;\n        if (layoutItem == null) {\n            return null;\n        }\n        const itemSetting = lodash.assign({}, DEFAULT_FIX_LAYOUT_ITEM_SETTING, layoutItem.setting);\n        const { leftAuto, rightAuto, topAuto, bottomAuto } = this.checkAutoProps(itemSetting);\n        const { top, bottom, left, right } = this.checkOrigin(leftAuto, rightAuto, topAuto, bottomAuto);\n        const canSwitchXAuto = this.allowChangeAutoProps('width');\n        const canSwitchYAuto = this.allowChangeAutoProps('height');\n        return (jsx(\"div\", { css: this.getStyle(), className: 'w-100' },\n            jsx(\"div\", { className: 'position-setting rounded-2' },\n                jsx(\"div\", { className: 'content d-flex justify-content-center align-items-center' },\n                    jsx(\"div\", { className: 'd-flex w-half flex-column justify-content-center align-items-center' },\n                        jsx(\"div\", { className: 'd-flex w-100 justify-content-center align-items-center' },\n                            jsx(Tooltip, { placement: 'bottom', title: canSwitchXAuto ? formatMessage(leftAuto ? 'changeToCustom' : 'changeToAuto') : '' },\n                                jsx(\"div\", { className: classNames('from-left line-h flex-grow-1 flex-shrink-1', {\n                                        'is-auto': leftAuto,\n                                        'allow-change': canSwitchXAuto\n                                    }), onClick: canSwitchXAuto ? this.switchAuto.bind(this, 'left', 'right', leftAuto) : null })),\n                            leftAuto ? null : this.inputUnit('left'))),\n                    jsx(\"div\", { className: 'd-flex h-100 flex-column justify-content-center align-items-center box-column' },\n                        jsx(\"div\", { className: 'd-flex h-half w-100 flex-column justify-content-center align-items-center' },\n                            jsx(Tooltip, { placement: 'bottom', title: canSwitchYAuto ? formatMessage(topAuto ? 'changeToCustom' : 'changeToAuto') : '' },\n                                jsx(\"div\", { className: classNames('from-top line-v flex-grow-1 flex-shrink-1', {\n                                        'is-auto': topAuto,\n                                        'allow-change': canSwitchYAuto\n                                    }), onClick: canSwitchYAuto ? this.switchAuto.bind(this, 'top', 'bottom', topAuto) : null })),\n                            topAuto ? null : this.inputUnit('top')),\n                        jsx(\"div\", { className: classNames('box-item rounded-lg', {\n                                stretch: widthMode === LayoutItemSizeModes.Stretch || heightMode === LayoutItemSizeModes.Stretch,\n                                'stretch-w': widthMode === LayoutItemSizeModes.Stretch,\n                                'stretch-h': heightMode === LayoutItemSizeModes.Stretch\n                            }) },\n                            jsx(\"div\", { className: 'h-arrow' },\n                                jsx(ArrowStretchedOutlined, { className: 'arrow-icon' })),\n                            jsx(\"div\", { className: 'v-arrow' },\n                                jsx(ArrowStretchedOutlined, { className: 'arrow-icon', rotate: 90 }))),\n                        jsx(\"div\", { className: 'd-flex h-half w-100 flex-column justify-content-center align-items-center' },\n                            jsx(Tooltip, { placement: 'bottom', title: canSwitchYAuto ? formatMessage(bottomAuto ? 'changeToCustom' : 'changeToAuto') : '' },\n                                jsx(\"div\", { className: classNames('from-bottom line-v flex-grow-1 flex-shrink-1', {\n                                        'is-auto': bottomAuto,\n                                        'allow-change': canSwitchYAuto\n                                    }), onClick: canSwitchYAuto ? this.switchAuto.bind(this, 'bottom', 'top', bottomAuto) : null })),\n                            bottomAuto ? null : this.inputUnit('bottom'))),\n                    jsx(\"div\", { className: 'd-flex w-half flex-column justify-content-center align-items-center' },\n                        jsx(\"div\", { className: 'd-flex w-100 justify-content-center align-items-center' },\n                            jsx(Tooltip, { placement: 'bottom', title: canSwitchXAuto ? formatMessage(rightAuto ? 'changeToCustom' : 'changeToAuto') : '' },\n                                jsx(\"div\", { className: classNames('from-right line-h flex-grow-1 flex-shrink-1', {\n                                        'is-auto': rightAuto,\n                                        'allow-change': canSwitchXAuto\n                                    }), onClick: canSwitchXAuto ? this.switchAuto.bind(this, 'right', 'left', rightAuto) : null })),\n                            rightAuto ? null : this.inputUnit('right'))),\n                    jsx(\"div\", { className: classNames('anchor top left', {\n                            selected: !left && !top\n                        }) }),\n                    jsx(\"div\", { className: classNames('anchor top right', {\n                            selected: !right && !top\n                        }) }),\n                    jsx(\"div\", { className: classNames('anchor bottom left', {\n                            selected: !left && !bottom\n                        }) }),\n                    jsx(\"div\", { className: classNames('anchor bottom right', {\n                            selected: !bottom && !right\n                        }) }))),\n            jsx(\"div\", { className: 'origin-tip d-flex justify-content-center align-item-center' }, this.getOrigin(left, top, right, bottom))));\n    }\n}\n","/** @jsx jsx */\nimport { React, Immutable, jsx, css, lodash, APP_FRAME_NAME_IN_BUILDER, LayoutItemType, classNames } from 'jimu-core';\nimport { DEFAULT_FIX_LAYOUT_ITEM_SETTING } from '../default-setting';\nimport { SettingSection, SettingRow } from 'jimu-ui/advanced/setting-components';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { Tooltip, Switch, DistanceUnits, Button, utils as uiUtils } from 'jimu-ui';\nimport { SizeEditor, InputRatio } from 'jimu-ui/advanced/style-setting-components';\nimport CommonLayoutItemSetting from '../../builder/common-layout-item-setting';\nimport CommonTransformSetting from '../../builder/common-transform-setting';\nimport { utils, LayoutItemSizeModes } from 'jimu-layouts/layout-runtime';\nimport { ItemPositionSetting } from './item-position-setting';\nimport { fixedItemMenu } from './fixed-item-menu';\nimport { Toolbar } from '../../builder/toolbar';\nimport { LockOutlined } from 'jimu-icons/outlined/editor/lock';\nimport { UnlockOutlined } from 'jimu-icons/outlined/editor/unlock';\nimport moreHorizontalOutlined from 'jimu-icons/svg/outlined/application/more-horizontal.svg';\nimport { getTheme } from 'jimu-theme';\nconst sizemodes = [LayoutItemSizeModes.Auto, LayoutItemSizeModes.Custom, LayoutItemSizeModes.Stretch];\nconst sizemodesWithoutAuto = [LayoutItemSizeModes.Custom, LayoutItemSizeModes.Stretch];\nconst group1 = [\n    fixedItemMenu[1][1],\n    fixedItemMenu[1][2],\n    fixedItemMenu[1][3],\n    fixedItemMenu[1][4],\n    { separator: true },\n    fixedItemMenu[0][1],\n    fixedItemMenu[0][2],\n    fixedItemMenu[0][3]\n].map(item => { return Object.assign(Object.assign({}, item), { title: item.title, label: null }); });\nconst positionMenus = [\n    ...group1,\n    [\n        { icon: moreHorizontalOutlined, caret: false },\n        fixedItemMenu[0][4],\n        fixedItemMenu[0][5],\n        fixedItemMenu[0][6],\n        { separator: true },\n        fixedItemMenu[0][7],\n        fixedItemMenu[0][8],\n        fixedItemMenu[0][9]\n    ]\n];\nexport default class FixedItemSetting extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.updateBBox = (prop, value) => {\n            var _a;\n            let bbox = this.props.layoutItem.bbox;\n            const { distance, unit } = value;\n            const originalValue = bbox[prop];\n            const containerRect = this.getSizeOfContainer();\n            let newValue = distance.toFixed(2);\n            let pixelValue;\n            if (utils.isPercentage(originalValue) && unit === DistanceUnits.PIXEL) { // change from percentage to pixel\n                if (containerRect) {\n                    if (prop === 'left' || prop === 'right' || prop === 'width') {\n                        newValue = Math.round(parseFloat(originalValue) * containerRect.width / 100);\n                    }\n                    else {\n                        newValue = Math.round(parseFloat(originalValue) * containerRect.height / 100);\n                    }\n                    pixelValue = newValue;\n                }\n            }\n            else if (!utils.isPercentage(originalValue) && unit === DistanceUnits.PERCENTAGE) { // change from pixel to percentage\n                if (containerRect) {\n                    if (prop === 'left' || prop === 'right' || prop === 'width') {\n                        newValue = (parseFloat(originalValue) * 100 / containerRect.width).toFixed(4);\n                    }\n                    else {\n                        newValue = (parseFloat(originalValue) * 100 / containerRect.height).toFixed(4);\n                    }\n                }\n                pixelValue = parseFloat(originalValue);\n            }\n            if (!pixelValue && unit === DistanceUnits.PERCENTAGE) {\n                // change percentage value\n                const total = prop === 'width' ? containerRect.width : containerRect.height;\n                pixelValue = Math.round(distance * total / 100);\n            }\n            else if (!pixelValue && unit === DistanceUnits.PIXEL) {\n                pixelValue = distance;\n            }\n            bbox = bbox.set(prop, unit === DistanceUnits.PERCENTAGE ? `${newValue}%` : `${newValue}px`);\n            if (((_a = this.props.layoutItem.setting) === null || _a === void 0 ? void 0 : _a.heightMode) === 'ratio') {\n                const ratio = utils.parseAspectRatio(this.props.layoutItem.setting.aspectRatio);\n                if (prop === 'width') {\n                    const height = pixelValue * ratio;\n                    if (utils.isPercentage(bbox.height)) {\n                        const newValue = (height * 100 / containerRect.height).toFixed(4);\n                        bbox = bbox.set('height', `${newValue}%`);\n                    }\n                    else {\n                        bbox = bbox.set('height', `${Math.round(height)}px`);\n                    }\n                }\n                else {\n                    const width = pixelValue / ratio;\n                    if (utils.isPercentage(bbox.width)) {\n                        const newValue = (width * 100 / containerRect.width).toFixed(4);\n                        bbox = bbox.set('width', `${newValue}%`);\n                    }\n                    else {\n                        bbox = bbox.set('width', `${Math.round(width)}px`);\n                    }\n                }\n            }\n            this.props.onPosChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, bbox);\n        };\n        this.updateMode = (prop, value) => {\n            var _a;\n            const setting = (_a = this.props.layoutItem.setting) !== null && _a !== void 0 ? _a : Immutable({});\n            const layoutInfo = {\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            };\n            // set specific width/height if value is CUSTOM\n            if (value === LayoutItemSizeModes.Custom) {\n                const containerRect = this.getSizeOfContainer();\n                const itemRect = this.getSizeOfItem();\n                if (containerRect && itemRect) {\n                    const newValue = (itemRect[prop] * 100 / containerRect[prop]).toFixed(4);\n                    const appConfigAction = getAppConfigAction();\n                    appConfigAction\n                        .editLayoutItemProperty(layoutInfo, 'setting', setting.setIn(['autoProps', prop], value))\n                        .editLayoutItemProperty(layoutInfo, `bbox.${prop}`, `${newValue}%`)\n                        .exec();\n                    return;\n                }\n            }\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.setIn(['autoProps', prop], value));\n        };\n        this.updateLockParent = (e) => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            setting = setting.set('lockParent', e.target.checked);\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.toggleHeightMode = () => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            const mode = setting.heightMode === 'ratio' ? 'fixed' : 'ratio';\n            setting = setting.set('heightMode', mode);\n            if (mode === 'ratio') {\n                const itemRect = this.getSizeOfItem();\n                if (itemRect) {\n                    setting = setting.set('aspectRatio', Number((itemRect.height / itemRect.width).toFixed(2)))\n                        .setIn(['autoProps', 'height', 'AUTO']);\n                }\n            }\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.updateAspectRatio = (newRatio) => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            setting = setting.set('aspectRatio', newRatio);\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.flipLeftRight = utils.isRTL();\n        this.state = { enableToolbar: false };\n    }\n    componentDidMount() {\n        if (this.ref) {\n            this.setState({ enableToolbar: true });\n        }\n    }\n    getSizeOfContainer() {\n        const layoutElem = this.querySelector(`div.fixed-layout[data-layoutid=\"${this.props.layoutId}\"]`);\n        if (layoutElem) {\n            return layoutElem.getBoundingClientRect();\n        }\n        return null;\n    }\n    getSizeOfItem() {\n        const { layoutId, layoutItem } = this.props;\n        const layoutElem = this.querySelector(`div.exb-rnd[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItem.id}\"]`);\n        if (layoutElem) {\n            return layoutElem.getBoundingClientRect();\n        }\n        return null;\n    }\n    querySelector(selector) {\n        const appFrame = document.querySelector(`iframe[name=\"${APP_FRAME_NAME_IN_BUILDER}\"]`);\n        if (appFrame) {\n            const appFrameDoc = appFrame.contentDocument || appFrame.contentWindow.document;\n            return appFrameDoc.querySelector(selector);\n        }\n        return null;\n    }\n    getStyle() {\n        return css `\r\n      .layout-item-toolbar {\r\n        box-shadow: none;\r\n        background: transparent;\r\n\r\n        .toolbar-item, icon-container {\r\n          width: 28px;\r\n          min-height: 28px;\r\n        }\r\n        .toolbar-group {\r\n          background: transparent;\r\n          margin: 0 1px;\r\n        }\r\n        .toolbar-item {\r\n          margin: 0 1px;\r\n          background: transparent;\r\n          &:hover {\r\n            background: var(--ref-palette-neutral-500);\r\n          }\r\n\r\n          svg {\r\n            width: 14px;\r\n            height: 14px;\r\n          }\r\n        }\r\n      }\r\n\r\n      .ratio-value {\r\n        font-size: 12px;\r\n      }\r\n    `;\n    }\n    render() {\n        const { layoutItem, layoutId, formatMessage, isLockLayout, supportAutoSize } = this.props;\n        if (!layoutItem) {\n            return null;\n        }\n        this.itemSetting = lodash.assign({}, DEFAULT_FIX_LAYOUT_ITEM_SETTING, layoutItem.setting);\n        const isKeepAspect = this.itemSetting.heightMode === 'ratio';\n        const widthMode = utils.getLayoutItemSizeMode('width', layoutItem.bbox, this.itemSetting.autoProps);\n        const heightMode = utils.getLayoutItemSizeMode('height', layoutItem.bbox, this.itemSetting.autoProps);\n        const bbox = layoutItem.bbox;\n        const theme = getTheme();\n        const inputStyle = css `width: 100px;`;\n        return (jsx(\"div\", { className: 'fixed-item-setting', css: this.getStyle(), ref: el => { this.ref = el; } },\n            !isLockLayout && this.state.enableToolbar && (jsx(React.Fragment, null,\n                jsx(SettingSection, { className: 'p-0 d-flex justify-content-center' },\n                    jsx(Toolbar, { layoutId: layoutId, layoutItem: layoutItem, parentRef: this.ref, theme: theme, tools: positionMenus, formatMessage: this.props.formatMessage })),\n                jsx(SettingSection, { role: 'group', \"aria-label\": `${formatMessage('size')} & ${formatMessage('position')}`, title: `${formatMessage('size')} & ${formatMessage('position')}` },\n                    jsx(SettingRow, { role: 'group', \"aria-label\": formatMessage('width'), label: formatMessage('width') },\n                        jsx(\"div\", { css: inputStyle },\n                            jsx(SizeEditor, { label: 'W', mode: widthMode, sizeModes: supportAutoSize && !isKeepAspect ? sizemodes : sizemodesWithoutAuto, value: uiUtils.stringOfLinearUnit(bbox.width), onChange: value => { this.updateBBox('width', value); }, onModeChange: value => { this.updateMode('width', value); } }))),\n                    widthMode !== LayoutItemSizeModes.Auto && (jsx(\"div\", null,\n                        jsx(Tooltip, { title: formatMessage('keepAspectRatio'), placement: 'bottom' },\n                            jsx(Button, { size: 'sm', type: 'tertiary', className: 'ml-1', icon: true, onClick: this.toggleHeightMode, \"aria-pressed\": isKeepAspect }, isKeepAspect ? jsx(LockOutlined, { size: 's' }) : jsx(UnlockOutlined, { size: 's' }))))),\n                    jsx(SettingRow, { role: 'group', \"aria-label\": formatMessage('height'), label: formatMessage('height'), className: classNames({ 'mt-0': widthMode !== LayoutItemSizeModes.Auto }) },\n                        jsx(\"div\", { css: inputStyle },\n                            jsx(SizeEditor, { label: 'H', mode: heightMode, sizeModes: supportAutoSize ? sizemodes : sizemodesWithoutAuto, disabled: isKeepAspect, value: uiUtils.stringOfLinearUnit(bbox.height), onChange: value => { this.updateBBox('height', value); }, onModeChange: value => { this.updateMode('height', value); } }))),\n                    isKeepAspect && (jsx(SettingRow, { \"aria-label\": formatMessage('aspectRatio'), label: formatMessage('aspectRatio') },\n                        jsx(InputRatio, { value: this.itemSetting.aspectRatio, style: { width: 100 }, onChange: this.updateAspectRatio }))),\n                    jsx(SettingRow, null,\n                        jsx(ItemPositionSetting, Object.assign({}, this.props, { widthMode: widthMode, heightMode: heightMode }))),\n                    jsx(CommonTransformSetting, { layoutId: layoutId, layoutItemId: layoutItem.id, setting: layoutItem.setting, onSettingChange: this.props.onSettingChange, formatMessage: this.props.formatMessage })),\n                jsx(SettingSection, null,\n                    jsx(SettingRow, { tag: 'label', label: formatMessage('lockParent') },\n                        jsx(Switch, { checked: this.itemSetting.lockParent, onChange: this.updateLockParent }))))),\n            (layoutItem.type === LayoutItemType.Widget || layoutItem.sectionId) && (jsx(CommonLayoutItemSetting, { layoutId: layoutId, layoutItemId: layoutItem.id, style: this.props.style, isSection: layoutItem.type === LayoutItemType.Section, onStyleChange: this.props.onStyleChange, formatMessage: this.props.formatMessage, setting: layoutItem.setting || Immutable({}), onSettingChange: this.props.onSettingChange }))));\n    }\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ScreenTransitionType, classNames } from 'jimu-core';\nimport { Icon, Checkbox } from 'jimu-ui';\nimport { SettingSection, SettingRow } from 'jimu-ui/advanced/setting-components';\nexport const icons = {\n    [ScreenTransitionType.Push]: require('jimu-ui/advanced/lib/assets/icon_animation_transition_push.svg'),\n    [ScreenTransitionType.Fade]: require('jimu-ui/advanced/lib/assets/icon_animation_transition_fade.svg'),\n    [ScreenTransitionType.Cover]: require('jimu-ui/advanced/lib/assets/icon_animation_transition_push.svg')\n};\nexport class TransitionPopperContent extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.onTypeChanged = (e, type, isPanel) => {\n            if (isPanel) {\n                this.props.onPanelTransitionTypeChange(type);\n            }\n            else {\n                this.props.onTransitionTypeChange(type);\n            }\n        };\n        this.updateFirstPanel = (e) => {\n            // e.target.checked;\n        };\n    }\n    getStyle() {\n        return css `\r\n      .animation-cards {\r\n        display: grid;\r\n        grid-template-columns: 1fr 1fr;\r\n        grid-row-gap: 12px;\r\n        grid-column-gap: 12px;\r\n      }\r\n\r\n      .card-item {\r\n        font-size: 13px;\r\n        flex: 0 0 45%;\r\n\r\n        user-select: none;\r\n        cursor: pointer;\r\n        position: relative;\r\n\r\n        .card-content {\r\n          width: 100%;\r\n          height: 5rem;\r\n          background-color: var(--ref-palette-neutral-300);\r\n        }\r\n\r\n        &.selected .card-content {\r\n          outline: 2px solid var(--sys-color-primary-light);\r\n        }\r\n\r\n        .card-image {\r\n          width: 100%;\r\n          height: 100%;\r\n          padding: 8px;\r\n          &:after {\r\n            display: none;\r\n          }\r\n        }\r\n\r\n        .card-name {\r\n          max-width: 90px;\r\n          margin: 0 auto;\r\n          color: var(--ref-palette-neutral-1100);\r\n          .card-name-content {\r\n            line-height: 1rem;\r\n            max-height: 2rem;\r\n            white-space: normal;\r\n          }\r\n        }\r\n      }\r\n    `;\n    }\n    createAnimationCard(type, index, isPanel = false) {\n        const { transitionType, panelTransitionType } = this.props;\n        let effectType;\n        if (isPanel) {\n            effectType = panelTransitionType !== null && panelTransitionType !== void 0 ? panelTransitionType : ScreenTransitionType.Push;\n        }\n        else {\n            effectType = transitionType !== null && transitionType !== void 0 ? transitionType : ScreenTransitionType.Fade;\n        }\n        return (jsx(\"div\", { className: classNames('d-flex flex-column align-items-center card-item', {\n                selected: type === effectType\n            }), key: index, onClick: (e) => { this.onTypeChanged(e, type, isPanel); } },\n            jsx(\"div\", { className: 'd-flex justify-content-center card-content' },\n                jsx(\"div\", { className: 'card-image' },\n                    jsx(Icon, { className: 'w-100', currentColor: false, icon: icons[type], size: 72 }))),\n            jsx(\"div\", { className: 'card-name flex-grow-1 d-flex align-items-start mt-1' },\n                jsx(\"span\", { className: 'text-center text-truncate card-name-content', title: this.props.formatMessage(type.toLowerCase()) }, this.props.formatMessage(type.toLowerCase())))));\n    }\n    render() {\n        const { formatMessage } = this.props;\n        return (jsx(\"div\", { className: 'bg-default border-color-gray-400', css: this.getStyle() },\n            jsx(SettingSection, { title: formatMessage('mainStage') },\n                jsx(\"div\", { className: 'animation-cards' }, [ScreenTransitionType.Fade, ScreenTransitionType.Cover, ScreenTransitionType.Push]\n                    .map((info, index) => this.createAnimationCard(info, index)))),\n            jsx(SettingSection, { title: formatMessage('scrollingPanel') },\n                jsx(\"div\", { className: 'animation-cards' }, [ScreenTransitionType.Push, ScreenTransitionType.Fade]\n                    .map((info, index) => this.createAnimationCard(info, index, true)))),\n            jsx(SettingSection, null,\n                jsx(SettingRow, null,\n                    jsx(Checkbox, { onChange: this.updateFirstPanel, className: 'mr-2' }),\n                    formatMessage('applyToFirstPanel')))));\n    }\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, ScreenTransitionType, createSelector } from 'jimu-core';\nimport { SettingSection, SidePopper } from 'jimu-ui/advanced/setting-components';\nimport { Icon, Button } from 'jimu-ui';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { TransitionPopperContent, icons } from './screen-group-setting-popper';\nconst animationIcon = require('jimu-ui/advanced/lib/assets/icon_animation_in_none.svg');\nclass ScreenGroupSetting extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.sidePopperTrigger = React.createRef();\n        this.onTransitionTypeChange = (type) => {\n            const { screenGroupId } = this.props.layoutItem;\n            getAppConfigAction().editScreenGroupProperty(screenGroupId, 'transitionType', type).exec();\n        };\n        this.onPanelTransitionTypeChange = (type) => {\n            const { screenGroupId } = this.props.layoutItem;\n            getAppConfigAction().editScreenGroupProperty(screenGroupId, 'panelTransitionType', type).exec();\n        };\n        this.toggleSidePanel = () => {\n            this.setState({ showSidePanel: !this.state.showSidePanel });\n        };\n        this.state = {\n            showSidePanel: false\n        };\n    }\n    getAnimBoxStyle() {\n        return css `\r\n      background-color: transparent;\r\n      width: 100%;\r\n      height: 72px;\r\n\r\n      .img-tip {\r\n        position: relative;\r\n        min-width: 90px;\r\n        height: 72px;\r\n        cursor: pointer;\r\n        background: var(--ref-palette-neutral-300);\r\n\r\n        .has-sibling {\r\n          position: absolute;\r\n          &.first {\r\n            left: 5px;\r\n            top: 5px;\r\n          }\r\n          &.second {\r\n            bottom: 5px;\r\n            right: 5px;\r\n          }\r\n        }\r\n\r\n        .diag-sep {\r\n          position: absolute;\r\n          height: 1px;\r\n          width: 80px;\r\n          top: 36px;\r\n          transform: rotateZ(-45deg);\r\n          background: var(--ref-palette-neutral-500);\r\n        }\r\n      }\r\n\r\n      .anim-label {\r\n        align-self: flex-start;\r\n      }\r\n    `;\n    }\n    getSidePopperStyle() {\n        return css `\r\n      .header {\r\n        height: 60px;\r\n        padding: 0 0.5rem;\r\n      }\r\n      .side-popper-title {\r\n        color: var(--ref-palette-neutral-1000);\r\n        font-size: 13px;\r\n      }\r\n      .side-content {\r\n        position: relative;\r\n        width: 100%;\r\n        height: calc(100% - 60px);\r\n        overflow: auto;\r\n      }\r\n    `;\n    }\n    render() {\n        var _a, _b, _c, _d, _e;\n        const { formatMessage } = this.props;\n        const transitionType = (_a = this.props.transitionType) !== null && _a !== void 0 ? _a : ScreenTransitionType.Fade;\n        const panelTransitionType = (_b = this.props.panelTransitionType) !== null && _b !== void 0 ? _b : ScreenTransitionType.Push;\n        return (jsx(SettingSection, { title: formatMessage('transition') },\n            jsx(\"div\", { className: 'anima-box d-flex justify-content-between align-items-center', css: this.getAnimBoxStyle() },\n                jsx(\"div\", { className: 'img-tip d-flex justify-content-center align-items-center', onClick: this.toggleSidePanel },\n                    jsx(\"div\", { className: 'anim-icon first has-sibling' },\n                        jsx(Icon, { icon: (_c = icons[transitionType]) !== null && _c !== void 0 ? _c : animationIcon, size: 32 })),\n                    jsx(\"div\", { className: 'diag-sep' }),\n                    jsx(\"div\", { className: 'anim-icon second has-sibling' },\n                        jsx(Icon, { icon: (_d = icons[panelTransitionType]) !== null && _d !== void 0 ? _d : animationIcon, size: 32 }))),\n                jsx(\"div\", { className: 'd-flex flex-column justify-content-between align-items-end h-100' },\n                    jsx(\"div\", { className: 'anim-label' },\n                        jsx(\"span\", null, formatMessage(transitionType.toLowerCase())),\n                        jsx(\"span\", { className: 'mx-1' }, \"/\"),\n                        jsx(\"span\", null, formatMessage(panelTransitionType.toLowerCase()))),\n                    jsx(\"div\", { className: 'amin-icons w-100', ref: this.sidePopperTrigger },\n                        jsx(Button, { size: 'sm', onClick: this.toggleSidePanel, className: 'text-truncate', title: formatMessage('change') }, formatMessage('change'))))),\n            this.state.showSidePanel && (jsx(SidePopper, { isOpen: true, title: formatMessage('transition'), css: this.getSidePopperStyle(), position: 'right', toggle: this.toggleSidePanel, trigger: (_e = this.sidePopperTrigger) === null || _e === void 0 ? void 0 : _e.current },\n                jsx(\"div\", { className: 'side-content' },\n                    jsx(TransitionPopperContent, { transitionType: transitionType, panelTransitionType: panelTransitionType, onTransitionTypeChange: this.onTransitionTypeChange, onPanelTransitionTypeChange: this.onPanelTransitionTypeChange, formatMessage: formatMessage }))))));\n    }\n}\nconst mapStateToProps = createSelector([\n    (state, props) => {\n        const { screenGroupId } = props.layoutItem;\n        const { appConfig } = state.appStateInBuilder;\n        return appConfig.screenGroups[screenGroupId].transitionType;\n    },\n    (state, props) => {\n        const { screenGroupId } = props.layoutItem;\n        const { appConfig } = state.appStateInBuilder;\n        return appConfig.screenGroups[screenGroupId].panelTransitionType;\n    }\n], (transitionType, panelTransitionType) => ({ transitionType, panelTransitionType }));\nexport default ReactRedux.connect(mapStateToProps)(ScreenGroupSetting);\n","/** @jsx jsx */\nimport { React, Immutable, jsx, css, classNames, lodash, LayoutItemType } from 'jimu-core';\nimport { LayoutItemSizeModes } from 'jimu-layouts/layout-runtime';\nimport { DEFAULT_FLOW_ITEM_SETTING } from '../default-setting';\nimport { SettingSection, SettingRow } from 'jimu-ui/advanced/setting-components';\nimport CommonLayoutItemSetting from '../../builder/common-layout-item-setting';\nimport { NumericInput, utils as uiUtils } from 'jimu-ui';\nimport { SizeEditor } from 'jimu-ui/advanced/style-setting-components';\nimport ScreenGroupSetting from './screen-group-setting';\n// const marginSides = [Sides.T, Sides.R, Sides.B, Sides.L];\nconst inputStyle = { width: 110 };\nexport default class FloatingItemSetting extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.updateWidth = (value) => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            setting = setting.set('width', uiUtils.stringOfLinearUnit(value));\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.updateBBoxWidth = (value) => {\n            let bbox = Immutable(this.props.layoutItem.bbox || {});\n            bbox = bbox.set('width', uiUtils.stringOfLinearUnit(value));\n            this.props.onPosChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, bbox);\n        };\n        this.updateHeight = (value) => {\n            let bbox = Immutable(this.props.layoutItem.bbox || {});\n            bbox = bbox.set('height', uiUtils.stringOfLinearUnit(value));\n            this.props.onPosChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, bbox);\n        };\n        this.updateOffsetX = (value) => {\n            const setting = this.props.layoutItem.setting || Immutable({});\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.set('offsetX', value));\n        };\n        this.updateOffsetY = (value) => {\n            const setting = this.props.layoutItem.setting || Immutable({});\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.set('offsetY', value));\n        };\n        this.updateHeightMode = (mode) => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            setting = setting.set('heightMode', mode === LayoutItemSizeModes.Custom ? 'fixed' : 'auto');\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n    }\n    updateFloatingArea(value) {\n        const setting = this.props.layoutItem.setting || Immutable({});\n        this.props.onSettingChange({\n            layoutId: this.props.layoutId,\n            layoutItemId: this.props.layoutItem.id\n        }, setting.set('floatingArea', value));\n    }\n    getStyle() {\n        return css `\r\n      .floating-position {\r\n        margin-bottom: 1rem;\r\n      }\r\n\r\n      .floating-area-chooser {\r\n        position: relative;\r\n\r\n        .content {\r\n          display: grid;\r\n          grid-template-columns: 1fr 1fr 1fr;\r\n          grid-row-gap: 0;\r\n          grid-column-gap: 0;\r\n          border: 1px solid var(--ref-palette-neutral-500);\r\n\r\n          & > div {\r\n            cursor: pointer;\r\n            width: 30px;\r\n            height: 30px;\r\n            position: relative;\r\n          }\r\n\r\n          & > div:nth-of-type(3n+1) {\r\n            border-right: 1px solid var(--ref-palette-neutral-500);\r\n          }\r\n          & > div:nth-of-type(3n) {\r\n            border-left: 1px solid var(--ref-palette-neutral-500);\r\n          }\r\n          & > div:nth-of-type(1), & > div:nth-of-type(2), & > div:nth-of-type(3) {\r\n            border-bottom: 1px solid var(--ref-palette-neutral-500);\r\n          }\r\n          & > div:nth-of-type(7), & > div:nth-of-type(8), & > div:nth-of-type(9) {\r\n            border-top: 1px solid var(--ref-palette-neutral-500);\r\n          }\r\n\r\n          .selected:after {\r\n            content: '';\r\n            position: absolute;\r\n            width: 100%;\r\n            height: 100%;\r\n            background-color: var(--sys-color-primary-light);\r\n            border: 1px solid var(--sys-color-primary-main);\r\n          }\r\n        }\r\n      }\r\n    `;\n    }\n    render() {\n        const { layoutId, layoutItem, formatMessage, isLockLayout } = this.props;\n        if (!layoutItem) {\n            return null;\n        }\n        if (layoutItem.type === LayoutItemType.ScreenGroup) {\n            return jsx(ScreenGroupSetting, Object.assign({}, this.props));\n        }\n        this.itemSetting = lodash.assign({}, DEFAULT_FLOW_ITEM_SETTING, layoutItem.setting);\n        const bbox = layoutItem.bbox;\n        return (jsx(\"div\", { className: 'flow-item-setting', css: this.getStyle() },\n            !isLockLayout && jsx(React.Fragment, null,\n                jsx(SettingSection, { title: `${formatMessage('position')} & ${formatMessage('size')}` },\n                    jsx(\"div\", { className: 'floating-position d-flex' },\n                        jsx(\"div\", { className: 'floating-area-chooser' },\n                            jsx(\"div\", { className: 'content' },\n                                jsx(\"div\", { className: classNames('top-left', { selected: this.itemSetting.floatingArea === 1 }), onClick: this.updateFloatingArea.bind(this, 1) }),\n                                jsx(\"div\", { className: classNames('top-center', { selected: this.itemSetting.floatingArea === 2 }), onClick: this.updateFloatingArea.bind(this, 2) }),\n                                jsx(\"div\", { className: classNames('top-right', { selected: this.itemSetting.floatingArea === 3 }), onClick: this.updateFloatingArea.bind(this, 3) }),\n                                jsx(\"div\", { className: classNames('middle-left', { selected: this.itemSetting.floatingArea === 4 }), onClick: this.updateFloatingArea.bind(this, 4) }),\n                                jsx(\"div\", { className: classNames('middle-center', { selected: this.itemSetting.floatingArea === 5 }), onClick: this.updateFloatingArea.bind(this, 5) }),\n                                jsx(\"div\", { className: classNames('middle-right', { selected: this.itemSetting.floatingArea === 6 }), onClick: this.updateFloatingArea.bind(this, 6) }),\n                                jsx(\"div\", { className: classNames('bottom-left', { selected: this.itemSetting.floatingArea === 7 }), onClick: this.updateFloatingArea.bind(this, 7) }),\n                                jsx(\"div\", { className: classNames('bottom-center', { selected: this.itemSetting.floatingArea === 8 }), onClick: this.updateFloatingArea.bind(this, 8) }),\n                                jsx(\"div\", { className: classNames('bottom-right', { selected: this.itemSetting.floatingArea === 9 }), onClick: this.updateFloatingArea.bind(this, 9) }))),\n                        jsx(\"div\", { className: 'd-flex flex-grow-1 flex-column justify-content-between align-items-end' },\n                            jsx(\"div\", { className: 'd-flex align-items-center', css: css `width: 110px` },\n                                jsx(\"span\", { className: 'mr-2' }, \"W\"),\n                                jsx(SizeEditor, { label: 'W', mode: LayoutItemSizeModes.Custom, disableModeSelect: true, value: bbox === null || bbox === void 0 ? void 0 : bbox.width, onChange: this.updateBBoxWidth })),\n                            jsx(\"div\", { className: 'd-flex align-items-center', css: css `width: 110px` },\n                                jsx(\"span\", { className: 'mr-2' }, \"H\"),\n                                jsx(SizeEditor, { label: 'H', mode: LayoutItemSizeModes.Custom, disableModeSelect: true, value: bbox === null || bbox === void 0 ? void 0 : bbox.height, onChange: this.updateHeight })))),\n                    jsx(SettingRow, { label: formatMessage('offsetX') },\n                        jsx(NumericInput, { style: inputStyle, value: this.itemSetting.offsetX, precision: 0, onChange: this.updateOffsetX, size: 'sm' })),\n                    jsx(SettingRow, { label: formatMessage('offsetY') },\n                        jsx(NumericInput, { style: inputStyle, precision: 0, value: this.itemSetting.offsetY, onChange: this.updateOffsetY, size: 'sm' })))),\n            (layoutItem.type === LayoutItemType.Widget || layoutItem.sectionId) && (jsx(CommonLayoutItemSetting, { layoutId: layoutId, layoutItemId: layoutItem.id, isSection: false, style: this.props.style, onStyleChange: this.props.onStyleChange, onSettingChange: this.props.onSettingChange, formatMessage: this.props.formatMessage }))));\n    }\n}\n","/** @jsx jsx */\nimport { React, jsx, css, Immutable, LayoutItemType, APP_FRAME_NAME_IN_BUILDER } from 'jimu-core';\nimport { SettingSection, SettingRow } from 'jimu-ui/advanced/setting-components';\nimport { SizeEditor, InputRatio } from 'jimu-ui/advanced/style-setting-components';\nimport { DistanceUnits, Select, Tooltip, Button } from 'jimu-ui';\nimport { LayoutItemSizeModes, utils as layoutUtils } from 'jimu-layouts/layout-runtime';\nimport CommonLayoutItemSetting from '../../builder/common-layout-item-setting';\nimport CommonTransformSetting from '../../builder/common-transform-setting';\nimport { LockOutlined } from 'jimu-icons/outlined/editor/lock';\nimport { UnlockOutlined } from 'jimu-icons/outlined/editor/unlock';\nconst inputStyle = css `width: 100px;`;\nconst widthModes = [LayoutItemSizeModes.Stretch, LayoutItemSizeModes.Custom];\nconst heightModes = [LayoutItemSizeModes.Auto, LayoutItemSizeModes.Stretch, LayoutItemSizeModes.Custom];\nconst heightModesWithoutAuto = [LayoutItemSizeModes.Stretch, LayoutItemSizeModes.Custom];\nconst availableWidthUnits = [DistanceUnits.PIXEL, DistanceUnits.PERCENTAGE];\nconst availableHeightUnits = [DistanceUnits.PIXEL];\nexport default class ColumnItemSetting extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.updateBBox = (prop, value) => {\n            var _a;\n            let bbox = this.props.layoutItem.bbox;\n            const { distance, unit } = value;\n            const originalValue = bbox[prop];\n            const containerRect = this.getSizeOfContainer();\n            let newValue = distance.toFixed(2);\n            let pixelValue;\n            if (layoutUtils.isPercentage(originalValue) && unit === DistanceUnits.PIXEL) { // change from percentage to pixel\n                if (containerRect) {\n                    if (prop === 'left' || prop === 'right' || prop === 'width') {\n                        newValue = Math.round(parseFloat(originalValue) * containerRect.width / 100);\n                    }\n                    else {\n                        newValue = Math.round(parseFloat(originalValue) * containerRect.height / 100);\n                    }\n                    pixelValue = newValue;\n                }\n            }\n            else if (!layoutUtils.isPercentage(originalValue) && unit === DistanceUnits.PERCENTAGE) { // change from pixel to percentage\n                if (containerRect) {\n                    if (prop === 'left' || prop === 'right' || prop === 'width') {\n                        newValue = (parseFloat(originalValue) * 100 / containerRect.width).toFixed(4);\n                    }\n                    else {\n                        newValue = (parseFloat(originalValue) * 100 / containerRect.height).toFixed(4);\n                    }\n                }\n                pixelValue = parseFloat(originalValue);\n            }\n            if (!pixelValue && unit === DistanceUnits.PERCENTAGE) {\n                // change percentage value\n                const total = prop === 'width' ? containerRect.width : containerRect.height;\n                pixelValue = Math.round(distance * total / 100);\n            }\n            else if (!pixelValue && unit === DistanceUnits.PIXEL) {\n                pixelValue = distance;\n            }\n            bbox = bbox.set(prop, unit === DistanceUnits.PERCENTAGE ? `${newValue}%` : `${newValue}px`);\n            if (((_a = this.props.layoutItem.setting) === null || _a === void 0 ? void 0 : _a.heightMode) === 'ratio') {\n                const ratio = this.props.layoutItem.setting.aspectRatio;\n                if (prop === 'width') {\n                    const height = pixelValue * ratio;\n                    if (layoutUtils.isPercentage(bbox.height)) {\n                        const newValue = (height * 100 / containerRect.height).toFixed(4);\n                        bbox = bbox.set('height', `${newValue}%`);\n                    }\n                    else {\n                        bbox = bbox.set('height', `${Math.round(height)}px`);\n                    }\n                }\n                else {\n                    const width = pixelValue / ratio;\n                    if (layoutUtils.isPercentage(bbox.width)) {\n                        const newValue = (width * 100 / containerRect.width).toFixed(4);\n                        bbox = bbox.set('width', `${newValue}%`);\n                    }\n                    else {\n                        bbox = bbox.set('width', `${Math.round(width)}px`);\n                    }\n                }\n            }\n            this.props.onPosChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, bbox);\n        };\n        this.toggleHeightMode = () => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            const heightMode = setting.heightMode === 'ratio' ? 'fixed' : 'ratio';\n            setting = setting.set('heightMode', heightMode);\n            if (heightMode === 'ratio') {\n                const itemRect = this.getSizeOfItem();\n                if (itemRect) {\n                    setting = setting.set('aspectRatio', Number((itemRect.height / itemRect.width).toFixed(2)));\n                }\n            }\n            else {\n                let bbox = this.props.layoutItem.bbox;\n                const rect = this.getSizeOfItem();\n                if (layoutUtils.isPercentage(bbox.width)) {\n                    const containerRect = this.getSizeOfContainer();\n                    bbox = bbox.set('width', `${(rect.width * 100 / containerRect.width).toFixed(4)}%`);\n                }\n                else {\n                    bbox = bbox.set('width', `${Math.round(rect.width)}px`);\n                }\n                bbox = bbox.set('height', `${Math.round(rect.height)}px`);\n                this.props.onPosChange({\n                    layoutId: this.props.layoutId,\n                    layoutItemId: this.props.layoutItem.id\n                }, bbox);\n            }\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.updateAlignSelf = (e) => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            setting = setting.setIn(['style', 'alignSelf'], e.target.value);\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.updateHeightMode = (mode) => {\n            const setting = this.props.layoutItem.setting || Immutable({});\n            let bbox = Immutable(this.props.layoutItem.bbox);\n            if (mode === LayoutItemSizeModes.Custom && isNaN(parseFloat(bbox.height))) {\n                const rect = this.getSizeOfItem();\n                bbox = bbox.set('height', `${Math.round(rect.height)}px`);\n                this.props.onPosChange({\n                    layoutId: this.props.layoutId,\n                    layoutItemId: this.props.layoutItem.id\n                }, bbox);\n            }\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.setIn(['autoProps', 'height'], mode));\n        };\n        this.updateWidthMode = (mode) => {\n            const setting = this.props.layoutItem.setting || Immutable({});\n            let bbox = Immutable(this.props.layoutItem.bbox);\n            if (mode === LayoutItemSizeModes.Custom && isNaN(parseFloat(bbox.width))) {\n                const rect = this.getSizeOfItem();\n                bbox = bbox.set('width', `${Math.round(rect.width)}px`);\n                this.props.onPosChange({\n                    layoutId: this.props.layoutId,\n                    layoutItemId: this.props.layoutItem.id\n                }, bbox);\n            }\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.setIn(['autoProps', 'width'], mode));\n        };\n        this.updateAspectRatio = (newRatio) => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            setting = setting.set('aspectRatio', newRatio);\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.formatMessage = (id) => {\n            return this.props.formatMessage(id);\n        };\n    }\n    getSizeOfContainer() {\n        const layoutElem = this.querySelector(`div.column-layout[data-layoutid=\"${this.props.layoutId}\"]`);\n        if (layoutElem) {\n            return layoutElem.getBoundingClientRect();\n        }\n        return null;\n    }\n    getSizeOfItem() {\n        const { layoutId, layoutItem } = this.props;\n        const layoutElem = this.querySelector(`div.exb-rnd[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItem.id}\"]`);\n        if (layoutElem) {\n            return layoutElem.getBoundingClientRect();\n        }\n        return null;\n    }\n    querySelector(selector) {\n        const appFrame = document.querySelector(`iframe[name=\"${APP_FRAME_NAME_IN_BUILDER}\"]`);\n        if (appFrame) {\n            const appFrameDoc = appFrame.contentDocument || appFrame.contentWindow.document;\n            return appFrameDoc.querySelector(selector);\n        }\n        return null;\n    }\n    getStyle() {\n        return css `\r\n      .rotation-setting, .rotation-setting input {\r\n        height: 26px;\r\n      }\r\n\r\n      .ratio-value {\r\n        font-size: 12px;\r\n      }\r\n\r\n      .align-select {\r\n        .dropdown-button, .dropdown-button:hover {\r\n          height: 26px;\r\n        }\r\n      }\r\n    `;\n    }\n    // getAspectRatio() {\n    //   const ratio = this.props.layoutItem.setting?.aspectRatio ?? -1;\n    //   if (ratio < 0) {\n    //     return '';\n    //   }\n    //   const width = 100;\n    //   const height = Math.round(ratio * 100);\n    //   const common = layoutUtils.gcd(width, height);\n    //   return `${width / common} : ${height / common}`;\n    // }\n    render() {\n        var _a, _b, _c, _d;\n        const { layoutId, layoutItem, isLockLayout, supportAutoSize } = this.props;\n        if (!layoutItem) {\n            return null;\n        }\n        const setting = layoutItem.setting || {};\n        const style = setting.style || {};\n        const bbox = layoutItem.bbox || {};\n        const isAutoWidth = ((_a = setting.autoProps) === null || _a === void 0 ? void 0 : _a.width) !== LayoutItemSizeModes.Custom;\n        const heightMode = (_c = (_b = setting.autoProps) === null || _b === void 0 ? void 0 : _b.height) !== null && _c !== void 0 ? _c : LayoutItemSizeModes.Custom;\n        const keepAspectRatio = setting.heightMode === 'ratio';\n        return (jsx(\"div\", { className: 'column-item-setting', css: this.getStyle() },\n            !isLockLayout && jsx(React.Fragment, null,\n                jsx(SettingSection, { role: 'group', title: this.formatMessage('size'), \"aria-label\": this.formatMessage('size') },\n                    jsx(SettingRow, { role: 'group', label: this.formatMessage('width'), \"aria-label\": this.formatMessage('width') },\n                        jsx(\"div\", { css: inputStyle },\n                            jsx(SizeEditor, { label: 'W', mode: isAutoWidth ? LayoutItemSizeModes.Stretch : LayoutItemSizeModes.Custom, sizeModes: widthModes, value: bbox === null || bbox === void 0 ? void 0 : bbox.width, availableUnits: availableWidthUnits, onChange: value => { this.updateBBox('width', value); }, onModeChange: this.updateWidthMode }))),\n                    jsx(SettingRow, { className: 'mt-0', label: jsx(Tooltip, { title: this.formatMessage('keepAspectRatio'), placement: 'bottom' },\n                            jsx(Button, { size: 'sm', type: 'tertiary', className: 'ml-1', icon: true, onClick: this.toggleHeightMode, \"aria-pressed\": keepAspectRatio }, keepAspectRatio ? jsx(LockOutlined, { size: 's' }) : jsx(UnlockOutlined, { size: 's' }))) }),\n                    jsx(SettingRow, { role: 'group', className: 'mt-0', label: this.formatMessage('height'), \"aria-label\": this.formatMessage('height') },\n                        jsx(\"div\", { css: inputStyle },\n                            jsx(SizeEditor, { label: 'H', mode: heightMode || LayoutItemSizeModes.Custom, sizeModes: supportAutoSize ? heightModes : heightModesWithoutAuto, value: bbox.height, availableUnits: availableHeightUnits, onChange: value => { this.updateBBox('height', value); }, onModeChange: this.updateHeightMode, disabled: keepAspectRatio }))),\n                    keepAspectRatio &&\n                        jsx(SettingRow, { label: this.formatMessage('aspectRatio'), \"aria-label\": this.formatMessage('aspectRatio') },\n                            jsx(InputRatio, { value: setting.aspectRatio, style: { width: 100 }, onChange: this.updateAspectRatio })),\n                    !isAutoWidth && jsx(SettingRow, { label: this.formatMessage('align') },\n                        jsx(Select, { \"aria-label\": this.formatMessage('align'), className: 'align-select', value: (_d = style.alignSelf) !== null && _d !== void 0 ? _d : 'flex-start', onChange: this.updateAlignSelf, css: inputStyle },\n                            jsx(\"option\", { value: 'flex-start' }, this.formatMessage('start')),\n                            jsx(\"option\", { value: 'flex-end' }, this.formatMessage('end')),\n                            jsx(\"option\", { value: 'center' }, this.formatMessage('center')))),\n                    jsx(CommonTransformSetting, { layoutId: layoutId, layoutItemId: layoutItem.id, setting: setting, onSettingChange: this.props.onSettingChange, formatMessage: this.props.formatMessage }))),\n            (layoutItem.type === LayoutItemType.Widget || layoutItem.sectionId) && (jsx(CommonLayoutItemSetting, { layoutId: layoutId, layoutItemId: layoutItem.id, isSection: layoutItem.type === LayoutItemType.Section, style: this.props.style, onStyleChange: this.props.onStyleChange, onSettingChange: this.props.onSettingChange, formatMessage: this.props.formatMessage }))));\n    }\n}\n","/** @jsx jsx */\nimport { React, jsx, css, Immutable, LayoutItemType, APP_FRAME_NAME_IN_BUILDER } from 'jimu-core';\nimport { SettingSection, SettingRow } from 'jimu-ui/advanced/setting-components';\nimport { SizeEditor, InputRatio } from 'jimu-ui/advanced/style-setting-components';\nimport { DistanceUnits, Select, Tooltip, Button } from 'jimu-ui';\nimport { LayoutItemSizeModes, utils as layoutUtils } from 'jimu-layouts/layout-runtime';\nimport CommonLayoutItemSetting from '../../builder/common-layout-item-setting';\nimport CommonTransformSetting from '../../builder/common-transform-setting';\nimport { LockOutlined } from 'jimu-icons/outlined/editor/lock';\nimport { UnlockOutlined } from 'jimu-icons/outlined/editor/unlock';\nimport { getAppConfigAction } from 'jimu-for-builder';\nconst inputStyle = css `width: 100px;`;\nconst heightModes = [LayoutItemSizeModes.Auto, LayoutItemSizeModes.Stretch, LayoutItemSizeModes.Custom];\nconst widthModes = [LayoutItemSizeModes.Auto, LayoutItemSizeModes.Stretch, LayoutItemSizeModes.Custom];\nconst heightModesWithoutAuto = [LayoutItemSizeModes.Stretch, LayoutItemSizeModes.Custom];\nconst availableHeightUnits = [DistanceUnits.PIXEL, DistanceUnits.PERCENTAGE];\nconst availableWidthUnits = [DistanceUnits.PIXEL];\nexport default class FlexRowItemSetting extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.updateBBox = (prop, value) => {\n            var _a;\n            let bbox = this.props.layoutItem.bbox;\n            const { distance, unit } = value;\n            const originalValue = bbox[prop];\n            const containerRect = this.getSizeOfContainer();\n            let newValue = distance.toFixed(2);\n            let pixelValue;\n            if (layoutUtils.isPercentage(originalValue) && unit === DistanceUnits.PIXEL) { // change from percentage to pixel\n                if (containerRect) {\n                    if (prop === 'left' || prop === 'right' || prop === 'width') {\n                        newValue = Math.round(parseFloat(originalValue) * containerRect.width / 100);\n                    }\n                    else {\n                        newValue = Math.round(parseFloat(originalValue) * containerRect.height / 100);\n                    }\n                    pixelValue = newValue;\n                }\n            }\n            else if (!layoutUtils.isPercentage(originalValue) && unit === DistanceUnits.PERCENTAGE) { // change from pixel to percentage\n                if (containerRect) {\n                    if (prop === 'left' || prop === 'right' || prop === 'width') {\n                        newValue = (parseFloat(originalValue) * 100 / containerRect.width).toFixed(4);\n                    }\n                    else {\n                        newValue = (parseFloat(originalValue) * 100 / containerRect.height).toFixed(4);\n                    }\n                }\n                pixelValue = parseFloat(originalValue);\n            }\n            if (!pixelValue && unit === DistanceUnits.PERCENTAGE) {\n                // change percentage value\n                const total = prop === 'width' ? containerRect.width : containerRect.height;\n                pixelValue = Math.round(distance * total / 100);\n            }\n            else if (!pixelValue && unit === DistanceUnits.PIXEL) {\n                pixelValue = distance;\n            }\n            bbox = bbox.set(prop, unit === DistanceUnits.PERCENTAGE ? `${newValue}%` : `${newValue}px`);\n            if (((_a = this.props.layoutItem.setting) === null || _a === void 0 ? void 0 : _a.heightMode) === 'ratio') {\n                const ratio = this.props.layoutItem.setting.aspectRatio;\n                if (prop === 'width') {\n                    const height = pixelValue * ratio;\n                    if (layoutUtils.isPercentage(bbox.height)) {\n                        const newValue = (height * 100 / containerRect.height).toFixed(4);\n                        bbox = bbox.set('height', `${newValue}%`);\n                    }\n                    else {\n                        bbox = bbox.set('height', `${Math.round(height)}px`);\n                    }\n                }\n                else {\n                    const width = pixelValue / ratio;\n                    if (layoutUtils.isPercentage(bbox.width)) {\n                        const newValue = (width * 100 / containerRect.width).toFixed(4);\n                        bbox = bbox.set('width', `${newValue}%`);\n                    }\n                    else {\n                        bbox = bbox.set('width', `${Math.round(width)}px`);\n                    }\n                }\n            }\n            this.props.onPosChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, bbox);\n        };\n        this.toggleHeightMode = () => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            const heightMode = setting.heightMode === 'ratio' ? 'fixed' : 'ratio';\n            setting = setting.set('heightMode', heightMode);\n            const appConfigAction = getAppConfigAction();\n            if (heightMode === 'ratio') {\n                const itemRect = this.getSizeOfItem();\n                if (itemRect) {\n                    setting = setting.set('aspectRatio', Number((itemRect.height / itemRect.width).toFixed(2)));\n                }\n            }\n            else {\n                let bbox = this.props.layoutItem.bbox;\n                const rect = this.getSizeOfItem();\n                if (layoutUtils.isPercentage(bbox.width)) {\n                    const containerRect = this.getSizeOfContainer();\n                    bbox = bbox.set('width', `${(rect.width * 100 / containerRect.width).toFixed(4)}%`);\n                }\n                else {\n                    bbox = bbox.set('width', `${Math.round(rect.width)}px`);\n                }\n                bbox = bbox.set('height', `${Math.round(rect.height)}px`);\n                appConfigAction.editLayoutItemProperty({\n                    layoutId: this.props.layoutId,\n                    layoutItemId: this.props.layoutItem.id\n                }, 'bbox', bbox);\n            }\n            appConfigAction.editLayoutItemProperty({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, 'setting', setting).exec();\n        };\n        this.updateAlignSelf = (e) => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            setting = setting.setIn(['style', 'alignSelf'], e.target.value);\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.updateHeightMode = (mode) => {\n            const setting = this.props.layoutItem.setting || Immutable({});\n            let bbox = Immutable(this.props.layoutItem.bbox);\n            if (mode === LayoutItemSizeModes.Custom && isNaN(parseFloat(bbox.height))) {\n                const rect = this.getSizeOfItem();\n                bbox = bbox.set('height', `${Math.round(rect.height)}px`);\n                this.props.onPosChange({\n                    layoutId: this.props.layoutId,\n                    layoutItemId: this.props.layoutItem.id\n                }, bbox);\n            }\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.setIn(['autoProps', 'height'], mode));\n        };\n        this.updateWidthMode = (mode) => {\n            const setting = this.props.layoutItem.setting || Immutable({});\n            let bbox = Immutable(this.props.layoutItem.bbox);\n            if (mode === LayoutItemSizeModes.Custom && isNaN(parseFloat(bbox.width))) {\n                const rect = this.getSizeOfItem();\n                bbox = bbox.set('width', `${Math.round(rect.width)}px`);\n                this.props.onPosChange({\n                    layoutId: this.props.layoutId,\n                    layoutItemId: this.props.layoutItem.id\n                }, bbox);\n            }\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.setIn(['autoProps', 'width'], mode));\n        };\n        this.updateAspectRatio = (newRatio) => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            setting = setting.set('aspectRatio', newRatio);\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.formatMessage = (id) => {\n            return this.props.formatMessage(id);\n        };\n    }\n    getSizeOfContainer() {\n        const layoutElem = this.querySelector(`div.column-layout[data-layoutid=\"${this.props.layoutId}\"]`);\n        if (layoutElem) {\n            return layoutElem.getBoundingClientRect();\n        }\n        return null;\n    }\n    getSizeOfItem() {\n        const { layoutId, layoutItem } = this.props;\n        const layoutElem = this.querySelector(`div.exb-rnd[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItem.id}\"]`);\n        if (layoutElem) {\n            return layoutElem.getBoundingClientRect();\n        }\n        return null;\n    }\n    querySelector(selector) {\n        const appFrame = document.querySelector(`iframe[name=\"${APP_FRAME_NAME_IN_BUILDER}\"]`);\n        if (appFrame) {\n            const appFrameDoc = appFrame.contentDocument || appFrame.contentWindow.document;\n            return appFrameDoc.querySelector(selector);\n        }\n        return null;\n    }\n    getStyle() {\n        return css `\r\n      .rotation-setting, .rotation-setting input {\r\n        height: 26px;\r\n      }\r\n\r\n      .ratio-value {\r\n        font-size: 12px;\r\n      }\r\n\r\n      .align-select {\r\n        .dropdown-button, .dropdown-button:hover {\r\n          height: 26px;\r\n        }\r\n      }\r\n    `;\n    }\n    render() {\n        var _a, _b, _c, _d, _e;\n        const { layoutId, layoutItem, isLockLayout, supportAutoSize } = this.props;\n        if (!layoutItem) {\n            return null;\n        }\n        const setting = layoutItem.setting || {};\n        const style = setting.style || {};\n        const bbox = layoutItem.bbox || {};\n        const heightMode = (_b = (_a = setting.autoProps) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : LayoutItemSizeModes.Stretch;\n        const isStretch = heightMode === LayoutItemSizeModes.Stretch;\n        const widthMode = (_d = (_c = setting.autoProps) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : LayoutItemSizeModes.Custom;\n        const keepAspectRatio = setting.heightMode === 'ratio';\n        return (jsx(\"div\", { className: 'flex-row-item-setting', css: this.getStyle() },\n            !isLockLayout && jsx(React.Fragment, null,\n                jsx(SettingSection, { role: 'group', title: this.formatMessage('size'), \"aria-label\": this.formatMessage('size') },\n                    jsx(SettingRow, { role: 'group', label: this.formatMessage('width'), \"aria-label\": this.formatMessage('width') },\n                        jsx(\"div\", { css: inputStyle },\n                            jsx(SizeEditor, { label: 'W', mode: widthMode, sizeModes: widthModes, value: bbox === null || bbox === void 0 ? void 0 : bbox.width, availableUnits: availableWidthUnits, onChange: value => { this.updateBBox('width', value); }, onModeChange: this.updateWidthMode }))),\n                    jsx(\"div\", null,\n                        jsx(Tooltip, { title: this.formatMessage('keepAspectRatio'), placement: 'bottom' },\n                            jsx(Button, { size: 'sm', type: 'tertiary', className: 'ml-1', icon: true, onClick: this.toggleHeightMode, \"aria-pressed\": keepAspectRatio }, keepAspectRatio ? jsx(LockOutlined, { size: 's' }) : jsx(UnlockOutlined, { size: 's' })))),\n                    jsx(SettingRow, { role: 'group', className: 'mt-0', label: this.formatMessage('height'), \"aria-label\": this.formatMessage('height') },\n                        jsx(\"div\", { css: inputStyle },\n                            jsx(SizeEditor, { label: 'H', mode: heightMode, sizeModes: supportAutoSize ? heightModes : heightModesWithoutAuto, value: bbox.height, availableUnits: availableHeightUnits, onChange: value => { this.updateBBox('height', value); }, onModeChange: this.updateHeightMode, disabled: keepAspectRatio }))),\n                    keepAspectRatio &&\n                        jsx(SettingRow, { label: this.formatMessage('aspectRatio'), \"aria-label\": this.formatMessage('aspectRatio') },\n                            jsx(InputRatio, { value: setting.aspectRatio, style: { width: 100 }, onChange: this.updateAspectRatio })),\n                    !isStretch && jsx(SettingRow, { label: this.formatMessage('align') },\n                        jsx(Select, { \"aria-label\": this.formatMessage('align'), className: 'align-select', value: (_e = style.alignSelf) !== null && _e !== void 0 ? _e : 'flex-start', onChange: this.updateAlignSelf, css: inputStyle },\n                            jsx(\"option\", { value: 'flex-start' }, this.formatMessage('start')),\n                            jsx(\"option\", { value: 'flex-end' }, this.formatMessage('end')),\n                            jsx(\"option\", { value: 'center' }, this.formatMessage('center')))),\n                    jsx(CommonTransformSetting, { layoutId: layoutId, layoutItemId: layoutItem.id, setting: setting, onSettingChange: this.props.onSettingChange, formatMessage: this.props.formatMessage }))),\n            (layoutItem.type === LayoutItemType.Widget || layoutItem.sectionId) && (jsx(CommonLayoutItemSetting, { layoutId: layoutId, layoutItemId: layoutItem.id, isSection: layoutItem.type === LayoutItemType.Section, style: this.props.style, onStyleChange: this.props.onStyleChange, onSettingChange: this.props.onSettingChange, formatMessage: this.props.formatMessage }))));\n    }\n}\n","/** @jsx jsx */\nimport { React, Immutable, jsx, css, lodash, APP_FRAME_NAME_IN_BUILDER, LayoutItemType } from 'jimu-core';\nimport { SettingSection, SettingRow } from 'jimu-ui/advanced/setting-components';\nimport { Select, NumericInput, utils, DistanceUnits, Checkbox } from 'jimu-ui';\nimport { SizeEditor, InputRatio } from 'jimu-ui/advanced/style-setting-components';\nimport { LayoutItemSizeModes, utils as layoutUtils } from 'jimu-layouts/layout-runtime';\nimport CommonTransformSetting from '../../builder/common-transform-setting';\nimport CommonLayoutItemSetting from '../../builder/common-layout-item-setting';\nimport { DEFAULT_ROW_ITEM_SETTING } from '../default-setting';\nconst inputStyle = css `width: 72px`;\nconst sizeEditorStyle = css `width: 100px;`;\nconst heightModes = [\n    LayoutItemSizeModes.Auto,\n    LayoutItemSizeModes.Stretch,\n    LayoutItemSizeModes.Custom\n];\nconst heightModesWithoutAuto = [\n    LayoutItemSizeModes.Stretch,\n    LayoutItemSizeModes.Custom\n];\nexport default class RowItemSetting extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.handleAlignChange = (e) => {\n            this.updateStyle('alignSelf', e.target.value);\n        };\n        this.handleHeightChange = (value) => {\n            let bbox = this.props.layoutItem.bbox;\n            const { distance, unit } = value;\n            const originalValue = bbox.height;\n            const containerRect = this.getSizeOfContainer();\n            let newValue = distance.toFixed(2);\n            if (layoutUtils.isPercentage(originalValue) && unit === DistanceUnits.PIXEL) {\n                // change from percentage to pixel\n                if (containerRect != null) {\n                    newValue = Math.round((parseFloat(originalValue) * containerRect.height) / 100);\n                }\n            }\n            else if (!layoutUtils.isPercentage(originalValue) &&\n                unit === DistanceUnits.PERCENTAGE) {\n                // change from pixel to percentage\n                if (containerRect != null) {\n                    newValue = ((parseFloat(originalValue) * 100) /\n                        containerRect.height).toFixed(4);\n                }\n            }\n            bbox = bbox.set('height', unit === DistanceUnits.PERCENTAGE ? `${newValue}%` : `${newValue}px`);\n            this.props.onPosChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, bbox);\n        };\n        this.handleHeightModeChange = (mode) => {\n            var _a;\n            const setting = (_a = this.props.layoutItem.setting) !== null && _a !== void 0 ? _a : Immutable({});\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.setIn(['autoProps', 'height'], mode));\n        };\n        this.updateAspectSetting = (heightMode) => {\n            var _a;\n            let setting = (_a = this.props.layoutItem.setting) !== null && _a !== void 0 ? _a : Immutable({});\n            if (setting.heightMode === 'fit') { // back compatible, save this setting in autoProps\n                setting = setting.setIn(['autoProps', 'height'], LayoutItemSizeModes.Stretch);\n            }\n            setting = setting.set('heightMode', heightMode);\n            if (heightMode === 'ratio') {\n                const itemRect = this.getSizeOfItem();\n                if (itemRect != null) {\n                    setting = setting.set('aspectRatio', Number((itemRect.height / itemRect.width).toFixed(2)));\n                }\n            }\n            else {\n                const bbox = this.props.layoutItem.bbox;\n                const rect = this.getSizeOfItem();\n                if (layoutUtils.isPercentage(bbox.height)) {\n                    const containerRect = this.getSizeOfContainer();\n                    this.props.onPosChange({\n                        layoutId: this.props.layoutId,\n                        layoutItemId: this.props.layoutItem.id\n                    }, bbox.set('height', `${((rect.height * 100) / containerRect.height).toFixed(4)}%`));\n                }\n                else {\n                    this.props.onPosChange({\n                        layoutId: this.props.layoutId,\n                        layoutItemId: this.props.layoutItem.id\n                    }, bbox.set('height', `${Math.round(rect.height)}px`));\n                }\n            }\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.handleAspectRatioChange = (newRatio) => {\n            var _a;\n            let setting = (_a = this.props.layoutItem.setting) !== null && _a !== void 0 ? _a : Immutable({});\n            setting = setting.set('aspectRatio', newRatio);\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.handleOffsetXChange = (value) => {\n            var _a;\n            const setting = (_a = this.props.layoutItem.setting) !== null && _a !== void 0 ? _a : Immutable({});\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.set('offsetX', value));\n        };\n        this.handleOffsetYChange = (value) => {\n            var _a;\n            const setting = (_a = this.props.layoutItem.setting) !== null && _a !== void 0 ? _a : Immutable({});\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.set('offsetY', value));\n        };\n        this.formatMessage = (id) => {\n            return this.props.formatMessage(id);\n        };\n    }\n    updateStyle(key, value) {\n        var _a;\n        const { layoutItem } = this.props;\n        const setting = Immutable((_a = layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.setting) !== null && _a !== void 0 ? _a : {});\n        this.props.onSettingChange({\n            layoutId: this.props.layoutId,\n            layoutItemId: this.props.layoutItem.id\n        }, setting.setIn(['style', key], value));\n    }\n    getSizeOfContainer() {\n        const layoutElem = this.querySelector(`div.row-layout[data-layoutid=\"${this.props.layoutId}\"]`);\n        if (layoutElem != null) {\n            return layoutElem.getBoundingClientRect();\n        }\n        return null;\n    }\n    getSizeOfItem() {\n        const { layoutId, layoutItem } = this.props;\n        // not only widget, but also for section and placeholder\n        const layoutElem = this.querySelector(`div.exb-rnd[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItem.id}\"] > div.layout-item-content`);\n        if (layoutElem != null) {\n            return layoutElem.getBoundingClientRect();\n        }\n        return null;\n    }\n    querySelector(selector) {\n        var _a;\n        const appFrame = document.querySelector(`iframe[name=\"${APP_FRAME_NAME_IN_BUILDER}\"]`);\n        if (appFrame != null) {\n            const appFrameDoc = (_a = appFrame.contentDocument) !== null && _a !== void 0 ? _a : appFrame.contentWindow.document;\n            return appFrameDoc.querySelector(selector);\n        }\n        return null;\n    }\n    getStyle() {\n        return css `\r\n      .align-select {\r\n        .dropdown-button,\r\n        .dropdown-button:hover {\r\n          height: 26px;\r\n        }\r\n      }\r\n    `;\n    }\n    render() {\n        var _a, _b, _c, _d;\n        const { layoutId, layoutItem, isLockLayout, supportAutoSize } = this.props;\n        if (layoutItem == null) {\n            return null;\n        }\n        const itemSetting = lodash.assign({}, DEFAULT_ROW_ITEM_SETTING, layoutItem.setting);\n        const bbox = layoutItem.bbox;\n        const style = (_a = itemSetting.style) !== null && _a !== void 0 ? _a : {};\n        const heightMode = (_c = (_b = itemSetting.autoProps) === null || _b === void 0 ? void 0 : _b.height) !== null && _c !== void 0 ? _c : LayoutItemSizeModes.Stretch;\n        const keepAspectRatio = itemSetting.heightMode === 'ratio';\n        return (jsx(\"div\", { className: 'row-item-setting', css: this.getStyle() },\n            !isLockLayout && (jsx(React.Fragment, null,\n                jsx(SettingSection, { role: 'group', title: this.formatMessage('size'), \"aria-label\": this.formatMessage('size') },\n                    jsx(SettingRow, { role: 'group', label: this.formatMessage('height'), \"aria-label\": this.formatMessage('height') },\n                        jsx(\"div\", { css: sizeEditorStyle },\n                            jsx(SizeEditor, { label: 'H', mode: heightMode, sizeModes: supportAutoSize ? heightModes : heightModesWithoutAuto, value: utils.stringOfLinearUnit(bbox.height), onChange: this.handleHeightChange, onModeChange: this.handleHeightModeChange, disabled: keepAspectRatio }))),\n                    jsx(SettingRow, null,\n                        jsx(Checkbox, { \"aria-label\": this.formatMessage('keepAspectRatio'), checked: keepAspectRatio, onChange: e => {\n                                this.updateAspectSetting(e.target.checked ? 'ratio' : 'fixed');\n                            }, className: 'mr-2' }),\n                        this.formatMessage('keepAspectRatio')),\n                    keepAspectRatio && (jsx(SettingRow, { label: this.formatMessage('aspectRatio'), \"aria-label\": this.formatMessage('aspectRatio') },\n                        jsx(InputRatio, { value: itemSetting.aspectRatio, style: { width: 100 }, onChange: this.handleAspectRatioChange }))),\n                    heightMode !== LayoutItemSizeModes.Stretch && (jsx(SettingRow, { label: this.formatMessage('align') },\n                        jsx(Select, { \"aria-label\": this.formatMessage('align'), className: 'align-select', css: sizeEditorStyle, value: (_d = style.alignSelf) !== null && _d !== void 0 ? _d : 'flex-start', onChange: this.handleAlignChange },\n                            jsx(\"option\", { value: 'flex-start' }, this.formatMessage('T')),\n                            jsx(\"option\", { value: 'flex-end' }, this.formatMessage('B')),\n                            jsx(\"option\", { value: 'center' }, this.formatMessage('center')))))),\n                jsx(SettingSection, { role: 'group', title: this.formatMessage('position'), \"aria-label\": this.formatMessage('position') },\n                    jsx(CommonTransformSetting, { layoutId: layoutId, layoutItemId: layoutItem.id, setting: layoutItem.setting, onSettingChange: this.props.onSettingChange, formatMessage: this.props.formatMessage }),\n                    jsx(SettingRow, { label: this.formatMessage('offsetX'), \"aria-label\": this.formatMessage('offsetX') },\n                        jsx(NumericInput, { css: inputStyle, value: itemSetting.offsetX, onChange: this.handleOffsetXChange, precision: 0, size: 'sm' })),\n                    jsx(SettingRow, { label: this.formatMessage('offsetY'), \"aria-label\": this.formatMessage('offsetY') },\n                        jsx(NumericInput, { css: inputStyle, value: itemSetting.offsetY, onChange: this.handleOffsetYChange, precision: 0, size: 'sm' }))))),\n            (layoutItem.type === LayoutItemType.Widget || layoutItem.sectionId != null) && (jsx(CommonLayoutItemSetting, { layoutId: layoutId, layoutItemId: layoutItem.id, isSection: layoutItem.type === LayoutItemType.Section, style: this.props.style, onStyleChange: this.props.onStyleChange, onSettingChange: this.props.onSettingChange, formatMessage: this.props.formatMessage }))));\n    }\n}\n","/** @jsx jsx */\nimport { React, jsx, css, Immutable, LayoutItemType } from 'jimu-core';\nimport { SettingSection, SettingRow } from 'jimu-ui/advanced/setting-components';\nimport { SizeEditor, InputRatio } from 'jimu-ui/advanced/style-setting-components';\nimport { DistanceUnits, Checkbox, Label } from 'jimu-ui';\nimport { LayoutItemSizeModes } from 'jimu-layouts/layout-runtime';\nimport CommonLayoutItemSetting from '../../builder/common-layout-item-setting';\nconst inputStyle = css `width: 100px;`;\nconst heightModes = [LayoutItemSizeModes.Auto, LayoutItemSizeModes.Custom];\nconst heightModesWithoutAuto = [LayoutItemSizeModes.Auto, LayoutItemSizeModes.Custom];\nconst availableHeightUnits = [DistanceUnits.PIXEL];\nexport default class AccordionItemSetting extends React.PureComponent {\n    constructor() {\n        super(...arguments);\n        this.updateHeight = (value) => {\n            const bbox = this.props.layoutItem.bbox;\n            this.props.onPosChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, bbox.set('height', `${value.distance}px`));\n        };\n        this.toggleAspectRatio = (e, checked) => {\n            const setting = this.props.layoutItem.setting || Immutable({});\n            const heightMode = checked ? 'ratio' : 'fixed';\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.set('heightMode', heightMode));\n        };\n        this.updateHeightMode = (mode) => {\n            const setting = this.props.layoutItem.setting || Immutable({});\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting.setIn(['autoProps', 'height'], mode));\n        };\n        this.updateAspectRatio = (newRatio) => {\n            let setting = this.props.layoutItem.setting || Immutable({});\n            setting = setting.set('aspectRatio', newRatio);\n            this.props.onSettingChange({\n                layoutId: this.props.layoutId,\n                layoutItemId: this.props.layoutItem.id\n            }, setting);\n        };\n        this.formatMessage = (id) => {\n            return this.props.formatMessage(id);\n        };\n    }\n    getStyle() {\n        return css `\r\n      .rotation-setting, .rotation-setting input {\r\n        height: 26px;\r\n      }\r\n\r\n      .ratio-value {\r\n        font-size: 12px;\r\n      }\r\n\r\n      .align-select {\r\n        .dropdown-button, .dropdown-button:hover {\r\n          height: 26px;\r\n        }\r\n      }\r\n    `;\n    }\n    // getAspectRatio() {\n    //   const ratio = this.props.layoutItem.setting?.aspectRatio ?? -1;\n    //   if (ratio < 0) {\n    //     return '';\n    //   }\n    //   const width = 100;\n    //   const height = Math.round(ratio * 100);\n    //   const common = layoutUtils.gcd(width, height);\n    //   return `${width / common} : ${height / common}`;\n    // }\n    render() {\n        var _a, _b;\n        const { layoutId, layoutItem, isLockLayout, supportAutoSize } = this.props;\n        if (!layoutItem) {\n            return null;\n        }\n        const setting = layoutItem.setting || {};\n        const bbox = layoutItem.bbox || {};\n        const heightMode = (_b = (_a = setting.autoProps) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : LayoutItemSizeModes.Custom;\n        const keepAspectRatio = setting.heightMode === 'ratio';\n        return (jsx(\"div\", { className: 'accordion-item-setting', css: this.getStyle() },\n            !isLockLayout && jsx(React.Fragment, null,\n                jsx(SettingSection, { role: 'group', title: this.formatMessage('size'), \"aria-label\": this.formatMessage('size') },\n                    jsx(SettingRow, { role: 'group', label: this.formatMessage('height'), \"aria-label\": this.formatMessage('height') },\n                        jsx(\"div\", { css: inputStyle },\n                            jsx(SizeEditor, { label: 'H', mode: heightMode || LayoutItemSizeModes.Custom, sizeModes: supportAutoSize ? heightModes : heightModesWithoutAuto, value: bbox.height, availableUnits: availableHeightUnits, onChange: this.updateHeight, onModeChange: this.updateHeightMode, disabled: keepAspectRatio }))),\n                    jsx(SettingRow, null,\n                        jsx(Label, null,\n                            jsx(Checkbox, { className: 'mr-2', checked: keepAspectRatio, onChange: this.toggleAspectRatio }),\n                            jsx(\"span\", { className: \"checkbox-label\" }, this.formatMessage('keepAspectRatio')))),\n                    keepAspectRatio &&\n                        jsx(SettingRow, { label: this.formatMessage('aspectRatio'), \"aria-label\": this.formatMessage('aspectRatio') },\n                            jsx(InputRatio, { value: setting.aspectRatio || '1:1', style: { width: 100 }, onChange: this.updateAspectRatio })))),\n            (layoutItem.type === LayoutItemType.Widget || layoutItem.sectionId) && (jsx(CommonLayoutItemSetting, { layoutId: layoutId, layoutItemId: layoutItem.id, isSection: layoutItem.type === LayoutItemType.Section, style: this.props.style, onStyleChange: this.props.onStyleChange, onSettingChange: this.props.onSettingChange, formatMessage: this.props.formatMessage }))));\n    }\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, classNames, lodash, BrowserSizeMode, Immutable, getAppStore, appActions } from 'jimu-core';\nimport { getAppConfigAction, appBuilderSync } from 'jimu-for-builder';\nimport { TemplateSelector } from 'jimu-ui/advanced/setting-components';\nimport { getBlockTemplates, getScreenGroupTemplates } from 'jimu-for-builder/templates';\nimport { PageContext, utils } from 'jimu-layouts/layout-runtime';\nimport { DEFAULT_FLOW_ITEM_SETTING } from '../default-setting';\nimport { CONTEXT_MENU_ITEM_SIZE, CONTEXT_MENU_ICON_SIZE, MIN_LAYOUT_ITEM_SIZE } from '../../types';\nimport LayoutItem from '../../builder/layout-item';\n// import { DropArea } from '../../builder/interactive/droparea-hook';\nimport { FlowContextMenu } from './flow-context-menu';\nimport { mapStateToFlowItemProps, getWidthFromSetting } from '../layout-utils';\nimport { addTemplateRow, addTemplateScreenGroup, moveDown, moveUp } from './utils';\nimport { duplicateMenuItem, isLockLayout, getLabelOfLayoutItem } from '../../builder/menu/common-menu';\nimport deleteIcon from 'jimu-icons/svg/outlined/editor/trash.svg';\nimport settingIcon from 'jimu-icons/svg/outlined/application/setting.svg';\nimport draggingIcon from 'jimu-icons/svg/outlined/editor/move.svg';\nimport addIcon from 'jimu-icons/svg/outlined/brand/block.svg';\nimport rectIcon from 'jimu-icons/svg/outlined/brand/screen-group.svg';\nimport upIcon from 'jimu-icons/svg/outlined/directional/up.svg';\nimport * as commonUtils from '../common/util';\nclass FlowLayoutItem extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.state = {\n            isResizing: false,\n            dh: 0,\n            showBlockTemplatePopup: false,\n            showScreenTemplatePopup: false,\n            referenceElem: null\n        };\n        this.onResizeStart = (id, initWidth, initHeight) => {\n            const { padding } = this.props;\n            this.minHeight = MIN_LAYOUT_ITEM_SIZE + padding;\n            this.initHeight = initHeight;\n            this.setState({\n                dh: 0,\n                isResizing: true\n            });\n        };\n        this.onResizing = (id, x, y, dw, dh) => {\n            let delta = dh;\n            if (dh < 0 && this.initHeight + dh < this.minHeight) {\n                delta = this.minHeight - this.initHeight;\n            }\n            this.setState({\n                dh: delta,\n                isResizing: true\n            });\n        };\n        this.onResizeEnd = (id, x, y, dw, dh, shiftKey) => {\n            const { layoutId, layoutItem } = this.props;\n            let delta = dh;\n            if (dh < 0 && this.initHeight + dh < this.minHeight) {\n                delta = this.minHeight - this.initHeight;\n            }\n            const bbox = Immutable(layoutItem.bbox || {}).set('height', Math.round(this.initHeight + delta));\n            const appConfigAction = getAppConfigAction();\n            appConfigAction.editLayoutItemProperty({\n                layoutId,\n                layoutItemId: layoutItem.id\n            }, 'bbox', bbox).exec();\n            this.setState({\n                isResizing: false,\n                dh: 0\n            });\n        };\n        this.toggleBlockTemplatePopup = () => {\n            if (getAppStore().getState().browserSizeMode === BrowserSizeMode.Small) {\n                appBuilderSync.publishSidePanelToApp({ type: 'templateBlock', templateMethod: 'getBlockTemplates', onSelect: this.onTemplateBlockSelected });\n                return;\n            }\n            this.setState({ showBlockTemplatePopup: !this.state.showBlockTemplatePopup });\n        };\n        this.toggleScreenTemplatePopup = () => {\n            if (getAppStore().getState().browserSizeMode === BrowserSizeMode.Small) {\n                appBuilderSync.publishSidePanelToApp({ type: 'template', templateMethod: 'getScreenGroupTemplates', onSelect: this.onTemplateScreenGroupSelected });\n                return;\n            }\n            this.setState({ showScreenTemplatePopup: !this.state.showScreenTemplatePopup });\n        };\n        this.removeLayoutItem = () => {\n            const { layoutId, layoutItemId } = this.props;\n            const appConfigAction = getAppConfigAction();\n            appConfigAction.removeLayoutItem({ layoutId, layoutItemId }, true).exec();\n        };\n        this.moveLayoutItemUp = () => {\n            const { layoutId, layoutItemId } = this.props;\n            const appConfigAction = getAppConfigAction();\n            const appConfig = moveUp(appConfigAction.appConfig, { layoutId, layoutItemId });\n            getAppConfigAction(appConfig).exec();\n        };\n        this.moveLayoutItemDown = () => {\n            const { layoutId, layoutItemId } = this.props;\n            const appConfigAction = getAppConfigAction();\n            const appConfig = moveDown(appConfigAction.appConfig, { layoutId, layoutItemId });\n            getAppConfigAction(appConfig).exec();\n        };\n        this.switchSetting = () => {\n            const { layoutId, layoutItemId, selected } = this.props;\n            if (!selected) {\n                getAppStore().dispatch(appActions.selectionChanged({\n                    layoutId,\n                    layoutItemId\n                }));\n            }\n        };\n        this.onTemplateBlockSelected = (template) => {\n            addTemplateRow(this.props.layoutId, this.props.layoutItemId, template);\n            this.setState({ showBlockTemplatePopup: false });\n        };\n        this.onTemplateScreenGroupSelected = (template) => {\n            addTemplateScreenGroup(this.props.layoutId, this.props.layoutItemId, template);\n            this.setState({ showScreenTemplatePopup: false });\n        };\n        this.fakeTopLayouts = Immutable({\n            [BrowserSizeMode.Large]: `${this.props.layoutId}_${this.props.layoutItemId}_tlarge`,\n            [BrowserSizeMode.Medium]: `${this.props.layoutId}_${this.props.layoutItemId}_tmedium`,\n            [BrowserSizeMode.Small]: `${this.props.layoutId}_${this.props.layoutItemId}_tsmall`\n        });\n        this.fakeBottomLayouts = Immutable({\n            [BrowserSizeMode.Large]: `${this.props.layoutId}_${this.props.layoutItemId}_blarge`,\n            [BrowserSizeMode.Medium]: `${this.props.layoutId}_${this.props.layoutItemId}_bmedium`,\n            [BrowserSizeMode.Small]: `${this.props.layoutId}_${this.props.layoutItemId}_bsmall`\n        });\n        this.minHeight = 0;\n        this.contextMenus = [{\n                icon: addIcon,\n                title: this.props.formatMessage('insertABlock'),\n                onClick: this.toggleBlockTemplatePopup,\n                visible: () => !isLockLayout()\n            },\n            {\n                icon: rectIcon,\n                title: this.props.formatMessage('insertAScreenGroup'),\n                onClick: this.toggleScreenTemplatePopup,\n                visible: () => !isLockLayout() && getAppStore().getState().browserSizeMode !== BrowserSizeMode.Small\n            },\n            duplicateMenuItem,\n            {\n                icon: settingIcon,\n                title: this.props.formatMessage('setting'),\n                onClick: this.switchSetting\n            }, {\n                icon: draggingIcon,\n                title: this.props.formatMessage('dragToMove', { label: getLabelOfLayoutItem(this.props.layoutItem) }),\n                className: 'tool-drag-handler',\n                onClick: () => null,\n                visible: () => !isLockLayout()\n            }, {\n                icon: upIcon,\n                onClick: this.moveLayoutItemUp,\n                title: this.props.formatMessage('moveup'),\n                visible: () => !this.props.isFirst && !isLockLayout()\n            }, {\n                icon: upIcon,\n                rotate: 180,\n                onClick: this.moveLayoutItemDown,\n                title: this.props.formatMessage('movedown'),\n                visible: () => !this.props.isLast && !isLockLayout()\n            }, {\n                icon: deleteIcon,\n                title: this.props.formatMessage('delete'),\n                onClick: this.removeLayoutItem,\n                visible: () => !isLockLayout()\n            }];\n    }\n    // dropAtTop = (draggingItem: LayoutItemConstructorProps, containerRect: DOMRect, itemRect: DOMRect) => {\n    //   this.props.onDropAtBoundary(draggingItem, itemRect, this.props.index);\n    // }\n    // dropAtBottom = (draggingItem: LayoutItemConstructorProps, containerRect: DOMRect, itemRect: DOMRect) => {\n    //   this.props.onDropAtBoundary(draggingItem, itemRect, this.props.index + 1);\n    // }\n    calHeight(itemSetting) {\n        if (this.state.isResizing) {\n            return `${this.initHeight + this.state.dh}px`;\n        }\n        const height = commonUtils.calHeight(this.props.layoutItem, itemSetting);\n        this.autoHeight = height === 'auto';\n        return height;\n    }\n    createContextMenu() {\n        const { builderTheme } = this.pageContext;\n        const { layoutId, layoutItem, isFirst, isLast } = this.props;\n        return (jsx(FlowContextMenu, { layoutId: layoutId, layoutItem: layoutItem, builderTheme: builderTheme, positionType: 'center', size: CONTEXT_MENU_ITEM_SIZE, iconSize: CONTEXT_MENU_ICON_SIZE, className: 'widget-context-menu', menuItems: this.contextMenus, isFirst: isFirst, isLast: isLast },\n            jsx(\"div\", { ref: ref => { this.reference = ref; }, css: css `position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;` }),\n            this.state.showBlockTemplatePopup && (jsx(TemplateSelector, { templates: getBlockTemplates(), referenceElement: this.reference, onItemSelect: this.onTemplateBlockSelected, onClose: this.toggleBlockTemplatePopup })),\n            this.state.showScreenTemplatePopup && (jsx(TemplateSelector, { templates: getScreenGroupTemplates(), referenceElement: this.reference, onItemSelect: this.onTemplateScreenGroupSelected, onClose: this.toggleScreenTemplatePopup }))));\n    }\n    getStyle(itemSetting) {\n        const { builderTheme } = this.pageContext;\n        const { index, gutter } = this.props;\n        const sign = utils.isRTL() ? -1 : 1;\n        return [\n            css `\r\n        margin-top: ${index > 0 ? `${gutter}px` : 'unset'};\r\n        width: ${getWidthFromSetting(itemSetting)};\r\n        height: ${this.calHeight(itemSetting)};\r\n        flex-shrink: 0;\r\n        position: relative;\r\n        cursor: default;\r\n        & > div.widget-context-menu {\r\n          display: none;\r\n        }\r\n\r\n        &:hover > div.widget-context-menu {\r\n          display: flex;\r\n        }\r\n\r\n        .template-popup {\r\n          background-color: ${builderTheme.ref.palette.black};\r\n        }\r\n\r\n        .tool-drag-handler {\r\n          cursor: move;\r\n        }\r\n      `,\n            itemSetting.offsetX || itemSetting.offsetY ? `translate(${(itemSetting.offsetX || 0) * sign}px, ${itemSetting.offsetY || 0}px)` : null\n        ];\n    }\n    render() {\n        const { layoutId, layoutItem, draggable, selectable, isEmpty, selected } = this.props;\n        if (!layoutItem || isEmpty) {\n            return null;\n        }\n        const itemSetting = lodash.assign({}, DEFAULT_FLOW_ITEM_SETTING, layoutItem.setting);\n        const mergedClass = classNames('flow-layout-item d-flex', {\n            selected\n        });\n        const oneByOneAnimationProps = utils.handleOnebyOneAnimation(this.props);\n        return (jsx(PageContext.Consumer, null, (pageContext) => {\n            this.pageContext = pageContext;\n            const [cssStyle, transform] = this.getStyle(itemSetting);\n            return (jsx(LayoutItem, Object.assign({ id: `${layoutId}_block_${layoutItem.id}`, css: cssStyle, style: { transform }, layoutId: layoutId, layoutItemId: layoutItem.id, onResizeStart: this.onResizeStart, onResizing: this.onResizing, onResizeEnd: this.onResizeEnd, \n                // onDragStart={this.props.onDragStart}\n                left: false, right: false, top: false, bottom: itemSetting.heightMode === 'fixed', restrict: true, useDragHandler: true, draggable: draggable, selectable: selectable, forbidContextMenu: true, forbidToolbar: true, isBlock: true, className: mergedClass, autoHeight: this.autoHeight }, oneByOneAnimationProps), !pageContext.viewOnly && this.createContextMenu()));\n        }));\n    }\n}\nexport default ReactRedux.connect(mapStateToFlowItemProps)(FlowLayoutItem);\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css, getAppStore, appActions, BrowserSizeMode, AppMode, utils } from 'jimu-core';\nimport { Button, Icon } from 'jimu-ui';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { TemplateSelector } from 'jimu-ui/advanced/setting-components';\nimport { getScreenTemplates } from 'jimu-for-builder/templates';\nimport { getTheme2 } from 'jimu-theme';\nimport deleteIcon from 'jimu-icons/svg/outlined/editor/trash.svg';\nimport addIcon from 'jimu-icons/svg/outlined/editor/plus.svg';\nimport upIcon from 'jimu-icons/svg/outlined/directional/up.svg';\nimport duplicateIcon from 'jimu-icons/svg/outlined/editor/duplicate-page.svg';\nimport { ThemedTooltip } from '../../builder/theme-tooltip';\nexport function ScreenGroupMenu(props) {\n    const { formatMessage, activeScreenIndex, total, layoutId, layoutItemId, screenGroupId, browserSizeMode, hasPanel } = props;\n    const editable = ReactRedux.useSelector((state) => {\n        var _a, _b, _c;\n        const lockLayout = (_b = (_a = state.appConfig.forBuilderAttributes) === null || _a === void 0 ? void 0 : _a.lockLayout) !== null && _b !== void 0 ? _b : false;\n        const appMode = (_c = state.appRuntimeInfo) === null || _c === void 0 ? void 0 : _c.appMode;\n        return appMode === AppMode.Design && !lockLayout;\n    });\n    const readonly = !editable || browserSizeMode !== BrowserSizeMode.Large;\n    const [showPopper, setShowPopper] = React.useState(false);\n    const popperRef = React.useRef();\n    const closeScreenPopper = React.useCallback(() => {\n        setShowPopper(false);\n    }, []);\n    const tooltipStyle = React.useCallback(() => {\n        const theme = getTheme2();\n        return css `\r\n      border: none;\r\n\r\n      .tooltip {\r\n        color: ${theme.ref.palette.black};\r\n        background-color: ${theme.ref.palette.neutral[600]};\r\n        border-color: ${theme.ref.palette.neutral[400]};\r\n      }\r\n    `;\n    }, []);\n    const addScreen = React.useCallback((templateJson) => {\n        const appConfigAction = getAppConfigAction();\n        const screenGroupId = appConfigAction.appConfig.layouts[layoutId].content[layoutItemId].screenGroupId;\n        appConfigAction.createScreenFromTemplate(null, templateJson).then((newScreenId) => {\n            let appConfig = appConfigAction.appConfig;\n            appConfig = appConfig.setIn(['screenGroups', screenGroupId, 'screens'], [].concat(appConfig.screenGroups[screenGroupId].screens, newScreenId)).setIn(['screens', newScreenId, 'parent'], screenGroupId);\n            utils.changeAppConfig(appConfig);\n            getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenGroupId, appConfig.screenGroups[screenGroupId].screens.length - 1));\n        });\n        closeScreenPopper();\n    }, [closeScreenPopper, layoutId, layoutItemId]);\n    const toggleScreenPopper = React.useCallback(() => {\n        if (hasPanel) {\n            setShowPopper(!showPopper);\n        }\n        else {\n            const templates = getScreenTemplates();\n            const templateJson = templates.find(item => item.name === 'nopanel');\n            if (templateJson) {\n                addScreen(templateJson);\n            }\n        }\n    }, [showPopper, hasPanel, addScreen]);\n    const moveup = React.useCallback(() => {\n        getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenGroupId, activeScreenIndex - 1));\n    }, [screenGroupId, activeScreenIndex]);\n    const movedown = React.useCallback(() => {\n        getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenGroupId, activeScreenIndex + 1));\n    }, [screenGroupId, activeScreenIndex]);\n    const removeScreen = React.useCallback(() => {\n        const appConfigAction = getAppConfigAction();\n        appConfigAction.removeScreenByIndex(activeScreenIndex, screenGroupId).exec();\n        if (activeScreenIndex === total - 1) {\n            getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenGroupId, activeScreenIndex - 1));\n        }\n    }, [activeScreenIndex, total, screenGroupId]);\n    const duplicateScreen = React.useCallback(() => {\n        const appConfigAction = getAppConfigAction();\n        appConfigAction.duplicateScreenByIndex(activeScreenIndex, screenGroupId);\n        appConfigAction.exec();\n        getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenGroupId, activeScreenIndex + 1));\n    }, [activeScreenIndex, screenGroupId]);\n    return (jsx(\"div\", { className: 'menu-bar d-flex justify-content-between align-items-center' },\n        jsx(\"div\", { className: 'd-flex justify-content-start align-items-center' },\n            jsx(\"div\", { className: 'info ml-2' },\n                formatMessage('screen'),\n                \": \",\n                activeScreenIndex + 1,\n                \" / \",\n                total),\n            jsx(ThemedTooltip, { title: activeScreenIndex === 0 ? '' : formatMessage('previous'), placement: 'bottom', css: tooltipStyle() },\n                jsx(Button, { icon: true, className: 'rounded-circle', disabled: activeScreenIndex === 0, type: 'tertiary', onClick: moveup },\n                    jsx(Icon, { icon: upIcon, size: 16 }))),\n            jsx(ThemedTooltip, { title: activeScreenIndex === total - 1 ? '' : formatMessage('next'), placement: 'bottom', css: tooltipStyle() },\n                jsx(Button, { icon: true, className: 'rounded-circle', disabled: activeScreenIndex === total - 1, type: 'tertiary', onClick: movedown },\n                    jsx(Icon, { icon: upIcon, rotate: 180, size: 16 }))),\n            !readonly && (jsx(\"div\", { ref: popperRef },\n                jsx(ThemedTooltip, { title: formatMessage('newScreen'), placement: 'bottom', css: tooltipStyle() },\n                    jsx(Button, { icon: true, onClick: toggleScreenPopper, className: 'rounded-circle', type: 'tertiary', \"data-testid\": 'addBtn' },\n                        jsx(Icon, { icon: addIcon, size: 16 }))))),\n            !readonly && showPopper && (jsx(TemplateSelector, { templates: getScreenTemplates(), referenceElement: popperRef.current, onItemSelect: addScreen, onClose: closeScreenPopper })),\n            !readonly && (jsx(ThemedTooltip, { title: formatMessage('duplicateScreen'), placement: 'bottom', css: tooltipStyle() },\n                jsx(Button, { icon: true, className: 'rounded-circle', type: 'tertiary', onClick: duplicateScreen, \"data-testid\": 'duplicateBtn' },\n                    jsx(Icon, { icon: duplicateIcon, size: 16 })))),\n            !readonly && total > 1 && (jsx(ThemedTooltip, { title: formatMessage('deleteScreen'), placement: 'bottom', css: tooltipStyle() },\n                jsx(Button, { icon: true, className: 'rounded-circle', type: 'tertiary', onClick: removeScreen, \"data-testid\": 'removeBtn' },\n                    jsx(Icon, { icon: deleteIcon, size: 16 })))))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, getAppStore, ReactRedux, polished, BrowserSizeMode, LayoutType } from 'jimu-core';\nimport { Button } from 'jimu-ui';\nimport { getAppConfigAction, appBuilderSync, LayoutServiceProvider } from 'jimu-for-builder';\nimport { WidgetListPopper } from 'jimu-ui/advanced/setting-components';\nimport { LayoutContext, utils } from 'jimu-layouts/layout-runtime';\nimport { withBuilderTheme } from 'jimu-theme';\nimport { addItemToLayout } from '../../builder/common-layout-actions';\nimport { DropArea } from '../../builder/interactive/droparea-hook';\nimport { PlusOutlined } from 'jimu-icons/outlined/editor/plus';\nconst ThemeWidgetListPopper = withBuilderTheme(WidgetListPopper);\nconst buttonStyle = css `\r\n  width: 36px;\r\n  height: 36px;\r\n  padding: 0.5rem;\r\n`;\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  top: 0;\r\n  right: 0;\r\n  background: transparent;\r\n`;\nfunction getStyle(builderTheme) {\n    return css `\r\n    display: flex;\r\n    height: 200px;\r\n    position: relative;\r\n    z-index: 1;\r\n    border: 1px dashed ${polished.rgba(builderTheme.ref.palette.neutral[1000], 0.6)};\r\n\r\n    body.lock-layout &,\r\n    body:not(.design-mode) & {\r\n      display: none !important;\r\n    }\r\n\r\n    .action-item {\r\n      z-index: 1;\r\n    }\r\n  `;\n}\nexport function Placeholder(props) {\n    const { layouts, builderTheme } = props;\n    const layoutId = ReactRedux.useSelector((state) => {\n        return layouts[state.browserSizeMode] || layouts[state.appConfig.mainSizeMode];\n    });\n    const [showPopper, setShowPopper] = React.useState(false);\n    const templateRef = React.useRef(null);\n    const togglePopper = (e) => {\n        e.stopPropagation();\n        if (getAppStore().getState().browserSizeMode === BrowserSizeMode.Small) {\n            appBuilderSync.publishSidePanelToApp({ type: 'widget', isPlaceholder: true, isItemAccepted: isItemAccepted, onSelect: addWidget });\n            return;\n        }\n        setShowPopper(!showPopper);\n    };\n    const closePopper = () => {\n        setShowPopper(false);\n    };\n    const addWidget = React.useCallback((item) => {\n        const appConfigAction = getAppConfigAction();\n        addItemToLayout(appConfigAction.appConfig, item, layoutId).then(({ layoutInfo, updatedAppConfig }) => {\n            const columnService = LayoutServiceProvider.getInstance().getServiceByType(LayoutType.ColumnLayout);\n            const outAppConfig = columnService.processAfterItemAdded(updatedAppConfig, item, layoutInfo, {\n                currentSizeMode: null,\n                containerRect: { width: 100, height: 100 },\n                itemRect: { left: 0, top: 0 },\n                insertIndex: null\n            });\n            utils.changeLayout(outAppConfig, layoutInfo);\n        });\n        setShowPopper(false);\n    }, [layoutId]);\n    const onDrop = React.useCallback((draggingItem, containerRect, itemRect) => {\n        const appConfigAction = getAppConfigAction();\n        addItemToLayout(appConfigAction.appConfig, draggingItem, layoutId).then(({ layoutInfo, updatedAppConfig }) => {\n            const columnService = LayoutServiceProvider.getInstance().getServiceByType(LayoutType.ColumnLayout);\n            const outAppConfig = columnService.processAfterItemAdded(updatedAppConfig, draggingItem, layoutInfo, {\n                currentSizeMode: null,\n                containerRect,\n                itemRect,\n                insertIndex: null\n            });\n            utils.changeLayout(outAppConfig, layoutInfo);\n        });\n    }, [layoutId]);\n    const isItemAccepted = React.useCallback((item) => {\n        if (item.layoutInfo) {\n            return item.layoutInfo.layoutId !== layoutId;\n        }\n        return true;\n    }, [layoutId]);\n    return (jsx(LayoutContext.Provider, { value: { isItemAccepted } },\n        jsx(\"div\", { className: 'placeholder-btn w-100 justify-content-center align-items-center', css: getStyle(builderTheme) },\n            jsx(DropArea, { css: dropareaStyle, layouts: layouts, onDrop: onDrop }),\n            jsx(\"div\", { className: 'action-item', ref: templateRef },\n                jsx(Button, { icon: true, css: buttonStyle, onClick: togglePopper },\n                    jsx(PlusOutlined, { size: 'm' }))),\n            showPopper && (jsx(ThemeWidgetListPopper, { referenceElement: templateRef.current, isAccepted: isItemAccepted, onSelect: addWidget, onClose: closePopper })))));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css, ReactResizeDetector, ScreenTriggerType, classNames, spring, getAppStore, appActions } from 'jimu-core';\nimport { interact } from 'jimu-core/dnd';\nimport { Button } from 'jimu-ui';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { utils } from 'jimu-layouts/layout-runtime';\nimport { bindResizeHandler } from '../../builder/interactive/resize-event-handler';\nimport { getSidePanelStyle } from '../common/screen-side-panel';\nimport { useIntersection } from '../use-intersection';\nimport { Placeholder } from './screen-side-action-block';\nimport { InvisibleOutlined } from 'jimu-icons/outlined/application/invisible';\nimport { ThemedTooltip } from '../../builder/theme-tooltip';\nconst animated = spring.animated;\nfunction getStyle(options) {\n    const { props, viewHeight, headerHeight, isActive, verticalSpace, stretched, transitionType, screenTransitionType, isSmallSize, builderTheme, isResizing, width } = options;\n    const { side, size } = props.panel || {};\n    const visibleButtonStyle = css `\r\n    color: ${builderTheme.ref.palette.neutral[1200]};\r\n    background-color: ${builderTheme.ref.palette.neutral[500]};\r\n    border-color: ${builderTheme.ref.palette.neutral[600]};\r\n    &:hover {\r\n      color: ${builderTheme.ref.palette.black};\r\n      background-color: ${builderTheme.ref.palette.neutral[600]};\r\n    }\r\n  `;\n    if (isSmallSize) {\n        return css `\r\n      ${getSidePanelStyle({ props, viewHeight, headerHeight, isActive, verticalSpace, stretched, transitionType, screenTransitionType, isSmallSize })};\r\n\r\n      .panel-content {\r\n        transform: none !important;\r\n\r\n        &:not(.visible) {\r\n          pointer-events: none;\r\n          > .layout-wrapper > .layout,\r\n          > .layout-wrapper > .placeholder-btn {\r\n            pointer-events: none;\r\n          }\r\n        }\r\n      }\r\n\r\n      &.minimized .exb-drop-area, &.minimized .toggle-visible-btn {\r\n        pointer-events: none !important;\r\n      }\r\n\r\n      .resize-handle {\r\n        display: none;\r\n      }\r\n\r\n      .layout-wrapper {\r\n        transform-origin: right bottom;\r\n      }\r\n\r\n      .toggle-visible-btn {\r\n        display: flex;\r\n        justify-content: flex-end;\r\n        pointer-events: auto;\r\n\r\n        > button {\r\n          ${visibleButtonStyle};\r\n        }\r\n      }\r\n      body:not(.design-mode) & .toggle-visible-btn {\r\n        display: none !important;\r\n      }\r\n    `;\n    }\n    return css `\r\n    ${getSidePanelStyle({ props, viewHeight, headerHeight, isActive, verticalSpace, stretched, transitionType, screenTransitionType, isSmallSize })};\r\n\r\n    .panel-content {\r\n      position: relative;\r\n      touch-action: none;\r\n      width: ${isResizing ? `${width}px` : size};\r\n\r\n      &:not(.visible) {\r\n        pointer-events: none;\r\n        > .layout-wrapper > .layout,\r\n        > .layout-wrapper > .placeholder-btn {\r\n          pointer-events: none;\r\n        }\r\n      }\r\n\r\n      &.simple-mode {\r\n        display: flex;\r\n        flex-direction: column;\r\n        justify-content: flex-end;\r\n        width: 100% !important;\r\n      }\r\n\r\n      .layout-wrapper {\r\n        position: relative;\r\n        transform-origin: right bottom;\r\n      }\r\n    }\r\n\r\n    .toggle-visible-btn {\r\n      display: flex;\r\n      justify-content: flex-end;\r\n      pointer-events: auto;\r\n      > button {\r\n        ${visibleButtonStyle};\r\n        svg {\r\n          margin-right: 0;\r\n          margin-left: 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    &.minimized .exb-drop-area, &.minimized .toggle-visible-btn {\r\n        pointer-events: none !important;\r\n      }\r\n\r\n    .panel-content:hover {\r\n      .resize-handle {\r\n        display: block;\r\n      }\r\n    }\r\n    body:not(.design-mode) & .resize-handle,\r\n    body:not(.design-mode) & .toggle-visible-btn,\r\n    body.lock-layout & .resize-handle {\r\n      display: none !important;\r\n    }\r\n    .resize-handle {\r\n      position: absolute;\r\n      cursor: ew-resize;\r\n      top: 0;\r\n      bottom: 0;\r\n      display: ${isResizing ? 'block' : 'none'};\r\n      touch-action: none;\r\n      outline: 1px solid var(--ref-palette-neutral-500);\r\n      width: 5px;\r\n      pointer-events: auto;\r\n      &:after {\r\n        content: '';\r\n        position: absolute;\r\n        z-index: -1;\r\n        top: 0;\r\n        bottom: 0;\r\n        left: 50%;\r\n        border-left: 1px dotted var(--ref-palette-neutral-500);\r\n        transform: translate(-50%);\r\n      }\r\n\r\n      &.left {\r\n        left: -5px;\r\n        display: ${side !== 'left' ? 'none' : 'none !important'};\r\n      }\r\n      &.right {\r\n        right: -5px;\r\n        display: ${side !== 'right' ? 'none' : 'none !important'};\r\n      }\r\n    }\r\n  `;\n}\nfunction updateScreenSize(screenId, size) {\n    var _a;\n    const appConfigAction = getAppConfigAction();\n    const screenJson = appConfigAction.appConfig.screens[screenId];\n    let newSize;\n    if (utils.isPercentage((_a = screenJson.panel) === null || _a === void 0 ? void 0 : _a.size)) {\n        newSize = utils.toRatio(size, document.body.clientWidth);\n    }\n    else {\n        newSize = `${Math.round(size)}px`;\n    }\n    appConfigAction.editScreenProperty(screenId, 'panel.size', newSize).exec();\n}\nexport function ScreenSidePanel(props) {\n    const { index, screenId, onInteractionChange, onHeightChange, builderTheme, viewHeight, headerHeight, layoutEntry: LayoutEntry, isActive, isSmallSize, isDesignMode, transitionType, screenTransitionType, triggerType, stretched, viewOnly, verticalSpace = '0', useAnimation = true, formatMessage } = props;\n    const screenJson = ReactRedux.useSelector((state) => {\n        return state.appConfig.screens[screenId];\n    });\n    const panelVisible = ReactRedux.useSelector((state) => {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.screenPanelStates) === null || _b === void 0 ? void 0 : _b[screenId]) !== null && _c !== void 0 ? _c : true;\n    });\n    const { panel } = screenJson;\n    const domRef = React.useRef();\n    const elementRef = React.useRef();\n    const interactableRef = React.useRef();\n    const [isResizing, setIsResizing] = React.useState(false);\n    const [deltaWidth, setDeltaWidth] = React.useState(0);\n    const panelVisibleRef = React.useRef(panelVisible);\n    const designModeRef = React.useRef(isDesignMode);\n    const initWidth = React.useRef();\n    const initialOffset = React.useMemo(() => {\n        if (panel && panel.overlay && Math.abs(parseFloat(panel.offset)) > 0) {\n            const isRTL = getAppStore().getState().appContext.isRTL;\n            const factor = isRTL ? (panel.side === 'left' ? -1 : 1) : (panel.side === 'right' ? -1 : 1);\n            return parseFloat(panel.offset) * factor;\n        }\n        return 0;\n    }, [panel]);\n    const [animationProps, api] = spring.useSpring(() => ({ opacity: 1, size: 1, x: 0, y: 0 }));\n    const onResizeStart = React.useCallback((id, width) => {\n        initWidth.current = width;\n        setIsResizing(true);\n        setDeltaWidth(0);\n    }, []);\n    const onResizing = React.useCallback((id, dx, dy, dw, dh) => {\n        setDeltaWidth(dw);\n    }, []);\n    const onResizeEnd = React.useCallback((id, dx, dy, dw, dh) => {\n        updateScreenSize(screenId, initWidth.current + dw);\n        setIsResizing(false);\n    }, [screenId]);\n    React.useEffect(() => {\n        if (designModeRef.current !== isDesignMode) {\n            designModeRef.current = isDesignMode;\n            if (!isDesignMode) {\n                api.start({ opacity: 1, x: 0, y: 0, immediate: true, onRest: null });\n            }\n            else {\n                if (panelVisibleRef.current) {\n                    api.start({ opacity: 1, x: 0, y: 0, immediate: true, onRest: null });\n                }\n                else {\n                    api.start({ opacity: 0, immediate: true, onRest: null });\n                }\n            }\n        }\n    }, [isDesignMode, api]);\n    React.useEffect(() => {\n        if (!interactableRef.current && elementRef.current) {\n            interactableRef.current = interact(elementRef.current);\n            bindResizeHandler(interactableRef.current, {\n                layoutItemId: screenId,\n                onResizeStart: onResizeStart,\n                onResizing: onResizing,\n                onResizeEnd: onResizeEnd\n            });\n            return () => {\n                if (interactableRef.current) {\n                    interactableRef.current.unset();\n                    interactableRef.current = null;\n                }\n            };\n        }\n    }, [screenId, onResizeStart, onResizing, onResizeEnd]);\n    const intersectionChange = React.useCallback((isIntersecting) => {\n        onInteractionChange(index, isIntersecting);\n    }, [index, onInteractionChange]);\n    const onSizeChange = React.useCallback(({ width, height }) => {\n        onHeightChange(index, height);\n    }, [index, onHeightChange]);\n    const hidePanel = React.useCallback((e) => {\n        const buttonRect = e.target.getBoundingClientRect();\n        const parentRect = domRef.current.getBoundingClientRect();\n        const isRTL = getAppStore().getState().appContext.isRTL;\n        domRef.current.classList.add('minimized');\n        api.start({\n            opacity: 0,\n            size: 0,\n            x: isRTL ? parentRect.left - buttonRect.left : parentRect.right - buttonRect.right,\n            y: parentRect.bottom - buttonRect.bottom,\n            immediate: !useAnimation,\n            onRest: () => {\n                panelVisibleRef.current = false;\n                getAppStore().dispatch(appActions.screenPanelVisibleChanged(screenId, false));\n            }\n        });\n    }, [api, screenId, useAnimation]);\n    const showPanel = React.useCallback(() => {\n        domRef.current.classList.remove('minimized');\n        api.start({\n            opacity: 1,\n            size: 1,\n            x: 0,\n            y: 0,\n            immediate: !useAnimation,\n            onRest: null\n        });\n    }, [api, useAnimation]);\n    React.useEffect(() => {\n        if (panelVisibleRef.current !== panelVisible && panelVisible) {\n            showPanel();\n            panelVisibleRef.current = panelVisible;\n        }\n    }, [panelVisible, showPanel]);\n    useIntersection(domRef.current, props.refElement, isSmallSize ? ScreenTriggerType.Lower : triggerType !== null && triggerType !== void 0 ? triggerType : ScreenTriggerType.Bottom, intersectionChange);\n    const animationStyle = {\n        opacity: animationProps.opacity,\n        translateX: initialOffset,\n        x: animationProps.x,\n        y: animationProps.y\n    };\n    const togglable = React.useCallback(() => {\n        return !viewOnly && isActive && (panel === null || panel === void 0 ? void 0 : panel.overlay);\n    }, [panel, isActive, viewOnly]);\n    return (jsx(\"div\", { className: classNames('screen-side-panel', {\n            'top-spacing': index === 0 && ((panel === null || panel === void 0 ? void 0 : panel.overlay) || isSmallSize)\n        }), \"data-screenid\": screenId, \"data-index\": index, ref: domRef, css: getStyle({\n            props: screenJson,\n            viewHeight,\n            headerHeight,\n            isActive,\n            verticalSpace,\n            stretched: stretched || panel == null,\n            transitionType,\n            screenTransitionType,\n            isSmallSize,\n            panelVisible,\n            builderTheme,\n            isResizing,\n            width: initWidth.current + deltaWidth\n        }) },\n        panel && (jsx(animated.div, { className: classNames('panel-content', { visible: panelVisible }), ref: elementRef, style: animationStyle },\n            jsx(\"div\", { className: 'layout-wrapper' },\n                jsx(LayoutEntry, { layouts: panel.layout }),\n                !viewOnly && jsx(Placeholder, { layouts: panel.layout, builderTheme: builderTheme }),\n                jsx(\"span\", { className: 'resize-handle left rnd-resize-left' }),\n                jsx(\"span\", { className: 'resize-handle right rnd-resize-right' })),\n            togglable() && (jsx(\"div\", { className: 'toggle-visible-btn', onClick: hidePanel, \"data-testid\": `toggleBtn-${panelVisible}` },\n                jsx(ThemedTooltip, { placement: 'auto', title: formatMessage('hideInDesignView') },\n                    jsx(Button, { type: 'default', size: 'sm', className: 'rounded-1' },\n                        jsx(InvisibleOutlined, { size: 'm' }))))),\n            jsx(\"div\", { className: classNames('panel-spacing', { 'last-item': props.isLast }) }))),\n        !panel && panelVisible && jsx(\"div\", { className: 'panel-content-placeholder' }),\n        jsx(ReactResizeDetector, { targetRef: domRef, handleHeight: true, onResize: onSizeChange })));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ReactRedux, BrowserSizeMode, utils as jimuUtils, getAppStore, appActions, ScreenTransitionType, classNames, ScreenTriggerType, Keyboard, AppMode, ReactResizeDetector, lodash } from 'jimu-core';\nimport { interact } from 'jimu-core/dnd';\nimport { builderActions } from 'jimu-for-builder';\nimport { PageContext } from 'jimu-layouts/layout-runtime';\nimport { ScreenGroupContext } from '../../builder/page-context';\nimport { ScreenGroupMenu } from './screen-menu';\nimport { ScreenMainPanelList } from '../common';\nimport { ScreenSidePanel } from './screen-side-panel';\nimport { bindDragHandler, setIsDragging } from '../../builder/interactive/drag-event-handler';\nimport LayoutEntry from '../../builder/layout-entry';\nimport { isLockLayout } from '../../builder/menu/common-menu';\nimport { ScreenContextMenu } from './screen-context-menu';\nimport { SCREEN_RATIO_IN_SMALL_SIZE, DEFAULT_HEADER_HEIGHT } from '../common/type';\nimport { updateScreenHeight } from '../common/util';\nfunction getStyle(viewHeight, builderTheme, isFirst, isLast, selected, isOverlay) {\n    return css `\r\n    position: relative;\r\n    width: 100%;\r\n\r\n    & > div.widget-context-menu {\r\n      display: none;\r\n    }\r\n\r\n    &:hover > div.widget-context-menu {\r\n      display: flex;\r\n    }\r\n\r\n    body.lock-layout & {\r\n      .screen-menu {\r\n        bottom: ${isFirst ? (isLast ? '-10px' : '-32px') : 'auto'};\r\n        z-index: ${isFirst && isLast ? 10 : null};\r\n      }\r\n    }\r\n\r\n    .screen-menu {\r\n      display: ${selected ? 'block' : 'none'};\r\n      position: absolute;\r\n      opacity: ${selected ? 0.8 : 0.5};\r\n      left: 0;\r\n      top: ${isFirst ? 'auto' : '-32px'};\r\n      bottom: ${isFirst ? '-32px' : 'auto'};\r\n      height: 32px;\r\n      width: 100%;\r\n      background-color: ${builderTheme.ref.palette.neutral[300]};\r\n      overflow: visible;\r\n\r\n      .info {\r\n        color: ${builderTheme.ref.palette.black};\r\n      }\r\n\r\n      .jimu-btn svg {\r\n        color: ${builderTheme.ref.palette.neutral[1000]};\r\n      }\r\n    }\r\n\r\n    .screen-group {\r\n      position: relative;\r\n      height: ${viewHeight}px;\r\n      overflow-y: auto;\r\n      overflow-x: hidden;\r\n    }\r\n\r\n    .main-panels {\r\n      position: absolute;\r\n      left: 0;\r\n      right: 0;\r\n      top: 0;\r\n      pointer-events: none;\r\n      z-index: 0;\r\n    }\r\n\r\n    &.small-size .main-panels {\r\n      z-index: ${isOverlay ? 0 : 1};\r\n    }\r\n\r\n    &.small-size .side-panels {\r\n      z-index: ${isOverlay ? 1 : 0};\r\n    }\r\n\r\n    .side-panels {\r\n      position: relative;\r\n      z-index: 1;\r\n      pointer-events: none;\r\n\r\n      > div:first-of-type > div.panel-content {\r\n        padding-top: ${Math.round(viewHeight * SCREEN_RATIO_IN_SMALL_SIZE)}px;\r\n      }\r\n\r\n      /* > div:nth-last-of-type(2) {\r\n        min-height: ${viewHeight}px;\r\n      } */\r\n    }\r\n\r\n    body:not(.design-mode) & {\r\n      .screen-group {\r\n        position: static;\r\n        height: auto;\r\n        overflow-y: unset;\r\n        overflow-x: unset;\r\n      }\r\n      .side-panels {\r\n        > div:first-of-type > div.panel-content {\r\n          padding-top: ${100 * SCREEN_RATIO_IN_SMALL_SIZE}vh;\r\n          padding-top: calc(var(--vh) * ${100 * SCREEN_RATIO_IN_SMALL_SIZE});\r\n        }\r\n        /* > div:nth-last-of-type(2) {\r\n          min-height: 100vh;\r\n        } */\r\n      }\r\n      .screen-menu {\r\n        display: none !important;\r\n      }\r\n    }\r\n\r\n    .group-tip {\r\n      display: none;\r\n      padding: inherit;\r\n      position: absolute;\r\n      left: 0;\r\n      bottom: 0;\r\n      top: 0;\r\n      right: 0;\r\n      pointer-events: none;\r\n      .tip-content {\r\n        height: 100%;\r\n        padding: 2px;\r\n        &:after {\r\n          content: '';\r\n          width: 100%;\r\n          height: 100%;\r\n          outline: 2px solid ${builderTheme.sys.color.primary.dark};\r\n          display: block;\r\n        }\r\n      }\r\n    }\r\n\r\n    &:hover .group-tip {\r\n      display: block;\r\n    }\r\n  `;\n}\nfunction clearSelectionInScreen(screenGroupId, screenIndex) {\n    var _a;\n    const appConfig = getAppStore().getState().appConfig;\n    const sizeMode = getAppStore().getState().browserSizeMode;\n    const selection = (_a = getAppStore().getState().appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.selection;\n    if (selection != null) {\n        const screenGroup = appConfig.screenGroups[screenGroupId];\n        const screenId = screenGroup.screens[screenIndex];\n        const screenJson = appConfig.screens[screenId];\n        if (screenJson) { // the active screen may being removed\n            const screenLayoutId = screenJson.main.layout[sizeMode];\n            // selection is in the layout\n            if (selection.layoutId === screenLayoutId) {\n                getAppStore().dispatch(appActions.selectionChanged(null));\n            }\n            // selection in descendant of the layout\n            const element = document.querySelector(`div[data-layoutid=\"${screenLayoutId}\"] div[data-layoutid=\"${selection.layoutId}\"][data-layoutitemid=\"${selection.layoutItemId}\"]`);\n            if (element != null) {\n                getAppStore().dispatch(appActions.selectionChanged(null));\n            }\n        }\n    }\n}\nexport function ScreenGroup(props) {\n    var _a;\n    const { layoutId, layoutItemId, layoutItem, formatMessage, itemIndex, isFirst, isLast } = props;\n    const { screenGroupId } = layoutItem;\n    const selected = ReactRedux.useSelector((state) => {\n        var _a;\n        const selection = (_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.selection;\n        if (selection) {\n            return selection.layoutId === layoutId && selection.layoutItemId === layoutItemId;\n        }\n        return false;\n    });\n    const screenGroup = ReactRedux.useSelector((state) => {\n        return state.appConfig.screenGroups[layoutItem.screenGroupId];\n    });\n    const hasPanel = ReactRedux.useSelector((state) => {\n        // screen with panel and without panel can be mixed\n        const screenIds = state.appConfig.screenGroups[layoutItem.screenGroupId].screens;\n        return screenIds.some(screenId => {\n            const screen = state.appConfig.screens[screenId];\n            return screen.panel != null;\n        });\n    });\n    const browserSizeMode = ReactRedux.useSelector((state) => {\n        return state.browserSizeMode;\n    });\n    const { screens, stretchPanel = true, triggerType = ScreenTriggerType.Bottom, verticalSpace = '0', panelTransitionType = ScreenTransitionType.Push } = screenGroup;\n    let transitionType = (_a = screenGroup.transitionType) !== null && _a !== void 0 ? _a : ScreenTransitionType.Fade;\n    if (browserSizeMode === BrowserSizeMode.Small && !hasPanel) {\n        transitionType = ScreenTransitionType.Cover;\n    }\n    const navInfo = ReactRedux.useSelector((state) => {\n        var _a;\n        return (_a = state.appRuntimeInfo.screenGroupNavInfos) === null || _a === void 0 ? void 0 : _a[screenGroupId];\n    });\n    const viewportSize = ReactRedux.useSelector((state) => {\n        return jimuUtils.findViewportSize(state.appConfig, state.browserSizeMode || BrowserSizeMode.Large);\n    });\n    const isDesignMode = ReactRedux.useSelector((state) => { var _a; return ((_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.appMode) === AppMode.Design; });\n    const { viewOnly, builderTheme, pageId } = React.useContext(PageContext);\n    const headerHeight = ReactRedux.useSelector((state) => {\n        const pageJson = state.appConfig.pages[pageId];\n        if (pageJson === null || pageJson === void 0 ? void 0 : pageJson.header) {\n            const headerJson = state.appConfig.header;\n            if (headerJson === null || headerJson === void 0 ? void 0 : headerJson.sticky) {\n                const browserSizeMode = state.browserSizeMode;\n                const mainSizeMode = state.appConfig.mainSizeMode;\n                const height = headerJson.height[browserSizeMode] || headerJson.height[mainSizeMode] || DEFAULT_HEADER_HEIGHT;\n                return parseInt(height, 10);\n            }\n        }\n        return 0;\n    });\n    const domRef = React.useRef();\n    const screenGroupRef = React.useRef();\n    const mainPanelRef = React.useRef();\n    const sidePanelsRef = React.useRef();\n    const monitorScrollRef = React.useRef(true);\n    const scrollListenerRef = React.useRef();\n    const interactableRef = React.useRef();\n    const [activeIndex, setActiveIndex] = React.useState(0);\n    React.useEffect(() => {\n        if (selected) {\n            const element = document.querySelector(`div.exb-rnd[data-layoutid=\"${layoutId}\"][data-layoutitemid=\"${layoutItemId}\"]`);\n            if (element != null) {\n                element.scrollIntoView({ behavior: 'auto', block: 'center' });\n            }\n        }\n    }, [selected, layoutId, layoutItemId]);\n    const isOverlay = React.useMemo(() => {\n        var _a, _b, _c;\n        if (browserSizeMode !== BrowserSizeMode.Small) {\n            return false;\n        }\n        const appConfig = getAppStore().getState().appConfig;\n        const screens = (_b = (_a = appConfig.screenGroups) === null || _a === void 0 ? void 0 : _a[screenGroupId]) === null || _b === void 0 ? void 0 : _b.screens;\n        if (screens === null || screens === void 0 ? void 0 : screens[activeIndex]) {\n            const screen = appConfig.screens[screens[activeIndex]];\n            return (_c = screen.panel) === null || _c === void 0 ? void 0 : _c.overlay;\n        }\n        return false;\n    }, [screenGroupId, activeIndex, browserSizeMode]);\n    const scrollIntoView = React.useCallback((index) => {\n        var _a;\n        // check if side panel of index is in current view extent\n        const sideElements = screenGroupRef.current.querySelectorAll('div.screen-side-panel');\n        let previousItemsHeight = 0;\n        // let targetHeight = 0;\n        sideElements.forEach(element => {\n            const elementIndex = +element.getAttribute('data-index');\n            if (elementIndex < index) {\n                previousItemsHeight += element.clientHeight;\n            }\n        });\n        screenGroupRef.current.scrollTop = previousItemsHeight;\n        if (transitionType !== ScreenTransitionType.Fade) {\n            const screenContainerElem = (_a = mainPanelRef.current) === null || _a === void 0 ? void 0 : _a.children[0];\n            if (screenContainerElem) {\n                screenContainerElem.scrollTop = screenGroupRef.current.scrollTop;\n            }\n        }\n    }, [transitionType]);\n    const onItemDragStart = React.useCallback(() => {\n        setIsDragging(true);\n    }, []);\n    const onItemDragEnd = React.useCallback(() => {\n        setIsDragging(false);\n    }, []);\n    React.useEffect(() => {\n        if (domRef.current && !interactableRef.current) {\n            const { layoutId, layoutItemId, layoutItem } = props;\n            interactableRef.current = interact(domRef.current).origin('parent');\n            interactableRef.current = bindDragHandler(interactableRef.current, {\n                layoutId,\n                layoutItemId,\n                // onDragging,\n                onDragStart: onItemDragStart,\n                onDragEnd: onItemDragEnd,\n                useDragHandler: true,\n                itemType: layoutItem.type,\n                rootLayoutId: () => layoutId,\n                restrict: () => true\n            });\n            interactableRef.current.draggable({\n                modifiers: [interact.modifiers.restrictRect({\n                        restriction: 'parent'\n                    })]\n            });\n        }\n        return () => {\n            if (interactableRef.current) {\n                interactableRef.current.unset();\n                interactableRef.current = null;\n            }\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    React.useEffect(() => {\n        if ((navInfo === null || navInfo === void 0 ? void 0 : navInfo.activeIndex) != null && navInfo.activeIndex !== activeIndex) {\n            // clear selection if it is a child of the last screen\n            clearSelectionInScreen(screenGroupId, activeIndex);\n            setActiveIndex(navInfo.activeIndex);\n            if (navInfo.scrollIntoView) {\n                monitorScrollRef.current = false; // do not monitor scroll event when user jumps to another screen\n                scrollIntoView(navInfo.activeIndex);\n                setTimeout(() => {\n                    monitorScrollRef.current = true;\n                }, 200);\n            }\n        }\n    }, [navInfo, activeIndex, scrollIntoView, screenGroupId]);\n    React.useEffect(() => {\n        if (scrollListenerRef.current) {\n            screenGroupRef.current.removeEventListener('scroll', scrollListenerRef.current);\n            scrollListenerRef.current = null;\n        }\n        scrollListenerRef.current = () => {\n            var _a;\n            const screenContainerElem = (_a = mainPanelRef.current) === null || _a === void 0 ? void 0 : _a.children[0];\n            if (!screenContainerElem || transitionType === ScreenTransitionType.Fade) {\n                return;\n            }\n            // for cover effect\n            screenContainerElem.scrollTop = screenGroupRef.current.scrollTop;\n        };\n        screenGroupRef.current.addEventListener('scroll', scrollListenerRef.current);\n    }, [transitionType]);\n    React.useEffect(() => {\n        getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenGroupId, 0));\n    }, [isDesignMode, screenGroupId]);\n    const onInteractionChange = React.useCallback((index, isIntersecting) => {\n        if (!monitorScrollRef.current) {\n            return;\n        }\n        if (isIntersecting && index !== activeIndex) {\n            getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenGroupId, index, false));\n        }\n        else if (!isIntersecting && index > 0) {\n            getAppStore().dispatch(appActions.screenGroupNavInfoChanged(screenGroupId, index - 1, false));\n        }\n    }, [activeIndex, screenGroupId]);\n    const selectItem = React.useCallback((e) => {\n        e.stopPropagation();\n        if (!isLockLayout() && !viewOnly && browserSizeMode !== BrowserSizeMode.Small) {\n            getAppStore().dispatch(appActions.selectionChanged({ layoutId, layoutItemId }));\n        }\n    }, [viewOnly, browserSizeMode, layoutId, layoutItemId]);\n    const sidepanelResizeHandler = React.useCallback(() => {\n        if (!screenGroupRef.current) {\n            return;\n        }\n        const mainPanelContainer = screenGroupRef.current.children[0];\n        const sidePanelContainer = screenGroupRef.current.children[1];\n        mainPanelContainer.style.height = `${sidePanelContainer.clientHeight}px`;\n    }, []);\n    const debounceResizeHandler = React.useMemo(() => lodash.debounce(sidepanelResizeHandler, 200), [sidepanelResizeHandler]);\n    const onSidePanelHeightChange = React.useCallback((index, height) => {\n        if (!screenGroupRef.current) {\n            return;\n        }\n        const mainPanelContainer = screenGroupRef.current.children[0];\n        const sidePanelContainer = screenGroupRef.current.children[1];\n        if (transitionType === ScreenTransitionType.Fade) {\n            mainPanelContainer.style.height = `${sidePanelContainer.clientHeight}px`;\n            return;\n        }\n        if (transitionType === ScreenTransitionType.Cover) {\n            updateScreenHeight(mainPanelContainer, sidePanelContainer, browserSizeMode);\n            return;\n        }\n        if (transitionType === ScreenTransitionType.Push) {\n            const relatedElement = mainPanelContainer.querySelector(`div.screen-main-panel[data-index=\"${index}\"]`);\n            const panelElement = sidePanelContainer.querySelector(`div.screen-side-panel[data-index=\"${index}\"]`);\n            relatedElement.style.height = `${panelElement.clientHeight}px`;\n            mainPanelContainer.style.height = `${sidePanelContainer.clientHeight}px`;\n        }\n    }, [browserSizeMode, transitionType]);\n    const deleteSelectedItem = React.useCallback(() => {\n        getAppStore().dispatch(builderActions.confirmDeleteContentChanged({ layoutId, layoutItemId }));\n    }, [layoutId, layoutItemId]);\n    const keyBindings = React.useMemo(() => {\n        return {\n            delete: deleteSelectedItem,\n            backspace: deleteSelectedItem\n        };\n    }, [deleteSelectedItem]);\n    if (screens.length > 0) {\n        return (jsx(ScreenGroupContext.Provider, { value: `${layoutId}:${layoutItemId}` },\n            jsx(\"div\", { className: classNames('builder-layout-item exb-rnd', {\n                    selected,\n                    'small-size': browserSizeMode === BrowserSizeMode.Small\n                }), css: getStyle(viewportSize.height, builderTheme, isFirst, isLast, selected, isOverlay), \"data-layoutitemid\": layoutItemId, \"data-layoutid\": layoutId, onClick: selectItem, ref: domRef },\n                jsx(\"div\", { className: 'screen-menu' },\n                    jsx(ScreenGroupMenu, { activeScreenIndex: activeIndex, itemIndex: itemIndex, total: screens.length, screenGroupId: screenGroupId, layoutId: layoutId, layoutItemId: layoutItemId, browserSizeMode: browserSizeMode, hasPanel: hasPanel, formatMessage: formatMessage })),\n                jsx(\"div\", { className: 'screen-group', ref: screenGroupRef },\n                    jsx(\"div\", { className: 'main-panels', ref: mainPanelRef },\n                        jsx(ScreenMainPanelList, { rootLayoutId: layoutId, activeIndex: activeIndex, viewHeight: viewportSize.height, headerHeight: headerHeight, screens: screens, transitionType: transitionType, layoutEntry: LayoutEntry, isSmallSize: browserSizeMode === BrowserSizeMode.Small, isDesignMode: isDesignMode, builderTheme: builderTheme, formatMessage: formatMessage })),\n                    jsx(\"div\", { className: 'side-panels', ref: sidePanelsRef },\n                        screens.map((screenId, idx) => {\n                            return (jsx(ScreenSidePanel, { key: screenId, index: idx, isLast: idx === screens.length - 1, screenId: screenId, viewHeight: viewportSize.height, headerHeight: headerHeight, refElement: isDesignMode ? domRef.current : null, layoutEntry: LayoutEntry, viewOnly: viewOnly, builderTheme: builderTheme, isActive: idx === activeIndex, isSmallSize: browserSizeMode === BrowserSizeMode.Small, isDesignMode: isDesignMode, stretched: stretchPanel, triggerType: triggerType, verticalSpace: verticalSpace, transitionType: panelTransitionType, screenTransitionType: transitionType, onHeightChange: onSidePanelHeightChange, onInteractionChange: onInteractionChange, formatMessage: formatMessage }));\n                        }),\n                        jsx(ReactResizeDetector, { targetRef: sidePanelsRef, handleHeight: true, onResize: debounceResizeHandler }))),\n                !viewOnly && (jsx(ScreenContextMenu, { layoutId: layoutId, layoutItemId: layoutItemId, layoutItem: layoutItem, isFirst: isFirst, isLast: isLast, builderTheme: builderTheme, formatMessage: formatMessage })),\n                isDesignMode && (jsx(\"div\", { className: 'group-tip' },\n                    jsx(\"div\", { className: 'tip-content' }))),\n                isDesignMode && selected && jsx(Keyboard, { bindings: keyBindings }))));\n    }\n    return null;\n}\n","/** @jsx jsx */\nimport { React, jsx, css, classNames, BrowserSizeMode, ReactRedux, AppMode } from 'jimu-core';\nimport { Button } from 'jimu-ui';\nimport { TemplateSelector } from 'jimu-ui/advanced/setting-components';\nimport { appBuilderSync } from 'jimu-for-builder';\nimport { getBlockTemplates, getScrollingPageTemplates, getScreenGroupTemplates } from 'jimu-for-builder/templates';\nimport { BlockOutlined } from 'jimu-icons/outlined/brand/block';\nimport { ScreenGroupOutlined } from 'jimu-icons/outlined/brand/screen-group';\nimport { TemplateOutlined } from 'jimu-icons/outlined/application/template';\nimport { ThemedTooltip } from '../../builder/theme-tooltip';\nconst buttonStyle = css `\r\n  pointer-events: auto;\r\n`;\nfunction getStyle(builderTheme) {\n    return css `\r\n    body.lock-layout &,\r\n    body:not(.design-mode) & {\r\n      display: none !important;\r\n    }\r\n\r\n    display: flex;\r\n    height: 200px;\r\n    padding: 1rem;\r\n    pointer-events: none;\r\n    position: relative;\r\n    z-index: 1;\r\n    .btn-text {\r\n      line-height: 32px;\r\n    }\r\n    .btn {\r\n      margin-right: 2rem;\r\n      background: ${builderTheme.ref.palette.neutral[600]};\r\n      &:hover {\r\n        background: ${builderTheme.ref.palette.neutral[700]};\r\n      }\r\n    }\r\n    .action-item {\r\n      width: 32px;\r\n    }\r\n\r\n    .action-separator {\r\n      width: 300px;\r\n      height: 1px;\r\n      background-color: ${builderTheme.ref.palette.neutral[1100]};\r\n    }\r\n  `;\n}\nfunction sizemodeSupported(browserSizeMode) {\n    return browserSizeMode === BrowserSizeMode.Large;\n}\nexport function ActionBlock(props) {\n    const { pageContext, browserSizeMode, onPageTemplateSelected, onBlockTemplateSelected, onScreenTemplateSelected, blockOnly } = props;\n    const { builderTheme, formatMessage, isHeader, isFooter } = pageContext;\n    const [showTemplatePopper, setShowTemplatePopper] = React.useState(false);\n    const [showBlockPopper, setShowBlockPopper] = React.useState(false);\n    const [showScreenPopper, setShowScreenPopper] = React.useState(false);\n    const blockRef = React.useRef(null);\n    const screenRef = React.useRef(null);\n    const templateRef = React.useRef(null);\n    const show = ReactRedux.useSelector((state) => {\n        var _a, _b, _c;\n        const lockLayout = (_c = (_b = (_a = state.appConfig) === null || _a === void 0 ? void 0 : _a.forBuilderAttributes) === null || _b === void 0 ? void 0 : _b.lockLayout) !== null && _c !== void 0 ? _c : false;\n        const isDesignMode = state.appRuntimeInfo.appMode === AppMode.Design;\n        return isDesignMode && !lockLayout;\n    });\n    const isPageBody = !isHeader && !isFooter;\n    let templateTooltip;\n    if (isHeader) {\n        templateTooltip = formatMessage('chooseHeaderTemplate');\n    }\n    else if (isFooter) {\n        templateTooltip = formatMessage('chooseFooterTemplate');\n    }\n    else {\n        templateTooltip = formatMessage('chooseTemplate', {\n            type: pageContext.isDialog\n                ? formatMessage('dialog').toLocaleLowerCase()\n                : formatMessage('page').toLocaleLowerCase()\n        });\n    }\n    const toggleBlockPopper = (e) => {\n        e.stopPropagation();\n        if (browserSizeMode === BrowserSizeMode.Small) {\n            appBuilderSync.publishSidePanelToApp({ type: 'templateBlock', templateMethod: 'getBlockTemplates', onSelect: onBlockTemplateSelected });\n            return;\n        }\n        setShowBlockPopper(!showBlockPopper);\n    };\n    const toggleScreenPopper = (e) => {\n        e.stopPropagation();\n        setShowScreenPopper(!showScreenPopper);\n    };\n    const toggleTemplatePopper = (e) => {\n        e.stopPropagation();\n        if (browserSizeMode === BrowserSizeMode.Small) {\n            appBuilderSync.publishSidePanelToApp({ type: 'template', templateMethod: 'getScrollingPageTemplates', onSelect: onPageTemplateSelected });\n            return;\n        }\n        setShowTemplatePopper(!showTemplatePopper);\n    };\n    const closeBlockPopper = () => {\n        setShowBlockPopper(false);\n    };\n    const closeScreenPopper = () => {\n        setShowScreenPopper(false);\n    };\n    const closeTemplatePopover = () => {\n        setShowTemplatePopper(false);\n    };\n    const onBlockSelected = (template) => {\n        setShowBlockPopper(false);\n        onBlockTemplateSelected(template);\n    };\n    const onScreenSelected = (template) => {\n        setShowScreenPopper(false);\n        onScreenTemplateSelected(template);\n    };\n    const onTemplateSelected = (template) => {\n        setShowTemplatePopper(false);\n        onPageTemplateSelected(template);\n    };\n    if (!show) {\n        return null;\n    }\n    return (jsx(\"div\", { className: 'w-100 flex-column justify-content-center align-items-center', css: getStyle(builderTheme) },\n        jsx(\"div\", { className: 'd-flex' },\n            isPageBody && (jsx(React.Fragment, null,\n                jsx(ThemedTooltip, { placement: 'bottom', title: formatMessage('insertABlock') },\n                    jsx(\"div\", { className: 'action-item' },\n                        jsx(Button, { ref: blockRef, icon: true, onClick: toggleBlockPopper, css: buttonStyle, className: 'rounded-circle' },\n                            jsx(BlockOutlined, { size: 'm', color: builderTheme.ref.palette.neutral[1100] })))),\n                sizemodeSupported(browserSizeMode) && (jsx(ThemedTooltip, { placement: 'bottom', title: formatMessage('insertAScreenGroup') },\n                    jsx(\"div\", { className: 'action-item ml-5' },\n                        jsx(Button, { ref: screenRef, icon: true, onClick: toggleScreenPopper, css: buttonStyle, className: 'rounded-circle' },\n                            jsx(ScreenGroupOutlined, { size: 16, color: builderTheme.ref.palette.neutral[1100] }))))))),\n            !blockOnly && (jsx(ThemedTooltip, { placement: 'bottom', title: templateTooltip },\n                jsx(\"div\", { className: classNames('action-item', { 'ml-5': isPageBody }) },\n                    jsx(Button, { ref: templateRef, icon: true, onClick: toggleTemplatePopper, css: buttonStyle, className: 'rounded-circle' },\n                        jsx(TemplateOutlined, { autoFlip: true, size: 16, color: builderTheme.ref.palette.neutral[1100] })))))),\n        jsx(\"div\", { className: 'action-separator mt-4' }),\n        jsx(\"div\", null,\n            jsx(\"h5\", { className: 'btn-text mt-2' }, formatMessage('dropWidgetToAdd'))),\n        isPageBody && showBlockPopper && (jsx(TemplateSelector, { templates: getBlockTemplates(), referenceElement: blockRef.current, onItemSelect: onBlockSelected, onClose: closeBlockPopper })),\n        isPageBody && showScreenPopper && sizemodeSupported(browserSizeMode) && (jsx(TemplateSelector, { templates: getScreenGroupTemplates(), referenceElement: screenRef.current, onItemSelect: onScreenSelected, onClose: closeScreenPopper })),\n        !blockOnly && showTemplatePopper && (jsx(TemplateSelector, { templates: getScrollingPageTemplates(false), referenceElement: templateRef.current, onItemSelect: onTemplateSelected, onClose: closeTemplatePopover }))));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, classNames, polished, jsx, css, lodash, getAppStore, appActions, ExtensionManager, extensionSpec, LayoutItemType, OneByOneAnimation, IntersectionContext, LayoutType } from 'jimu-core';\nimport { LayoutServiceProvider, getAppConfigAction } from 'jimu-for-builder';\nimport { styleUtils, Loading, LoadingType } from 'jimu-ui';\nimport { calInsertPositionForColumn, DropIndicatorSize } from './dnd-helper';\nimport FlowLayoutItem from './layout-item';\nimport FloatingLayoutItem from './floating-layout-item';\nimport { ScreenGroup } from './screen-group';\nimport { PageContext, LayoutZIndex, CLICK_TOLERANCE, utils } from 'jimu-layouts/layout-runtime';\nimport { DropArea } from '../../builder/interactive/droparea-hook';\nimport { addItemToLayout, addBlockToFlowLayout } from '../../builder/common-layout-actions';\nimport { isResizing } from '../../builder/interactive/resize-event-handler';\nimport { isDragging } from '../../builder/interactive/drag-event-handler';\nimport { isDesignMode, isExpressMode } from '../../builder/menu/common-menu';\nimport { DEFAULT_FLOW_SETTING } from '../default-setting';\nimport { addTemplateRow, addTemplateScreenGroup, isFirstNonFloatingItem, isLastNonFloatingItem } from './utils';\nimport { ActionBlock } from './action-block';\nimport { CanvasPane } from '../../builder/interactive/canvas-pane';\nconst dropareaStyle = css `\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  top: 0;\r\n  right: 0;\r\n  background: transparent;\r\n`;\nconst guideOverlay = css `\r\n  ${dropareaStyle};\r\n  z-index: ${LayoutZIndex.DragMoveTip};\r\n  pointer-events: none;\r\n`;\nclass Layout extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.state = {\n            isDragover: false,\n            isLoadingTemplate: false\n        };\n        this.handleActivate = (e) => {\n            if (!isDesignMode() && !isExpressMode()) {\n                return;\n            }\n            if (Math.abs(e.screenX - this.mousedownX) > CLICK_TOLERANCE ||\n                Math.abs(e.screenY - this.mousedownY) > CLICK_TOLERANCE) {\n                e.stopPropagation();\n                return;\n            }\n            const { isInSection, isInWidget } = this.props;\n            if (!this.pageContext.viewOnly && !isInSection && !isInWidget && !isResizing() && !isDragging()) {\n                e.stopPropagation();\n                getAppStore().dispatch(appActions.selectionChanged(null));\n            }\n        };\n        this.handleMouseDown = (e) => {\n            this.mousedownX = e.screenX;\n            this.mousedownY = e.screenY;\n        };\n        this.handleDragOver = (draggingItem, draggingElement, containerRect, itemRect, clientX, clientY) => {\n            var _a, _b, _c;\n            const { layout } = this.props;\n            const layoutInfo = (_a = draggingItem.layoutInfo) !== null && _a !== void 0 ? _a : { layoutId: null };\n            let rect = itemRect;\n            this.canvasPane.clear();\n            if (((_b = this.childRects) === null || _b === void 0 ? void 0 : _b.length) > 0) {\n                const { insertY, refId } = calInsertPositionForColumn(containerRect, clientY, this.childRects, DropIndicatorSize);\n                this.referenceId = refId;\n                if (layoutInfo.layoutId === this.props.layout.id) {\n                    const content = layout.order;\n                    const draggingIndex = content.indexOf(layoutInfo.layoutItemId);\n                    const refIndex = content.indexOf(refId);\n                    if (((_c = layout.content[layoutInfo.layoutItemId].setting) === null || _c === void 0 ? void 0 : _c.isFloating) ||\n                        draggingIndex === refIndex - 1 ||\n                        (refId == null && draggingIndex === content.length - 1)) {\n                        return;\n                    }\n                }\n                rect = {\n                    top: insertY - DropIndicatorSize / 2 + this.ref.scrollTop,\n                    width: containerRect.width - DropIndicatorSize,\n                    left: DropIndicatorSize / 2,\n                    height: DropIndicatorSize\n                };\n            }\n            else {\n                this.referenceId = null;\n                rect = {\n                    top: containerRect.height / 2 - DropIndicatorSize / 2,\n                    width: containerRect.width - DropIndicatorSize,\n                    left: DropIndicatorSize / 2,\n                    height: DropIndicatorSize\n                };\n            }\n            this.canvasPane.setColor(polished.rgba(this.builderTheme.sys.color.primary.light, 0.5));\n            this.canvasPane.drawRect(rect);\n        };\n        this.handleToggleDragoverEffect = (value, draggingItem) => {\n            var _a;\n            if (value) {\n                this.referenceId = null;\n                this.collectBounds((_a = draggingItem.layoutInfo) !== null && _a !== void 0 ? _a : { layoutId: null });\n            }\n            this.canvasPane.clear();\n            this.setState({\n                isDragover: value\n            });\n        };\n        this.handleDrop = (draggingItem, containerRect, itemRect) => {\n            var _a, _b;\n            this.canvasPane.clear();\n            const { layout } = this.props;\n            const draggingLayoutInfo = (_a = draggingItem.layoutInfo) !== null && _a !== void 0 ? _a : { layoutId: null };\n            const appConfigAction = getAppConfigAction();\n            let insertIndex = 0;\n            if (this.referenceId != null) {\n                insertIndex = layout.order.indexOf(this.referenceId);\n            }\n            else if (layout.order != null) {\n                insertIndex = layout.order.length;\n            }\n            this.referenceId = null;\n            this.childRects = [];\n            // move in the same layout or add a new row widget\n            if (draggingLayoutInfo.layoutId === layout.id) {\n                if ((_b = layout.content[draggingLayoutInfo.layoutItemId].setting) === null || _b === void 0 ? void 0 : _b.isFloating) {\n                    const appConfigAction = getAppConfigAction();\n                    // pending item added back\n                    appConfigAction.setLayoutItemToPending(draggingLayoutInfo, false);\n                    utils.changeLayout(appConfigAction.appConfig, Object.assign(Object.assign({}, draggingLayoutInfo), { autoScroll: false }));\n                    return;\n                }\n                addItemToLayout(appConfigAction.appConfig, draggingItem, layout.id).then(result => {\n                    const { layoutInfo, updatedAppConfig } = result;\n                    const service = LayoutServiceProvider.getInstance().getServiceByType(LayoutType.FlowLayout);\n                    const outAppConfig = service.processAfterItemAdded(updatedAppConfig, draggingItem, layoutInfo, {\n                        currentSizeMode: null,\n                        containerRect,\n                        itemRect,\n                        insertIndex\n                    });\n                    utils.changeLayout(outAppConfig, Object.assign(Object.assign({}, layoutInfo), { autoScroll: true }));\n                }).finally(null);\n                return;\n            }\n            // Create a row widget, then add the dragging item\n            const totalCols = 12;\n            const rowWidth = this.maxPageWidth > 0 ? Math.min(this.maxPageWidth, containerRect.width) : containerRect.width;\n            const colWidth = rowWidth / totalCols;\n            const span = Math.min(Math.ceil(itemRect.width / colWidth), totalCols);\n            if (draggingItem.itemType === LayoutItemType.ScreenGroup) {\n                addItemToLayout(appConfigAction.appConfig, draggingItem, layout.id).then(result => {\n                    const { layoutInfo, updatedAppConfig } = result;\n                    const service = LayoutServiceProvider.getInstance().getServiceByType(LayoutType.FlowLayout);\n                    const outAppConfig = service.processAfterItemAdded(updatedAppConfig, draggingItem, layoutInfo, {\n                        currentSizeMode: null,\n                        containerRect,\n                        itemRect,\n                        insertIndex\n                    });\n                    utils.changeLayout(outAppConfig, Object.assign(Object.assign({}, layoutInfo), { autoScroll: true }));\n                }).finally(null);\n            }\n            else {\n                this.addWidgetToLayout(draggingItem, containerRect, itemRect, span, insertIndex);\n            }\n        };\n        this.handleDropAtBoundary = (draggingItem, itemRect, insertIndex) => {\n            if (insertIndex < this.props.layout.order.length) {\n                this.referenceId = this.props.layout.order[insertIndex];\n            }\n            else {\n                this.referenceId = null;\n            }\n            if (this.domRect == null) {\n                this.domRect = this.ref.getBoundingClientRect();\n            }\n            this.handleDrop(draggingItem, this.domRect, itemRect);\n        };\n        this.onWidgetItemSelected = (item) => {\n            var _a, _b, _c;\n            const rect = this.ref.getBoundingClientRect();\n            const itemRect = {\n                height: (_c = (_b = (_a = item.manifest) === null || _a === void 0 ? void 0 : _a.defaultSize) === null || _b === void 0 ? void 0 : _b.height) !== null && _c !== void 0 ? _c : 300\n            };\n            this.addWidgetToLayout(item, rect, itemRect, 4, 0);\n        };\n        this.handleBlockTemplateSelected = (template) => {\n            this.setState({ isLoadingTemplate: true });\n            addTemplateRow(this.props.layout.id, '', template).finally(() => {\n                this.setState({ isLoadingTemplate: false });\n            });\n        };\n        this.handleScreenTemplateSelected = (template) => {\n            this.setState({ isLoadingTemplate: true });\n            addTemplateScreenGroup(this.props.layout.id, '', template).finally(() => {\n                this.setState({ isLoadingTemplate: false });\n            });\n        };\n        this.handlePageTemplateSelected = (templatePageJson) => {\n            const appConfigAction = getAppConfigAction();\n            this.setState({ isLoadingTemplate: true });\n            if (this.pageContext.isHeader) {\n                appConfigAction.applyHeaderTemplate(templatePageJson).then(() => {\n                    appConfigAction.exec();\n                    lodash.defer(() => {\n                        this.setState({ isLoadingTemplate: false });\n                    });\n                }).finally(null);\n            }\n            else if (this.pageContext.isFooter) {\n                appConfigAction.applyFooterTemplate(templatePageJson).then(() => {\n                    appConfigAction.exec();\n                    lodash.defer(() => {\n                        this.setState({ isLoadingTemplate: false });\n                    });\n                }).finally(null);\n            }\n            else {\n                appConfigAction.applyPageBodyTemplate(this.pageContext.pageId, templatePageJson)\n                    .then(() => {\n                    appConfigAction.exec();\n                    lodash.defer(() => {\n                        this.setState({ isLoadingTemplate: false });\n                    });\n                }).finally(null);\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-template-expression\n        const exts = ExtensionManager.getInstance().getExtensions(`${extensionSpec.ExtensionPoints.LayoutTransformer}`);\n        if ((exts === null || exts === void 0 ? void 0 : exts.length) > 0) {\n            const ext = exts.find(item => item.layoutType === this.props.layout.type);\n            this.layoutTransform = ext === null || ext === void 0 ? void 0 : ext.transformLayout;\n        }\n    }\n    componentDidMount() {\n        this.canvasPane = new CanvasPane(this.canvasRef);\n        this.canvasPane.setSize(this.ref.clientWidth, this.ref.clientHeight);\n    }\n    componentDidUpdate() {\n        this.canvasPane.setSize(this.ref.clientWidth, this.ref.clientHeight);\n    }\n    addWidgetToLayout(draggingItem, containerRect, itemRect, width, insertIndex, appConfig) {\n        addBlockToFlowLayout(draggingItem, {\n            targetLayoutId: this.props.layout.id,\n            containerRect,\n            itemRect,\n            width,\n            insertIndex,\n            appConfig\n        }).finally(null);\n    }\n    collectBounds(layoutInfo) {\n        const { layout } = this.props;\n        this.childRects = [];\n        this.domRect = this.ref.getBoundingClientRect();\n        const draggableChildren = this.ref.parentNode.querySelectorAll(`div[data-layoutid=\"${layout.id}\"] > div.exb-rnd`);\n        if ((draggableChildren === null || draggableChildren === void 0 ? void 0 : draggableChildren.length) > 0) {\n            draggableChildren.forEach(node => {\n                var _a, _b;\n                const itemId = node.getAttribute('data-layoutitemid');\n                if ((layoutInfo.layoutId !== layout.id || layoutInfo.layoutItemId !== itemId) &&\n                    ((_a = layout.order) === null || _a === void 0 ? void 0 : _a.includes(itemId))) {\n                    // exclude pinned items\n                    const layoutItem = layout.content[itemId];\n                    if (!((_b = layoutItem.setting) === null || _b === void 0 ? void 0 : _b.isFloating)) {\n                        const rect = utils.relativeClientRect(node.getBoundingClientRect(), this.domRect);\n                        rect.id = itemId;\n                        this.childRects.push(rect);\n                    }\n                }\n            });\n        }\n        return this.childRects.sort((a, b) => a.top - b.top);\n    }\n    createItem(item, total, index, layoutSetting) {\n        if (item === null || item === void 0 ? void 0 : item.isPending) {\n            return null;\n        }\n        const { layouts, layout, itemDraggable, itemSelectable } = this.props;\n        const isFirst = isFirstNonFloatingItem({ layoutId: layout.id, layoutItemId: item.id });\n        const isLast = isLastNonFloatingItem({ layoutId: layout.id, layoutItemId: item.id });\n        const itemSetting = item.setting;\n        if (item.type === LayoutItemType.ScreenGroup) {\n            return (jsx(ScreenGroup, { key: `${layout.id}_${item.id}`, itemIndex: index, isFirst: isFirst, isLast: isLast, layoutId: layout.id, layoutItemId: item.id, layoutItem: item, theme: this.pageContext.builderTheme, formatMessage: this.pageContext.formatMessage }));\n        }\n        if (itemSetting === null || itemSetting === void 0 ? void 0 : itemSetting.isFloating) {\n            return (jsx(FloatingLayoutItem, { key: `${layout.id}_${item.id}`, index: index, total: total, builderTheme: this.builderTheme, layouts: layouts, layoutId: layout.id, layoutItemId: item.id, layoutItem: item, gutter: layoutSetting.gutter, draggable: itemDraggable, selectable: itemSelectable, onDropAtBoundary: this.handleDropAtBoundary, formatMessage: this.pageContext.formatMessage }));\n        }\n        return (jsx(FlowLayoutItem, { key: `${layout.id}_${item.id}`, index: index, isFirst: isFirst, isLast: isLast, builderTheme: this.builderTheme, layouts: layouts, layoutId: layout.id, layoutItemId: item.id, layoutItem: item, gutter: layoutSetting.gutter, draggable: itemDraggable, selectable: itemSelectable, onDropAtBoundary: this.handleDropAtBoundary, formatMessage: this.pageContext.formatMessage }));\n    }\n    getActionStyle() {\n        return css `\r\n      height: 200px;\r\n      padding: 1rem;\r\n      pointer-events: none;\r\n      z-index: 1;\r\n      .btn-text {\r\n        line-height: 32px;\r\n      }\r\n      .btn {\r\n        margin-right: 2rem;\r\n        background: ${this.builderTheme.ref.palette.neutral[600]};\r\n        &:hover {\r\n          background: ${this.builderTheme.ref.palette.neutral[700]};\r\n        }\r\n      }\r\n      .action-item {\r\n        width: 32px;\r\n      }\r\n\r\n      .action-separator {\r\n        .sep {\r\n          width: 65px;\r\n          height: 1px;\r\n          background-color: ${this.builderTheme.ref.palette.neutral[1100]};\r\n        }\r\n        .btn-text {\r\n          margin: 0 13px;\r\n        }\r\n      }\r\n    `;\n    }\n    getStyle() {\n        const { builderTheme } = this.pageContext;\n        return css `\r\n      & > .trail-container > .builder-layout-item {\r\n        margin-bottom: 10px;\r\n        border-top: 1px dashed ${polished.rgba(builderTheme.ref.palette.neutral[1000], 0.6)};\r\n        border-bottom: 1px dashed ${polished.rgba(builderTheme.ref.palette.neutral[1000], 0.6)};\r\n        z-index: 0;\r\n\r\n        .widget-context-menu {\r\n          width: 100%;\r\n          height: auto;\r\n          top: 0;\r\n        }\r\n\r\n        &.selected, &.floating {\r\n          z-index: 1;\r\n        }\r\n      }\r\n\r\n      body:not(.design-mode) & {\r\n        & > .trail-container > .builder-layout-item {\r\n          margin-bottom: 0;\r\n          border-top: none;\r\n          border-bottom: none;\r\n        }\r\n      }\r\n    `;\n    }\n    createActions(blockOnly) {\n        const { viewOnly, rootLayoutId } = this.pageContext;\n        const { layout } = this.props;\n        const isPageBody = !this.pageContext.isHeader && !this.pageContext.isFooter;\n        if (this.state.isLoadingTemplate ||\n            !isPageBody ||\n            viewOnly ||\n            layout.id !== rootLayoutId) {\n            return null;\n        }\n        return (jsx(ActionBlock, { pageContext: this.pageContext, browserSizeMode: this.props.browserSizeMode, blockOnly: blockOnly, onPageTemplateSelected: this.handlePageTemplateSelected, onBlockTemplateSelected: this.handleBlockTemplateSelected, onScreenTemplateSelected: this.handleScreenTemplateSelected }));\n    }\n    render() {\n        const { layout, className, isPageItem, layouts, mainSizeMode, browserSizeMode } = this.props;\n        if (layout == null) {\n            return null;\n        }\n        const outClass = classNames('layout flow-layout w-100', className);\n        const guideVisibleStyle = {\n            display: this.state.isDragover ? 'block' : 'none'\n        };\n        return (jsx(PageContext.Consumer, null, (props) => {\n            var _a;\n            this.builderTheme = props.builderTheme;\n            this.maxPageWidth = props.maxWidth;\n            this.pageContext = props;\n            let targetLayout = layout;\n            const viewOnly = layouts[browserSizeMode] !== layout.id;\n            if (viewOnly && this.layoutTransform != null) {\n                targetLayout = this.layoutTransform(layout, mainSizeMode, browserSizeMode);\n            }\n            const content = (_a = targetLayout.order) !== null && _a !== void 0 ? _a : [];\n            const layoutSetting = lodash.assign({}, DEFAULT_FLOW_SETTING, targetLayout.setting);\n            const mergedStyle = Object.assign({ position: 'relative' }, styleUtils.toCSSStyle(layoutSetting.style));\n            return (jsx(\"div\", { className: outClass, ref: el => { this.ref = el; }, css: this.getStyle(), style: mergedStyle, \"data-layoutid\": layout.id, onClick: this.handleActivate, onMouseDown: this.handleMouseDown },\n                jsx(IntersectionContext.Provider, { value: { monitor: true } },\n                    jsx(OneByOneAnimation, { oid: targetLayout.id, \"data-layoutid\": targetLayout.id, className: 'trail-container d-flex flex-column align-items-center', css: css `\r\n                    width: 100%;\r\n                  ` },\n                        !props.viewOnly && (jsx(DropArea, { css: dropareaStyle, layouts: this.props.layouts, isRepeat: this.props.isRepeat, highlightDragover: !isPageItem, onDragOver: this.handleDragOver, onDrop: this.handleDrop, onToggleDragoverEffect: this.handleToggleDragoverEffect })),\n                        content.length > 0 &&\n                            content.map((layoutItemId, index) => {\n                                return this.createItem(targetLayout.content[layoutItemId], content.length, index, layoutSetting);\n                            }))),\n                !this.state.isLoadingTemplate &&\n                    !props.viewOnly &&\n                    utils.isEmptyLayout(targetLayout) &&\n                    layout.id === props.rootLayoutId &&\n                    this.createActions(false),\n                content.length > 0 && this.createActions(true),\n                this.state.isLoadingTemplate && jsx(Loading, { type: LoadingType.Primary }),\n                jsx(\"canvas\", { css: guideOverlay, style: guideVisibleStyle, ref: el => { this.canvasRef = el; } })));\n        }));\n    }\n}\nexport default ReactRedux.connect(utils.mapStateToLayoutProps)(Layout);\n","import { getAppStore, css, appActions, PagePart } from 'jimu-core';\nimport { searchUtils } from 'jimu-layouts/layout-runtime';\nexport const RESIZE_HANDLER_HEIGHT = 16;\nexport const resizeHandlerStyle = css `\r\n  .resize-handler {\r\n    height: ${RESIZE_HANDLER_HEIGHT}px;\r\n    width: 100%;\r\n    cursor: ns-resize;\r\n    position: absolute;\r\n  }\r\n`;\nexport const maskStyle = css `\r\n  position: absolute;\r\n  right: 0;\r\n  top: 0;\r\n  left: 0;\r\n  bottom: 0;\r\n`;\nexport function editBtnStyle(theme) {\n    return css `\r\n    .edit-btn {\r\n      background: ${theme.sys.color.primary.main};\r\n      color: ${theme.ref.palette.neutral[1100]};\r\n      border-radius: 2px;\r\n      &:hover {\r\n        background: ${theme.sys.color.primary.main};\r\n        color: ${theme.ref.palette.black};\r\n      }\r\n    }\r\n  `;\n}\nexport function editHeader() {\n    getAppStore().dispatch(appActions.activePagePartChanged(PagePart.Header));\n}\nexport function editFooter() {\n    getAppStore().dispatch(appActions.activePagePartChanged(PagePart.Footer));\n}\nexport function editBody() {\n    getAppStore().dispatch(appActions.activePagePartChanged(PagePart.Body));\n}\nexport function getHeaderLayoutId() {\n    const state = getAppStore().getState();\n    const sizeModeLayout = state.appConfig.header.layout;\n    return searchUtils.findLayoutId(sizeModeLayout, state.browserSizeMode, state.appConfig.mainSizeMode);\n}\nexport function getFooterLayoutId() {\n    const state = getAppStore().getState();\n    const sizeModeLayout = state.appConfig.footer.layout;\n    return searchUtils.findLayoutId(sizeModeLayout, state.browserSizeMode, state.appConfig.mainSizeMode);\n}\nexport function getPageLayoutId(pageId) {\n    var _a;\n    const state = getAppStore().getState();\n    const sizeModeLayout = (_a = state.appConfig.pages[pageId]) === null || _a === void 0 ? void 0 : _a.layout;\n    if (sizeModeLayout) {\n        return searchUtils.findLayoutId(sizeModeLayout, state.browserSizeMode, state.appConfig.mainSizeMode);\n    }\n    return null;\n}\nexport function getDialogLayoutId(dialogId) {\n    var _a;\n    const state = getAppStore().getState();\n    const sizeModeLayout = (_a = state.appConfig.dialogs[dialogId]) === null || _a === void 0 ? void 0 : _a.layout;\n    return searchUtils.findLayoutId(sizeModeLayout, state.browserSizeMode, state.appConfig.mainSizeMode);\n}\nexport function getVisiblePageId(pageStatus) {\n    return Object.keys(pageStatus).find(pid => pageStatus[pid]);\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, AppMode, jsx, css, PagePart, polished, ReactResizeDetector, classNames } from 'jimu-core';\nimport { interact } from 'jimu-core/dnd';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { EditOutlined } from 'jimu-icons/outlined/editor/edit';\nimport { PageContext, utils } from 'jimu-layouts/layout-runtime';\nimport { Button } from 'jimu-ui';\nimport LayoutEntry from './layout-entry';\nimport { RESIZE_HANDLER_HEIGHT, resizeHandlerStyle, maskStyle, editBtnStyle, editBody, editHeader, getHeaderLayoutId } from './page-renderer-common';\nimport { DEFAULT_HEADER_HEIGHT } from '../common/page-util';\nfunction getStyle(header, height, builderTheme, theme) {\n    var _a, _b;\n    return css `\r\n    ${resizeHandlerStyle};\r\n    ${editBtnStyle(builderTheme)};\r\n    position: relative;\r\n    z-index: 0;\r\n    top: 0;\r\n    display: flex;\r\n    width: 100%;\r\n    height: auto;\r\n    min-height: ${parseFloat(height)}px;\r\n    overflow: hidden;\r\n    background-color: ${header.backgroundColor || ((_a = theme.comp) === null || _a === void 0 ? void 0 : _a.Header.root.vars.bg) || 'transparent'};\r\n    background-image: ${header.backgroundIMage};\r\n    background-position: ${header.backgroundPosition};\r\n    color: ${(_b = theme.comp) === null || _b === void 0 ? void 0 : _b.Header.root.vars.color};\r\n    border-bottom: 1px dashed ${polished.rgba(builderTheme.ref.palette.white, 0.12)};\r\n    flex: 0 0 auto;\r\n\r\n    &:hover {\r\n      .edit-mask {\r\n        display: flex;\r\n      }\r\n    }\r\n\r\n    .resize-handler {\r\n      bottom: ${-RESIZE_HANDLER_HEIGHT / 2}px;\r\n      z-index: 1;\r\n      .handler {\r\n        width: 36px;\r\n        height: 4px;\r\n        background: var(--ref-palette-black);\r\n        border: 1px solid var(--ref-palette-white);\r\n        position: absolute;\r\n        left: 50%;\r\n        bottom: 9px;\r\n        transform: translateX(-50%);\r\n      }\r\n    }\r\n\r\n    body.lock-layout &,\r\n    body:not(.design-mode) & {\r\n      border-bottom: none;\r\n      > .resize-handler {\r\n        display: none !important;\r\n      }\r\n    }\r\n    body:not(.design-mode) & {\r\n      position: ${header.sticky ? 'sticky' : 'relative'};\r\n      z-index: ${header.sticky ? 2 : '0'};\r\n\r\n      .edit-mask, .edit-mask-all {\r\n        display: none !important;\r\n      }\r\n    }\r\n  `;\n}\nfunction bindResizeHandler(headerRef) {\n    let dh;\n    let initHeight;\n    return interact(headerRef)\n        .origin('parent')\n        .resizable({\n        inertia: false,\n        edges: {\n            bottom: '.resize-handler'\n        },\n        onstart: (event) => {\n            event.stopPropagation();\n            dh = 0;\n            initHeight = headerRef.getBoundingClientRect().height;\n            headerRef.style.minHeight = '0px';\n        },\n        onmove: (event) => {\n            event.stopPropagation();\n            const deltaRect = event.deltaRect;\n            dh += deltaRect.height;\n            headerRef.style.height = `${initHeight + dh}px`;\n        },\n        onend: (event) => {\n            event.stopPropagation();\n            headerRef.style.height = null;\n            headerRef.style.minHeight = null;\n            getAppConfigAction()\n                .editHeaderProperty(`height.${utils.getCurrentSizeMode()}`, Math.round(initHeight + dh))\n                .exec();\n        }\n    });\n}\nexport function PageHeader(props) {\n    const { header, browserSizeMode, mainSizeMode, activePagePart, pageContext, onHeightChange } = props;\n    const isDesignMode = ReactRedux.useSelector((state) => { var _a; return ((_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.appMode) === AppMode.Design; });\n    const headerRef = React.useRef(null);\n    const height = header.height[browserSizeMode] || header.height[mainSizeMode] || DEFAULT_HEADER_HEIGHT;\n    const layout = header.layout;\n    const viewOnly = !layout[browserSizeMode];\n    const builderTheme = pageContext.builderTheme;\n    React.useEffect(() => {\n        let interactble;\n        if (headerRef.current) {\n            interactble = bindResizeHandler(headerRef.current);\n        }\n        return () => {\n            if (interactble) {\n                interactble.unset();\n            }\n        };\n    }, []);\n    const headerLayoutId = getHeaderLayoutId();\n    const pageContextValue = React.useMemo(() => {\n        return Object.assign(Object.assign({}, pageContext), { isHeader: true, rootLayoutId: headerLayoutId, viewOnly: viewOnly || (isDesignMode && activePagePart !== PagePart.Header) });\n    }, [pageContext, headerLayoutId, viewOnly, activePagePart, isDesignMode]);\n    const handleSizeChange = React.useCallback(({ width, height }) => {\n        onHeightChange(Math.round(height));\n    }, [onHeightChange]);\n    return (jsx(PageContext.Provider, { value: pageContextValue },\n        jsx(\"div\", { className: 'header', css: getStyle(header, height, pageContext.builderTheme, pageContext.theme), ref: el => { headerRef.current = el; } },\n            jsx(\"div\", { className: 'w-100 h-100', css: css `\r\n            overflow: auto;\r\n            display: flex;\r\n            position: relative;\r\n            z-index: 0;\r\n            min-height: ${parseFloat(height)}px;\r\n          ` },\n                jsx(LayoutEntry, { layouts: layout, isPageItem: true, visible: true })),\n            !viewOnly && (jsx(\"span\", { className: 'resize-handler' },\n                jsx(\"div\", { className: classNames('handler', { 'd-none': activePagePart !== PagePart.Header }) }))),\n            activePagePart !== PagePart.Header && !viewOnly && (jsx(\"div\", { className: 'edit-mask-all', css: css `\r\n              ${maskStyle};\r\n              background: ${activePagePart === PagePart.Body ? 'transparent' : polished.rgba(builderTheme.ref.palette.neutral[500], 0.6)};\r\n              z-index: 1;\r\n            `, onClick: editBody })),\n            activePagePart === PagePart.Body && (!viewOnly || browserSizeMode === mainSizeMode) && (jsx(\"div\", { className: 'edit-mask justify-content-center align-items-center', css: css `\r\n              ${maskStyle};\r\n              background: ${polished.rgba(builderTheme.ref.palette.neutral[500], 0.6)};\r\n              z-index: 1;\r\n              display: none;\r\n            ` },\n                jsx(Button, { className: 'edit-btn btn-large border-0', onClick: editHeader },\n                    jsx(EditOutlined, { size: 'm' }),\n                    pageContext.formatMessage('editHeader')))),\n            jsx(ReactResizeDetector, { targetRef: headerRef, handleHeight: true, handleWidth: false, onResize: handleSizeChange }))));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, AppMode, jsx, css, PagePart, polished, ReactResizeDetector, classNames } from 'jimu-core';\nimport { interact } from 'jimu-core/dnd';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { EditOutlined } from 'jimu-icons/outlined/editor/edit';\nimport { PageContext, utils } from 'jimu-layouts/layout-runtime';\nimport { Button } from 'jimu-ui';\nimport LayoutEntry from './layout-entry';\nimport { RESIZE_HANDLER_HEIGHT, resizeHandlerStyle, maskStyle, editBtnStyle, editBody, editFooter, getFooterLayoutId } from './page-renderer-common';\nimport { DEFAULT_FOOTER_HEIGHT } from '../common/page-util';\nfunction getStyle(footer, height, builderTheme, theme) {\n    var _a, _b;\n    return css `\r\n    ${resizeHandlerStyle};\r\n    ${editBtnStyle(builderTheme)};\r\n    display: flex;\r\n    position: relative;\r\n    width: 100%;\r\n    height: auto;\r\n    min-height: ${parseFloat(height)}px;\r\n    overflow: hidden;\r\n    background-color: ${footer.backgroundColor || ((_a = theme.comp) === null || _a === void 0 ? void 0 : _a.Footer.root.vars.bg) || 'transparent'};\r\n    background-image: ${footer.backgroundIMage};\r\n    background-position: ${footer.backgroundPosition};\r\n    color: ${(_b = theme.comp) === null || _b === void 0 ? void 0 : _b.Footer.root.vars.color};\r\n    border-top: 1px dashed ${polished.rgba(builderTheme.ref.palette.white, 0.12)};\r\n    z-index: 0;\r\n\r\n    .resize-handler {\r\n      top: ${-RESIZE_HANDLER_HEIGHT / 2}px;\r\n      z-index: 1;\r\n      .handler {\r\n        width: 36px;\r\n        height: 4px;\r\n        background: var(--ref-palette-black);\r\n        border: 1px solid var(--ref-palette-white);\r\n        position: absolute;\r\n        left: 50%;\r\n        top: 9px;\r\n        transform: translateX(-50%);\r\n      }\r\n    }\r\n\r\n    &:hover {\r\n      .edit-mask {\r\n        display: flex;\r\n      }\r\n    }\r\n\r\n    body.lock-layout &,\r\n    body:not(.design-mode) & {\r\n      > .resize-handler {\r\n        display: none !important;\r\n      }\r\n    }\r\n    body:not(.design-mode) & {\r\n      .edit-mask, .edit-mask-all {\r\n        display: none !important;\r\n      }\r\n    }\r\n  `;\n}\nfunction bindResizeHandler(footerRef) {\n    let dh = 0;\n    let initHeight = 0;\n    let initDeviceHeight = 0;\n    const deviceFrame = window.parent.document.querySelector('.device-frame');\n    return interact(footerRef)\n        .origin('parent')\n        .resizable({\n        inertia: false,\n        edges: {\n            top: '.resize-handler'\n        },\n        onstart: (event) => {\n            event.stopPropagation();\n            dh = 0;\n            initHeight = footerRef.getBoundingClientRect().height;\n            initDeviceHeight = (deviceFrame === null || deviceFrame === void 0 ? void 0 : deviceFrame.getBoundingClientRect().height) || 0;\n        },\n        onmove: (event) => {\n            event.stopPropagation();\n            const deltaRect = event.deltaRect;\n            dh += deltaRect.height;\n            footerRef.style.height = `${initHeight + dh}px`;\n            if (deviceFrame) {\n                deviceFrame.style.height = `${initDeviceHeight + dh}px`;\n            }\n        },\n        onend: (event) => {\n            event.stopPropagation();\n            footerRef.style.height = null;\n            if (deviceFrame) {\n                deviceFrame.style.height = `${initDeviceHeight}px`;\n            }\n            getAppConfigAction()\n                .editFooterProperty(`height.${utils.getCurrentSizeMode()}`, Math.round(initHeight + dh))\n                .exec();\n        }\n    });\n}\nexport function PageFooter(props) {\n    const { footer, browserSizeMode, mainSizeMode, activePagePart, pageContext, onHeightChange } = props;\n    const isDesignMode = ReactRedux.useSelector((state) => { var _a; return ((_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.appMode) === AppMode.Design; });\n    const footerRef = React.useRef(null);\n    const height = footer.height[browserSizeMode] || footer.height[mainSizeMode] || DEFAULT_FOOTER_HEIGHT;\n    const layout = footer.layout;\n    const viewOnly = !layout[browserSizeMode];\n    const builderTheme = pageContext.builderTheme;\n    React.useEffect(() => {\n        let interactble;\n        if (footerRef.current) {\n            interactble = bindResizeHandler(footerRef.current);\n        }\n        return () => {\n            if (interactble) {\n                interactble.unset();\n            }\n        };\n    }, []);\n    const footerLayoutId = getFooterLayoutId();\n    const pageContextValue = React.useMemo(() => {\n        return Object.assign(Object.assign({}, pageContext), { isFooter: true, rootLayoutId: footerLayoutId, viewOnly: viewOnly || (isDesignMode && activePagePart !== PagePart.Footer) });\n    }, [pageContext, footerLayoutId, viewOnly, activePagePart, isDesignMode]);\n    const handleSizeChange = React.useCallback(({ width, height }) => {\n        onHeightChange(Math.round(height));\n    }, [onHeightChange]);\n    return (jsx(PageContext.Provider, { value: pageContextValue },\n        jsx(\"div\", { className: 'footer', css: getStyle(footer, height, pageContext.builderTheme, pageContext.theme), ref: el => { footerRef.current = el; } },\n            !viewOnly && (jsx(\"span\", { className: 'resize-handler' },\n                jsx(\"div\", { className: classNames('handler', { 'd-none': activePagePart !== PagePart.Footer }) }))),\n            jsx(\"div\", { className: 'w-100 h-100', css: css `\r\n            overflow: auto;\r\n            display: flex;\r\n            position: relative;\r\n            z-index: 0;\r\n            min-height: ${parseFloat(height)}px;\r\n          ` },\n                jsx(LayoutEntry, { layouts: layout, isPageItem: true, visible: true })),\n            activePagePart !== PagePart.Footer && !viewOnly && (jsx(\"div\", { className: 'edit-mask-all', css: css `\r\n              ${maskStyle};\r\n              background: ${activePagePart === PagePart.Body ? 'transparent' : polished.rgba(builderTheme.ref.palette.neutral[500], 0.6)};\r\n              z-index: 1;\r\n            `, onClick: editBody })),\n            activePagePart === PagePart.Body && (!viewOnly || browserSizeMode === mainSizeMode) && (jsx(\"div\", { className: 'edit-mask justify-content-center align-items-center', css: css `\r\n              ${maskStyle};\r\n              background: ${polished.rgba(builderTheme.ref.palette.neutral[500], 0.6)};\r\n              z-index: 1;\r\n              display: none;\r\n            ` },\n                jsx(Button, { className: 'edit-btn btn-large border-0', onClick: editFooter },\n                    jsx(EditOutlined, { size: 'm' }),\n                    pageContext.formatMessage('editFooter')))),\n            jsx(ReactResizeDetector, { targetRef: footerRef, handleHeight: true, handleWidth: false, onResize: handleSizeChange }))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, WidgetManager, ErrorBoundary, ReactRedux, AppMode, WidgetState, classNames, WidgetType, hooks, getAppStore, appActions, spring, getAnimationEffect, AnimationType, DEFAULT_ANIMATION_PROPS, lodash, utils, focusElementInKeyboardMode } from 'jimu-core';\nimport { Loading, LoadingType, PanelHeader, useTrapFocusBySelector } from 'jimu-ui';\nimport { PageContext } from 'jimu-layouts/layout-runtime';\nimport { LayoutItemToolbar } from '../../builder/layout-item-toolbar';\nimport { getTheme2 } from 'jimu-theme';\nimport { useHandleLastVirtualNodeFocus } from '../util';\nimport upDoubleOutlined from 'jimu-icons/svg/outlined/directional/up-double.svg';\nimport closeOutlined from 'jimu-icons/svg/outlined/editor/close.svg';\nconst { animated, useSpring } = spring;\nconst style = css `\r\n  position: relative;\r\n  display: flex;\r\n  background-color: var(--ref-palette-white);\r\n  box-shadow: 0px 0px 10px 1px rgba(0, 0, 0, 0.2);\r\n  .panel-header {\r\n    > .actions > .action-collapse {\r\n      svg {\r\n        transition: transform 0.3s ease-in-out;\r\n      }\r\n      &.collapsed svg {\r\n        transform: rotate(180deg);\r\n      }\r\n    }\r\n  }\r\n  .panel-content {\r\n    position: relative;\r\n    overflow: hidden;\r\n\r\n    .widget-content {\r\n      z-index: 0;\r\n    }\r\n\r\n    .widget-mask {\r\n      position: absolute;\r\n      background: transparent;\r\n      left: 0;\r\n      right: 0;\r\n      top: 0;\r\n      bottom: 0;\r\n      z-index: 1;\r\n    }\r\n  }\r\n`;\nconst shiftOptions = {\n    rootBoundary: 'viewport',\n    crossAxis: true\n};\nconst flipOptions = {\n    fallbackPlacements: ['top-start', 'bottom-start', 'right-start', 'left-start']\n};\nexport function Panel(props) {\n    const { layoutId, layoutItemId, controllerId, minimized, onClick, onToggle, onClose } = props;\n    const [mounted, setMounted] = React.useState(false);\n    const ref = React.useRef();\n    const onCloseRef = hooks.useLatest(onClose);\n    const onToggleRef = hooks.useLatest(onToggle);\n    const translate = hooks.useTranslation();\n    const isDesignMode = ReactRedux.useSelector((state) => {\n        return state.appRuntimeInfo.appMode === AppMode.Design;\n    });\n    const selected = ReactRedux.useSelector((state) => {\n        var _a;\n        const selection = state.appRuntimeInfo.selection;\n        if (!selection) { // ignore this in live view mode\n            return false;\n        }\n        if (layoutId === selection.layoutId && layoutItemId === selection.layoutItemId) {\n            return true;\n        }\n        const nested = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.querySelector(`div.builder-layout-item[data-layoutid=\"${selection.layoutId}\"][data-layoutitemid=\"${selection.layoutItemId}\"]`);\n        return nested != null;\n    });\n    const widgetId = ReactRedux.useSelector((state) => {\n        const layoutItem = state.appConfig.layouts[layoutId].content[layoutItemId];\n        return layoutItem.widgetId;\n    });\n    const hasEmbeddedLayout = ReactRedux.useSelector((state) => {\n        var _a, _b, _c;\n        const widgetJson = state.appConfig.widgets[widgetId];\n        return ((_b = (_a = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.manifest) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.hasEmbeddedLayout) && Object.keys((_c = widgetJson.layouts) !== null && _c !== void 0 ? _c : {}).length > 0;\n    });\n    const isFunctionalWidget = ReactRedux.useSelector((state) => {\n        var _a;\n        const widgetJson = state.appConfig.widgets[widgetId];\n        return ((_a = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.manifest) === null || _a === void 0 ? void 0 : _a.widgetType) !== WidgetType.Layout;\n    });\n    const supportInlineEditing = ReactRedux.useSelector((state) => {\n        var _a, _b, _c;\n        const widgetJson = state.appConfig.widgets[widgetId];\n        return (_c = (_b = (_a = widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.manifest) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.supportInlineEditing) !== null && _c !== void 0 ? _c : false;\n    });\n    const isInlineEditing = ReactRedux.useSelector((state) => {\n        const widgetRuntimeInfo = state.widgetsRuntimeInfo[widgetId];\n        return supportInlineEditing && (widgetRuntimeInfo === null || widgetRuntimeInfo === void 0 ? void 0 : widgetRuntimeInfo.isInlineEditing);\n    });\n    const isOpen = ReactRedux.useSelector((state) => {\n        var _a;\n        const info = (_a = state.widgetsRuntimeInfo) === null || _a === void 0 ? void 0 : _a[widgetId];\n        return (info === null || info === void 0 ? void 0 : info.state) === WidgetState.Opened;\n    });\n    const label = ReactRedux.useSelector((state) => {\n        const widgetJson = state.appConfig.widgets[widgetId];\n        return widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.label;\n    }, ReactRedux.shallowEqual);\n    const widgetClassLoaded = ReactRedux.useSelector((state) => {\n        var _a;\n        const widgetRuntimeInfo = state.widgetsRuntimeInfo[widgetId];\n        return (_a = widgetRuntimeInfo === null || widgetRuntimeInfo === void 0 ? void 0 : widgetRuntimeInfo.isClassLoaded) !== null && _a !== void 0 ? _a : false;\n    });\n    const effect = ReactRedux.useSelector((state) => {\n        const panelJson = state.appConfig.controllerPanels[controllerId];\n        return panelJson.effect;\n    });\n    const animationObj = React.useMemo(() => {\n        var _a, _b;\n        if ((effect === null || effect === void 0 ? void 0 : effect.type) && effect.type !== AnimationType.None) {\n            return getAnimationEffect(effect.type, {\n                configType: (_a = effect.option) === null || _a === void 0 ? void 0 : _a.configType,\n                direction: (_b = effect.option) === null || _b === void 0 ? void 0 : _b.direction\n            });\n        }\n        return null;\n    }, [effect]);\n    const [effectProps, api] = useSpring(() => {\n        return DEFAULT_ANIMATION_PROPS;\n    }, [animationObj]);\n    const handleClose = React.useCallback((e) => {\n        onCloseRef.current(e, widgetId);\n        // after panel closed, focus back to button\n        const button = document.querySelector(`.widget-controller .avatar-card[data-widgetid='${widgetId}'] button`);\n        if (button) {\n            focusElementInKeyboardMode(button);\n        }\n        else {\n            const moreButton = document.querySelector(`[data-widgetid='${controllerId}'] .popup-more-button button`);\n            focusElementInKeyboardMode(moreButton);\n        }\n    }, [onCloseRef, widgetId, controllerId]);\n    useTrapFocusBySelector(ref, true, true, '.first-node', '.last-virtual-node', mounted && isOpen);\n    const { viewOnly } = React.useContext(PageContext);\n    const isExpressMode = ReactRedux.useSelector((state) => state.appRuntimeInfo.appMode === AppMode.Express);\n    const notMainSizeMode = ReactRedux.useSelector((state) => state.browserSizeMode !== state.appConfig.mainSizeMode);\n    const handleClick = React.useCallback((e) => {\n        var _a;\n        e.stopPropagation();\n        if (viewOnly || (isExpressMode && notMainSizeMode))\n            return;\n        const selection = (_a = getAppStore().getState().appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.selection;\n        if (!selection || selection.layoutId !== layoutId || selection.layoutItemId !== layoutItemId) {\n            getAppStore().dispatch(appActions.selectionChanged({ layoutId, layoutItemId }));\n        }\n        onClick === null || onClick === void 0 ? void 0 : onClick(e);\n    }, [isExpressMode, layoutId, layoutItemId, notMainSizeMode, onClick, viewOnly]);\n    /**\n     * Enable inline editing mode for the widget\n     *\n     * @memberof LayoutItemInBuilder\n     */\n    const handleDoubleClick = React.useCallback((e) => {\n        e.stopPropagation();\n        const { browserSizeMode, appConfig: { mainSizeMode } } = getAppStore().getState();\n        if (supportInlineEditing && !viewOnly && !(utils.isExpressMode() && browserSizeMode !== mainSizeMode)) {\n            getAppStore().dispatch(appActions.setWidgetIsInlineEditingState(widgetId, true));\n        }\n    }, [supportInlineEditing, viewOnly, widgetId]);\n    React.useEffect(() => {\n        if (isOpen && !mounted) { // load the class when this widget is opened the first time\n            setMounted(true);\n            WidgetManager.getInstance()\n                .loadWidgetClass(widgetId)\n                .catch((err) => {\n                console.log(err);\n            });\n        }\n        if (isOpen && !selected && isDesignMode) {\n            getAppStore().dispatch(appActions.closeWidget(widgetId));\n        }\n    }, [isOpen, selected, widgetId, mounted, isDesignMode]);\n    React.useEffect(() => {\n        if (isOpen && !isDesignMode && animationObj != null) {\n            api.start(Object.assign(Object.assign({}, animationObj.animateProps()), { onRest: () => {\n                    lodash.defer(() => {\n                        ref.current.style.clipPath = null; // eliminate clipPath to show box-shadow\n                        ref.current.parentElement.style.clipPath = null;\n                    });\n                } }));\n        }\n    }, [api, isOpen, isDesignMode, animationObj]);\n    let WidgetClass;\n    if (mounted && widgetClassLoaded) {\n        WidgetClass = WidgetManager.getInstance().getWidgetClass(widgetId);\n    }\n    const showMask = isDesignMode && !isInlineEditing && isFunctionalWidget && !hasEmbeddedLayout;\n    const theme = getTheme2();\n    const appConfig = getAppStore().getState().appConfig;\n    const layoutItem = appConfig.layouts[layoutId].content[layoutItemId];\n    const handleLastVirtualNodeFocus = useHandleLastVirtualNodeFocus(ref.current, 'first-node', 'last-virtual-node');\n    const actions = React.useMemo(() => {\n        return [{\n                name: 'collapse',\n                className: minimized ? 'first-node action-collapse collapsed' : 'first-node action-collapse',\n                label: translate(minimized ? 'expand' : 'collapse'),\n                icon: upDoubleOutlined,\n                onClick: onToggleRef.current\n            }, {\n                name: 'close',\n                className: 'action-close',\n                label: translate('close'),\n                icon: closeOutlined,\n                onClick: handleClose\n            }];\n    }, [handleClose, minimized, onToggleRef, translate]);\n    return (jsx(animated.div, { className: classNames('controller-panel flex-column w-100 h-100', { 'd-none': !mounted || !isOpen }), css: style, style: animationObj != null ? effectProps : null, onClick: handleClick, onDoubleClick: handleDoubleClick, ref: ref },\n        jsx(PanelHeader, { level: 2, type: 'primary', title: label, actions: actions, moveable: false }),\n        jsx(\"div\", { className: 'panel-content d-flex flex-grow-1' },\n            !widgetClassLoaded && jsx(Loading, { type: LoadingType.Donut }),\n            WidgetClass && (jsx(\"div\", { className: 'w-100 h-100 widget-content p-1' },\n                jsx(ErrorBoundary, null,\n                    jsx(WidgetClass, { widgetId: widgetId, layoutId: layoutId, layoutItemId: layoutItemId }),\n                    (isDesignMode) && (jsx(LayoutItemToolbar, { layoutId: layoutId, layoutItem: layoutItem, refElement: ref.current, shiftOptions: shiftOptions, flipOptions: flipOptions, builderTheme: theme, formatMessage: translate, showDefaultTools: false }))))),\n            showMask && jsx(\"div\", { className: 'widget-mask' }),\n            jsx(\"button\", { className: 'sr-only last-virtual-node', onKeyUp: handleLastVirtualNodeFocus }))));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css, polished, getAppStore, appActions, WidgetState, spring } from 'jimu-core';\nimport { interact } from 'jimu-core/dnd';\nimport { getTheme2 } from 'jimu-theme';\nimport { utils, searchUtils, LayoutItemSizeModes } from 'jimu-layouts/layout-runtime';\nimport { ResizeHandlers } from '../../builder/resize-handlers';\nimport { bindResizeHandler } from '../../builder/interactive/resize-event-handler';\nimport { getAppConfigAction } from 'jimu-for-builder';\nimport { Panel } from './panel';\nimport { convertToStyle, panelTransformStyle } from '../util';\nimport { useAnimation } from './use-animation';\nconst { animated } = spring;\nfunction updateControllerStyle(options) {\n    const { controllerId, dx, dy, dw, dh, width, height } = options;\n    const appConfigAction = getAppConfigAction();\n    const appConfig = appConfigAction.appConfig;\n    let originStyle = appConfig.controllerPanels[controllerId];\n    if (originStyle.widthMode === LayoutItemSizeModes.Stretch) {\n        if (dw !== 0) {\n            if (dx !== 0) { // update left\n                if (utils.isPercentage(originStyle.left)) {\n                    originStyle = originStyle.set('left', `${(parseFloat(originStyle.left) + dx * 100 / window.innerWidth).toFixed(2)}%`);\n                }\n                else {\n                    originStyle = originStyle.set('left', `${Math.round(parseFloat(originStyle.left) + dx)}px`);\n                }\n            }\n            else { // update right\n                if (utils.isPercentage(originStyle.right)) {\n                    originStyle = originStyle.set('right', `${(parseFloat(originStyle.right) - dw * 100 / window.innerWidth).toFixed(2)}%`);\n                }\n                else {\n                    originStyle = originStyle.set('right', `${Math.round(parseFloat(originStyle.right) - dw)}px`);\n                }\n            }\n        }\n    }\n    else {\n        if (utils.isPercentage(originStyle.width)) {\n            originStyle = originStyle.set('width', `${(width * 100 / window.innerWidth).toFixed(2)}%`);\n        }\n        else {\n            originStyle = originStyle.set('width', `${Math.round(width)}px`);\n        }\n    }\n    if (originStyle.heightMode === LayoutItemSizeModes.Stretch) {\n        if (dh !== 0) {\n            if (dy !== 0) { // update top\n                if (utils.isPercentage(originStyle.top)) {\n                    originStyle = originStyle.set('top', `${(parseFloat(originStyle.top) + dy * 100 / window.innerHeight).toFixed(2)}%`);\n                }\n                else {\n                    originStyle = originStyle.set('top', `${Math.round(parseFloat(originStyle.top) + dy)}px`);\n                }\n            }\n            else { // update bottom\n                if (utils.isPercentage(originStyle.bottom)) {\n                    originStyle = originStyle.set('bottom', `${(parseFloat(originStyle.bottom) - dh * 100 / window.innerHeight).toFixed(2)}%`);\n                }\n                else {\n                    originStyle = originStyle.set('bottom', `${Math.round(parseFloat(originStyle.bottom) - dh)}px`);\n                }\n            }\n        }\n    }\n    else {\n        if (utils.isPercentage(originStyle.height)) {\n            originStyle = originStyle.set('height', `${(height * 100 / window.innerHeight).toFixed(2)}%`);\n        }\n        else {\n            originStyle = originStyle.set('height', `${Math.round(height)}px`);\n        }\n    }\n    appConfigAction.editControllerPanel(controllerId, originStyle).exec();\n}\nexport function ControllerPanelBuilder(props) {\n    var _a, _b, _c, _d;\n    const { controllerId, selected, innerSelected, isDesignMode } = props;\n    const ref = React.useRef();\n    const [isResizing, setIsResizing] = React.useState(false);\n    const [size, setSize] = React.useState();\n    const [minimized, setMinimized] = React.useState(false);\n    const innerLayoutId = ReactRedux.useSelector((state) => {\n        // find the layoutInfo of the opened widget\n        const controllerJson = state.appConfig.widgets[controllerId];\n        const layoutName = controllerJson.manifest.layouts[0].name;\n        const sizeModeLayouts = controllerJson.layouts[layoutName];\n        return searchUtils.findLayoutId(sizeModeLayouts, state.browserSizeMode, state.appConfig.mainSizeMode);\n    });\n    const items = ReactRedux.useSelector((state) => {\n        var _a;\n        // find the items of the opened widget\n        const layout = state.appConfig.layouts[innerLayoutId];\n        // innerLayoutId may be undefined\n        if (!layout) {\n            return '';\n        }\n        const widgetsJson = state.appConfig.widgets;\n        const itemIds = Object.keys((_a = layout.content) !== null && _a !== void 0 ? _a : {})\n            .filter(itemId => {\n            const layoutItem = layout.content[itemId];\n            const widgetJson = widgetsJson[layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.widgetId];\n            return (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.widgetId) != null && !layoutItem.isPending && !(widgetJson === null || widgetJson === void 0 ? void 0 : widgetJson.offPanel);\n        });\n        itemIds.sort();\n        return itemIds.join(',');\n    });\n    const hasItemOpened = ReactRedux.useSelector((state) => {\n        var _a, _b;\n        if (isDesignMode) {\n            return false;\n        }\n        const widgetsJson = state.appConfig.widgets;\n        const openedWidgets = Object.keys((_a = state.widgetsRuntimeInfo) !== null && _a !== void 0 ? _a : {}).filter(widgetId => {\n            var _a;\n            const info = state.widgetsRuntimeInfo[widgetId];\n            return info.state === WidgetState.Opened && !((_a = widgetsJson[widgetId]) === null || _a === void 0 ? void 0 : _a.offPanel);\n        });\n        // find the items of the opened widget\n        const layout = state.appConfig.layouts[innerLayoutId];\n        return Object.keys((_b = layout.content) !== null && _b !== void 0 ? _b : {})\n            .some(itemId => {\n            const layoutItem = layout.content[itemId];\n            return (layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.widgetId) != null && !layoutItem.isPending && openedWidgets.includes(layoutItem.widgetId);\n        });\n    });\n    const itemIdList = React.useMemo(() => items.split(',').filter(id => id !== ''), [items]);\n    const panelJson = ReactRedux.useSelector((state) => {\n        return state.appConfig.controllerPanels[controllerId];\n    });\n    const animationStyle = useAnimation({ controllerId });\n    React.useEffect(() => {\n        let width;\n        let height;\n        const widthRatio = ((panelJson === null || panelJson === void 0 ? void 0 : panelJson.position) || '').includes('CENTER') ? 2 : 1;\n        const heightRatio = ((panelJson === null || panelJson === void 0 ? void 0 : panelJson.position) || '').includes('MIDDLE') ? 2 : 1;\n        const onResizeStart = (_, initWidth, initHeight) => {\n            width = initWidth;\n            height = initHeight;\n            setIsResizing(true);\n            setSize({ dx: 0, dy: 0, dw: 0, dh: 0, width: initWidth, height: initHeight });\n        };\n        const onResizing = (_, dx, dy, dw, dh) => {\n            setSize({ dx, dy, dw, dh, width: width + dw * widthRatio, height: height + dh * heightRatio });\n        };\n        const onResizeEnd = (_, dx, dy, dw, dh) => {\n            setIsResizing(false);\n            updateControllerStyle({ controllerId, dx, dy, dw, dh, width: width + dw * widthRatio, height: height + dh * heightRatio });\n        };\n        let interactable;\n        if (ref.current) {\n            const interactable = interact(ref.current).origin('parent');\n            bindResizeHandler(interactable, {\n                layoutItemId: 'controller',\n                restrictEdges: true,\n                onResizeStart,\n                onResizing,\n                onResizeEnd\n            });\n        }\n        return () => {\n            interactable === null || interactable === void 0 ? void 0 : interactable.unset();\n        };\n    }, [controllerId, panelJson === null || panelJson === void 0 ? void 0 : panelJson.position]);\n    const handleClick = React.useCallback((e) => {\n        e.stopPropagation();\n    }, []);\n    const toggleMinimized = React.useCallback(() => {\n        setMinimized(!minimized);\n    }, [minimized]);\n    const handleClose = React.useCallback((e, widgetId) => {\n        e.stopPropagation();\n        getAppStore().dispatch(appActions.selectionChanged(null));\n        getAppStore().dispatch(appActions.closeWidget(widgetId));\n    }, []);\n    const visible = isDesignMode ? (selected || innerSelected) : hasItemOpened;\n    const getStyle = () => {\n        const theme = getTheme2();\n        if (isResizing) {\n            let hPos;\n            let vPos;\n            if (panelJson.widthMode === LayoutItemSizeModes.Stretch) {\n                hPos = css `\r\n          left: calc(${panelJson.left} + ${size.dx}px);\r\n          right: ${size.dx === 0 ? `calc(${panelJson.right} - ${size.dw}px)` : panelJson.right};\r\n        `;\n            }\n            if (panelJson.heightMode === LayoutItemSizeModes.Stretch) {\n                vPos = css `\r\n          top: calc(${panelJson.top} + ${size.dy}px);\r\n          bottom: ${size.dy === 0 ? `calc(${panelJson.bottom} - ${size.dh}px)` : panelJson.bottom};\r\n        `;\n            }\n            return css `\r\n        ${convertToStyle(panelJson)};\r\n        display: ${visible ? 'block' : 'none'};\r\n        width: ${panelJson.widthMode !== LayoutItemSizeModes.Stretch ? size.width + 'px' : 'auto'};\r\n        height: ${panelJson.heightMode !== LayoutItemSizeModes.Stretch ? size.height + 'px' : 'auto'};\r\n        ${hPos}\r\n        ${vPos}\r\n        border: ${selected ? '1px solid var(--sys-color-primary-main)' : 'none'};\r\n        background: ${selected ? polished.rgba(theme.sys.color.primary.main, 0.2) : 'transparent'};\r\n      `;\n        }\n        return css `\r\n      ${convertToStyle(panelJson)};\r\n      display: ${visible ? 'block' : 'none'};\r\n      height: ${minimized ? '36px' : panelJson === null || panelJson === void 0 ? void 0 : panelJson.height};\r\n      border: ${selected ? '1px solid var(--sys-color-primary-main)' : 'none'};\r\n      transition: height 0.3s ease-in-out;\r\n      background: ${selected ? polished.rgba(theme.sys.color.primary.main, 0.2) : 'transparent'};\r\n    `;\n    };\n    let mergedStyle = animationStyle;\n    const panelTransform = panelTransformStyle(panelJson);\n    if (panelTransform != null) {\n        mergedStyle = Object.assign({}, {\n            transform: panelTransform\n        }, animationStyle);\n    }\n    return (jsx(animated.div, { ref: ref, style: mergedStyle, css: getStyle(), onClick: handleClick, className: 'panel-container' },\n        selected && (jsx(ResizeHandlers, { left: !((_a = panelJson === null || panelJson === void 0 ? void 0 : panelJson.position) === null || _a === void 0 ? void 0 : _a.includes('LEFT')) || panelJson.widthMode === LayoutItemSizeModes.Stretch, right: !((_b = panelJson === null || panelJson === void 0 ? void 0 : panelJson.position) === null || _b === void 0 ? void 0 : _b.includes('RIGHT')) || panelJson.widthMode === LayoutItemSizeModes.Stretch, top: !((_c = panelJson === null || panelJson === void 0 ? void 0 : panelJson.position) === null || _c === void 0 ? void 0 : _c.includes('TOP')) || panelJson.heightMode === LayoutItemSizeModes.Stretch, bottom: !((_d = panelJson === null || panelJson === void 0 ? void 0 : panelJson.position) === null || _d === void 0 ? void 0 : _d.includes('BOTTOM')) || panelJson.heightMode === LayoutItemSizeModes.Stretch })),\n        jsx(React.Fragment, null, itemIdList.map(itemId => (jsx(Panel, { key: itemId, controllerId: controllerId, layoutId: innerLayoutId, layoutItemId: itemId, minimized: minimized, onToggle: toggleMinimized, onClose: handleClose }))))));\n}\n","/** @jsx jsx */\nimport { React, ReactRedux, jsx, css, PagePart, BrowserSizeMode, polished, PageMode, AnimationContext, AnimationType, AppMode, getAppStore, appActions, getNextAnimationId } from 'jimu-core';\nimport { PageContext, PageVisibilityContext, searchUtils } from 'jimu-layouts/layout-runtime';\nimport LayoutEntry from './layout-entry';\nimport { maskStyle, editBody } from './page-renderer-common';\nimport { computePageHeight } from '../common/page-util';\nimport { ControllerPanelGroup } from '../controller-panel/builder/group';\nfunction mapStateToProps(state, pageId) {\n    const animationPreview = state.appRuntimeInfo.animationPreview;\n    if ((animationPreview === null || animationPreview === void 0 ? void 0 : animationPreview.pageId) === pageId) {\n        return { previewId: animationPreview.id, playMode: animationPreview.playMode };\n    }\n    return { previewId: 0, playMode: null };\n}\nexport function PageBody(props) {\n    const { pageJson, visible, renderedPageId, browserSizeMode, activePagePart, pageContext, headerFooterHeight } = props;\n    const [playId, setPlayId] = React.useState(0);\n    const { previewId, playMode } = ReactRedux.useSelector((state) => mapStateToProps(state, pageJson.id), ReactRedux.shallowEqual);\n    const pageHeight = React.useMemo(() => {\n        return computePageHeight(pageJson, headerFooterHeight);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [headerFooterHeight]);\n    const layout = pageJson.layout;\n    const oneByOneEffect = pageJson.oneByOneEffect && pageJson.oneByOneEffect.type !== AnimationType.None ? pageJson.oneByOneEffect : null;\n    const isDesignMode = ReactRedux.useSelector((state) => {\n        var _a;\n        return oneByOneEffect === null ? true : ((_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.appMode) === AppMode.Design;\n    });\n    const sizeMode = ReactRedux.useSelector((state) => {\n        return oneByOneEffect === null ? null : state.browserSizeMode;\n    });\n    const effectRef = React.useRef(oneByOneEffect);\n    const sizeModeRef = React.useRef(sizeMode);\n    const visibleRef = React.useRef(visible);\n    const revert = oneByOneEffect ? (!visible) : null;\n    React.useEffect(() => {\n        effectRef.current = oneByOneEffect;\n    });\n    React.useEffect(() => {\n        if (!isDesignMode) { // isDesignMode === false\n            // play every animation\n            setPlayId(getNextAnimationId());\n        }\n        else if (!visibleRef.current) {\n            setPlayId(getNextAnimationId()); // restore the hidden items\n        }\n    }, [isDesignMode]);\n    React.useEffect(() => {\n        if (!isDesignMode && sizeModeRef.current !== sizeMode) {\n            setPlayId(getNextAnimationId());\n        }\n        sizeModeRef.current = sizeMode;\n    }, [sizeMode, isDesignMode]);\n    React.useEffect(() => {\n        if (!isDesignMode && visibleRef.current !== visible && effectRef.current) {\n            setPlayId(getNextAnimationId());\n        }\n        visibleRef.current = visible;\n    }, [visible, isDesignMode]);\n    const viewOnly = !layout[browserSizeMode];\n    let maxWidth;\n    if (pageJson.mode !== PageMode.FitWindow && pageJson.maxWidth > 0) {\n        maxWidth = pageJson.maxWidth;\n    }\n    const pageContextValue = React.useMemo(() => {\n        const state = getAppStore().getState();\n        let rootLayoutId;\n        if (pageJson.layout) {\n            rootLayoutId = searchUtils.findLayoutId(pageJson.layout, browserSizeMode, state.appConfig.mainSizeMode);\n        }\n        return Object.assign(Object.assign({}, pageContext), { maxWidth,\n            viewOnly,\n            // visible,\n            rootLayoutId, pageId: renderedPageId });\n    }, [pageContext, viewOnly, maxWidth, renderedPageId, pageJson.layout, browserSizeMode]);\n    const animationContextValue = React.useMemo(() => {\n        // isDesignMdoe === false\n        const setting = (!isDesignMode || previewId > 0) ? oneByOneEffect : null;\n        return {\n            setting,\n            revert,\n            playId: previewId > 0 ? previewId : playId,\n            oid: pageContextValue.rootLayoutId,\n            playMode,\n            onContextAnimationEnd: () => {\n                if (previewId > 0) {\n                    getAppStore().dispatch(appActions.clearAnimationPreview());\n                }\n                else {\n                    setPlayId(-1);\n                }\n            }\n        };\n    }, [isDesignMode, revert, playId, previewId, oneByOneEffect, playMode, pageContextValue.rootLayoutId]);\n    const getStyle = React.useCallback(() => {\n        return css `\r\n      display: ${visible ? 'flex' : 'none'};\r\n      position: relative;\r\n      background-color: ${pageJson.bodyBackgroundColor || 'transparent'};\r\n      z-index: 1;\r\n      flex: 1 0 auto;\r\n      height: ${pageHeight};\r\n\r\n      body:not(.design-mode) & {\r\n        .edit-mask {\r\n          display: none !important;\r\n        }\r\n      }\r\n\r\n      .exb-drop-area {\r\n        pointer-events: ${activePagePart !== PagePart.Body ? 'none !important' : 'auto'}\r\n      }\r\n    `;\n    }, [visible, pageHeight, activePagePart, pageJson.bodyBackgroundColor]);\n    if (!layout) {\n        return;\n    }\n    return (jsx(PageContext.Provider, { key: pageJson.id, value: pageContextValue },\n        jsx(PageVisibilityContext.Provider, { value: visible },\n            jsx(\"div\", { id: pageJson.id, \"data-pageid\": pageJson.id, className: 'page', css: getStyle() },\n                jsx(AnimationContext.Provider, { value: animationContextValue },\n                    jsx(LayoutEntry, { layouts: layout, isPageItem: true, visible: visible, className: 'w-100', css: css `\r\n                margin: 0 auto;\r\n                background-color: transparent;\r\n                z-index: 0;\r\n              ` })),\n                browserSizeMode !== BrowserSizeMode.Small && jsx(ControllerPanelGroup, { pageId: pageJson.id }),\n                activePagePart !== PagePart.Body && (jsx(\"div\", { className: 'edit-mask', css: css `\r\n                ${maskStyle};\r\n                background: ${polished.rgba(pageContext.theme.ref.palette.neutral[1100], 0.6)};\r\n                z-index: 1;\r\n              `, onClick: editBody }))))));\n}\n","/** @jsx jsx */\nimport { React, jsx, css, ExtensionManager, ReactRedux, extensionSpec, Immutable, BrowserSizeMode, LayoutType, getAppStore, appActions, PagePart, utils, injectIntl, Keyboard, AppDialog, PageMode, PageType, createSelector } from 'jimu-core';\nimport FixedLayoutBuilder from '../fixed-layout/builder/layout';\nimport { FlowLayoutTransformer } from '../flow-layout/layout-transform';\nimport { RowLayoutTransformer } from '../row-layout/layout-transform';\nimport { GridLayoutTransformer } from '../grid-layout/layout-transform';\nimport FlowLayoutBuilder from '../flow-layout/builder/layout';\nimport GridLayoutBuilder from '../grid-layout/builder/layout';\nimport ColumnLayoutBuilder from '../column-layout/builder/layout';\nimport AccordionLayoutBuilder from '../accordion-layout/builder/layout';\nimport FlexRowLayoutBuilder from '../flex-row-layout/builder/layout';\nimport { registerLayoutBuilder, PageContext, LayoutZIndex } from 'jimu-layouts/layout-runtime';\nimport { isDragging } from './interactive/drag-event-handler';\nimport { isResizing } from './interactive/resize-event-handler';\nimport defaultMessages from '../translations/default';\nimport { pasteLayoutItem } from './common-layout-actions';\nimport { PageHeader } from './page-header';\nimport { PageFooter } from './page-footer';\nimport { PageBody } from './page-body';\nimport { getDialogLayoutId, getFooterLayoutId, getHeaderLayoutId, getPageLayoutId, getVisiblePageId } from './page-renderer-common';\nimport { isLockLayout, isDesignMode, isExpressMode } from './menu/common-menu';\nimport { withTheme, getBuilderThemeVariables } from 'jimu-theme';\nimport { LayoutServiceProvider } from 'jimu-for-builder';\nimport { RowLayoutService } from '../row-layout/builder/layout-service';\nimport { GridLayoutService } from '../grid-layout/builder/layout-service';\nimport { FixedLayoutService } from '../fixed-layout/builder/layout-service';\nimport { FlowLayoutService } from '../flow-layout/builder/layout-service';\nimport { ColumnLayoutService } from '../column-layout/builder/layout-service';\nimport { AccordionLayoutService } from '../accordion-layout/builder/layout-service';\nimport { FlexRowLayoutService } from '../flex-row-layout/builder/layout-service';\nLayoutServiceProvider.getInstance().registerService(LayoutType.RowLayout, new RowLayoutService());\nLayoutServiceProvider.getInstance().registerService(LayoutType.GridLayout, new GridLayoutService());\nLayoutServiceProvider.getInstance().registerService(LayoutType.FixedLayout, new FixedLayoutService());\nLayoutServiceProvider.getInstance().registerService(LayoutType.FlowLayout, new FlowLayoutService());\nLayoutServiceProvider.getInstance().registerService(LayoutType.ColumnLayout, new ColumnLayoutService());\nLayoutServiceProvider.getInstance().registerService(LayoutType.AccordionLayout, new AccordionLayoutService());\nLayoutServiceProvider.getInstance().registerService(LayoutType.FlexRowLayout, new FlexRowLayoutService());\nregisterLayoutBuilder(LayoutType.FixedLayout, FixedLayoutBuilder);\nregisterLayoutBuilder(LayoutType.FlowLayout, FlowLayoutBuilder);\nregisterLayoutBuilder(LayoutType.GridLayout, GridLayoutBuilder);\nregisterLayoutBuilder(LayoutType.ColumnLayout, ColumnLayoutBuilder);\nregisterLayoutBuilder(LayoutType.AccordionLayout, AccordionLayoutBuilder);\nregisterLayoutBuilder(LayoutType.FlexRowLayout, FlexRowLayoutBuilder);\nexport class PageRenderer extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.updateHeaderHeight = (height) => {\n            this.setState({ headerHeight: height });\n        };\n        this.updateFooterHeight = (height) => {\n            this.setState({ footerHeight: height });\n        };\n        this.startPaste = () => {\n            var _a;\n            const clipboardItem = (_a = getAppStore().getState().appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.clipboard;\n            const { activePagePart, pageStatus, currentDialogId, dialogs } = this.props;\n            if (clipboardItem) {\n                let targetLayoutId;\n                if (currentDialogId && dialogs[currentDialogId]) {\n                    targetLayoutId = getDialogLayoutId(currentDialogId);\n                }\n                else if (activePagePart === PagePart.Header) {\n                    targetLayoutId = getHeaderLayoutId();\n                }\n                else if (activePagePart === PagePart.Footer) {\n                    targetLayoutId = getFooterLayoutId();\n                }\n                else {\n                    const vivisiblePageId = getVisiblePageId(pageStatus);\n                    targetLayoutId = getPageLayoutId(vivisiblePageId);\n                }\n                pasteLayoutItem(clipboardItem, targetLayoutId);\n            }\n        };\n        this.isMac = () => {\n            var _a, _b;\n            return ((_b = (_a = window.jimuUA) === null || _a === void 0 ? void 0 : _a.os) === null || _b === void 0 ? void 0 : _b.name) === 'macOS';\n        };\n        this.clearSelection = (e) => {\n            if ((isDesignMode() || isExpressMode()) && !isResizing() && !isDragging()) {\n                e.stopPropagation();\n                getAppStore().dispatch(appActions.selectionChanged(null));\n            }\n        };\n        this.formatMessage = (id, values) => {\n            if (this.props.intl) {\n                return this.props.intl.formatMessage({ id, defaultMessage: defaultMessages[id] }, values);\n            }\n            return defaultMessages[id];\n        };\n        this.state = { headerHeight: 0, footerHeight: 0 };\n        ExtensionManager.getInstance().registerExtension({\n            epName: extensionSpec.ExtensionPoints.LayoutTransformer,\n            extension: new FlowLayoutTransformer()\n        });\n        ExtensionManager.getInstance().registerExtension({\n            epName: extensionSpec.ExtensionPoints.LayoutTransformer,\n            extension: new RowLayoutTransformer()\n        });\n        ExtensionManager.getInstance().registerExtension({\n            epName: extensionSpec.ExtensionPoints.LayoutTransformer,\n            extension: new GridLayoutTransformer()\n        });\n        if (this.isMac()) {\n            this.keyBindings = {\n                'command+keyv': this.startPaste\n            };\n        }\n        else {\n            this.keyBindings = {\n                'ctrl+keyv': this.startPaste\n            };\n        }\n        this.updatePageContext();\n    }\n    componentDidMount() {\n        if (isDesignMode() && !document.body.classList.contains('design-mode')) {\n            document.body.classList.add('design-mode');\n        }\n        if (isLockLayout() && !document.body.classList.contains('lock-layout')) {\n            document.body.classList.add('lock-layout');\n        }\n    }\n    componentDidUpdate(prevProps) {\n        var _a;\n        const documentElement = (_a = window.document) === null || _a === void 0 ? void 0 : _a.documentElement;\n        if (documentElement) {\n            if (window.jimuConfig.isInBuilder && isDesignMode()) {\n                documentElement.classList.add('is-in-builder');\n            }\n            else {\n                documentElement.classList.remove('is-in-builder');\n            }\n        }\n        const previousPageId = getVisiblePageId(prevProps.pageStatus);\n        const currentPageId = getVisiblePageId(this.props.pageStatus);\n        if (previousPageId !== currentPageId) {\n            this.pageRef.scrollTop = 0;\n        }\n    }\n    getPageStyle() {\n        const { pageStatus, pages, minHeight } = this.props;\n        const visiblePageId = Object.keys(pageStatus).find((pid) => pageStatus[pid]);\n        const pageJson = pages[visiblePageId];\n        return css `\r\n      position: relative;\r\n      margin: 0 auto;\r\n      overflow: hidden;\r\n      z-index: 0;\r\n      height: ${pageJson.mode === PageMode.FitWindow ? '100%' : 'auto'};\r\n      min-height: ${minHeight}px;\r\n      .is-dragging {\r\n        z-index: ${LayoutZIndex.DraggingItem};\r\n        opacity: 0.8;\r\n      }\r\n\r\n      body:not(.design-mode) & {\r\n        overflow: auto;\r\n        height: 100%;\r\n      }\r\n    `;\n    }\n    updatePageContext() {\n        const { theme } = this.props;\n        const pageContext = {\n            theme,\n            builderTheme: getBuilderThemeVariables(),\n            formatMessage: this.formatMessage\n        };\n        if (!this.pageContext) {\n            this.pageContext = Immutable(pageContext);\n        }\n        else {\n            for (const prop in pageContext) {\n                if (this.pageContext[prop] !== pageContext[prop]) {\n                    this.pageContext = this.pageContext.set(prop, pageContext[prop]);\n                }\n            }\n        }\n    }\n    render() {\n        const { pageStatus, pages, headerVisible, footerVisible } = this.props;\n        const visiblePageId = getVisiblePageId(pageStatus);\n        if (!visiblePageId || !(pages === null || pages === void 0 ? void 0 : pages[visiblePageId])) {\n            return null;\n        }\n        this.updatePageContext();\n        return (jsx(\"div\", { className: 'page-renderer d-flex flex-column align-items-center w-100', ref: (el) => { this.pageRef = el; }, css: this.getPageStyle(), \"data-testid\": 'pageRenderer', onClick: this.clearSelection },\n            this.renderDialog(),\n            headerVisible && this.renderHeader(),\n            Object.keys(pageStatus).map((pId) => this.renderPageBody(pId)),\n            footerVisible && this.renderFooter(),\n            jsx(Keyboard, { bindings: this.keyBindings })));\n    }\n    renderHeader() {\n        if (!this.props.header) {\n            return null;\n        }\n        const { header, browserSizeMode, mainSizeMode, activePagePart } = this.props;\n        return (jsx(PageHeader, { header: header, activePagePart: activePagePart, browserSizeMode: browserSizeMode, mainSizeMode: mainSizeMode, pageContext: this.pageContext, onHeightChange: this.updateHeaderHeight }));\n    }\n    renderFooter() {\n        if (!this.props.footer) {\n            return null;\n        }\n        const { footer, browserSizeMode, mainSizeMode, activePagePart } = this.props;\n        return (jsx(PageFooter, { footer: footer, activePagePart: activePagePart, browserSizeMode: browserSizeMode, mainSizeMode: mainSizeMode, pageContext: this.pageContext, onHeightChange: this.updateFooterHeight }));\n    }\n    renderPageBody(renderedPageId) {\n        const { pages, pageStatus, browserSizeMode, activePagePart } = this.props;\n        const pageJson = pages[renderedPageId];\n        if (!pageJson || pageJson.type !== PageType.Normal) {\n            // page is removed, or current type is link or folder\n            return;\n        }\n        return (jsx(PageBody, { key: pageJson.id, pageJson: pageJson, renderedPageId: renderedPageId, activePagePart: activePagePart, browserSizeMode: browserSizeMode, pageContext: this.pageContext, visible: !!pageStatus[pageJson.id], headerFooterHeight: this.state.headerHeight + this.state.footerHeight }));\n    }\n    // viewOnly when dialog is in mode: !Large && AUTO\n    isDialogViewOnly(dialogJson) {\n        const { browserSizeMode } = this.props;\n        const isAutoInUnLargeSize = browserSizeMode !== BrowserSizeMode.Large && !dialogJson.layout[browserSizeMode];\n        return !!isAutoInUnLargeSize;\n    }\n    renderDialog() {\n        const { currentDialogId, urlDialogJson, splashDialogJson, isSplashClosed, isPageDlgClosed, pageDialogJson, pageDialogId } = this.props;\n        const showSplash = !isSplashClosed && splashDialogJson;\n        const showPageDlg = !isPageDlgClosed && pageDialogJson;\n        const showUrlDlg = urlDialogJson ? ((splashDialogJson === null || splashDialogJson === void 0 ? void 0 : splashDialogJson.id) === urlDialogJson.id || (pageDialogJson === null || pageDialogJson === void 0 ? void 0 : pageDialogJson.id) === urlDialogJson.id) ? null : urlDialogJson : null;\n        return (jsx(React.Fragment, null,\n            showUrlDlg && (jsx(PageContext.Provider, { value: Object.assign(Object.assign({}, this.pageContext), { dialogId: currentDialogId, isDialog: true, viewOnly: this.isDialogViewOnly(urlDialogJson), rootLayoutId: getDialogLayoutId(currentDialogId) }) },\n                jsx(AppDialog, { dialogJson: urlDialogJson }))),\n            showPageDlg && (jsx(PageContext.Provider, { value: Object.assign(Object.assign({}, this.pageContext), { dialogId: pageDialogId, isDialog: true, viewOnly: this.isDialogViewOnly(pageDialogJson), rootLayoutId: getDialogLayoutId(pageDialogJson.id) }) },\n                jsx(AppDialog, { dialogJson: pageDialogJson, isOpenByPage: true }))),\n            showSplash && (jsx(PageContext.Provider, { value: Object.assign(Object.assign({}, this.pageContext), { dialogId: splashDialogJson.id, isDialog: true, viewOnly: this.isDialogViewOnly(splashDialogJson), rootLayoutId: getDialogLayoutId(splashDialogJson.id) }) },\n                jsx(AppDialog, { dialogJson: splashDialogJson })))));\n    }\n}\nPageRenderer.displayName = 'BuilderPageRenderer';\nconst mapStateToProps = createSelector([\n    (state) => {\n        const viewportSize = utils.findViewportSize(state.appConfig, state.browserSizeMode);\n        return viewportSize.height;\n    },\n    (_, ownProps) => {\n        return getVisiblePageId(ownProps.pageStatus);\n    },\n    (_, ownProps) => ownProps.dialogId,\n    (state) => state.appRuntimeInfo.currentPageId,\n    (state) => state.appConfig.pages,\n    (state) => state.appConfig.dialogs,\n    (state) => state.appConfig.header,\n    (state) => state.appConfig.footer,\n    (state) => state.appConfig.mainSizeMode,\n    (state) => state.browserSizeMode,\n    (state) => { var _a; return (_a = state.appRuntimeInfo.activePagePart) !== null && _a !== void 0 ? _a : PagePart.Body; },\n    (state) => state.appRuntimeInfo.clipboard,\n    (state) => state.appRuntimeInfo.currentDialogId,\n    (state) => { var _a; return (_a = state.appRuntimeInfo) === null || _a === void 0 ? void 0 : _a.dialogInfos; },\n    (state) => {\n        return state.appConfig.pages[state.appRuntimeInfo.currentPageId].autoOpenDialogId;\n    }\n    // eslint-disable-next-line max-params\n], (minHeight, pageId, dialogId, currentPageId, pages, dialogs, header, footer, mainSizeMode, browserSizeMode, activePagePart, clipboardItem, currentDialogId, dialogInfos, pageDlgId) => {\n    var _a, _b;\n    if (!pageId || !pages[pageId]) {\n        return {};\n    }\n    const dialogJson = dialogs[Object.keys(dialogs).find(dlgId => dialogs[dlgId].isSplash)];\n    return {\n        pages,\n        dialogs,\n        header,\n        footer,\n        headerVisible: !!pages[pageId].header,\n        footerVisible: !!pages[pageId].footer,\n        mainSizeMode,\n        browserSizeMode,\n        minHeight,\n        activePagePart,\n        clipboardItem,\n        currentDialogId,\n        splashDialogJson: dialogJson,\n        isSplashClosed: (_a = dialogInfos === null || dialogInfos === void 0 ? void 0 : dialogInfos[dialogJson === null || dialogJson === void 0 ? void 0 : dialogJson.id]) === null || _a === void 0 ? void 0 : _a.isClosed,\n        pageDialogId: pageDlgId,\n        pageDialogJson: dialogs[pageDlgId],\n        isPageDlgClosed: (_b = dialogInfos === null || dialogInfos === void 0 ? void 0 : dialogInfos[currentPageId + '-' + pageDlgId]) === null || _b === void 0 ? void 0 : _b.isClosed,\n        urlDialogJson: dialogs[dialogId]\n    };\n});\nexport default injectIntl(ReactRedux.connect(mapStateToProps)(withTheme(PageRenderer)));\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/** @jsx jsx */\nimport { React, ReactRedux, classNames, jsx, css, LayoutItemType } from 'jimu-core';\nimport { interact } from 'jimu-core/dnd';\nimport * as hoistNonReactStatic from 'hoist-non-react-statics';\nimport { bindDragHandler } from './drag-event-handler';\nimport { bindResizeHandler } from './resize-event-handler';\nimport { PageContext, utils } from 'jimu-layouts/layout-runtime';\nexport function mapStateToRndWrapperProps(state, ownProps) {\n    var _a, _b, _c, _d;\n    const layoutId = ownProps.layoutId;\n    // const layout = state.appConfig.layouts[layoutId];\n    // const layoutItemId = ownProps.layoutItemId;\n    const selection = state.appRuntimeInfo.selection;\n    const layoutItem = ownProps.layoutItem;\n    let selected = false;\n    let isInlineEditing = false;\n    let supportRepeat = false;\n    let isLayoutWidget = false;\n    if (layoutItem) {\n        selected = Boolean(selection && layoutId === selection.layoutId && layoutItem.id === selection.layoutItemId);\n        if (layoutItem.type === LayoutItemType.Widget) {\n            const widget = state.appConfig.widgets[layoutItem.widgetId];\n            const supportInlineEditing = (_b = (_a = widget === null || widget === void 0 ? void 0 : widget.manifest) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.supportInlineEditing;\n            supportRepeat = (_d = (_c = widget === null || widget === void 0 ? void 0 : widget.manifest) === null || _c === void 0 ? void 0 : _c.properties) === null || _d === void 0 ? void 0 : _d.supportRepeat;\n            if (supportInlineEditing) {\n                const widgetRuntimeInfo = state.widgetsRuntimeInfo[layoutItem.widgetId];\n                isInlineEditing = widgetRuntimeInfo && widgetRuntimeInfo.isInlineEditing;\n            }\n            isLayoutWidget = utils.isWidgetHasEmbeddedLayout(layoutItem.widgetId, state.appConfig);\n        }\n    }\n    return {\n        selected,\n        supportRepeat,\n        isInlineEditing,\n        isLayoutWidget\n    };\n}\nconst emptyFunc = () => null;\nexport function withRnd(autoSelect) {\n    return (WrappedComponent) => {\n        class RndWrapper extends React.PureComponent {\n            constructor(props) {\n                super(props);\n                this.ref = React.createRef();\n            }\n            componentDidMount() {\n                const { layoutId, layoutItemId, layoutItem, onResizeStart, onResizing, onResizeEnd, onDragStart, onDragging, onDragEnd, useDragHandler } = this.props;\n                if (this.ref.current) {\n                    this.interactable = interact(this.ref.current).origin('parent');\n                    this.interactable = bindDragHandler(this.interactable, {\n                        layoutId,\n                        layoutItemId,\n                        useDragHandler,\n                        onDragging,\n                        onDragStart,\n                        onDragEnd,\n                        itemType: layoutItem.type,\n                        rootLayoutId: () => this.rootLayoutId,\n                        restrict: () => this.props.restrict\n                    });\n                    this.interactable = bindResizeHandler(this.interactable, {\n                        layoutItemId,\n                        onResizing,\n                        onResizeStart,\n                        onResizeEnd\n                    });\n                }\n            }\n            componentWillUnMount() {\n                if (this.interactable) {\n                    this.interactable.unset();\n                    this.interactable = null;\n                }\n            }\n            getStyle(isInlineEditing) {\n                return css `\r\n          ${this.aspectRatioStyle()};\r\n\r\n          &.dragging {\r\n            opacity: 0.9;\r\n          }\r\n\r\n          display: flex;\r\n          position: relative;\r\n          touch-action: ${isInlineEditing ? 'auto' : 'none'};\r\n          user-select: ${isInlineEditing ? 'auto' : 'none'};\r\n        `;\n            }\n            aspectRatioStyle() {\n                const { aspectRatio, forceAspectRatio: keepAspectRatio } = this.props;\n                if (keepAspectRatio) {\n                    return css `\r\n            & > div.rnd-aspect-ratio-wrapper {\r\n              width: 100%;\r\n              position: relative;\r\n              padding-top: ${aspectRatio * 100}%;\r\n\r\n              & > div {\r\n                position: absolute !important;\r\n                top: 0;\r\n                left: 0;\r\n                bottom: 0;\r\n                right: 0;\r\n              }\r\n            }\r\n          `;\n                }\n                return css `\r\n          & > .rnd-aspect-ratio-wrapper {\r\n            width: 100%;\r\n            height: 100%;\r\n            display: flex;\r\n          }\r\n        `;\n            }\n            render() {\n                return (jsx(PageContext.Consumer, null, (pageContext) => {\n                    this.rootLayoutId = pageContext.rootLayoutId;\n                    const _a = this.props, { gridSize, draggable, onResizeStart, onResizing, onResizeEnd, style, className, useDragHandler, children } = _a, otherProps = __rest(_a, [\"gridSize\", \"draggable\", \"onResizeStart\", \"onResizing\", \"onResizeEnd\", \"style\", \"className\", \"useDragHandler\", \"children\"]);\n                    const { isInlineEditing } = this.props;\n                    const mergedClass = classNames('exb-rnd', className, {\n                        'functional-widget': !this.props.isLayoutWidget\n                    });\n                    const mergedStyle = typeof style === 'string'\n                        ? JSON.parse(style)\n                        : Object.assign({}, style);\n                    if (this.props.forceAspectRatio) {\n                        mergedStyle.height = 'auto';\n                    }\n                    return (jsx(\"div\", { className: mergedClass, ref: this.ref, css: this.getStyle(isInlineEditing), \"data-layoutid\": this.props.layoutId, \"data-layoutitemid\": this.props.layoutItemId, \"data-repeatable\": this.props.supportRepeat, style: mergedStyle },\n                        jsx(\"div\", { className: 'rnd-aspect-ratio-wrapper' },\n                            jsx(WrappedComponent, Object.assign({ layoutId: this.props.layoutId, className: 'w-100', layoutItemId: this.props.layoutItemId }, otherProps))),\n                        children));\n                }));\n            }\n        }\n        RndWrapper.defaultProps = {\n            left: true,\n            top: true,\n            right: true,\n            bottom: true,\n            restrict: false,\n            onResizeStart: emptyFunc,\n            onResizing: emptyFunc,\n            onResizeEnd: emptyFunc,\n            onDragStart: emptyFunc,\n            onDragging: emptyFunc,\n            onDragEnd: emptyFunc\n        };\n        const HoistedComponent = hoistNonReactStatic(RndWrapper, WrappedComponent);\n        return ReactRedux.connect(mapStateToRndWrapperProps)(HoistedComponent);\n    };\n}\n"],"names":[],"sourceRoot":""}