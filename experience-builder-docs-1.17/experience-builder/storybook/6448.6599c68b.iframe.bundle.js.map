{"version":3,"file":"6448.6599c68b.iframe.bundle.js","mappings":";AA4CA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;AAsBA;;AAGA;;;;;;;;;AC4DA;;;;;;;;;;;;AAwBA;;;;;;;;;;;;AAiCA;;;;AAsBA;;AAGA;;;;;;AAwCA;;;;;;;;;AASA;;;AAIA;;;;;;AAcA;;;;;;AAeA;;;;;AAaA;;;;;;;;AA4CA;;;;;AAgCA;;;;;;;;;;AAqBA;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;AA2DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;;;;;AAKA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA;;;;;;;;;;;AAWA;;;;AAIA;;;AAGA;;;;AAIA;;;;;;;;;;AAUA;;;;;;;;;AASA;;;;;;;;;;;;AAYA;;;AAGA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;;;;;AAMA;;;;AAKA;;;;;ACjlBA;;;;;;;;;;;;;;;;;;;ACaA","sources":["webpack://arcgis-experience-builder-design-system/../jimu-ui/basic/lib/list-tree/common/tree-command-list.tsx","webpack://arcgis-experience-builder-design-system/../jimu-ui/basic/lib/list-tree/common/tree-item.tsx","webpack://arcgis-experience-builder-design-system/../jimu-ui/basic/lib/list-tree/common/tree-main.tsx","webpack://arcgis-experience-builder-design-system/../jimu-ui/basic/lib/list-tree/tree.tsx"],"sourcesContent":["/** @jsx jsx */\nimport { React, css, jsx, injectIntl } from 'jimu-core';\nimport { Icon, Popper, Tooltip, defaultMessages } from 'jimu-ui';\nimport { withTheme } from 'jimu-theme';\nimport { TreeButton } from './tree-button';\nexport const CommandList = withTheme(injectIntl((props) => {\n    var _a, _b;\n    const { className, theme, intl, itemCommands, data, moreCommand = {\n        key: Symbol(),\n        label: intl.formatMessage({ id: 'more', defaultMessage: defaultMessages.more }),\n        iconProps: { icon: require('jimu-icons/svg/outlined/application/more-horizontal.svg') },\n        action: () => null\n    }, maxIconCount = 3, onClickItemCommand = () => null } = props;\n    const itemStateDisabled = !!((_b = (_a = data === null || data === void 0 ? void 0 : data.itemJsons) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.itemStateDisabled);\n    const [dropdownVisible, setDropdownVisible] = React.useState(false);\n    const [dropdownContainer, setDropdownContainer] = React.useState(null);\n    const renderCommandItems = (commands) => {\n        return (commands.map((command, x) => {\n            var _a;\n            const iconProps = (typeof command.iconProps === 'function' ? command.iconProps() : command.iconProps) || { icon: null };\n            return command && !command.collapsed &&\n                jsx(Tooltip, { key: x, title: command.label },\n                    jsx(TreeButton, { icon: true, type: 'tertiary', variant: 'text', disableHoverEffect: true, disableRipple: true, \"data-testid\": command.label, className: 'jimu-tree-command-list__command-item', disabled: itemStateDisabled, \"aria-label\": command.label, \"aria-pressed\": (_a = command.buttonAriaPressed) !== null && _a !== void 0 ? _a : null, onClick: (event) => {\n                            var _a;\n                            event.stopPropagation();\n                            setDropdownVisible(!dropdownVisible);\n                            const actionData = { event, data, command, itemCommands };\n                            (_a = command.action) === null || _a === void 0 ? void 0 : _a.call(command, actionData);\n                            onClickItemCommand(actionData);\n                        } },\n                        jsx(Icon, Object.assign({ size: 'm', className: 'jimu-tree-command-list__command-item-icon' }, iconProps)),\n                        jsx(\"div\", { className: 'jimu-tree-command-list__command-item-label' }, command.label)));\n        }));\n    };\n    const displayableCommands = itemCommands.filter(command => !command.collapsed);\n    const withMoreCommand = displayableCommands.length > maxIconCount;\n    const renderingCommands = withMoreCommand ? [...displayableCommands.slice(0, maxIconCount - 1), moreCommand, ...displayableCommands.slice(maxIconCount - 1)] : displayableCommands;\n    return (jsx(\"div\", { ref: el => { setDropdownContainer(el); }, className: `jimu-tree-command-list ${className || ''}`, css: getStyle },\n        renderCommandItems(renderingCommands.slice(0, maxIconCount)),\n        withMoreCommand &&\n            jsx(Popper, { open: dropdownVisible, reference: dropdownContainer, toggle: () => { setDropdownVisible(false); }, css: getStyle },\n                jsx(\"div\", { className: 'jimu-tree-command-list-dropdown' }, renderCommandItems(renderingCommands.slice(maxIconCount))))));\n    function getStyle() {\n        return css `\r\n      color: ${theme.ref.palette.neutral[1000]};\r\n      .jimu-tree-command-list-dropdown {\r\n        display: flex;\r\n        flex-flow: column;\r\n        background-color: ${theme.ref.palette.neutral[500]};\r\n        padding: .25rem;\r\n        .jimu-tree-command-list__command-item-label {\r\n          display: flex;\r\n        }\r\n      }\r\n      .jimu-tree-command-list__command-item {\r\n        display: flex;\r\n        cursor: pointer;\r\n        margin: 0 0.25rem;\r\n        &.icon-btn{\r\n          padding: 0;\r\n        }\r\n        .icon-btn-sizer{\r\n          min-width: 0;\r\n          min-height: 0;\r\n        }\r\n      }\r\n      .jimu-tree-command-list__command-item-icon {\r\n      }\r\n      .jimu-tree-command-list__command-item-label {\r\n        display: none;\r\n        color: ${theme.ref.palette.black};\r\n      }\r\n    `;\n    }\n}));\n","/** @jsx jsx */\nimport { React, css, jsx, esri, moduleLoader, injectIntl, lodash, polished, classNames, defaultMessages as jimuCoreMsg, focusElementInKeyboardMode } from 'jimu-core';\nimport { Icon, ListGroupItem, Collapse, TextInput, Button, Checkbox, defaultMessages, Tooltip } from 'jimu-ui';\nimport { withTheme } from 'jimu-theme';\nimport { TreeItemActionType, TreeCollapseStyle, TreeAlignmentType, TreeSelectionStyle, TreeStyle } from './tree-types';\nimport * as treeUtils from './tree-utils';\nimport { CommandList } from './tree-command-list';\nimport { TreeContext } from './tree-context';\nimport { TreeButton } from './tree-button';\nimport { MinusCircleOutlined } from 'jimu-icons/outlined/editor/minus-circle';\nimport { PlusCircleOutlined } from 'jimu-icons/outlined/editor/plus-circle';\nimport { DownFilled } from 'jimu-icons/filled/directional/down';\nimport { LeftFilled } from 'jimu-icons/filled/directional/left';\nimport { RightFilled } from 'jimu-icons/filled/directional/right';\nimport { CloseOutlined } from 'jimu-icons/outlined/editor/close';\nimport { CheckFilled } from 'jimu-icons/filled/application/check';\n/**\n * The TreeItem component.\n *\n * ```ts\n * import { TreeItem } from 'jimu-ui/basic/list-tree'\n * ```\n */\nexport class _TreeItem extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n        this.dropZoneRef = React.createRef();\n        this.dragRef = React.createRef();\n        this.dropZoneInteractable = null;\n        this.dragInteractable = null;\n        this.dndInteract = null;\n        this.intl = this.props.intl;\n        const Sanitizer = esri.Sanitizer;\n        this.sanitizer = new Sanitizer();\n    }\n    componentDidMount() {\n        if (this.props.dndEnabled && this.dragRef.current) {\n            import('jimu-core/dnd').then((dndModule) => {\n                this.dndInteract = dndModule.interact;\n                this.props.handleAction(TreeItemActionType.HandleInitTreeItemDndDropZone, { type: 'mount' }, this);\n                this.props.handleAction(TreeItemActionType.HandleInitTreeItemDndDrag, { type: 'mount' }, this);\n            });\n        }\n    }\n    componentWillUnmount() {\n        if (this.dndInteract) {\n            this.props.handleAction(TreeItemActionType.HandleInitTreeItemDndDropZone, { type: 'unmount' }, this);\n            this.props.handleAction(TreeItemActionType.HandleInitTreeItemDndDrag, { type: 'unmount' }, this);\n        }\n    }\n    render() {\n        const { handleAction } = this.props;\n        const _itemBlockInfo = this.props.itemBlockInfo || _TreeItem.itemBlockInfos[this.props.treeAlignmentType];\n        const itemBlockInfo = handleAction(TreeItemActionType.OverrideItemBlockInfo, { itemBlockInfo: _itemBlockInfo }, this);\n        return this.renderChildBlocks({ currentBlockInfo: { name: null, children: [itemBlockInfo] } }, this);\n    }\n    renderChildBlocks(actionData, refComponent) {\n        const { handleAction } = refComponent.props;\n        const { currentBlockInfo } = actionData;\n        return (currentBlockInfo.children || []).filter(child => !!child).map((child, x) => (jsx(React.Fragment, { key: x }, handleAction(child.name, Object.assign(Object.assign({}, actionData), { currentBlockInfo: child }), refComponent))));\n    }\n}\n_TreeItem.contextType = TreeContext;\n_TreeItem.defaultHandleActionMap = {\n    overrideItemBlockInfo: (actionData, refComponent) => {\n        const { itemBlockInfo } = actionData;\n        return itemBlockInfo;\n    },\n    renderOverrideItemChildrenToggle: (actionData, refComponent) => {\n        var _a;\n        const { itemJsons, collapseStyle, isMultiSelection, checkboxLinkage, treeAlignmentType, theme, itemJsons: [{ itemStateExpanded, itemExpandIconShown = false, itemStateChecked, indeterminate, isCheckboxDisabled, isItemSelectable = true, itemStateTitle, itemChildren }], handleAction } = refComponent.props;\n        const showExpandIcon = itemExpandIconShown || ((_a = treeUtils.getItemChildren(itemJsons)) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        const isFolder = handleAction(TreeItemActionType.IsFolder, {\n            draggingItemJsons: null,\n            targetItemJsons: itemJsons\n        }, refComponent);\n        const disabled = isCheckboxDisabled || !isItemSelectable || (refComponent.context.isTree && isFolder && (!itemChildren || (itemChildren === null || itemChildren === void 0 ? void 0 : itemChildren.length) === 0) && itemJsons.length === 2);\n        const showCheckbox = treeUtils.showCheckbox(refComponent.context.isTree, isMultiSelection, checkboxLinkage);\n        let ItemCheckbox = null;\n        if (showCheckbox) {\n            if (treeAlignmentType === TreeAlignmentType.Intact) {\n                ItemCheckbox = jsx(\"div\", { className: classNames('d-flex align-items-center', { 'pr-1': !showExpandIcon }) },\n                    jsx(Checkbox, { \"aria-label\": itemStateTitle, checked: itemStateChecked, indeterminate: indeterminate, disabled: disabled, onChange: evt => {\n                            evt.stopPropagation();\n                            if (disabled)\n                                return;\n                            handleAction(TreeItemActionType.HandleCheckboxChanged, { itemStateChecked: evt.target.checked }, refComponent);\n                        } }));\n            }\n        }\n        else if (refComponent.context.selectionStyle === TreeSelectionStyle.CheckSelection) {\n            ItemCheckbox = jsx(Button, { icon: true, type: 'tertiary', variant: 'text', disableHoverEffect: true, disableRipple: true, size: 'sm', className: 'mr-1', tabIndex: -1, onClick: (evt) => {\n                    evt.stopPropagation();\n                    handleAction(TreeItemActionType.HandleCheckboxChanged, { itemStateChecked: !itemStateChecked, isMultiSelection: isMultiSelection }, refComponent);\n                } }, itemStateChecked && !disabled ? jsx(CheckFilled, { size: '12', color: theme.sys.color.primary.light }) : jsx(\"div\", null));\n        }\n        if (!refComponent.context.multiLevel) {\n            return ItemCheckbox;\n        }\n        const labelKey = itemStateExpanded ? 'collapse' : 'expand';\n        const label = refComponent.intl.formatMessage({ id: labelKey, defaultMessage: defaultMessages[labelKey] });\n        const MinusIcon = collapseStyle === TreeCollapseStyle.Arrow ? jsx(DownFilled, { size: 's' }) : jsx(MinusCircleOutlined, null);\n        const PlusIcon = collapseStyle === TreeCollapseStyle.Arrow ? (refComponent.context.isRTL ? jsx(LeftFilled, { size: 's' }) : jsx(RightFilled, { size: 's' })) : jsx(PlusCircleOutlined, null);\n        return (jsx(React.Fragment, null,\n            showExpandIcon\n                ? jsx(Button, { icon: true, type: 'tertiary', variant: 'text', disableHoverEffect: true, disableRipple: true, className: 'jimu-tree-item__children-toggle jimu-outline-inside', title: label, \"aria-label\": label, onClick: (evt) => {\n                        evt.stopPropagation();\n                        handleAction(TreeItemActionType.HandleExpandItem, { itemStateExpanded: !itemStateExpanded }, refComponent);\n                    }, onKeyDown: evt => {\n                        if (treeUtils.shouldHandleKeyEvent(evt)) {\n                            evt.preventDefault();\n                            evt.stopPropagation();\n                        }\n                    }, onKeyUp: evt => {\n                        if (treeUtils.shouldHandleKeyEvent(evt)) {\n                            evt.stopPropagation();\n                            handleAction(TreeItemActionType.HandleExpandItem, { itemStateExpanded: !itemStateExpanded }, refComponent);\n                        }\n                    }, css: getStyle }, itemStateExpanded ? MinusIcon : PlusIcon)\n                : jsx(\"div\", { className: 'toggle-placeholder', css: css `width: ${collapseStyle === TreeCollapseStyle.Arrow ? 18 : 22}px;` }),\n            ItemCheckbox));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__children-toggle {\r\n            cursor: pointer;\r\n\r\n            .icon-btn-sizer {\r\n              min-width: 0.75rem;\r\n              min-height: 0.75rem;\r\n            }\r\n          }\r\n        `;\n        }\n    },\n    renderOverrideItemDragHandle: (actionData, refComponent) => {\n        if (!refComponent.props.dndEnabled) {\n            return null;\n        }\n        const icon = require('../assets/icons/drag-16.svg');\n        const label = refComponent.intl.formatMessage({ id: 'dragHandler', defaultMessage: defaultMessages.dragHandler });\n        return (jsx(TreeButton, { icon: true, type: 'tertiary', \"aria-label\": label, className: 'jimu-tree-item__drag-handle', css: getStyle },\n            jsx(Icon, { icon: icon, width: 4, height: 16 })));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__drag-handle {\r\n            display: flex;\r\n            align-items: center;\r\n            touch-action: none;\r\n            border: 0;\r\n\r\n            .icon-btn-sizer {\r\n              min-width: 0.25rem;\r\n              min-height: 1rem;\r\n            }\r\n          }\r\n        `;\n        }\n    },\n    /**\n     * Render item detail icon, two cases for itemStateDetailContent value:\n     * valid value         : Render Icon when\n     * null, or undefined  : Not render\n     */\n    renderOverrideItemDetailToggle: (actionData, refComponent) => {\n        const { itemJsons: [{ itemStateDetailVisible, itemStateDetailContent, itemStateDisabled }], handleAction } = refComponent.props;\n        const DetailIcon = itemStateDetailVisible ? DownFilled : RightFilled;\n        const labelKey = itemStateDetailVisible ? 'collapse' : 'expand';\n        const label = refComponent.intl.formatMessage({ id: labelKey, defaultMessage: defaultMessages[labelKey] });\n        return (itemStateDetailContent\n            ? jsx(TreeButton, { icon: true, type: 'tertiary', title: label, \"aria-label\": label, disabled: !!itemStateDisabled, className: 'jimu-tree-item__detail-toggle', onClick: (evt) => {\n                    evt.stopPropagation();\n                    handleAction(TreeItemActionType.HandleToggleDetail, { itemStateDetailVisible: !itemStateDetailVisible }, refComponent);\n                }, css: getStyle },\n                jsx(DetailIcon, { size: 's', autoFlip: !itemStateDetailVisible }))\n            : null);\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__detail-toggle {\r\n            display: flex;\r\n            align-items: center;\r\n            cursor: pointer;\r\n\r\n            .icon-btn-sizer {\r\n              margin: 0;\r\n              min-width: 0.5rem;\r\n              min-height: 0.5rem;\r\n            }\r\n          }\r\n        `;\n        }\n    },\n    /**\n     * Render item icon, three cases for iconProps value:\n     * {icon=validSource } : Render Icon\n     * {}, or {icon=null/undefined}  : Render placeholder\n     * null, or undefined  : Not render\n     */\n    renderOverrideItemIcon: (actionData, refComponent) => {\n        var _a;\n        const { currentBlockInfo: { autoCollapsed = false } } = actionData;\n        const { itemJsons: [{ itemStateIcon }] } = refComponent.props;\n        const iconProps = typeof itemStateIcon === 'function' ? itemStateIcon() : itemStateIcon;\n        return (iconProps\n            ? jsx(\"div\", { className: 'jimu-tree-item__icon', css: getStyle, style: autoCollapsed && !iconProps.icon ? { display: 'none' } : {} },\n                jsx(Icon, Object.assign({}, iconProps, { icon: (_a = iconProps.icon) !== null && _a !== void 0 ? _a : require('../assets/icons/drag-16.svg'), className: 'mr-1' })))\n            : null);\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__icon {\r\n            display: flex;\r\n            align-items: center;\r\n            opacity: ${(iconProps === null || iconProps === void 0 ? void 0 : iconProps.icon) ? 1 : 0};\r\n          }\r\n        `;\n        }\n    },\n    renderOverrideItemTitle: (actionData, refComponent) => {\n        const { currentBlockInfo: { onClick = event => handleAction(TreeItemActionType.HandleClickItemTitle, {}, refComponent), onDoubleClick = event => {\n            if (!disableDoubleClickTitle) {\n                handleAction(TreeItemActionType.HandleDoubleClickItemTitle, {}, refComponent);\n            }\n        } } } = actionData;\n        const { itemJsons, singleLineText, searchedText, itemJsons: [{ itemStateTitle, itemStateEditingText }], handleAction, theme, disableDoubleClickTitle } = refComponent.props;\n        const isFolder = handleAction(TreeItemActionType.IsFolder, {\n            draggingItemJsons: null,\n            targetItemJsons: itemJsons\n        }, refComponent);\n        let inputRef = null;\n        if (typeof itemStateEditingText === 'string') {\n            const debounceFunc = lodash.debounce(() => {\n                focusElementInKeyboardMode(inputRef, true);\n            }, 50);\n            debounceFunc();\n        }\n        // get formatted title html\n        const formattedTitle = searchedText ? itemStateTitle.replace(new RegExp(`(${searchedText})`, 'gi'), '<strong>$1</strong>') : itemStateTitle;\n        const formattedTitleHTML = refComponent.sanitizer.sanitize(formattedTitle);\n        return (jsx(\"div\", { className: 'jimu-tree-item__title', onClick: onClick, onDoubleClick: onDoubleClick, css: getStyle }, typeof itemStateEditingText === 'string'\n            ? (jsx(TextInput, { size: 'sm', ref: ref => { inputRef = ref; }, className: 'jimu-tree-item__editing-input', value: itemStateEditingText, onChange: (evt) => {\n                    const itemStateEditingText = evt.target.value;\n                    handleAction(TreeItemActionType.HandleEditingTextChange, { itemStateEditingText }, refComponent);\n                }, onBlur: (evt) => {\n                    const itemStateEditingText = evt.target.value;\n                    handleAction(TreeItemActionType.HandleExitEditing, { itemStateEditingText }, refComponent);\n                } }))\n            : jsx(\"div\", { className: 'jimu-tree-item__title-text', title: itemStateTitle, dangerouslySetInnerHTML: { __html: formattedTitleHTML } })));\n        function getStyle() {\n            const hoverOutline = `${isFolder && !itemStateEditingText ? 1 : 0}px solid ${theme.ref.palette.neutral[700]}`;\n            return css `\r\n          &.jimu-tree-item__title {\r\n            display: flex;\r\n            flex: 1;\r\n            align-items: center;\r\n            &:hover {\r\n              outline: ${hoverOutline};\r\n              outline-offset: 2px;\r\n            }\r\n            > .jimu-tree-item__title-text {\r\n              overflow: hidden;\r\n              text-overflow: ellipsis;\r\n              display: -webkit-box;\r\n              -webkit-box-orient: vertical;\r\n              word-break: break-word;\r\n              -webkit-line-clamp: ${singleLineText ? 1 : 2};\r\n            }\r\n          }\r\n        `;\n        }\n    },\n    renderOverrideItemCommands: (actionData, refComponent) => {\n        const { currentBlockInfo: { commandListProps = {} } } = actionData;\n        const { itemJsons, itemJsons: [{ itemStateCommands = [] }], handleAction } = refComponent.props;\n        return (jsx(CommandList, Object.assign({ className: 'jimu-tree-item__commands', itemCommands: itemStateCommands, data: { refComponent, itemJsons }, onClickItemCommand: (commandActionData) => { handleAction(TreeItemActionType.OnClickItemCommand, commandActionData, refComponent); }, css: getStyle }, commandListProps)));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__commands {\r\n            display: flex;\r\n            flex: none;\r\n            align-items: center;\r\n          }\r\n        `;\n        }\n    },\n    renderOverrideItemDraggableContainer: (actionData, refComponent) => {\n        return (jsx(\"div\", { ref: refComponent.dragRef, className: 'jimu-tree-item__draggable', \"data-dndzone-draggable\": 'true' }, refComponent.renderChildBlocks(actionData, refComponent)));\n    },\n    renderOverrideItemMainLine: (actionData, refComponent) => {\n        return (jsx(\"div\", { className: classNames('jimu-tree-item__main-line', { 'pl-2': !refComponent.props.dndEnabled }), css: getStyle }, refComponent.renderChildBlocks(actionData, refComponent)));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__main-line {\r\n            display: flex;\r\n            flex: 1;\r\n            align-items: center;\r\n          }\r\n        `;\n        }\n    },\n    renderOverrideItemDetailLine: (actionData, refComponent) => {\n        const { itemJsons: [{ itemStateDetailVisible, itemStateDetailContent }] } = refComponent.props;\n        return (itemStateDetailVisible &&\n            jsx(\"div\", { className: 'jimu-tree-item__detail-line', css: getStyle, \"aria-expanded\": true }, itemStateDetailContent));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__detail-line {\r\n            display: flex;\r\n            flex: 0 0 100%;\r\n          }\r\n        `;\n        }\n    },\n    renderOverrideItemBody: (actionData, refComponent) => {\n        const { handleAction, isMultiSelection, checkboxLinkage, itemJsons: [{ itemStateTitle, itemStateChecked, isItemSelectable = true, itemExpandIconShown = false, isCheckboxDisabled, itemChildren }] } = refComponent.props;\n        // const showSquireMark = refComponent.context.isTree && itemStateChecked && ((isMultiSelection && !checkboxLinkage) || !isMultiSelection)\n        const showSquireMark = treeUtils.showSquireMark(refComponent.context.isTree, isMultiSelection, refComponent.context.selectionStyle, itemStateChecked, checkboxLinkage);\n        let _isItemSelectable = isItemSelectable;\n        // Update selectable for parentNodes in this case.\n        if (refComponent.context.isTree && isMultiSelection && checkboxLinkage) {\n            if ((itemChildren === null || itemChildren === void 0 ? void 0 : itemChildren.length) > 0 || itemExpandIconShown) {\n                _isItemSelectable = false;\n            }\n            else {\n                _isItemSelectable = true;\n            }\n        }\n        const bodyClassName = [\n            'jimu-tree-item__body',\n            `jimu-tree-item_selectable_${_isItemSelectable}`,\n            `jimu-tree-item_squire_${showSquireMark}`\n        ].join(' ');\n        return (jsx(\"div\", { className: bodyClassName, role: 'treeitem', tabIndex: 0, \"aria-label\": itemStateTitle, onClick: (evt) => { handleAction(TreeItemActionType.HandleClickItemBody, { isMultiSelection, checkboxLinkage, isItemSelectable: _isItemSelectable, itemStateChecked: !itemStateChecked, isCheckboxDisabled }, refComponent); }, onKeyDown: evt => {\n                if (treeUtils.shouldHandleKeyEvent(evt)) {\n                    evt.preventDefault();\n                }\n            }, onKeyUp: evt => {\n                if (treeUtils.shouldHandleKeyEvent(evt)) {\n                    evt.preventDefault();\n                    handleAction(TreeItemActionType.HandleClickItemBody, { isMultiSelection, checkboxLinkage, isItemSelectable: _isItemSelectable, itemStateChecked: !itemStateChecked, isCheckboxDisabled }, refComponent);\n                }\n            }, css: getStyle },\n            showSquireMark && jsx(\"div\", { className: 'item-active-icon-container item-active-icon-container456' },\n                jsx(\"div\", { className: 'item-active-icon' })),\n            refComponent.renderChildBlocks(actionData, refComponent)));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__body {\r\n            position: relative;\r\n            display: flex;\r\n            flex-flow: row wrap;\r\n            flex: 1;\r\n            align-items: center;\r\n          }\r\n        `;\n        }\n    },\n    renderOverrideItemContent: (actionData, refComponent) => {\n        var _a;\n        const { itemJsons, handleAction, isMultiSelection, checkboxLinkage, treeAlignmentType, itemJsons: [{ itemStateChecked, indeterminate, isCheckboxDisabled, itemExpandIconShown = false, itemStateTitle, itemChildren }] } = refComponent.props;\n        const [, ...parentItemJsons] = itemJsons;\n        const showExpandIcon = itemExpandIconShown || ((_a = treeUtils.getItemChildren(itemJsons)) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        const level = treeAlignmentType === TreeAlignmentType.Typical ? (parentItemJsons.length - (showExpandIcon ? 1 : 0)) : (parentItemJsons.length - 1);\n        const levelPadding = 1.25 * level + 'rem';\n        const isFolder = handleAction(TreeItemActionType.IsFolder, {\n            draggingItemJsons: null,\n            targetItemJsons: itemJsons\n        }, refComponent);\n        const disabled = isCheckboxDisabled || (refComponent.context.isTree && isFolder && (!itemChildren || (itemChildren === null || itemChildren === void 0 ? void 0 : itemChildren.length) === 0) && itemJsons.length === 2);\n        const showCheckbox = treeUtils.showCheckbox(refComponent.context.isTree, isMultiSelection, checkboxLinkage);\n        return (jsx(\"div\", { className: 'jimu-tree-item__content', css: getStyle },\n            showCheckbox && treeAlignmentType === TreeAlignmentType.Typical && jsx(\"div\", { className: classNames('d-flex def align-items-center', { 'pr-1': !refComponent.context.multiLevel }) },\n                jsx(Checkbox, { \"aria-label\": itemStateTitle, checked: itemStateChecked, indeterminate: indeterminate, disabled: disabled, onChange: evt => {\n                        evt.stopPropagation();\n                        if (disabled)\n                            return;\n                        handleAction(TreeItemActionType.HandleCheckboxChanged, { itemStateChecked: evt.target.checked }, refComponent);\n                    } })),\n            refComponent.context.multiLevel && jsx(\"div\", { className: 'jimu-tree-item__level-padding', style: { width: levelPadding } }),\n            refComponent.renderChildBlocks(actionData, refComponent)));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__content {\r\n            display: flex;\r\n            flex: 1;\r\n          }\r\n        `;\n        }\n    },\n    renderOverrideItemDroppableContainer: (actionData, refComponent) => {\n        const renderContent = (children) => {\n            return refComponent.context.isTree // use listGroup for all nodes of tree.\n                ? (jsx(ListGroupItem, { className: 'jimu-tree-item__list-group-item' }, children))\n                : children;\n        };\n        return (jsx(\"div\", { ref: refComponent.dropZoneRef, className: 'jimu-tree-item__droppable', \"data-dndzone-droppable\": 'true', css: getStyle }, renderContent(refComponent.renderChildBlocks(actionData, refComponent))));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__droppable {\r\n            .jimu-tree-item__list-group-item {\r\n              padding: 0;\r\n              background: unset;\r\n              border: none;\r\n              display: flex;\r\n              flex: 1;\r\n            }\r\n          }\r\n        `;\n        }\n    },\n    renderOverrideItemSubitems: (actionData, refComponent) => {\n        const { itemJsons: [{ itemStateExpanded, itemStateDisabled }], children } = refComponent.props;\n        if (itemStateDisabled) {\n            return null;\n        }\n        return Array.isArray(children) && children.length > 0 && (jsx(Collapse, { className: 'jimu-tree-item__subitems', isOpen: !!itemStateExpanded, role: 'group', css: getStyle }, itemStateExpanded && children));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-item__subitems {\r\n            display: flex;\r\n            flex: 0 0 100%;\r\n            flex-flow: wrap;\r\n          }\r\n        `;\n        }\n    },\n    renderOverrideItem: (actionData, refComponent) => {\n        const { currentBlockInfo: { additionalClassName = '' } } = actionData;\n        const { className, theme, dndEnabled, isMultiSelection, checkboxLinkage, showRemoveIconForDisabledItem, itemJsons: [{ itemStateDisabled, itemStateChecked }], handleAction, treeStyle } = refComponent.props;\n        const foundSearchText = handleAction(TreeItemActionType.HandleFindSearchText, {}, refComponent);\n        const isItemDisplayable = handleAction(TreeItemActionType.IsItemDisplayable, {}, refComponent);\n        const focused = !!itemStateChecked;\n        const disabled = !!itemStateDisabled;\n        const currentClassName = [\n            additionalClassName,\n            className,\n            'jimu-tree-item',\n            'jimu-tree-item_template',\n            `jimu-tree-item_template-${treeStyle.toLowerCase()}`,\n            `jimu-tree-item_dnd-${dndEnabled}`,\n            `jimu-tree-item_focused-${focused}`,\n            `jimu-tree-item_disabled-${!!disabled}`\n        ].join(' ');\n        return (jsx(\"div\", { className: `jimu-tree-item ${currentClassName}`, css: getStyle, style: { display: foundSearchText && isItemDisplayable ? undefined : 'none' } },\n            refComponent.renderChildBlocks(actionData, refComponent),\n            disabled && jsx(\"div\", { className: 'jimu-tree-item__mask' }, showRemoveIconForDisabledItem &&\n                jsx(Tooltip, { title: refComponent.intl.formatMessage({ id: 'delete', defaultMessage: jimuCoreMsg.delete }) },\n                    jsx(Button, { icon: true, type: 'default', size: 'sm', className: 'mr-1', onClick: (evt) => {\n                            evt.stopPropagation();\n                            handleAction(TreeItemActionType.HandleDisabledItemRemoved, {}, refComponent);\n                        } },\n                        jsx(CloseOutlined, null))))));\n        function getStyle() {\n            const { size = 'default' } = refComponent.props;\n            const paddingBySize = size === 'default' ? 6 : size === 'sm' ? 3 : 10;\n            let paddingBySizeForBasic;\n            if (isMultiSelection && checkboxLinkage) {\n                paddingBySizeForBasic = size === 'default' ? 6 : size === 'sm' ? 4 : 11;\n            }\n            else {\n                paddingBySizeForBasic = size === 'default' ? 2 : size === 'sm' ? 0 : 6;\n            }\n            return css `\r\n          &.jimu-tree-item {\r\n            position: relative;\r\n            display: flex;\r\n            flex: 0 0 100%;\r\n            flex-flow: wrap;\r\n            user-select: none;\r\n            &.jimu-tree-item_focused-true {\r\n              .jimu-tree-item__body {\r\n                &:after {\r\n                  content: '';\r\n                  position: absolute;\r\n                  top: 0;\r\n                  left: 0;\r\n                  bottom: 0;\r\n                }\r\n              }\r\n            }\r\n            &.jimu-tree-item_disabled-true {\r\n              .jimu-tree-item__droppable{\r\n                opacity: .7;\r\n                background-color: ${window.jimuConfig.isBuilder ? theme.ref.palette.neutral[400] : 'unset'};\r\n              }\r\n              .jimu-tree-item__mask {\r\n                position: absolute;\r\n                width: 100%;\r\n                height: calc(100% - 0.25rem);\r\n                display: flex;\r\n                align-items: center;\r\n                justify-content: flex-end;\r\n              }\r\n            }\r\n            &.jimu-tree-item_dnd-true {\r\n              [data-dndzone-draggable=true]:hover {\r\n                cursor: pointer !important;\r\n                .jimu-tree-item__drag-handle {\r\n                  opacity: 1;\r\n                }\r\n              }\r\n            }\r\n            [data-dndzone-draggable=true] {\r\n              display: flex;\r\n              flex: 0 0 100%;\r\n              font-weight: 400;\r\n              touch-action: none;\r\n              &[data-dndon-dragging=true]{\r\n                opacity: 0;\r\n              }\r\n            }\r\n            [data-dndzone-droppable=true] {\r\n              display: flex;\r\n              flex: 0 0 100%;\r\n              border: 2px solid transparent; /** space for focus ring */\r\n              &[data-dndon-droppable=true] {\r\n                border-color: transparent;\r\n                &[data-dndon-drop-type=to-top] {\r\n                  .jimu-tree-item__body {\r\n                    box-shadow: 0 -2px 0 0 ${theme.sys.color.primary.main};\r\n                  }\r\n                }\r\n                &[data-dndon-drop-type=to-bottom] {\r\n                  .jimu-tree-item__body {\r\n                    box-shadow: 0 2px 0 0 ${theme.sys.color.primary.main};\r\n                  }\r\n                }\r\n                &[data-dndon-drop-type=to-inside] {\r\n                  .jimu-tree-item__body {\r\n                    outline: 2px solid ${theme.sys.color.primary.main};\r\n                    outline-offset: -2px;\r\n                  }\r\n                }\r\n                &[data-dndon-drop-type=to-nowhere] {\r\n                  opacity: .2;\r\n                }\r\n              }\r\n            }\r\n          }\r\n          &.jimu-tree-item_template {\r\n            padding-top: 0.25rem;\r\n            &:first-of-type {\r\n              padding-top: 0;\r\n            }\r\n            .jimu-tree-item__detail-line {\r\n            }\r\n            .jimu-tree-item__body {\r\n              line-height: 1.3;\r\n              &:hover {\r\n              }\r\n              &:focus {\r\n                outline-offset: 0;\r\n              }\r\n            }\r\n            .jimu-tree-item__drag-handle {\r\n              opacity: 0;\r\n              &:focus {\r\n                outline-offset: 1px;\r\n                opacity: 1;\r\n              }\r\n            }\r\n            .jimu-tree-item__children-toggle,\r\n            .jimu-tree-item__drag-handle,\r\n            .jimu-tree-item__detail-toggle,\r\n            .jimu-tree-item__icon {\r\n              padding: 0 .125rem;\r\n            }\r\n          }\r\n\r\n          &.jimu-tree-item_template-basic {\r\n            .jimu-tree-item__subitems .jimu-tree-item_template-basic:first-of-type {\r\n              padding-top: 0.25rem;\r\n            }\r\n            .jimu-tree-item__content {\r\n              color: ${theme.ref.palette.black};\r\n            }\r\n\r\n            /*\r\n            Can't add bgColor for the whole item since it could contain sub-items.\r\n              &:hover {\r\n                background-color: '';\r\n              }\r\n            */\r\n            .jimu-tree-item__body {\r\n              &:hover {\r\n                background-color: ${window.jimuConfig.isBuilder ? theme.ref.palette.neutral[500] : theme.ref.palette.neutral[200]};\r\n              }\r\n\r\n              &.jimu-tree-item_selectable_true {\r\n                border: ${dndEnabled ? '1px solid transparent' : 'none'};\r\n              }\r\n              &.jimu-tree-item_selectable_false {\r\n                background: ${window.jimuConfig.isBuilder ? theme.ref.palette.neutral[500] : theme.ref.palette.neutral[200]};\r\n                opacity: .5;\r\n              }\r\n              .jimu-tree-item__main-line {\r\n                padding: ${polished.rem(paddingBySizeForBasic)} 0.5rem ${polished.rem(paddingBySizeForBasic)} 0.125rem;\r\n              }\r\n            }\r\n          }\r\n\r\n          &.jimu-tree-item_template-card {\r\n            &.jimu-tree-item_focused-true {\r\n              .jimu-tree-item__body {\r\n                &:after {\r\n                  // Only for List & Single\r\n                  border-left: ${(!refComponent.context.isTree && !isMultiSelection) ? `.125rem solid ${theme.sys.color.primary.light}` : 'none'} ;\r\n                }\r\n                .item-active-icon-container {\r\n                  position: absolute;\r\n                  top: -1px;\r\n                  right: -1px;\r\n                  .item-active-icon {\r\n                    width: 0;\r\n                    height: 0;\r\n                    border-top: 0.75rem ${theme.sys.color.primary.light} solid;\r\n                    border-left: 0.75rem transparent solid;\r\n                    background-color: transparent;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            .jimu-tree-item__subitems .jimu-tree-item_template-card:first-of-type {\r\n              padding-top: 0.25rem;\r\n            }\r\n            .jimu-tree-item__content {\r\n              color: ${theme.ref.palette.black};\r\n            }\r\n            .jimu-tree-item__body {\r\n              background-color: ${window.jimuConfig.isBuilder ? theme.ref.palette.neutral[600] : 'unset'};\r\n              &.jimu-tree-item_selectable_true {\r\n                border: ${window.jimuConfig.isBuilder ? 'none' : `1px solid ${theme.ref.palette.neutral[300]}`};\r\n                &.jimu-tree-item_squire_true {\r\n                  border: 1px solid ${theme.sys.color.primary.main};\r\n                }\r\n                &:hover {\r\n                  background-color: ${window.jimuConfig.isBuilder ? polished.rgba(theme.ref.palette.neutral[600], 0.8) : theme.ref.palette.neutral[200]};\r\n                }\r\n              }\r\n              .jimu-tree-item__main-line {\r\n                padding: ${polished.rem(paddingBySize)} 0.5rem ${polished.rem(paddingBySize)} 0.125rem;\r\n              }\r\n            }\r\n            &.jimu-tree-item_disabled-false {\r\n              .jimu-tree-item__content .jimu-tree-item__body:hover {\r\n                cursor: default!important;\r\n                background-color: ${window.jimuConfig.isBuilder ? theme.ref.palette.neutral[600] : theme.ref.palette.neutral[200]};\r\n              }\r\n            }\r\n          }\r\n        `;\n        }\n    },\n    handleInitTreeItemDndDropZone: (actionData, refComponent) => {\n        const { type } = actionData;\n        if (type === 'mount') {\n            const interact = refComponent.dndInteract;\n            interact.dynamicDrop(true);\n            refComponent.dropZoneInteractable = interact(refComponent.dropZoneRef.current).dropzone({\n                accept: '[data-dndzone-draggable=true]',\n                overlap: 'pointer',\n                ondropmove: (dropEvent) => {\n                    const { target, relatedTarget } = dropEvent;\n                    const { itemJsons, itemJsons: [{ itemStateDisabled }], withStates, handleAction } = refComponent.props;\n                    const { searchForText } = withStates;\n                    const dragItemRect = relatedTarget.getBoundingClientRect();\n                    const dropItemRect = target.getBoundingClientRect();\n                    const dragStart = +relatedTarget.getAttribute('data-dndon-starty');\n                    const pointerY = dragItemRect.top + dragStart;\n                    const dragItem = handleAction(TreeItemActionType.GetDragItemJsons, { dragEvent: dropEvent.dragEvent }, refComponent);\n                    if (!dragItem) {\n                        return;\n                    }\n                    const [currentDragItemJson] = dragItem.itemJsons;\n                    const supportInside = refComponent.context.isTree && !itemStateDisabled;\n                    const allDropTypes = ['to-nowhere', 'to-top', ...(supportInside ? ['to-inside'] : []), 'to-bottom'];\n                    const dropType = allDropTypes.find((type, x, types) => {\n                        if (type === 'to-nowhere') {\n                            return itemJsons.includes(currentDragItemJson) || !!searchForText;\n                        }\n                        if (pointerY < dropItemRect.top + (dropItemRect.height * x) / (types.length - 1)) {\n                            return type;\n                        }\n                        return null;\n                    });\n                    let newDropType = dropType;\n                    if (refComponent.context.isTree && !itemStateDisabled && dropType !== 'to-nowhere') {\n                        /**\n                         * Two cases for tree:\n                         * 1. decided by current droppable value.\n                         * 2. decided by:  parents' > current\n                         */\n                        const isItemDroppable = handleAction(TreeItemActionType.IsItemDroppable, {\n                            draggingItemJsons: dragItem.itemJsons,\n                            targetItemJsons: itemJsons,\n                            dropType: newDropType\n                        }, refComponent);\n                        if (!isItemDroppable) {\n                            newDropType = 'to-nowhere';\n                        }\n                    }\n                    target.setAttribute('data-dndon-drop-type', newDropType);\n                },\n                ondragenter: (dropEvent) => {\n                    const { target } = dropEvent;\n                    target.setAttribute('data-dndon-droppable', 'true');\n                },\n                ondragleave: (dropEvent) => {\n                    const { target } = dropEvent;\n                    target.removeAttribute('data-dndon-droppable');\n                    target.removeAttribute('data-dndon-drop-type');\n                },\n                ondrop: (dropEvent) => {\n                    lodash.defer(() => {\n                        const { target } = dropEvent;\n                        const { itemJsons, handleAction } = refComponent.props;\n                        const dropType = dropEvent.target.getAttribute('data-dndon-drop-type');\n                        const dragItem = handleAction(TreeItemActionType.GetDragItemJsons, { dragEvent: dropEvent.dragEvent }, refComponent);\n                        handleAction(TreeItemActionType.SetDragItemJsons, { itemJsons, dragEvent: dropEvent.dragEvent, type: 'dragend' }, refComponent);\n                        handleAction(TreeItemActionType.HandleDidDrop, { dropType, dragItem }, refComponent);\n                        target.removeAttribute('data-dndon-droppable');\n                        target.removeAttribute('data-dndon-drop-type');\n                    });\n                }\n            });\n        }\n        if (type === 'unmount') {\n            if (refComponent.dropZoneInteractable) {\n                refComponent.dropZoneInteractable.unset();\n                refComponent.dropZoneInteractable = null;\n            }\n        }\n    },\n    handleInitTreeItemDndDrag: (actionData, refComponent) => {\n        const { type } = actionData;\n        if (type === 'mount') {\n            const interact = refComponent.dndInteract;\n            refComponent.dragInteractable = interact(refComponent.dragRef.current).draggable({\n                inertia: false,\n                modifiers: [],\n                autoScroll: { container: document.getElementById(refComponent.context.uuid) },\n                onstart: (dragEvent) => {\n                    if (treeUtils.isTitleEditing(dragEvent)) {\n                        return;\n                    }\n                    refComponent.dragTriggered = true;\n                    const { target, clientX, clientY } = dragEvent;\n                    target.style.position = 'fixed';\n                    const { itemJsons, handleAction } = refComponent.props;\n                    handleAction(TreeItemActionType.SetDragItemJsons, { itemJsons, dragEvent, type: 'dragstart' }, refComponent);\n                    const dragItemRect = target.getBoundingClientRect();\n                    target.setAttribute('data-dndon-limitx', Math.abs(dragItemRect.right - dragItemRect.left) / 2);\n                    target.setAttribute('data-dndon-startx', clientX - dragItemRect.left);\n                    target.setAttribute('data-dndon-starty', clientY - dragItemRect.top);\n                    target.setAttribute('data-dndon-dragging', 'true');\n                },\n                onmove: (dragEvent) => {\n                    if (treeUtils.isTitleEditing(dragEvent)) {\n                        return;\n                    }\n                    const { target, clientX, clientY, clientX0, clientY0 } = dragEvent;\n                    let translateX = clientX - clientX0;\n                    const limitX = target.getAttribute('data-dndon-limitx');\n                    if (translateX > 0) {\n                        translateX = Math.min(translateX, limitX);\n                    }\n                    else {\n                        translateX = Math.max(translateX, -limitX);\n                    }\n                    const translateY = clientY - clientY0;\n                    target.style.webkitTransform = target.style.transform = `translate(${translateX}px, ${translateY}px)`;\n                },\n                onend: (dragEvent) => {\n                    if (treeUtils.isTitleEditing(dragEvent)) {\n                        return;\n                    }\n                    const { target } = dragEvent;\n                    target.style.position = null;\n                    target.style.webkitTransform = target.style.transform = '';\n                    target.removeAttribute('data-dndon-startx');\n                    target.removeAttribute('data-dndon-starty');\n                    target.removeAttribute('data-dndon-dragging');\n                }\n            }).on('click', (event) => { if (refComponent.dragTriggered)\n                event.stopImmediatePropagation(); refComponent.dragTriggered = false; });\n        }\n        if (type === 'unmount') {\n            if (refComponent.dragInteractable) {\n                refComponent.dragInteractable.unset();\n                refComponent.dragInteractable = null;\n            }\n        }\n    },\n    handleDidDrop: (actionData, refComponent) => {\n        const { itemJsons } = refComponent.props;\n        const { dropType, dragItem } = actionData;\n        const allDropTypes = ['to-top', 'to-inside', 'to-bottom'];\n        if (allDropTypes.includes(dropType)) {\n            const dragItemJsons = dragItem.itemJsons;\n            const dropItemJsons = itemJsons;\n            const [dragItemJson] = dragItemJsons;\n            const [dropItemJson] = dropItemJsons;\n            const dragItemParentChildren = treeUtils.getItemChildren(dragItemJsons.slice(1));\n            const dropItemParentChildren = treeUtils.getItemChildren(dropItemJsons.slice(1));\n            const dropItemChildren = treeUtils.getItemChildren(dropItemJsons);\n            const dragItemIndex = dragItemParentChildren.indexOf(dragItemJson);\n            const targetDropItemJsons = dropType === 'to-inside' ? dropItemJsons : dropItemJsons.slice(1);\n            let targetDropItemIndex = dropType === 'to-top'\n                ? dropItemParentChildren.indexOf(dropItemJson)\n                : dropType === 'to-bottom'\n                    ? dropItemParentChildren.indexOf(dropItemJson) + 1\n                    : (dropItemChildren || []).length;\n            const targetDropItemChildren = treeUtils.getItemChildren(targetDropItemJsons);\n            targetDropItemIndex = targetDropItemIndex + (dragItemParentChildren === targetDropItemChildren && dragItemIndex < targetDropItemIndex ? -1 : 0);\n            const muteUpdate = (actionData, refComponent) => {\n                const { dragItemParentChildren, dragItemJson, dragItemIndex, targetDropItemChildren, targetDropItemJsons, targetDropItemIndex } = actionData;\n                dragItemParentChildren.splice(dragItemIndex, 1);\n                if (targetDropItemChildren) {\n                    targetDropItemChildren.splice(targetDropItemIndex, 0, dragItemJson);\n                }\n                else {\n                    const [currentItemJson] = targetDropItemJsons;\n                    currentItemJson.itemChildren = [dragItemJson];\n                }\n            };\n            let updateItemActionData = {\n                updateType: TreeItemActionType.HandleDidDrop,\n                parentDragItemJsons: dragItemJsons.slice(1),\n                dragItemParentChildren,\n                dragItemIndex,\n                dragItemJsons,\n                dragItemJson,\n                targetDropItemJsons,\n                targetDropItemChildren,\n                targetDropItemIndex,\n                dropType,\n                itemJsons,\n                muteUpdate\n            };\n            muteUpdate(updateItemActionData, refComponent);\n            const nextItemJsons = treeUtils.getItemJsonsWithCheckState(updateItemActionData, refComponent);\n            if (nextItemJsons) {\n                updateItemActionData = Object.assign(updateItemActionData, { itemJsons: [...itemJsons.slice(0, itemJsons.length - 1), nextItemJsons] });\n            }\n            refComponent.props.handleAction(TreeItemActionType.HandleUpdateItem, updateItemActionData, refComponent);\n        }\n        refComponent.props.handleAction(TreeItemActionType.OnDidDrop, actionData, refComponent);\n    },\n    handleDisabledItemRemoved: (actionData, refComponent) => {\n        const { itemJsons } = refComponent.props;\n        const dragItemJsons = itemJsons;\n        const [dragItemJson] = dragItemJsons;\n        const dragItemParentChildren = treeUtils.getItemChildren(dragItemJsons.slice(1));\n        const dragItemIndex = dragItemParentChildren.indexOf(dragItemJson);\n        const muteUpdate = (actionData, refComponent) => {\n            dragItemParentChildren.splice(dragItemIndex, 1);\n        };\n        const updateType = TreeItemActionType.HandleDisabledItemRemoved;\n        const updateItemActionData = {\n            updateType,\n            itemJsons\n        };\n        muteUpdate(updateItemActionData, refComponent);\n        refComponent.props.handleAction(TreeItemActionType.HandleUpdateItem, updateItemActionData, refComponent);\n    },\n    handleToggleDetail: (actionData, refComponent) => {\n        const { itemStateDetailVisible } = actionData;\n        const { itemJsons } = refComponent.props;\n        const [currentItemJson] = itemJsons;\n        refComponent.props.handleAction(TreeItemActionType.HandleUpdateItem, {\n            updateType: TreeItemActionType.HandleToggleDetail,\n            changeItemJson: { itemStateDetailVisible },\n            currentItemJson,\n            itemJsons\n        }, refComponent);\n        refComponent.props.handleAction(TreeItemActionType.OnToggleDetail, actionData, refComponent);\n    },\n    handleExpandItem: (actionData, refComponent) => {\n        const { itemStateExpanded } = actionData;\n        const { itemJsons } = refComponent.props;\n        const [currentItemJson] = itemJsons;\n        refComponent.props.handleAction(TreeItemActionType.HandleUpdateItem, {\n            updateType: TreeItemActionType.HandleExpandItem,\n            changeItemJson: { itemStateExpanded },\n            currentItemJson,\n            itemJsons\n        }, refComponent);\n        refComponent.props.handleAction(TreeItemActionType.OnExpandItem, actionData, refComponent);\n    },\n    handleEditingTextChange: (actionData, refComponent) => {\n        const { itemStateEditingText } = actionData;\n        const { itemJsons } = refComponent.props;\n        const [currentItemJson] = itemJsons;\n        refComponent.props.handleAction(TreeItemActionType.HandleUpdateItem, {\n            updateType: TreeItemActionType.HandleEditingTextChange,\n            changeItemJson: { itemStateEditingText: itemStateEditingText || '' },\n            currentItemJson,\n            itemJsons\n        }, refComponent);\n        refComponent.props.handleAction(TreeItemActionType.OnEditingTextChange, actionData, refComponent);\n    },\n    handleExitEditing: (actionData, refComponent) => {\n        const { itemStateEditingText } = actionData;\n        const { itemJsons } = refComponent.props;\n        const [currentItemJson] = itemJsons;\n        refComponent.props.handleAction(TreeItemActionType.HandleUpdateItem, {\n            updateType: TreeItemActionType.HandleExitEditing,\n            changeItemJson: { itemStateEditingText: null, itemStateTitle: itemStateEditingText || '' },\n            currentItemJson,\n            itemJsons\n        }, refComponent);\n        refComponent.props.handleAction(TreeItemActionType.OnExitEditing, actionData, refComponent);\n    },\n    handleFindSearchText: (actionData, refComponent) => {\n        const { itemJsons: [{ itemKey }], withStates: { searchForText } } = refComponent.props;\n        return (itemKey || '').match(searchForText || '');\n    },\n    isItemDisplayable: (actionData, refComponent) => {\n        return true;\n    },\n    handleClickItemBody: (actionData, refComponent) => {\n        const { itemStateChecked, isItemSelectable, isCheckboxDisabled, isMultiSelection, checkboxLinkage } = actionData;\n        if (!isItemSelectable || isCheckboxDisabled) {\n            refComponent.props.handleAction(TreeItemActionType.OnClickItemBody, {}, refComponent);\n            return;\n        }\n        if (treeUtils.showCheckbox(refComponent.context.isTree, isMultiSelection, checkboxLinkage)) {\n            actionData.isTriggeredByBodyClick = true;\n            refComponent.props.handleAction(TreeItemActionType.HandleCheckboxChanged, actionData, refComponent);\n            return;\n        }\n        else {\n            const { itemJsons } = refComponent.props;\n            const [currentItemJson] = itemJsons;\n            let newActionData = {\n                updateType: TreeItemActionType.HandleCheckboxChanged,\n                changeItemJson: { itemStateChecked: itemStateChecked || false },\n                currentItemJson,\n                itemJsons\n            };\n            newActionData = treeUtils.getActionDataByRadioActionData(refComponent.context.isTree, isMultiSelection, newActionData);\n            refComponent.props.handleAction(TreeItemActionType.OnUpdateItem, newActionData, refComponent);\n        }\n        refComponent.props.handleAction(TreeItemActionType.OnClickItemBody, {}, refComponent);\n        // lodash.defer(() => {\n        //   refComponent.props.handleAction(TreeItemActionType.OnClickItemBody, {}, refComponent)\n        // }, 1000)\n    },\n    handleDoubleClickItemTitle: (actionData, refComponent) => {\n        const { itemJsons: [{ itemStateTitle }] } = refComponent.props;\n        refComponent.props.handleAction(TreeItemActionType.HandleStartEditing, { itemStateEditingText: itemStateTitle }, refComponent);\n        refComponent.props.handleAction(TreeItemActionType.OnDoubleClickItemTitle, actionData, refComponent);\n    },\n    /**\n     * There are three states of item:\n     * Checked:       current item is checked\n     * Unchecked:     none of children is checked\n     * indeterminate: some of children are checked\n     * disabled:  current item is disabled, always Uncheck.\n     */\n    handleCheckboxChanged: (actionData, refComponent) => {\n        const { itemStateChecked, isTriggeredByBodyClick, isMultiSelection } = actionData;\n        const { itemJsons } = refComponent.props;\n        const [currentItemJson] = itemJsons;\n        let newActionData = {\n            updateType: TreeItemActionType.HandleCheckboxChanged,\n            changeItemJson: { itemStateChecked: itemStateChecked || false },\n            currentItemJson,\n            itemJsons\n        };\n        if (refComponent.context.selectionStyle === TreeSelectionStyle.CheckSelection) {\n            newActionData = treeUtils.getActionDataByRadioActionData(refComponent.context.isTree, isMultiSelection, newActionData);\n        }\n        else {\n            newActionData = treeUtils.getActionDataByCBXActionData(refComponent.context.isTree, newActionData);\n        }\n        refComponent.props.handleAction(TreeItemActionType.OnUpdateItem, newActionData, refComponent);\n        if (isTriggeredByBodyClick) {\n            refComponent.props.handleAction(TreeItemActionType.OnClickItemBody, newActionData, refComponent);\n        }\n    },\n    handleStartEditing: (actionData, refComponent) => {\n        const { itemStateEditingText } = actionData;\n        const { itemJsons } = refComponent.props;\n        const [currentItemJson] = itemJsons;\n        refComponent.props.handleAction(TreeItemActionType.HandleUpdateItem, {\n            updateType: TreeItemActionType.HandleStartEditing,\n            changeItemJson: { itemStateEditingText: itemStateEditingText || '' },\n            currentItemJson,\n            itemJsons\n        }, refComponent);\n    },\n    handleUpdateItem: (actionData, refComponent) => {\n        if (actionData.changeItemJson) {\n            actionData = treeUtils.getActionDataByChangeJson(refComponent.context.isTree, actionData);\n        }\n        refComponent.props.handleAction(TreeItemActionType.OnUpdateItem, actionData, refComponent);\n    },\n    isItemDroppable: (actionData, refComponent) => {\n        return true;\n    },\n    isFolder: (actionData, refComponent) => {\n        return false;\n    },\n    getDragItemJsons: null,\n    setDragItemJsons: null,\n    handleClickItemTitle: null,\n    handleFocusItem: null,\n    onToggleDetail: null,\n    onExpandItem: null,\n    /**\n     * @ignore\n     */\n    onEditingTextChange: null,\n    /**\n     * @ignore\n     */\n    onExitEditing: null,\n    onDidDrop: null,\n    onClickItemBody: null,\n    onDoubleClickItemTitle: null,\n    onClickItemCommand: null,\n    onUpdateItem: null\n};\n_TreeItem.itemBlockInfos = {\n    [TreeAlignmentType.Typical]: {\n        name: TreeItemActionType.RenderOverrideItem, // the tree item itself\n        children: [{\n                name: TreeItemActionType.RenderOverrideItemDroppableContainer, // the block that accepts release of an dragging tree item\n                children: [{\n                        name: TreeItemActionType.RenderOverrideItemContent, // the block that contains all item contents\n                        children: [{\n                                name: TreeItemActionType.RenderOverrideItemChildrenToggle // the block of the children toggle button\n                            }, {\n                                name: TreeItemActionType.RenderOverrideItemBody, // the block that contains all contents of the tree item itself\n                                children: [{\n                                        name: TreeItemActionType.RenderOverrideItemMainLine, // the block that contains all main contents of the tree item\n                                        children: [{\n                                                name: TreeItemActionType.RenderOverrideItemDraggableContainer, // the block that is draggable\n                                                children: [{\n                                                        name: TreeItemActionType.RenderOverrideItemDragHandle // the block of drag handle\n                                                    }, {\n                                                        name: TreeItemActionType.RenderOverrideItemDetailToggle // the block of detail contents toggle button\n                                                    }, {\n                                                        name: TreeItemActionType.RenderOverrideItemIcon // the block of tree item icon\n                                                    }, {\n                                                        name: TreeItemActionType.RenderOverrideItemTitle // the block of tree item title\n                                                    }, {\n                                                        name: TreeItemActionType.RenderOverrideItemCommands // the block of command items\n                                                    }]\n                                            }]\n                                    }, {\n                                        name: TreeItemActionType.RenderOverrideItemDetailLine // the block that contains all detail contents of the tree item\n                                    }]\n                            }]\n                    }]\n            }, {\n                name: TreeItemActionType.RenderOverrideItemSubitems // the children of the tree item(e.g. child tree items)\n            }]\n    },\n    [TreeAlignmentType.Intact]: {\n        name: TreeItemActionType.RenderOverrideItem, // the tree item itself\n        children: [{\n                name: TreeItemActionType.RenderOverrideItemDroppableContainer, // the block that accepts release of an dragging tree item\n                children: [{\n                        name: TreeItemActionType.RenderOverrideItemContent, // the block that contains all item contents\n                        children: [{\n                                name: TreeItemActionType.RenderOverrideItemBody, // the block that contains all contents of the tree item itself\n                                children: [{\n                                        name: TreeItemActionType.RenderOverrideItemMainLine, // the block that contains all main contents of the tree item\n                                        children: [{\n                                                name: TreeItemActionType.RenderOverrideItemDraggableContainer, // the block that is draggable\n                                                children: [{\n                                                        name: TreeItemActionType.RenderOverrideItemDragHandle // the block of drag handle\n                                                    }, {\n                                                        name: TreeItemActionType.RenderOverrideItemChildrenToggle // the block of the children toggle button\n                                                    }, {\n                                                        name: TreeItemActionType.RenderOverrideItemDetailToggle // the block of detail contents toggle button\n                                                    }, {\n                                                        name: TreeItemActionType.RenderOverrideItemIcon // the block of tree item icon\n                                                    }, {\n                                                        name: TreeItemActionType.RenderOverrideItemTitle // the block of tree item title\n                                                    }, {\n                                                        name: TreeItemActionType.RenderOverrideItemCommands // the block of command items\n                                                    }]\n                                            }]\n                                    }, {\n                                        name: TreeItemActionType.RenderOverrideItemDetailLine // the block that contains all detail contents of the tree item\n                                    }]\n                            }]\n                    }]\n            }, {\n                name: TreeItemActionType.RenderOverrideItemSubitems // the children of the tree item(e.g. child tree items)\n            }]\n    }\n};\n_TreeItem.defaultProps = Object.assign({ theme: {}, className: '', treeAlignmentType: TreeAlignmentType.Typical, treeStyle: TreeStyle.Card, dndEnabled: false, withStates: {}, handleAction: treeUtils.handleAction }, _TreeItem.defaultHandleActionMap);\n/**\n * The TreeItem component.\n *\n * ```ts\n * import { TreeItem } from 'jimu-ui/basic/list-tree'\n * ```\n */\nexport const TreeItem = withTheme(injectIntl(_TreeItem));\n","/** @jsx jsx */\nimport { React, jsx, css, getAppStore } from 'jimu-core';\nimport { TreeItemActionType, TreeMainActionType, TreeAlignmentType, TreeStyle } from './tree-types';\nimport * as treeUtils from './tree-utils';\nimport { TreeItem } from './tree-item';\nimport { TreeContext } from './tree-context';\nexport class TreeMain extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            dragItems: []\n        };\n    }\n    render() {\n        const treeMain = this.props.handleAction(TreeMainActionType.RenderOverrideMain, {}, this);\n        return treeMain;\n    }\n    renderItemJson(itemJsons) {\n        const { treeAlignmentType, treeStyle, collapseStyle, isMultiSelection, singleLineText, searchedText, checkboxLinkage, dndEnabled, disableDoubleClickTitle, withStates, size = 'default', showRemoveIconForDisabledItem } = this.props;\n        const [currentItemJson, ...parentItemJsons] = itemJsons;\n        const { itemKey, itemStateExpanded, itemStateEditingText } = currentItemJson;\n        const itemChildren = treeUtils.getItemChildren(itemJsons);\n        const level = parentItemJsons.length;\n        const expandable = !!itemChildren;\n        const className = [\n            'jimu-tree-main__item',\n            `jimu-tree-main__item_level-${level}`,\n            `jimu-tree-main__item_editing-${typeof itemStateEditingText === 'string'}`,\n            ...(!itemChildren\n                ? []\n                : [\n                    `jimu-tree-main__item_expandable-${expandable}`,\n                    `jimu-tree-main__item_expanded-${!!itemStateExpanded}`\n                ])\n        ].join(' ');\n        return (jsx(TreeItem, Object.assign({ key: itemKey, className: className, treeAlignmentType: treeAlignmentType, treeStyle: treeStyle, singleLineText: singleLineText, searchedText: searchedText, collapseStyle: collapseStyle, isMultiSelection: isMultiSelection, checkboxLinkage: checkboxLinkage, itemJsons: itemJsons, size: size, dndEnabled: dndEnabled, disableDoubleClickTitle: disableDoubleClickTitle, showRemoveIconForDisabledItem: showRemoveIconForDisabledItem, withStates: withStates }, Object.assign({}, ...Object.values(TreeItemActionType).map(actionKey => { var _a; return ({ [actionKey]: (_a = this.props[actionKey]) === null || _a === void 0 ? void 0 : _a.bind(this) }); }))), (itemChildren || []).map((subItemJson) => this.renderItemJson([subItemJson, ...itemJsons]))));\n    }\n}\nTreeMain.defaultHandleActionMap = {\n    renderOverrideMain: (actionData, refComponent) => {\n        var _a, _b, _c, _d;\n        const { className, topTag, isTree, uuid, rootItemVisible, rootItemJson, isMultiSelection, checkboxLinkage, treeStyle } = refComponent.props;\n        const itemChildren = rootItemJson ? treeUtils.getItemChildren([rootItemJson]) : null;\n        const multiLevel = ((_b = (_a = rootItemJson === null || rootItemJson === void 0 ? void 0 : rootItemJson.itemChildren) === null || _a === void 0 ? void 0 : _a.filter(child => { var _a; return ((_a = child === null || child === void 0 ? void 0 : child.itemChildren) === null || _a === void 0 ? void 0 : _a.length) > 0; })) === null || _b === void 0 ? void 0 : _b.length) > 0;\n        const TopTag = topTag;\n        const selectionStyle = treeUtils.getSelectionStyle(isTree, isMultiSelection, treeStyle, checkboxLinkage);\n        const isRTL = (_d = (_c = getAppStore().getState()) === null || _c === void 0 ? void 0 : _c.appContext) === null || _d === void 0 ? void 0 : _d.isRTL;\n        return (jsx(TreeContext.Provider, { value: { isTree, selectionStyle, multiLevel, uuid, isRTL } },\n            jsx(TopTag, { className: `jimu-tree-main ${className || ''}`, css: getStyle, role: 'tree' }, rootItemVisible\n                ? refComponent.renderItemJson([rootItemJson])\n                : (itemChildren || []).map((subItemJson) => jsx(React.Fragment, { key: subItemJson.itemKey }, refComponent.renderItemJson([subItemJson, rootItemJson]))))));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree-main {\r\n            width: 100%;\r\n            overflow-x: hidden;\r\n          }\r\n        `;\n        }\n    },\n    setDragItemJsons(actionData, refComponent) {\n        this.setState(({ dragItems }) => ({\n            dragItems: [...dragItems.filter(dragItem => dragItem.dragEvent.target !== actionData.dragEvent.target), ...(actionData.type === 'dragstart' ? [actionData] : [])]\n        }));\n    },\n    getDragItemJsons(actionData, refComponent) {\n        return this.state.dragItems.find(dragItem => dragItem.dragEvent.target === actionData.dragEvent.target);\n    }\n};\nTreeMain.defaultProps = Object.assign({ className: '', topTag: 'div', treeAlignmentType: TreeAlignmentType.Typical, singleLineText: false, treeStyle: TreeStyle.Card, rootItemVisible: false, dndEnabled: false, withStates: {}, handleAction: treeUtils.handleAction }, TreeMain.defaultHandleActionMap);\n","/** @jsx jsx */\nimport { React, jsx, css, Immutable, injectIntl } from 'jimu-core';\nimport { withTheme } from 'jimu-theme';\nimport { TreeActionType, TreeMainActionType, TreeItemActionType, TreeAlignmentType, TreeStyle } from './common/tree-types';\nimport * as treeUtils from './common/tree-utils';\nimport { TreeMain } from './common/tree-main';\n/**\n * The `Tree` component allows users to navigate complex data relationships by using multiple hierarchical structures.\n *\n * ```ts\n * import { Tree } from 'jimu-ui/basic/list-tree'\n * ```\n */\nexport class _Tree extends React.Component {\n    constructor(props) {\n        super(props);\n        _Tree.count++;\n        this.localRandomId = 'jimu-tree-' + _Tree.count;\n        this.state = {\n            searchForText: '',\n            filterEnabled: false\n        };\n    }\n    render() {\n        const tree = this.props.handleAction(TreeActionType.RenderOverride, {}, this);\n        return tree;\n    }\n}\n_Tree.count = -1;\n_Tree.defaultHandleActionMap = {\n    renderOverride: (actionData, refComponent) => {\n        var _a;\n        const { className, size, topTag, isTree = true, treeAlignmentType, collapseStyle, \n        /** eslint-disable-next-line @typescript-eslint/no-deprecated */\n        showCheckbox = true, isMultiSelection = true, checkboxLinkage = true, treeStyle, singleLineText, searchedText, disableDoubleClickTitle = false, rootItemJson, rootItemVisible, dndEnabled, showRemoveIconForDisabledItem, intl, forwardRef } = refComponent.props;\n        const { searchForText, filterEnabled } = refComponent.state;\n        const currentClassName = [\n            'jimu-tree',\n            className,\n            `jimu-tree_template-${treeStyle.toLowerCase()}`,\n            `jimu-tree_searched-text-${!!searchForText}`,\n            `jimu-tree_filter-enabled-${!!filterEnabled}`\n        ].join(' ');\n        let emptyListLabel = '';\n        if (!isTree && !(((_a = rootItemJson === null || rootItemJson === void 0 ? void 0 : rootItemJson.itemChildren) === null || _a === void 0 ? void 0 : _a.length) > 0)) {\n            emptyListLabel = intl.formatMessage({ id: 'emptyListWarning', defaultMessage: 'emptyListWarning' });\n        }\n        const TopTag = topTag;\n        return (jsx(TopTag, { ref: forwardRef, className: currentClassName, id: refComponent.localRandomId, tabIndex: -1, \"aria-label\": emptyListLabel, css: getStyle },\n            jsx(TreeMain, Object.assign({ className: '', uuid: refComponent.localRandomId, treeAlignmentType: treeAlignmentType, collapseStyle: collapseStyle, isMultiSelection: isMultiSelection !== null && isMultiSelection !== void 0 ? isMultiSelection : showCheckbox, checkboxLinkage: checkboxLinkage, treeStyle: treeStyle, singleLineText: singleLineText, searchedText: searchedText, topTag: TopTag, size: size, isTree: isTree, rootItemJson: rootItemJson, rootItemVisible: rootItemVisible, dndEnabled: dndEnabled, disableDoubleClickTitle: disableDoubleClickTitle, showRemoveIconForDisabledItem: showRemoveIconForDisabledItem, withStates: refComponent.state }, Object.assign({}, ...[...Object.values(TreeItemActionType), ...Object.values(TreeMainActionType)].map(k => { var _a; return ({ [k]: (_a = refComponent.props[k]) === null || _a === void 0 ? void 0 : _a.bind(refComponent) }); }))))));\n        function getStyle() {\n            return css `\r\n          &.jimu-tree {\r\n            display: flex;\r\n            flex-flow: wrap;\r\n            height: 100%;\r\n            overflow-y: auto;\r\n            &.jimu-tree_is-list-false {\r\n              .jimu-tree-search,\r\n              .jimu-tree-mod__widget_filter {\r\n                visibility: hidden;\r\n              }\r\n            }\r\n            &.jimu-tree_searched-text-true,\r\n            &.jimu-tree_filter-enabled-true {\r\n              .jimu-tree-mod__widget_add {\r\n                visibility: hidden;\r\n              }\r\n            }\r\n          }\r\n        `;\n        }\n    },\n    isItemDisplayable(actionData, refComponent) {\n        const { itemJsons: [{ itemStateChecked }] } = refComponent.props;\n        return this.state.filterEnabled ? !!itemStateChecked : true;\n    }\n};\n_Tree.defaultProps = Object.assign({ theme: Immutable({}), className: '', topTag: 'div', treeAlignmentType: TreeAlignmentType.Typical, treeStyle: TreeStyle.Card, rootItemVisible: false, dndEnabled: false, handleAction: treeUtils.handleAction }, _Tree.defaultHandleActionMap);\n/**\n * The `Tree` component allows users to navigate complex data relationships by using multiple hierarchical structures.\n *\n * ```ts\n * import { Tree } from 'jimu-ui/basic/list-tree'\n * ```\n */\nexport const Tree = withTheme(injectIntl(_Tree));\nexport { treeUtils };\n"],"names":[],"sourceRoot":""}