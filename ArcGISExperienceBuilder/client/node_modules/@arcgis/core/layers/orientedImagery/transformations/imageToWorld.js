/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{isArrayLike as e}from"../../../core/arrayUtils.js";import{clone as r,zeros as a}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{a as t}from"../../../chunks/vec32.js";import i from"../../../geometry/Point.js";import{fromPoints as o,fromValues as n}from"../../../geometry/support/ray.js";import{l as c,j as s}from"../../../chunks/sphere.js";import{isElevationSource as f}from"../core/ElevationSourceDefinitions.js";import{rectifyMapPoint as m,rectifyMapPointPanoramic as l}from"./rectifyMapPoint.js";import{or as p,isUpdateElevationWithElevationSource as y,isElevationSampler as u,scaleWithFactor as h,scaleAndAddWithFactor as d,computeNewReferenceCoordinates as g,projectiveTransform as w,validatePixelsToTransform as v,validateRotationMatrix as x,getWebMercatorScalingFactor as j,computeFarplaneVertices as A,computeHFOVAndVFOV as P,vecToPoint as R,hasAngles as V,convertPixelToHeadingPitch as F,convertHeadingPitchToSphereVertex as M,reducerFn as T}from"./utils.js";import{worldToImage as b}from"./worldToImage.js";import{defaultImageSphereCenter as L}from"../../../widgets/PanoramicViewer/constants.js";async function O(e,r,a){const{verticalFieldOfView:t,imageBoundaries:i,scalingFactor:o,farPlaneVertices:n,cameraLocation:c,pixelsToTransform:s,vecToPoint:f}=z(e,r),m=new Array;return await E(s,n,i,f,r,m,c,o,t,a),Array.isArray(e)?m:m[0]}async function E(e,a,t,i,o,n,c,s,f,l){for(const h of e){const e=q(a,t,h,i,o);let d=r(e);l&&p(u(l.elevationSample),y(l))&&(d=await m(i(e),{x:h[0],y:h[1]},{...o,...l,farPlaneVertices:a.map(i)})),n.push(i(k(d,c,s,o.averageElevation,o.cameraPitch,f)))}}function k(e,i,o,n,c,s){let f=r(e);const m=Math.sqrt((e[2]-i[2])**2+(Math.sqrt((e[0]-i[0])**2+(e[1]-i[1])**2)/o)**2)*o,l=h(t(a(),e,i),1/m,1/o);if(S(e[2],n,c,s)){const e=Math.abs((i[2]-n)/-l[2])*o;f=d(i,l,e,o)}else f[2]=n;return f}function S(e,r,a,t){return e<r||a+t/2<90}function q(e,r,a,t,i){let o=null;const n=9;let c,s=0,f=e,m=r;for(;s<=n;){const e=D(a,m,f,i);if(c=e.error,o=e.transformedPoint,p(c<=1,s===n))break;f=g(f,c,a,r),m=B(f,t,i),s++}return o}function B(e,r,a){return b(e.map(r),a).map((({x:e,y:r})=>[e,r,1]))}function D(e,r,a,t){const{cameraLocation:o}=t,n=w(e,r,a),{x:c,y:s}=b(new i(n,o.spatialReference),t);return{transformedPoint:n,error:H(e,[c,s,1])}}function H(e,r){return Math.abs(e[0]-r[0])+Math.abs(e[1]-r[1])}function z(r,a){const t=e(r)||"items"in r?r:[r],{cameraLocation:o,rotationMatrix:n}=a;if(v(t,o),x(n),9!==n?.length)throw new Error("Rotation matrix is not provided or is not a valid 3x3 matrix");const c=j(o.y,o.spatialReference),s=A({...a,scalingFactor:c}),f=b(s.map((e=>new i(e,o.spatialReference))),a),{vfov:m}=P(a.horizontalFieldOfView,a.verticalFieldOfView,a.cameraRoll);return{cameraLocation:o.toArray(),imageBoundaries:f.map((({x:e,y:r})=>[e,r,1])),verticalFieldOfView:m,farPlaneVertices:s,scalingFactor:c,pixelsToTransform:t.map((e=>[e.x,e.y,1])),vecToPoint:R(o.spatialReference)}}async function I(e,r,t){const{averageElevation:m,cameraHeading:p,cameraLocation:y,farDistance:h,imageHeight:d,imageWidth:g,verticalFieldOfView:w}=r,v=j(y.y,y.spatialReference),x=new Array,[A,P,R]=y.toArray(),b=c([A,P,R??0],h*v),O=L.toArray(),E=Array.isArray(e)?e:[e];for(const c of E){let e,j;if(V(c))e=c.heading,j=c.pitch;else{const r=F({x:c.x,y:c.y},g,d);e=r.heading,j=r.pitch}e=(e+p)%360;const L=o([O[0],O[1],O[2]],M(e,j)),E=n([A,P,R??0],L.direction);let S=a();s(b,E,S),t&&(f(t)||u(t.elevationSample))&&j+w/2<90&&(S=await l(new i(S,y.spatialReference),{heading:e,pitch:j},{...r,...t,farPlaneVertices:T(h,h).map((([e,r])=>new i([y.x+e,y.y+r],y.spatialReference)))})),S=k(S,y.toArray(),v,m,j,w),x.push(new i(S,y.spatialReference))}return Array.isArray(e)?x:x[0]}export{O as imageToWorld,I as imageToWorldPanoramic};
