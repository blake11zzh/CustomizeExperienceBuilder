/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import e from"../../../../Graphic.js";import t from"../../../../core/Error.js";import{generateUUID as s}from"../../../../core/uuid.js";import{isLoadedSharedTemplate as a,isSharedFeatureTemplate as r,isSharedPresetTemplate as o}from"../../../templateUtils.js";import{isRadial as i,maxDigitizingDisplayEdits as n}from"./executorUtils.js";import l from"../../../../geometry/Multipoint.js";import h from"../../../../geometry/Point.js";import p from"../../../../geometry/Polygon.js";import f from"../../../../geometry/Polyline.js";import{execute as u}from"../../../../geometry/operators/affineTransformOperator.js";import c from"../../../../geometry/operators/support/Transformation.js";import{isSubtypeGroupLayer as m}from"../../../../layers/support/layerUtils.js";function g({edits:s,geometry:r,relationships:o,tag:n="",template:l}){if(i(r)){const e=r.geometry.clone();for(const t of e.paths){g({geometry:new f({spatialReference:e.spatialReference,paths:[t],hasZ:e.hasZ,hasM:e.hasM}),template:l,edits:s,relationships:o,tag:n})}return}const{definition:h,layer:p}=l;r=y(r,p);const u=new e({attributes:h.defaultValues?{...h.defaultValues}:{},geometry:r,sourceLayer:p});if(x(u,p),p.globalIdField&&(u.attributes[p.globalIdField]=R()),s.push({id:p.layerId,graphic:u,tag:n,layer:p}),0!==h.relationships.length)for(const i of h.relationships||[]){const r=i.template;if(null==i.relationshipMetadata||!a(r))throw new t("shared-template:missing-relationship-metadata-or-definition","Relationship part must have metadata and a fully loaded template with definition");const{layer:n}=r,l=new e({attributes:{...h.defaultValues},sourceLayer:n});x(l,n),n.globalIdField&&(l.attributes[n.globalIdField]=R()),s.push({graphic:l,id:n.layerId,tag:"",layer:n}),o.push({...i.relationshipMetadata,sourceGraphic:u,destinationGraphic:l})}}function d({edits:e,geometry:s,mode:i,relationships:l,rotation:h,tag:p="",template:f}){const{definition:m}=f,y=s.x-m.origin.x,Z=s.y-m.origin.y,M=m.origin.hasZ&&s.hasZ?s.z-m.origin.z:0,R=j(m.origin.clone(),y,Z,M),w=(new c).rotate(h,R.x,R.y);for(const c of m.parts){if(e.length>n&&"digitizing"===i)break;const h=c.template;if(!a(h))throw new t("shared-template:template-not-loaded","A template part's template must be loaded before use");if(r(h)){let t=j(c.geometry,y,Z,M);w.isIdentity||(t=u(t,w)),g({edits:e,geometry:t,relationships:l,tag:p,template:h})}else if(o(h)){const t=[];if(d({edits:w.isIdentity?t:e,geometry:s,mode:i,relationships:l,rotation:0,tag:p,template:h}),!w.isIdentity)for(const s of t){const{geometry:t}=s.graphic;t&&"mesh"!==t.type&&(s.graphic.geometry=u(t,w),e.push(s))}}}return R}function y(e,t){if(!e)return null;if(e.hasZ===t.hasZ&&e.hasM===t.hasM)return e;switch(e.type){case"point":return new h({spatialReference:e.spatialReference,x:e.x,y:e.y,...t.hasZ?e.hasZ?{z:e.z}:{z:w(t)}:{},...t.hasM?e.hasM?{m:e.m}:{m:b(t)??void 0}:{}});case"polygon":return new p({spatialReference:e.spatialReference,rings:Z(e.rings,t.hasZ,t.hasM,w(t),b(t),e.hasM?e.hasZ?3:2:-1,e.hasZ?2:-1),hasZ:t.hasZ,hasM:t.hasM});case"polyline":return new f({spatialReference:e.spatialReference,paths:Z(e.paths,t.hasZ,t.hasM,w(t),b(t),e.hasM?e.hasZ?3:2:-1,e.hasZ?2:-1),hasZ:t.hasZ,hasM:t.hasM});case"multipoint":return new l({spatialReference:e.spatialReference,hasZ:t.hasZ,hasM:t.hasM,points:M(e.points,t.hasZ,t.hasM,w(t),b(t),e.hasM?e.hasZ?3:2:-1,e.hasZ?2:-1)});default:return e}}function Z(e,t,s,a,r,o,i){const n=[];for(const l of e)n.push(M(l,t,s,a,r,o,i));return n}function M(e,t,s,a,r,o,i){const n=[];for(const l of e){const e=[l[0],l[1]];t&&(e[2]=i>-1?l[2]:a),s&&(e[t?3:2]=o>-1?l[o]:r),n.push(e)}return n}function R(){return`{${s()}}`.toUpperCase()}function w(e){return e.capabilities.editing?.zDefault??0}function b(e){return e.capabilities.editing.supportsUpdateWithoutM?void 0:0}function j(e,t,s,a=0){if(!e)return null;if("point"===e.type)return new h({spatialReference:e.spatialReference,x:e.x+t,y:e.y+s,...e.hasZ?{z:e.z+a}:{},...e.hasM?{m:e.m}:{}});if("multipoint"===e.type){const r=[];if(e.hasZ&&e.hasM)for(let o=0;o<e.points.length;o++){const i=e.points[o];r.push([i[0]+t,i[1]+s,i[2]+a,i[3]])}else if(e.hasZ)for(let o=0;o<e.points.length;o++){const i=e.points[o];r.push([i[0]+t,i[1]+s,i[2]+a])}else if(e.hasM)for(let a=0;a<e.points.length;a++){const o=e.points[a];r.push([o[0]+t,o[1]+s,o[2]])}else for(let a=0;a<e.points.length;a++){const o=e.points[a];r.push([o[0]+t,o[1]+s])}return new l({spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM,points:r})}if("polygon"===e.type){const r=new p({spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM});for(let o=0;o<e.rings.length;o++){const i=e.rings[o],n=[];if(e.hasZ&&e.hasM)for(let e=0;e<i.length;e++)n.push([i[e][0]+t,i[e][1]+s,i[e][2]+a,i[e][3]]);else if(e.hasM)for(let e=0;e<i.length;e++)n.push([i[e][0]+t,i[e][1]+s,i[e][2]]);else if(e.hasZ)for(let e=0;e<i.length;e++)n.push([i[e][0]+t,i[e][1]+s,i[e][2]+a]);else for(let e=0;e<i.length;e++)n.push([i[e][0]+t,i[e][1]+s]);r.addRing(n)}return r}if("polyline"===e.type){const r=new f({spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM});for(let o=0;o<e.paths.length;o++){const i=e.paths[o],n=[];if(e.hasZ&&e.hasM)for(let e=0;e<i.length;e++)n.push([i[e][0]+t,i[e][1]+s,i[e][2]+a,i[e][3]]);else if(e.hasZ)for(let e=0;e<i.length;e++)n.push([i[e][0]+t,i[e][1]+s,i[e][2]+a]);else if(e.hasM)for(let e=0;e<i.length;e++)n.push([i[e][0]+t,i[e][1]+s,i[e][2]]);else for(let e=0;e<i.length;e++)n.push([i[e][0]+t,i[e][1]+s]);r.addPath(n)}return r}return e.clone()}function x(e,t){m(t)&&(e.sourceLayer=t.findSublayerForFeature(e))}export{g as createFeatureServiceEdit,d as createPresetServiceEdit,R as generateGlobalId,j as translate};
