/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import t from"../../core/Error.js";import"../../core/has.js";import e from"../../core/Logger.js";import{abortMaybe as i}from"../../core/maybe.js";import{isAbortError as r}from"../../core/promiseUtils.js";import{signal as s}from"../../core/signal.js";import{getTextureCompressionWorker as o,isCompressible as a}from"../support/TextureCompressionHelper.js";import{checkWebGLError as n}from"./checkWebGLError.js";import{TextureType as l,ResourceType as p,CompressedTextureFormat as m,TextureSamplingMode as h}from"./enums.js";import{GLObjectType as _}from"./GLObjectType.js";import{estimateMemory as d}from"./TextureDescriptor.js";import{isCompressedData as c,deriveInternalFormat as u,isTexImageSource as g,is3DTarget as T,validateTexture as x,isCompressedFormat as E,getDimensions as M,calcMipmapLevels as A,isSizedPixelFormat as I}from"./textureUtils.js";import{ValidatedTextureDescriptor as f}from"./ValidatedTextureDescriptor.js";const w=null,D=()=>e.getLogger("esri/views/webgl/Texture");let R=class e{constructor(e,i=null,r=null){if(this.type=_.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,this._compressionAbortController=s(null),"context"in e)this._descriptor=e,r=i;else{const r=f.validate(e,i);if(!r)throw new t("Texture descriptor invalid");this._descriptor=r}this._descriptor.target===l.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return d(this._descriptor)}get cachedMemory(){return this.usedMemory}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}get isCompressing(){return null!==this._compressionAbortController.value}dispose(){this.abortCompression(),this._glName&&this._descriptor.context.instanceCounter.decrement(p.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,i){const r=this._descriptor;if(r.width!==e||r.height!==i){if(this._wasImmutablyAllocated)throw new t("Immutable textures can't be resized!");r.width=e,r.height=i,this._descriptor.target===l.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}enableCompression(t){this._descriptor.shouldCompress=t}setData(t){this.abortCompression(),!c(t)&&this._descriptor.internalFormat&&this._descriptor.internalFormat in m&&(this._descriptor.internalFormat=void 0),this._setData(t),o()&&!c(t)&&a(t)&&this._descriptor.shouldCompress&&this.compressOnWorker(t)}updateData(i,r,s,o,a,n,l=0){n||D().error("An attempt to use uninitialized data!"),this._glName||D().error("An attempt to update uninitialized texture!");const p=this._descriptor;p.internalFormat=u(p);const{context:m,pixelFormat:h,dataType:_,target:d,isImmutable:T}=p;if(T&&!this._wasImmutablyAllocated)throw new t("Cannot update immutable texture before allocation!");const x=m.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||s<0||r+o>p.width||s+a>p.height)&&D().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:E}=m;l&&(o&&a||D().warn("Must pass width and height if `UNPACK_SKIP_ROWS` is used"),E.pixelStorei(E.UNPACK_SKIP_ROWS,l)),g(n)?E.texSubImage2D(d,i,r,s,o,a,h,_,n):c(n)?E.compressedTexSubImage2D(d,i,r,s,o,a,p.internalFormat,n.levels[i]):E.texSubImage2D(d,i,r,s,o,a,h,_,n),l&&E.pixelStorei(E.UNPACK_SKIP_ROWS,0),m.bindTexture(x,e.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(i,r,s,o,a,n,l,p){p||D().error("An attempt to use uninitialized data!"),this._glName||D().error("An attempt to update an uninitialized texture!");const m=this._descriptor;m.internalFormat=u(m);const{context:h,pixelFormat:_,dataType:d,isImmutable:g,target:x}=m;if(g&&!this._wasImmutablyAllocated)throw new t("Cannot update immutable texture before allocation!");T(x)||D().warn("Attempting to set 3D texture data on a non-3D texture");const E=h.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);h.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),(r<0||s<0||o<0||r+a>m.width||s+n>m.height||o+l>m.depth)&&D().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:M}=h;if(c(p))p=p.levels[i],M.compressedTexSubImage3D(x,i,r,s,o,a,n,l,m.internalFormat,p);else{const t=p;M.texSubImage3D(x,i,r,s,o,a,n,l,_,d,t)}h.bindTexture(E,e.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const i=this._descriptor;if(0===i.width||0===i.height)return;if(!i.hasMipmap){if(this._wasImmutablyAllocated)throw new t("Cannot add mipmaps to immutable texture after allocation");i.hasMipmap=!0,this._samplingModeDirty=!0,x(i)}i.samplingMode===h.LINEAR?(this._samplingModeDirty=!0,i.samplingMode=h.LINEAR_MIPMAP_NEAREST):i.samplingMode===h.NEAREST&&(this._samplingModeDirty=!0,i.samplingMode=h.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(i.target),this._descriptor.context.bindTexture(r,e.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new t("Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,x(e)}e.samplingMode===h.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,e.samplingMode=h.LINEAR):e.samplingMode===h.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=h.NEAREST)}setSamplingMode(t){t!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=t,this._samplingModeDirty=!0)}setWrapMode(t){t!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=t,x(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){this._samplingModeDirty&&(this._applySamplingMode(),this._samplingModeDirty=!1),this._wrapModeDirty&&(this._applyWrapMode(),this._wrapModeDirty=!1)}abortCompression(){this.isCompressing&&(this._compressionAbortController.value=i(this._compressionAbortController.value))}_setData(i,r){const s=this._descriptor,o=s.context?.gl;if(!o)return;n(o),this._glName||(this._glName=o.createTexture(),this._glName&&s.context.instanceCounter.increment(p.Texture,this)),x(s);const a=s.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);s.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._configurePixelStorage(),n(o);const l=r??s.target,m=T(l);if(g(i))this._setDataFromTexImageSource(i,l);else{const{width:e,height:r,depth:a}=s;if(null==e||null==r)throw new t("Width and height must be specified!");if(m&&null==a)throw new t("Depth must be specified!");if(s.internalFormat=u(s),s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(l,s.internalFormat,s.hasMipmap,e,r,a),c(i)){if(!E(s.internalFormat))throw new t("Attempting to use compressed data with an uncompressed format!");this._setDataFromCompressedSource(i,s.internalFormat,l)}else this._texImage(l,0,s.internalFormat,e,r,a,i),n(o),s.hasMipmap&&this.generateMipmap()}this._applySamplingMode(),this._applyWrapMode(),this._applyAnisotropicFilteringParameters(),n(o),s.context.bindTexture(a,e.TEXTURE_UNIT_FOR_UPDATES)}_setDataCubeMap(t=null){for(let e=l.TEXTURE_CUBE_MAP_POSITIVE_X;e<=l.TEXTURE_CUBE_MAP_NEGATIVE_Z;e++)this._setData(t,e)}_configurePixelStorage(){const t=this._descriptor.context.gl,{unpackAlignment:e,flipped:i,preMultiplyAlpha:r}=this._descriptor;t.pixelStorei(t.UNPACK_ALIGNMENT,e),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,i?1:0),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r?1:0)}_setDataFromTexImageSource(t,e){const{gl:i}=this._descriptor.context,r=this._descriptor;r.internalFormat=u(r);const s=T(e),{width:o,height:a,depth:l}=M(t);r.width&&r.height,r.width||(r.width=o),r.height||(r.height=a),s&&r.depth,s&&(r.depth=l),r.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(e,r.internalFormat,r.hasMipmap,o,a,l),this._texImage(e,0,r.internalFormat,o,a,l,t),n(i),r.hasMipmap&&(this.generateMipmap(),n(i))}_setDataFromCompressedSource(t,e,i){const r=this._descriptor,{width:s,height:o,depth:a}=r,n=t.levels,l=A(i,s,o,a),p=Math.min(l,n.length)-1;this._descriptor.context.gl.texParameteri(r.target,r.context.gl.TEXTURE_MAX_LEVEL,p),this._forEachMipmapLevel(((t,r,s,o)=>{const a=n[Math.min(t,n.length-1)];this._compressedTexImage(i,t,e,r,s,o,a)}),p)}_texStorage(e,i,r,s,o,a){const{gl:n}=this._descriptor.context;if(!I(i))throw new t("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const l=r?A(e,s,o,a):1;if(T(e)){if(null==a)throw new t("Missing depth dimension for 3D texture upload");n.texStorage3D(e,l,i,s,o,a)}else n.texStorage2D(e,l,i,s,o);this._wasImmutablyAllocated=!0}_texImage(e,i,r,s,o,a,n){const l=this._descriptor.context.gl,p=T(e),{isImmutable:m,pixelFormat:h,dataType:_}=this._descriptor;if(m){if(null!=n){const r=n;if(p){if(null==a)throw new t("Missing depth dimension for 3D texture upload");l.texSubImage3D(e,i,0,0,0,s,o,a,h,_,r)}else l.texSubImage2D(e,i,0,0,s,o,h,_,r)}}else{const m=n;if(p){if(null==a)throw new t("Missing depth dimension for 3D texture upload");l.texImage3D(e,i,r,s,o,a,0,h,_,m)}else l.texImage2D(e,i,r,s,o,0,h,_,m)}}_compressedTexImage(e,i,r,s,o,a,n){const l=this._descriptor.context.gl,p=T(e);if(this._descriptor.isImmutable){if(null!=n)if(p){if(null==a)throw new t("Missing depth dimension for 3D texture upload");l.compressedTexSubImage3D(e,i,0,0,0,s,o,a,r,n)}else l.compressedTexSubImage2D(e,i,0,0,s,o,r,n)}else if(p){if(null==a)throw new t("Missing depth dimension for 3D texture upload");l.compressedTexImage3D(e,i,r,s,o,a,0,n)}else l.compressedTexImage2D(e,i,r,s,o,0,n)}async compressOnWorker(t){const e=this._descriptor.context?.gl.getExtension("WEBGL_compressed_texture_etc"),i=this._descriptor.context?.gl.getExtension("WEBGL_compressed_texture_s3tc"),s=o();if(s&&(e||i)){const o=new AbortController;this._compressionAbortController.value=o;const a={data:await createImageBitmap(t),flipped:this.descriptor.flipped,width:t.width,height:t.height,hasMipmap:this._descriptor.hasMipmap,hasETC:!!e,hasS3TC:!!i};s.invoke(a,this._compressionAbortController.value.signal).then((t=>{t&&this.isCompressing&&this.glName&&(this._descriptor.internalFormat=t.internalFormat,this._setData(t.compressedTexture)),o===this._compressionAbortController.value&&(this._compressionAbortController.value=null)})).catch((t=>{r(t)||o!==this._compressionAbortController.value||(this._compressionAbortController.value=null)}))}}_forEachMipmapLevel(e,i=1/0){let{width:r,height:s,depth:o,hasMipmap:a,target:n}=this._descriptor;const p=n===l.TEXTURE_3D;if(null==r||null==s||p&&null==o)throw new t("Missing texture dimensions for mipmap calculation");for(let t=0;e(t,r,s,o),a&&(1!==r||1!==s||p&&1!==o)&&!(t>=i);++t)r=Math.max(1,r>>1),s=Math.max(1,s>>1),p&&(o=Math.max(1,o>>1))}_applySamplingMode(){const t=this._descriptor,e=t.context?.gl;let i=t.samplingMode,r=t.samplingMode;i===h.LINEAR_MIPMAP_NEAREST||i===h.LINEAR_MIPMAP_LINEAR?(i=h.LINEAR,t.hasMipmap||(r=h.LINEAR)):i!==h.NEAREST_MIPMAP_NEAREST&&i!==h.NEAREST_MIPMAP_LINEAR||(i=h.NEAREST,t.hasMipmap||(r=h.NEAREST)),e.texParameteri(t.target,e.TEXTURE_MAG_FILTER,i),e.texParameteri(t.target,e.TEXTURE_MIN_FILTER,r)}_applyWrapMode(){const t=this._descriptor,e=t.context?.gl;"number"==typeof t.wrapMode?(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(t.target,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(t.target,e.TEXTURE_WRAP_T,t.wrapMode.t))}_applyAnisotropicFilteringParameters(){const t=this._descriptor,e=t.context.capabilities.textureFilterAnisotropic;if(!e)return;t.context.gl.texParameterf(t.target,e.TEXTURE_MAX_ANISOTROPY,t.maxAnisotropy??1)}};R.TEXTURE_UNIT_FOR_UPDATES=0;export{R as Texture,w as tracer};
