import { f as P, i as y, b as T, a as b, c as A, L as x, E as D } from "./language-defaults-base.js";
import { supportedLocales as F, fetchT9nStringsBundle as M } from "@arcgis/components-utils";
import { g as m } from "./runtime.js";
import { CompletionItemKind as w, InsertTextMode as f, InsertTextFormat as d } from "vscode-languageserver-types";
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
v4.32.1 */
async function S(e) {
  const { apiVersion: i, bundles: t, hiddenApiItems: n } = e.toEditorProfileDefinition(), r = await h(e.dictionaryVariables);
  return { apiVersion: i, bundles: t, variables: r, hiddenApiItems: n?.map((s) => s.toLowerCase()) };
}
async function h(e, i = w.Variable) {
  return await Promise.all(
    e.map(async (t) => {
      switch (t.type) {
        case "dictionary":
          return await v(t, i);
        case "feature":
          return await k(t, i);
        default:
          return L(t, i);
      }
    })
  );
}
function L(e, i) {
  const { name: t, type: n } = e, r = e.getDescription();
  return {
    name: t,
    description: r,
    type: n,
    completion: {
      label: t,
      detail: t,
      insertText: t,
      insertTextMode: f.asIs,
      insertTextFormat: d.PlainText,
      kind: i,
      documentation: { kind: "markdown", value: r }
    }
  };
}
async function k(e, i) {
  const t = await e.loadSource(), { name: n } = e, r = e.getDescription(), s = {
    label: n,
    detail: n,
    insertText: n,
    insertTextMode: f.asIs,
    insertTextFormat: d.PlainText,
    kind: i
  }, a = {
    name: n,
    description: r,
    type: "dictionary",
    properties: [],
    completion: s
  };
  if (!t)
    return a;
  const [o, c] = P(t.fields, r, !0);
  return a.properties = o, s.documentation = { kind: "markdown", value: c }, a;
}
async function v(e, i) {
  const { name: t, dictionaryVariables: n } = e, r = e.getDescription(), s = n.reduce((a, o) => {
    a !== "" && (a += `  
  
`), a += `**${o.name}**  
${o.type}`;
    const c = o.getDescription();
    return c && (a += `  
${c}`), a;
  }, r);
  return {
    name: t,
    description: r,
    type: "dictionary",
    properties: await h(n, w.Field),
    completion: {
      label: t,
      detail: t,
      insertText: t,
      insertTextMode: f.asIs,
      insertTextFormat: d.PlainText,
      kind: i,
      documentation: { kind: "markdown", value: s }
    }
  };
}
async function l(e = "en") {
  const i = g.get(e);
  if (i)
    return i;
  if (!F.has(e))
    return await l("en");
  try {
    const t = await fetch(m(`./assets/arcade-language/profiles/arcade-profiles.t9n.${e}.json`));
    return t.ok ? E(e, await t.json()) : e === "en" ? null : await l("en");
  } catch {
    return null;
  }
}
const g = /* @__PURE__ */ new Map();
function E(e, i) {
  const t = /* @__PURE__ */ new Map();
  return i.forEach((n) => {
    t.set(n.id, n);
  }), g.set(e, t), t;
}
async function I(e, i = "en") {
  return (await l(i))?.get(e) ?? null;
}
function $(e) {
  return !!e && typeof e == "object" && "additionalVariables" in e && Array.isArray(e.additionalVariables);
}
function C(e) {
  return e?.map(p);
}
function p(e) {
  switch (e.type) {
    case "dictionary":
      return {
        ...e,
        type: e.type,
        properties: C(e.properties)
      };
    case "array":
      return {
        ...e,
        type: e.type,
        elementType: { type: "number", name: "number" }
      };
    default:
      return { ...e, type: e.type };
  }
}
async function j(e, i = "en") {
  if (!y(e))
    return;
  const t = await I(e.id, i);
  if (!t)
    return;
  const n = {
    bundles: [...t.bundles],
    variables: [],
    hiddenApiItems: e.hiddenApiItems?.map((r) => r.toLowerCase())
  };
  return t.variables.forEach((r) => {
    if (e.disabledVariables?.includes(r.name))
      return;
    const s = e.definitions[r.name];
    switch (r.type) {
      case "dictionary":
        return n.variables.push(
          p({
            ...r,
            type: r.type,
            properties: Array.isArray(s) ? [...s] : r.properties
          })
        );
      case "feature":
      case "voxel":
        return A(s) ? n.variables.push({ ...r, type: "feature", definition: s }) : void 0;
      case "featureSet":
        return b(s) ? n.variables.push({ ...r, type: r.type, definition: s }) : void 0;
      case "featureSetCollection":
        return T(s) ? n.variables.push({ ...r, type: r.type, definition: s }) : void 0;
      default:
        return n.variables.push(p(r));
    }
  }), $(e) && n.variables.push(...e.additionalVariables ?? []), n;
}
class B extends x {
  constructor() {
    super("arcade", {
      apiPath: "./assets/arcade-language/api",
      apiPrefix: "arcade-api.t9n."
    });
  }
  /**
   * Create an EditorProfile for the given model id using the given definition and locale.
   * The EditorProfile is used by the the Arcade Language service as well by the coding components.
   * The definition can be a pre-defined profile or an editor profile definition.
   * If the locale is not provided then the 'en' locale is used.
   * @param modelId The model id for which to create the context.
   * @param definition The definition to use for the model context.
   * @param locale The locale to use for the model context.
   * @returns The EditorProfile for the model.
   */
  async setProfileForModel(i, t, n = { locale: "en" }) {
    y(t) && (t = await j(t, n.locale));
    const r = await M(
      n.locale,
      m("./assets/editor-profile/t9n"),
      "messages."
    );
    if (!r)
      throw new Error(`Failed to load the language bundle for ${n.locale}`);
    this.disposeForModel(i);
    const s = this._getApiKey(i), a = new D(t, r);
    this._modelToProfileMap.set(s, a);
    const o = await S(a);
    this.updateApiContextForModel(i, {
      locale: n.locale,
      profile: o,
      snippets: n.snippets
    });
  }
}
const u = new B(), G = {
  setProfileForModel: u.setProfileForModel.bind(u),
  getApiLibraryForModel: u.getApiLibraryForModel.bind(u)
};
export {
  G as a,
  u as b
};
