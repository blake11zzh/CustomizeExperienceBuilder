/// <reference types="@arcgis/core/interfaces.d.ts" />
import { ApiVariableType, ApiValueVariable } from '@arcgis/languages-api-utils';
import type * as types from "./types";
/**
 * FeatureSetCollection interface. Used in Arcade expressions to represent Web Maps
 * or Feature Services.
 */
interface IFeatureSetCollections {
    /**
     * The collection of layers in the featureSetCollection. Layers contain features
     * with geometry.
     */
    layers: (FeatureSetVariable | GroupOfVariables)[];
    /**
     * The collection of tables in the featureSetCollection. Tables contain features
     * that don't have a geometry.
     */
    tables: (FeatureSetVariable | GroupOfVariables)[];
    /**
     * If the feature set collection represents a Web Map or a Web Scene then it will contain the instance.
     * If the feature set collection represents a service then it will be its URL.
     */
    source: __esri.Map | __esri.WebMap | __esri.WebScene | string;
}
/**
 * converts fields to profile values and calculates the feature completion description all in one iteration
 */
export declare function fieldsToProfileValues(fields: __esri.Field[], initialFeatureCompletionDescription: string, includeAliases?: boolean): [ApiValueVariable[], string];
type ProfileItemType = ApiVariableType | "group";
export type EditorVariable = ArrayVariable | DictionaryVariable | FeatureSetCollectionVariable | FeatureSetVariable | FeatureVariable | ValueVariable;
interface ConstructorProperties<T> {
    profile?: EditorProfile | null;
    declaration?: Partial<T>;
    label?: types.IIntlString | string | null;
    description?: types.IIntlString | string;
    snippet?: string;
    nonInteractive?: boolean;
    filterDescription?: boolean;
    icon?: string;
}
/**
 * Represents a item in the EditorProfile. The profile is converted into an optimized way for
 * rendering in the editor. In addition to the representation of profile variables, other
 * structures are created such as groups.
 */
declare abstract class ProfileItemBase {
    protected _profile: EditorProfile | null | undefined;
    private readonly _label;
    protected readonly description?: (types.IIntlString | string) | undefined;
    abstract readonly type: ProfileItemType;
    protected filterDescription: boolean;
    /**
     * True if the item represents a collection of items.
     */
    abstract readonly isCollection: boolean;
    constructor(_profile: EditorProfile | null | undefined, _label: types.IIntlString | string | null | undefined, description?: (types.IIntlString | string) | undefined);
    /**
     * Returns the label string.
     */
    getLabel(): string;
    /**
     * Returns the description string.
     */
    getDescription(): string;
    /**
     * Returns true if the item pass the filter test
     */
    passFilter(filterExpression?: RegExp): boolean;
}
/**
 * The base class for profile variables representation in the EditorProfile.
 */
declare abstract class VariableBase extends ProfileItemBase {
    abstract readonly type: ApiVariableType;
    readonly name: string;
    readonly snippet: string;
    /**
     * True if the variable doesn't can be used as snippet by the editor.
     */
    readonly nonInteractive: boolean;
    protected declaration: Partial<types.IProfileVariableBase>;
    icon: string | undefined;
    constructor(props: ConstructorProperties<types.IProfileVariableBase>);
    /**
     * Returns the IProfileVariable json representation.
     */
    abstract toProfileVariableDefinition(): types.IProfileVariable;
}
/**
 * Represents the IProfileValue.
 */
export declare class ValueVariable extends VariableBase {
    type: types.ProfileVariableValueType;
    isCollection: false;
    constructor(props: ConstructorProperties<types.IProfileValue>);
    getDescription(): string;
    toProfileVariableDefinition(): types.IProfileVariable;
}
/**
 * Represents the IProfileArray. The main difference is that the IProfileValue type
 * is used as valueType.
 */
export declare class ArrayVariable extends VariableBase {
    type: "array";
    isCollection: false;
    elementType: types.IProfileVariable;
    constructor(props: ConstructorProperties<types.IProfileArray>);
    getDescription(): string;
    toProfileVariableDefinition(): types.IProfileArray;
}
/**
 * Represents a collection of items. The collection of items can be synchronous or
 * asynchronous. If the collection is asynchronous then the collection should be
 * loaded by using the function 'load'. The property 'loaded' indicates if the
 * collection is ready or not.
 */
export declare abstract class CollectionBasedVariable extends VariableBase {
    private owner;
    isCollection: true;
    protected _loaded: boolean;
    /**
     * The collection of items used to display the profile.
     * If the collection is asynchronous, the 'load' function should
     * be called first before using the items.
     */
    variables: (EditorVariable | GroupOfVariables)[];
    constructor(owner: CollectionBasedVariable | undefined, props: ConstructorProperties<types.IProfileVariableBase>);
    get breadcrumb(): string;
    /**
     * Returns true if the collection has been loaded
     */
    get loaded(): boolean;
    /**
     * Loads the items if the collection is asynchronous.
     * If the collection is synchronous then the function is a no-op.
     */
    abstract loadSource(): Promise<unknown>;
    /**
     * Returns an url to the associated information
     */
    get informationUrl(): string | null;
    get informationType(): string;
}
export declare class GroupOfVariables extends ProfileItemBase {
    variables: (EditorVariable | GroupOfVariables)[];
    isHeader: boolean;
    type: "group";
    isCollection: true;
    constructor(profile: EditorProfile | null | undefined, label: types.IIntlString | string, variables?: (EditorVariable | GroupOfVariables)[], isHeader?: boolean);
    passFilter(): boolean;
}
export declare class DictionaryVariable extends CollectionBasedVariable {
    type: "dictionary";
    /**
     * The variables that the dictionary holds. It is different than the variables.
     * The variables may contain grouping.
     */
    dictionaryVariables: EditorVariable[];
    constructor(owner: CollectionBasedVariable | undefined, props: ConstructorProperties<types.IProfileDictionary>);
    loadSource(): Promise<void>;
    protected loadPropertyDeclarations(declarations: types.IProfileVariable[] | undefined): void;
    private createVariableInstances;
    private createVariableInstance;
    toProfileVariableDefinition(): types.IProfileVariable;
}
interface IRelationshipsProperties {
    exposeRelationships: boolean;
    sourceTableId?: number | null;
}
declare abstract class SourceBasedVariable extends CollectionBasedVariable {
    private relationshipsProperties?;
    protected _definition?: types.FeatureDefinition | types.FeatureSetDefinition;
    protected _source: types.SupportedSource | null;
    protected _loadPromise?: Promise<types.SupportedSource | null>;
    constructor(owner: CollectionBasedVariable | undefined, props: ConstructorProperties<types.IProfileFeature | types.IProfileFeatureSet>, relationshipsProperties?: IRelationshipsProperties | undefined);
    get title(): types.IIntlString | string;
    get url(): string;
    get informationUrl(): string | null;
    get informationType(): string;
    loadSource(): Promise<types.SupportedSource | null>;
    protected abstract _loadSource(): Promise<types.SupportedSource | null>;
    private _getValueSnippet;
    private _getSubtypeOrDomainNameSnippet;
    protected _getFieldProperty(field: __esri.Field): EditorVariable;
    private _getDomainDictionary;
    private _getSubtypeDomainDictionary;
    private _getFeatureTypeDomainDictionary;
    private _getFieldDomainDictionary;
    private _getTypeOrSubtypeDomainGroup;
    private _getCodedValueDomainGroup;
    private _getDomainValuesGroup;
    protected _createDomainDictionary(field: __esri.Field): DictionaryVariable;
    protected _getRelationshipsProperty(): Promise<GroupOfVariables | null>;
}
export declare class FeatureVariable extends SourceBasedVariable {
    type: "feature";
    constructor(owner: CollectionBasedVariable | undefined, props: ConstructorProperties<types.IProfileFeature>);
    get title(): types.IIntlString | string;
    protected _loadSource(): Promise<types.SupportedSource | null>;
    toProfileVariableDefinition(): types.IProfileVariable;
}
export declare class FeatureSetVariable extends SourceBasedVariable {
    private featureSetSnippets;
    type: "featureSet";
    protected _definition?: types.FeatureSetDefinition;
    constructor(owner: CollectionBasedVariable | undefined, props: ConstructorProperties<types.IProfileFeatureSet>, featureSetSnippets?: ValueVariable[], relationshipProps?: IRelationshipsProperties);
    get title(): types.IIntlString | string;
    protected _loadSource(): Promise<types.SupportedSource | null>;
    toProfileVariableDefinition(): types.IProfileFeatureSet;
}
export declare class FeatureSetCollectionVariable extends CollectionBasedVariable {
    type: "featureSetCollection";
    private _definition?;
    private _loadPromise?;
    private _featureSetCollections;
    constructor(owner: CollectionBasedVariable | undefined, props: ConstructorProperties<types.IProfileFeatureSetCollection>);
    get informationUrl(): string | null;
    get informationType(): string;
    loadSource(): Promise<IFeatureSetCollections | null>;
    private _loadSource;
    private _featureSetCollectionsFromDefinition;
    private _featureSetCollectionFromMap;
    private _featureSetCollectionFromPortalItem;
    private _featureSetCollectionFromUrl;
    private _convertWebMapLayersToVariables;
    private _createFeatureSetVariable;
    private _makeFeatureSetSnippets;
    toProfileVariableDefinition(): types.IProfileVariable;
}
/**
 * The EditorProfile is an object that represents an Arcade Profile.
 * It is used to display the profile in the editor.
 * It takes an IEditorProfile as a definition and a locale.
 * A EditorProfile instance
 * Some of the variables in the profile are based on layers, web maps, or feature services.
 * They need to be loaded asynchronously to get the metadata necessary for validation and completion.
 */
export declare class EditorProfile extends DictionaryVariable {
    readonly definition: types.IEditorProfileDefinition | undefined;
    readonly intlStrings: types.IndexedProfileStrings;
    readonly locale: string;
    variables: EditorVariable[];
    constructor(definition: types.IEditorProfileDefinition | undefined, intlStrings: types.IndexedProfileStrings, locale?: string);
    /**
     * Returns true if the profile supports feature set functions for snippets.
     */
    get supportFeatureSetFunctions(): boolean;
    /**
     * Returns the EditorProfile as a json. The EditorProfile may have been updated. This function allows to
     * get the new json representing mutations.
     */
    toEditorProfileDefinition(): types.IEditorProfileDefinition;
}
export {};
