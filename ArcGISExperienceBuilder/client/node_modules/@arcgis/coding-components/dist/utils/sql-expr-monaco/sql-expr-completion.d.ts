/// <reference types="@arcgis/core/interfaces.d.ts" />
import { IRange, Position, languages } from 'monaco-editor';
import { ApiDatabase, ApiVariable } from '@arcgis/languages-api-utils';
import { ICompletionContext } from './types';
/**
 * Class used for sql expression completion
 */
export declare class SqlExpressionCompletion {
    private _sdkFunctions;
    private _fields;
    constructor(sdkLibrary: ApiDatabase, fields: ApiVariable[]);
    /**
     * gets completions for the sql expression.
     * @param {Object} params - The parameters for the completion.
     * @param {IRange} params.range - The range of the current position.
     * @param {string} params.modelContent - The content of the model.
     * @param {Position} params.position - The current position of the cursor in the model.
     * @param {ICompletionContext} params.completionContext - The completion context.
     * @param {boolean} params.terminateOnError - Whether to terminate the completion when it fails to parse.
     * @returns {Promise<languages.CompletionItem[]>} The completion items.
     */
    getCompletions({ range, modelContent, position, completionContext, terminateOnError, }: {
        range: IRange;
        modelContent: string;
        position: Position;
        completionContext?: ICompletionContext;
        terminateOnError?: boolean;
    }): Promise<languages.CompletionItem[]>;
    /**
     * traverses the tree to find the node that contains the current position
     * @param node The current node to traverse
     * @param position The current position
     */
    traverse(node: __esri.SQLNode, completionContext: ICompletionContext): void;
    /**
     * gets completions by finding the context of the current node and suggesting completions based on that context
     */
    private _getCompletions;
    /**
     * utilizes peggy's error handling to provide suggestions for the user.
     */
    private handleParserFailure;
    /**
     * gets completions based on the function node
     * @param context the context root of the current node, see {@link identifyContextRoot}
     * @param slotPosition the position of the current node in the context root, see {@link getSlotPosition}
     * @param completionContext the completion context
     */
    private _getCompletionsFromFunction;
    /**
     * checks if the position is within the current node
     * @param node The current node to check
     * @param position The current position
     * @returns boolean
     */
    private _isPositionWithinNode;
    private _isPositionWithinSQLSourcePosition;
    private _suggestFields;
    private _suggestFunctions;
    private _suggestDataTypes;
    private _suggestDatePeriods;
    private _suggestTrimParts;
    private _suggestDateLiterals;
    private _suggestDateFunctions;
    private _suggestExpressions;
    private _suggestNull;
    private _suggestCurrentUser;
    /**
     * looks at the node and finds any children attached to it. If there are children, it will traverse them.
     * @param node The current node to traverse
     */
    private _traverseChildren;
    private _sliceToPosition;
}
