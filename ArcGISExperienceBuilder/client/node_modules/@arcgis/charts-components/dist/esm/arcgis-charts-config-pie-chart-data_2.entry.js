/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { r as registerInstance, c as createEvent, g as getAssetPath, h, H as Host, a as getElement } from './index-accb48c0.js';
import { R as RESTStatisticType, M as Mn, aa as wc, C as Tl, Z as Zy, r as Qy, a5 as Jy, u as RESTSymbolType, af as oa, ag as Zn } from './rest-js-object-literals-a5a8eefc.js';
import { t as th, r as rh } from './index-5e57070e.js';
import { P as PieChartDataPopoverKinds } from './interfaces-f2a30723.js';
import { l as defaultPieFromFieldsName, c as createActionTooltip, d as destroyActionTooltip, s as sanitizeNumber, U as UIDefaults } from './chart-ui-utils-0ccca40a.js';
import { d as debounce } from './debounce-473151c3.js';
import { i as isEmpty } from './isEmpty-4cf05ed7.js';
import { t as toNumber } from './toNumber-b791a338.js';
import './isObject-5bd27635.js';
import './_getTag-78bbf0d8.js';
import './_Map-474d2383.js';

const HTMLClasses$1 = {
    label: "label",
    text: "text",
    fieldList: "field-list",
    fab: "fab",
    disabledLabel: "disabled-label",
    rtl: "arcgis-charts-rtl",
};

const arcgisChartsConfigPieChartDataCss = ":host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin);margin-top:var(--arcgis-charts-top-section-margin)}.label,.disabled-label{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.text{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);width:calc(100% - 1.5rem);height:2rem;margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.field-list{max-height:50vh;overflow-y:auto}.disabled-label{pointer-events:none}.fab{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:1.5rem;justify-content:center}:host(.arcgis-chart-rtl) .text{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}";
const ArcgisChartsConfigPieChartDataStyle0 = arcgisChartsConfigPieChartDataCss;

const ArcGISChartsConfigPieChartData = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.arcgisChartsConfigPieChartDataNumericFieldValidate = createEvent(this, "arcgisChartsConfigPieChartDataNumericFieldValidate", 7);
        this.arcgisChartsConfigDataChangeError = createEvent(this, "arcgisChartsConfigDataChangeError", 7);
        /**
         * @category Private
         */
        this.pieChartPopover = null;
        /**
         * @category Event handler
         *
         * called when the sort order is clicked
         */
        this.onSortOrderSelect = () => {
            this.contentKind = PieChartDataPopoverKinds.sortOrder;
            this.setupPopover();
        };
        /**
         * @category Event handler
         *
         * called when the category is clicked
         */
        this.onCategorySelect = () => {
            this.contentKind = PieChartDataPopoverKinds.category;
            this.setupPopover();
        };
        /**
         * @category Event handler
         *
         * called when the add numeric fields button is clicked
         */
        this.onAddNumericFields = () => {
            this.contentKind = PieChartDataPopoverKinds.numericFields;
            this.setupPopover();
        };
        /**
         * @category Event handler
         *
         * Called when individual numeric field item is removed.
         */
        this.onRemoveNumericField = async (removedItemEvent) => {
            const removedField = removedItemEvent.target.value;
            await this.model.setNumericFields(this.model.getNumericFields().filter((field) => field !== removedField));
        };
        /**
         * @category Event handler
         *
         * called in response to the arcgisChartsConfigPieChartDataPopoverChange event
         */
        this.onPieChartDataChange = async (e) => {
            try {
                if (e.detail !== null && e.detail?.value !== undefined) {
                    const { contentKind } = e.detail;
                    const newValue = [...e.detail.value];
                    switch (contentKind) {
                        case PieChartDataPopoverKinds.aggregation:
                            await this.model.setAggregationType(newValue[0] !== RESTStatisticType.NoAggregation ? newValue[0] : "");
                            break;
                        case PieChartDataPopoverKinds.category: {
                            const newCategory = newValue[0]?.trim() || "";
                            this.updateMode(newCategory);
                            // if we have more than one numeric field, we need to trim it down to just the first one since category with multiple numeric fields is not supported
                            const numericFields = this.model.getNumericFields();
                            if (numericFields.length > 1 && newCategory !== defaultPieFromFieldsName) {
                                await this.model.setNumericFields([numericFields[0]]);
                            }
                            await this.model.setCategory(newCategory);
                            this.model.setColorMatch(true);
                            break;
                        }
                        case PieChartDataPopoverKinds.numericFields:
                            // if we have more than one numeric field, we need to clear the category since category with multiple numeric fields is not supported
                            if (newValue.length > 1) {
                                this.updateMode(defaultPieFromFieldsName);
                                await this.model.setCategory(defaultPieFromFieldsName);
                            }
                            await this.model.setNumericFields(newValue);
                            break;
                        case PieChartDataPopoverKinds.sortOrder:
                            this.model.setSortOrder(newValue[0]);
                            break;
                    }
                }
            }
            catch (error) {
                this.arcgisChartsConfigDataChangeError.emit({ error, model: this.model });
                throw error;
            }
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Event handler
         */
        this.onShowDataLabelsChange = (e) => {
            this.model.setDataLabelsVisibility(e.target.checked);
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Private
         */
        this.popoverClose = (e) => {
            if (this.pieChartPopover === e?.target) {
                this.removePieChartDataPopover();
            }
        };
        this.model = undefined;
        this.layerFieldsInfo = undefined;
        this.open = true;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removePieChartDataPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await Mn(this.hostElement, getAssetPath(`.`)));
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Render UX
     */
    renderSorting() {
        return (h("arcgis-charts-config-field-select", { label: this.strings[this.model.getSortOrder()], ref: (e) => {
                this.sortOrderElement = e;
            }, onClick: this.onSortOrderSelect }));
    }
    /**
     * @category Render UX
     */
    renderCategory() {
        const categoryString = this.getCorrectedCategoryValue();
        return (h("arcgis-charts-config-field-select", { label: categoryString, ref: (e) => {
                this.categoryElement = e;
            }, onClick: this.onCategorySelect }));
    }
    /**
     * @category Render UX
     */
    renderNumericFields(fields) {
        const objectIdField = wc(this.layerFieldsInfo);
        const fieldList = [];
        for (let i = 0; i < fields.length; i += 1) {
            if (fields[i] !== objectIdField) {
                fieldList.push(this.buildNumericFieldItem(fields[i]));
            }
        }
        return (h("calcite-list", { label: "", class: HTMLClasses$1.fieldList, ref: (e) => {
                this.numericFieldsElement = e;
            } }, fieldList));
    }
    /**
     * @category Render UX
     * @param field
     */
    buildNumericFieldItem(field) {
        return (h("calcite-list-item", { label: Tl(this.layerFieldsInfo, field), value: field, key: field, closable: true, onCalciteListItemClose: this.onRemoveNumericField }));
    }
    /**
     * @category Lifecycle
     */
    render() {
        const categoryUI = this.renderCategory();
        const sortingUI = this.renderSorting();
        const numericFieldsUI = this.renderNumericFields([...this.model.getNumericFields()]);
        return (h(Host, { key: '71c159378eacd2102b08dedb9f490be7a0d61a16', class: { [HTMLClasses$1.rtl]: this.direction === "rtl" } }, h("calcite-label", { key: 'a4257387596421399c45874db20d7b4113afe2f9', class: HTMLClasses$1.label }, this.strings.category, categoryUI), [
            h("calcite-label", { key: 'fe2ce6294d26d51237ca0e37b25e6260bd4f2b30', class: HTMLClasses$1.label }, this.strings.numericFields, numericFieldsUI),
            h("div", { key: '0ff966420080f20ec8234ba8667cd95839fffb9f', class: HTMLClasses$1.fab }, h("calcite-fab", { key: '3471ebb056b44ee0dece3f44dc68a095f6c347d0', appearance: "outline-fill", kind: "neutral", scale: "m", label: this.strings.selectNumericFields, "text-enabled": true, text: this.strings.selectNumericFields, icon: "plus", onClick: this.onAddNumericFields })),
        ], h("calcite-label", { key: 'e954a0fb8a21d2f5ba855524bbbab292113f6763', class: HTMLClasses$1.label, layout: "inline-space-between" }, this.strings.showDataLabels, h("calcite-switch", { key: '211743ae23fe12a013d4d05b111b262678f5fe61', checked: this.model.getDataLabelsVisibility(), onCalciteSwitchChange: this.onShowDataLabelsChange })), h("calcite-label", { key: 'e53374c316407695d6dd52883eec9f86c6d4cf5d', class: HTMLClasses$1.label }, this.strings.sortOrder, sortingUI)));
    }
    /**
     * @category Private
     */
    updateMode(category) {
        const categoryMode = category !== defaultPieFromFieldsName && category.trim() !== "";
        this.model.setMode(categoryMode ? th.Category : th.Fields);
    }
    /**
     * @category Private
     */
    setupPopover() {
        // remove already existing chart popover
        // TODO: this is a hotfix for https://devtopia.esri.com/webgis/arcgis-charts/issues/5366
        // have to find a better way to do this
        this.removePieChartDataPopover();
        // pieChartPopover config
        const popoverConfig = {
            layerFieldsInfo: [...this.layerFieldsInfo],
            onPieChartDataChange: this.onPieChartDataChange,
            popoverClose: this.popoverClose,
        };
        // create a new pieChartPopover
        this.pieChartPopover = Zy(Qy.PieChartDataPopover, popoverConfig);
        if (this.pieChartPopover !== null) {
            switch (this.contentKind) {
                case PieChartDataPopoverKinds.category:
                    this.pieChartPopover.referenceElement = this.categoryElement;
                    this.pieChartPopover.headingTitle = this.strings.categoryHeader;
                    this.pieChartPopover.selectedContent = this.model.getCategory();
                    break;
                case PieChartDataPopoverKinds.numericFields:
                    this.pieChartPopover.referenceElement = this.numericFieldsElement;
                    this.pieChartPopover.headingTitle = this.strings.numericFieldsMultipleHeader;
                    this.pieChartPopover.selectedContent = this.model.getNumericFields();
                    break;
                case PieChartDataPopoverKinds.sortOrder:
                    this.pieChartPopover.referenceElement = this.sortOrderElement;
                    this.pieChartPopover.headingTitle = this.strings.sortOrderHeader;
                    this.pieChartPopover.selectedContent = this.model.getSortOrder();
                    break;
            }
            this.pieChartPopover.contentKind = this.contentKind;
            this.pieChartPopover.open = true;
            this.addPopover();
        }
    }
    /**
     * @category Private
     */
    addPopover() {
        if (!document.body.contains(this.pieChartPopover) && this.pieChartPopover !== null) {
            document.body.appendChild(this.pieChartPopover);
        }
    }
    /**
     * Get the category value based on the current model's category field.
     *
     * **NOTE**: If the category field is the default value(`arcgis_charts_pie_from_fields_name`),
     * return an empty string.
     * @category Private
     * @returns {string} The category value.
     */
    getCorrectedCategoryValue() {
        return this.model.getCategory() === defaultPieFromFieldsName || this.model.getCategory().trim() === ""
            ? ""
            : Tl(this.layerFieldsInfo, this.model.getCategory());
    }
    /**
     * Remove pie chart data popover
     * @category Private
     */
    removePieChartDataPopover() {
        if (this.pieChartPopover !== null) {
            this.pieChartPopover.open = false;
            this.pieChartPopover = Jy(this.pieChartPopover);
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
};
ArcGISChartsConfigPieChartData.style = ArcgisChartsConfigPieChartDataStyle0;

const HTMLClasses = {
    sectionLabel: "section-label",
    label: "label",
    sliceList: "slice-list",
    radioGroup: "radio-group",
    pieDonutLabelsContainer: "pie-donut-labels-container",
    sliderInputContainer: "slider-input-container",
    groupingLabelContainer: "grouping-label-container",
    numberInput: "number-input",
};

const arcgisChartsConfigPieChartSlicesCss = ":host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}.section-label{display:flex;margin:var(--arcgis-charts-config-margin-major) var(--arcgis-charts-config-margin-minor);justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}.label{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.label .grouping-label-container{display:flex;justify-content:space-between}.label .slider-input-container{display:flex}.label .slider-input-container calcite-slider{--calcite-label-margin-bottom:var(--arcgis-charts-intra-section-margin) !important;margin-right:var(--arcgis-charts-config-margin-minor);flex-grow:1}.label .slider-input-container .number-input{width:8rem}.slice-list{margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-major)}.radio-group{margin-top:var(--arcgis-charts-config-margin-minor)}.pie-donut-labels-container{display:flex;justify-content:space-between;margin-top:calc(var(--arcgis-charts-config-margin-minor) * -3)}";
const ArcgisChartsConfigPieChartSlicesStyle0 = arcgisChartsConfigPieChartSlicesCss;

const ArcGISChartsConfigPieChartSlices = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.arcgisChartsConfigPieChartSlicesPopoverChange = createEvent(this, "arcgisChartsConfigPieChartSlicesPopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        /**
         * @category Private
         */
        this.slicesPopover = null;
        /**
         * @category Event handler
         */
        this.onDonutSizeSliderChange = debounce(() => {
            if (Number.isInteger(this.donutSizeSliderElement.value)) {
                this.model.setInnerRadiusSize(this.donutSizeSliderElement.value ?? oa);
            }
        }, UIDefaults.SliderTimer);
        /**
         * @category Event handler
         */
        this.onGroupingThresholdSliderChange = debounce(() => {
            const thresholdValue = this.groupingThresholdSliderElement.value;
            if (!Number.isNaN(thresholdValue)) {
                this.groupingThresholdElement.value = thresholdValue.toString();
                this.groupingThresholdSliderElement.value = thresholdValue;
                this.model.setGroupingThreshold(thresholdValue);
            }
            else {
                this.model.setGroupingThreshold(0);
            }
        }, UIDefaults.SliderTimer);
        /**
         * @category Event handler
         */
        this.onGroupingThresholdChange = (e) => {
            const rawValue = e.target.value;
            let value = Number.parseInt(rawValue);
            if (value > 100) {
                value = 100;
            }
            else if (value < 0) {
                value = 0;
            }
            if (!Number.isNaN(value)) {
                this.groupingThresholdElement.value = value.toString();
                this.model.setGroupingThreshold(value);
                this.groupingThresholdSliderElement.value = value;
            }
            else {
                this.model.setGroupingThreshold(0);
            }
        };
        /**
         * @category Event handler
         */
        this.onLabelCharacterLimitChange = (e) => {
            const rawValue = e.target.value;
            let value = Number.parseInt(rawValue);
            if (value < 1) {
                value = 1;
            }
            if (!Number.isNaN(value)) {
                this.labelCharacterLimitElement.value = value.toString();
                this.model.setLabelCharacterLimit(value);
            }
            else {
                this.model.setLabelCharacterLimit(null);
            }
        };
        /**
         * @category Event handler
         */
        this.onDecimalPlacesChange = (e) => {
            const rawValue = e.target.value;
            let value = Number.parseInt(rawValue);
            if (value < 0) {
                value = 0;
            }
            else if (value > 20) {
                value = 20;
            }
            if (!Number.isNaN(value)) {
                this.decimalPlacesElement.value = value.toString();
                this.model.setDecimalPlaces(value);
            }
            else {
                this.model.setDecimalPlaces(0);
            }
        };
        /**
         * @category Event handler
         */
        this.onDisplayTypeChange = (e) => {
            const displayType = e.target.selectedItem;
            this.model.setDisplayType(displayType.value);
        };
        /**
         * @category Event handler
         */
        this.resetSlicesOriginal = () => {
            this.configSliceOpen = false;
            this.selectedSliceId = undefined;
            this.model.setColorMatch(true);
            this.model.resetSlices();
        };
        /**
         * @category Event handler
         */
        this.sliceNameChange = (event) => {
            if (event.detail !== null || event.detail !== undefined) {
                const name = event.detail?.name;
                const index = this.model.getSlices()?.findIndex((s) => s.sliceId === this.selectedSliceId);
                const sliceGrouping = this.model.getSliceGrouping();
                if (index !== undefined && index !== null && index >= 0) {
                    this.model.setSliceName(name, index);
                }
                else if (sliceGrouping?.sliceId === this.selectedSliceId && sliceGrouping !== undefined) {
                    this.model.setSliceGrouping({
                        ...sliceGrouping,
                        label: name,
                    });
                }
            }
        };
        /**
         * @category Event handler
         */
        this.sliceColorChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { color } = e.detail;
                const index = this.model.getSlices()?.findIndex((s) => s.sliceId === this.selectedSliceId);
                const sliceGrouping = this.model.getSliceGrouping();
                if (index !== undefined && index !== null && index >= 0) {
                    this.model.setColorMatch(false);
                    this.model.setSliceColor(color, index);
                }
                else if (sliceGrouping?.sliceId === this.selectedSliceId && sliceGrouping !== undefined) {
                    this.model.setColorMatch(false);
                    this.model.setSliceGrouping({
                        ...sliceGrouping,
                        fillSymbol: {
                            ...sliceGrouping.fillSymbol,
                            type: RESTSymbolType.SFS,
                            color,
                        },
                    });
                }
            }
        };
        /**
         * @category Event handler
         */
        this.onCalciteListOrderChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { newIndex, oldIndex } = e.detail;
                this.model.moveSeries(oldIndex, newIndex);
            }
        };
        /**
         * @category Event handler
         */
        this.slicesPopoverClose = () => {
            this.selectedSliceId = undefined;
            this.configSliceOpen = false;
        };
        /**
         * @category Event handler
         */
        this.slicesPopoverChange = (open) => {
            this.arcgisChartsConfigPieChartSlicesPopoverChange.emit({
                open,
                element: this.slicesPopover,
            });
        };
        /**
         * @category Event handler
         */
        this.openSlicesPopover = (event) => {
            // The target can be either the list item or the icon
            const target = event.target;
            const listItem = target.localName === "calcite-list-item"
                ? target
                : target.parentNode;
            const negateConfigSliceOpen = !this.configSliceOpen;
            this.configSliceOpen = this.selectedSliceId === listItem.value ? negateConfigSliceOpen : true;
            if (this.configSliceOpen) {
                if (listItem.value === this.model.getSliceGrouping()?.sliceId) {
                    this.selectedSliceId = this.model.getSliceGrouping()?.sliceId;
                }
                else {
                    this.selectedSliceId = listItem.value;
                }
            }
            else {
                this.selectedSliceId = undefined;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Emit event on open popover.
         * @param e
         * @category Private
         */
        this.openChange = (e) => {
            this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
        };
        /**
         * Creates a tooltip for the hovered action.
         * @category Event handler
         */
        this.createTooltip = (e) => {
            const iconElement = e.target;
            this.tooltip = createActionTooltip(iconElement);
            this.tooltip.innerHTML = this.strings.groupingInfo;
            // append tooltip to the document body instead of action element
            // to avoid tooltip being cut off by calcite panel header element
            document.body.appendChild(this.tooltip);
        };
        /**
         * Destroys tooltip for the action that was being hovered.
         * @category Event handler
         */
        this.destroyTooltip = () => {
            destroyActionTooltip(this.tooltip);
        };
        this.model = undefined;
        this.configSliceOpen = false;
        this.popoverPlacement = "leading";
        this.chartData = undefined;
        this.selectedSliceId = undefined;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Watch handler
     */
    selectedSliceIdChange() {
        if (!isEmpty(this.selectedSliceId) && this.configSliceOpen) {
            this.setupSlicesPopover();
            if (this.slicesPopover !== null) {
                const slices = this.model.getSlices();
                const sliceGrouping = this.model.getSliceGrouping();
                // sync back to slicesPopover
                if (this.selectedSliceId === sliceGrouping?.sliceId) {
                    this.slicesPopover.selectedName = sliceGrouping?.label;
                    this.slicesPopover.selectedColor = sliceGrouping?.fillSymbol?.color;
                }
                else if (slices !== undefined) {
                    const index = slices.findIndex((slice) => slice.sliceId === this.selectedSliceId);
                    this.slicesPopover.selectedName = this.model.getSliceName(index);
                    this.slicesPopover.selectedColor = this.model.getSliceColor(index);
                }
                if (!this.slicesPopover.open) {
                    this.slicesPopover.open = true;
                }
            }
            this.addSlicesPopover();
        }
    }
    /**
     * @category Private
     */
    removeSlicesPopover() {
        if (this.slicesPopover !== undefined && this.slicesPopover !== null) {
            this.slicesPopover.open = false;
            this.slicesPopover.selectedName = undefined;
            this.slicesPopover.selectedColor = undefined;
            this.slicesPopover = Jy(this.slicesPopover);
        }
        this.slicesPopoverChange(false);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await Mn(this.hostElement, getAssetPath(`.`)));
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removeSlicesPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Render UX
     */
    buildSliceListItem() {
        let iconColor = "#CCCCCC";
        let icon = "minus-square";
        const sliceList = [];
        let slices = this.model.getSlices();
        const chartData = this.chartData?.dataItems;
        // Filter the slices based on the processed data
        if (chartData) {
            slices = slices?.filter((slice) => chartData?.findIndex((item) => item.arcgis_charts_slice_id === slice.sliceId) !== -1);
        }
        slices?.forEach((eachSlice) => {
            // If `undefined` is provided for the slice, we default the color icon to a grey minus square
            if (eachSlice.fillSymbol?.color !== undefined) {
                icon = "square-f";
                const [r, g, b, a] = [...eachSlice.fillSymbol.color];
                iconColor = `rgba(${r},${g},${b},${a / 255})`;
            }
            if (eachSlice !== undefined && !this.model.getGroupedSliceIds().includes(eachSlice.sliceId)) {
                let description = eachSlice.sliceId;
                // handling the special case of `null` and empty slices values, by replacing the technical slice id by a t9n label
                if (description === Zn.emptySliceId) {
                    description = this.strings.emptySlice;
                }
                else if (description === Zn.nullSliceId) {
                    description = this.strings.nullSlice;
                }
                sliceList?.push(h("calcite-list-item", { key: eachSlice.sliceId, label: eachSlice.label ?? eachSlice.sliceId, description: description, value: eachSlice.sliceId, selected: this.selectedSliceId === eachSlice.sliceId, onClick: this.openSlicesPopover }, h("calcite-icon", { slot: "content-end", icon: icon, style: { color: iconColor } })));
            }
        });
        const sliceGrouping = this.model.getSliceGrouping();
        if (sliceGrouping?.fillSymbol?.color !== undefined) {
            icon = "square-f";
            const [r, g, b, a] = [...sliceGrouping.fillSymbol.color];
            iconColor = `rgba(${r},${g},${b},${a / 255})`;
        }
        if (this.model.getGroupedSliceIds().length > 0) {
            sliceList?.push(h("calcite-list-item", { key: sliceGrouping?.sliceId, label: sliceGrouping?.label ?? sliceGrouping?.sliceId ?? "", description: this.strings.groupedSlices, value: sliceGrouping?.sliceId ?? "", selected: this.selectedSliceId === sliceGrouping?.sliceId, onClick: this.openSlicesPopover }, h("calcite-icon", { slot: "content-end", icon: icon, style: { color: iconColor } })));
        }
        return sliceList;
    }
    /**
     * @category Render UX
     */
    buildGroupedSlicesListItem() {
        let iconColor = "#CCCCCC";
        let icon = "minus-square";
        const sliceList = [];
        this.model.getSlices()?.forEach((eachSlice) => {
            // If `undefined` is provided for the slice, we default the color icon to a grey minus square
            if (eachSlice.fillSymbol?.color !== undefined) {
                icon = "square-f";
                const [r, g, b, a] = [...eachSlice.fillSymbol.color];
                iconColor = `rgba(${r},${g},${b},${a / 255})`;
            }
            if (eachSlice !== undefined && this.model.getGroupedSliceIds().includes(eachSlice.sliceId)) {
                sliceList?.push(h("calcite-list-item", { key: eachSlice.sliceId, label: eachSlice.label ?? eachSlice.sliceId, description: eachSlice.sliceId, value: eachSlice.sliceId, selected: this.selectedSliceId === eachSlice.sliceId, onClick: this.openSlicesPopover }, h("calcite-icon", { slot: "content-end", icon: icon, style: { color: iconColor } })));
            }
        });
        return sliceList;
    }
    /**
     * @category Render UX
     */
    buildSliceList() {
        return (h("calcite-list", { label: "", class: HTMLClasses.sliceList, selectionMode: "single", selectionAppearance: "border", onCalciteListOrderChange: this.onCalciteListOrderChange }, this.buildSliceListItem()));
    }
    /**
     * @category Render UX
     */
    buildGroupedSliceList() {
        return (h("calcite-list", { label: "", class: HTMLClasses.sliceList, selectionMode: "single", selectionAppearance: "border", onCalciteListOrderChange: this.onCalciteListOrderChange }, this.buildGroupedSlicesListItem()));
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (h(Host, { key: '293ddf3eb0fc2a0f6ddee6d6d7d67f83a581eddc' }, h("div", { key: '33736708d4bf2fd7ab4f2daea0250348000f0091', class: HTMLClasses.sectionLabel }, this.strings.settings), h("calcite-label", { key: 'b460ef6df43c4fa27874da0627067cc9da9be74c', class: HTMLClasses.label }, this.strings.shape, h("calcite-slider", { key: '4d2a71ed4ff75b3490872ac514d2662504ee6f70', labelHandles: false, min: 0, max: 100, step: 1, snap: true, value: this.model.getInnerRadiusSize() ?? oa, onCalciteSliderChange: this.onDonutSizeSliderChange, ref: (e) => {
                this.donutSizeSliderElement = e;
            } })), h("div", { key: '55b78f6fbaae0f57e5ac7ff8cda76d037fe5224f', class: HTMLClasses.pieDonutLabelsContainer }, h("calcite-label", { key: '2be88abd27cb7dd021ec4a50572a1062fa68f1a1', class: HTMLClasses.label }, this.strings.pie), h("calcite-label", { key: '3ebc0cb1e920ea29098a3985707b014eb0fb21cf', class: HTMLClasses.label }, this.strings.donut)), h("calcite-label", { key: '30ade5368a4b77b8c437403885e05f2ef1a47cf0', class: HTMLClasses.label }, h("div", { key: '692439e410c9d1ae400b14535511b03a6f5d4472', class: HTMLClasses.groupingLabelContainer }, h("div", { key: 'd9731959878d99243a0595d5bd217676cb265e16' }, this.strings.groupingPercent), h("calcite-icon", { key: '3c1d5035d3f130efc26ae9dd983cdd1b1b4fac34', icon: "information", scale: "s", flipRtl: true, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip })), h("div", { key: '0055f28f084b6786d9975ab003d8acda8972933c', class: HTMLClasses.sliderInputContainer }, h("calcite-slider", { key: 'd8984e35a7e76fc265b80d7ebc7153411a4af28f', labelHandles: false, min: 0, max: 50, step: 1, snap: true, value: toNumber(sanitizeNumber(this.model.getGroupingThreshold() ?? 0)), onCalciteSliderChange: this.onGroupingThresholdSliderChange, ref: (e) => {
                this.groupingThresholdSliderElement = e;
            } }), h("calcite-input", { key: 'af4d17930b74105701c70bd659f13a30eb8b05a0', class: HTMLClasses.numberInput, type: "number", min: 0, max: 100, step: 1, suffixText: "%", value: sanitizeNumber(this.model.getGroupingThreshold() ?? 0), onCalciteInputInput: this.onGroupingThresholdChange, ref: (e) => {
                this.groupingThresholdElement = e;
                this.groupingThresholdElement.addEventListener("click", (event) => {
                    // TODO: This is a temp fix. Remove this listener and its logic when calcite team fixes the issue - https://github.com/Esri/calcite-components/issues/5070
                    // stop propagation of click event to the nearby slider element
                    event.stopPropagation();
                });
            } }))), h("div", { key: '9b59c69fac201710189b16ff7165c0f8f78ca566', class: HTMLClasses.sectionLabel }, this.strings.labels), h("calcite-label", { key: '8b00f14ac794850d5d17d8b3810f1ee03d27f1ab', class: HTMLClasses.label }, this.strings.labelCharacterLimit, h("calcite-input", { key: 'c4fa9c3397c4e11350cb2508b8347d79e41b8658', type: "number", min: 1, step: 1, value: sanitizeNumber(this.model.getLabelCharacterLimit()), onCalciteInputInput: this.onLabelCharacterLimitChange, ref: (e) => {
                this.labelCharacterLimitElement = e;
            } })), h("calcite-label", { key: '6d43bcb7ba905e78457f2f87cd78a29b4fdc3c56', class: HTMLClasses.label }, this.strings.decimalPlaces, h("calcite-input", { key: 'df34a75495d81b26be2afc05bdce1fd5b1e3d490', type: "number", min: 0, max: 20, step: 1, value: sanitizeNumber(this.model.getDecimalPlaces()), onCalciteInputInput: this.onDecimalPlacesChange, ref: (e) => {
                this.decimalPlacesElement = e;
            } })), h("calcite-label", { key: '504bd5145c4f3da5388ae41f9887cae7469b5490', class: HTMLClasses.label }, this.strings.display, h("calcite-radio-button-group", { key: 'abbcc323977b72eaa00283be8f7ef7f861b090a9', class: HTMLClasses.radioGroup, name: "display", layout: "vertical", onCalciteRadioButtonGroupChange: this.onDisplayTypeChange }, h("calcite-label", { key: '402b87bd856dc1b81298d3be73aba87e05df9a66', layout: "inline" }, h("calcite-radio-button", { key: '252d104dcf622fac9099913dec3f1c4c6f97c33c', value: rh.Value, checked: this.model.getDisplayType() === rh.Value }), this.strings.value), h("calcite-label", { key: 'eb97a15177a32a39c6837e7bc80ca9258aa87af6', layout: "inline" }, h("calcite-radio-button", { key: 'df37ae7085998b12708b1395e90c60f57b7d747b', value: rh.Percentage, checked: this.model.getDisplayType() === rh.Percentage }), this.strings.percentage), h("calcite-label", { key: 'acd24bb6ebf731490a84854e50cb328dfdc42475', layout: "inline" }, h("calcite-radio-button", { key: 'fe31aa327b130225544b0cbfd88c50c053ae8004', value: rh.Both, checked: this.model.getDisplayType() === rh.Both }), this.strings.both))), h("div", { key: 'cce8d301acb22ef81d523e376319b014b0a27102', class: HTMLClasses.sectionLabel }, this.strings.slices, h("calcite-button", { key: '25e0ff6b850ffcfff2b2ec105d3343e2a2c21b44', onClick: this.resetSlicesOriginal, disabled: !this.model.resetAvailable(), appearance: "transparent", iconEnd: "reset" }, this.strings.reset)), this.buildSliceList(), h("div", { key: '1a8965ba5c7a444779f4b2eb5b78b5a05180de20', class: HTMLClasses.sectionLabel }, this.strings.groupedSlices), this.buildGroupedSliceList()));
    }
    /**
     * @category Private
     */
    setupSlicesPopover() {
        if (this.slicesPopover === null && this.hostElement !== undefined) {
            // slicesPopover config
            const popoverConfig = {
                referenceElement: this.hostElement,
                placement: this.popoverPlacement,
                sliceNameChange: this.sliceNameChange,
                sliceColorChange: this.sliceColorChange,
                openChange: this.openChange,
                popoverClose: this.slicesPopoverClose,
            };
            // create a new slicesPopover
            this.slicesPopover = Zy(Qy.PieChartSlicesPopover, popoverConfig);
        }
    }
    /**
     * @category Private
     */
    addSlicesPopover() {
        if (this.slicesPopover != null && !document.body.contains(this.slicesPopover)) {
            document.body.appendChild(this.slicesPopover);
        }
        this.slicesPopoverChange(true);
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "selectedSliceId": ["selectedSliceIdChange"]
    }; }
};
ArcGISChartsConfigPieChartSlices.style = ArcgisChartsConfigPieChartSlicesStyle0;

export { ArcGISChartsConfigPieChartData as arcgis_charts_config_pie_chart_data, ArcGISChartsConfigPieChartSlices as arcgis_charts_config_pie_chart_slices };
