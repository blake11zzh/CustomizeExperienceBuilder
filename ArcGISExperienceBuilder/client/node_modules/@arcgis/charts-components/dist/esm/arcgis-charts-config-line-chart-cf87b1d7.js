/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { r as registerInstance, c as createEvent, h, H as Host, a as getElement } from './index-accb48c0.js';
import { s as bc, S as Sc, T as Tc, t as ty, u as RESTSymbolType, I as Ic } from './rest-js-object-literals-a5a8eefc.js';
import { C as ChartAuthoringPages } from './interfaces-f2a30723.js';
import { i as isEqual } from './isEqual-963b8247.js';
import { c as cloneDeep } from './cloneDeep-1323ff62.js';

const arcgisChartsConfigBarChartCss = ":host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}";
const ArcgisChartsConfigBarChartStyle0 = arcgisChartsConfigBarChartCss;

const ArcGISChartsConfigBarChart = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.arcgisChartsNoSeriesUpdate = createEvent(this, "arcgisChartsConfigNoSeriesUpdate", 7);
        /**
         * @category Private
         */
        this.popoverElement = null;
        /**
         * @category Event handler
         */
        this.popoverOpen = (e) => {
            const { open = false, element = null } = { ...e.detail };
            if (open === true && this.popoverElement !== element) {
                if (this.popoverElement !== null) {
                    this.popoverElement.open = false;
                }
                this.popoverElement = element;
            }
            else if (open === false && this.popoverElement === element) {
                this.popoverElement = null;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = async (e) => {
            const config = e?.detail.config ?? this.model.getConfig();
            if (this.layer === undefined) {
                await this.updateFetchLayerFieldsInfo(config);
            }
        };
        this.model = undefined;
        this.timeZone = undefined;
        this.popoverPlacement = "leading";
        this.seriesColor = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.page = undefined;
        this.layer = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.layerFieldsInfo = undefined;
        this.activeColorMatch = false;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    async layerChange(newValue, oldValue) {
        if (newValue !== undefined && !isEqual(oldValue, newValue)) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    async usePopupTemplateFieldsInfoChange(newValue, oldValue) {
        if (newValue !== undefined && newValue !== oldValue) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * Assigns new colors to the series
     * @param seriesColor
     * @category Watch handler
     */
    seriesColorChange(seriesColor) {
        this.activeColorMatch = seriesColor?.get(0) === undefined;
        if (this.model.getColorMatch()) {
            seriesColor?.forEach((fillSymbol, index) => {
                if (seriesColor?.get(0) !== undefined &&
                    fillSymbol?.color !== undefined &&
                    !isEqual(this.model.getSeriesColor(index), fillSymbol?.color)) {
                    this.model.setSeriesColor(fillSymbol?.color, index);
                }
            });
        }
    }
    /**
     * update the data filter `where` clause with the layer definitionExpression if they are different
     */
    async updateDataFilters() {
        const savedDataFilter = this.model.getDataFilter();
        const whereFilter = savedDataFilter?.where;
        // NOTE: definitionalExpression is returned as null if it is not set
        const definitionExpressionFromLayer = this.layer?.definitionExpression ?? undefined;
        if (!isEqual(whereFilter, definitionExpressionFromLayer)) {
            await this.model.setDataFilter({
                ...savedDataFilter,
                where: definitionExpressionFromLayer,
            });
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        if (this.layer !== undefined) {
            await this.layerChange(this.layer, undefined);
        }
        if (this.seriesColor !== undefined) {
            this.seriesColorChange(this.seriesColor);
        }
        if (this.usePopupTemplateFieldsInfo !== undefined) {
            await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, undefined);
        }
        this.modelChange(this.model);
        this.onModelConfigChange();
        this.updateDataFilters();
    }
    /**
     * @category Lifecycle
     */
    async componentWillRender() {
        // Ensure layerFieldsInfo is defined
        if (this.layerFieldsInfo === undefined) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * Render the panels for each of the pages.
     * @category Lifecycle
     */
    render() {
        const categoryField = this.layerFieldsInfo.find((field) => field.name === this.model.getXAxisField());
        const enableXAxisGuide = categoryField !== undefined && Tc(categoryField);
        let panel;
        switch (this.page) {
            case ChartAuthoringPages.Data:
                panel = (h(Host, { key: '38f81554721a81aea0f101162f6067fef002479a' }, h("arcgis-charts-config-bar-chart-data", { key: '9b9d4ee22a2e8527c1d1504f5f16352f49012166', model: this.model, layerFieldsInfo: this.layerFieldsInfo })));
                break;
            case ChartAuthoringPages.Series:
                panel = (h(Host, { key: 'adae67c5e8f9cc05bb64912c326ed2a7e2480234' }, h("arcgis-charts-config-bar-chart-series", { key: 'cfbc4ae6a8d265ee504d24569604f2155cabf339', model: this.model, activeColorMatch: this.activeColorMatch, onArcgisChartsConfigBarChartSeriesPopoverChange: this.popoverOpen, popoverPlacement: this.popoverPlacement })));
                break;
            case ChartAuthoringPages.Axes:
                panel = (h(Host, { key: '7d60be19d23299c5bca7dc1969f4bc2c79cc48f6' }, h("arcgis-charts-config-axes", { key: '38a6a0224ea7479109813d51f5a3f4b0b44cbf42', model: this.model, showMinXBoundOption: false, showMaxXBoundOption: false, showMinYBoundOption: false, showMaxYBoundOption: true, showEnableXLogOption: false, showEnableYLogOption: false, calculatedMinMaxBounds: this.calculatedMinMaxBounds })));
                break;
            case ChartAuthoringPages.Guides:
                panel = (h(Host, { key: '90c15c898e0c3e097d4f3d99d1948b2d1111d4a9' }, h("arcgis-charts-config-guides", { key: '7ca16420980680735352bc6303a67c16559f43df', model: this.model, timeZone: this.timeZone, enableXAxisGuide: enableXAxisGuide, enableYAxisGuide: true, calculatedMinMaxBounds: this.calculatedMinMaxBounds, onArcgisChartsConfigGuidePopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.Format:
                panel = (h(Host, { key: 'b78ddf8c5e70f338e465a701b4e320b5b4b3317b' }, h("arcgis-charts-config-format", { key: '06c9bf969430192bf56620fe250b6dc6fcf4be58', model: this.model, onArcgisChartsConfigFormatPopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.General:
                panel = (h(Host, { key: '485101f708f3adf85199d955bf2c91e3242707e2' }, h("arcgis-charts-config-general", { key: 'd90af83fb5cb597331a369f8b486ffe7d27c84aa', model: this.model })));
                break;
            default:
                panel = h(Host, { key: 'd5e7aa173cd16ed363ce2af2d7ce92f635874344' });
                break;
        }
        return panel;
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Private
     */
    async updateFetchLayerFieldsInfo(config) {
        // get feature layer from component prop if exists, otherwise get from current config iLayer
        const currentConfig = config ?? this.model.getConfig();
        let layer = this.layer;
        // if the layer doesn't exist we build one from the config data source
        if (!layer) {
            const iLayer = ty(currentConfig) ? currentConfig.iLayer : undefined;
            if (iLayer) {
                layer = await bc(iLayer);
            }
        }
        if (layer) {
            this.layerFieldsInfo = await Sc(layer, this.usePopupTemplateFieldsInfo);
        }
    }
    get hostElement() { return getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "layer": ["layerChange"],
        "usePopupTemplateFieldsInfo": ["usePopupTemplateFieldsInfoChange"],
        "seriesColor": ["seriesColorChange"]
    }; }
};
ArcGISChartsConfigBarChart.style = ArcgisChartsConfigBarChartStyle0;

const arcgisChartsConfigBoxPlotCss = ":host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}";
const ArcgisChartsConfigBoxPlotStyle0 = arcgisChartsConfigBoxPlotCss;

const ArcGISChartsConfigBoxPlot = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * @category Private
         */
        this.popoverElement = null;
        /**
         * @category Event handler
         */
        this.popoverOpen = (e) => {
            const { open = false, element = null } = { ...e.detail };
            if (open === true && this.popoverElement !== element) {
                if (this.popoverElement !== null) {
                    this.popoverElement.open = false;
                }
                this.popoverElement = element;
            }
            else if (open === false && this.popoverElement === element) {
                this.popoverElement = null;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = async (e) => {
            const config = e?.detail.config ?? this.model.getConfig();
            if (this.layer === undefined) {
                await this.updateFetchLayerFieldsInfo(config);
            }
        };
        this.model = undefined;
        this.popoverPlacement = "leading";
        this.seriesColor = undefined;
        this.page = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.layer = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.layerFieldsInfo = undefined;
        this.activeColorMatch = false;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    async layerChange(newValue, oldValue) {
        if (newValue !== undefined && !isEqual(oldValue, newValue)) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    async usePopupTemplateFieldsInfoChange(newValue, oldValue) {
        if (newValue !== undefined && newValue !== oldValue) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * Assigns new colors to the series
     * @param seriesColor
     * @category Watch handler
     */
    seriesColorChange(seriesColor) {
        this.activeColorMatch = seriesColor?.get(0) === undefined;
        if (this.model.getColorMatch()) {
            seriesColor?.forEach((value, index) => {
                let color;
                if (value) {
                    if ("fillSymbol" in value) {
                        color = value.fillSymbol?.color;
                    }
                    else if ("lineSymbol" in value) {
                        color = value.lineSymbol.color;
                    }
                }
                if (seriesColor?.get(0) !== undefined &&
                    color !== undefined &&
                    !isEqual(this.model.getSeriesColor(index), color)) {
                    this.model.setSeriesColor(color, index);
                }
            });
        }
    }
    /**
     * update the data filter `where` clause with the layer definitionExpression if they are different
     */
    async updateDataFilters() {
        const savedDataFilter = this.model.getDataFilter();
        const whereFilter = savedDataFilter?.where;
        // NOTE: definitionalExpression is returned as null if it is not set
        const definitionExpressionFromLayer = this.layer?.definitionExpression ?? undefined;
        if (!isEqual(whereFilter, definitionExpressionFromLayer)) {
            await this.model.setDataFilter({
                ...savedDataFilter,
                where: definitionExpressionFromLayer ?? undefined,
            });
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        if (this.layer !== undefined) {
            await this.layerChange(this.layer, undefined);
        }
        if (this.seriesColor !== undefined) {
            this.seriesColorChange(this.seriesColor);
        }
        if (this.usePopupTemplateFieldsInfo !== undefined) {
            await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, undefined);
        }
        this.modelChange(this.model);
        this.onModelConfigChange();
        this.updateDataFilters();
    }
    /**
     * @category Lifecycle
     */
    async componentWillRender() {
        // Ensure layerFieldsInfo is defined
        if (this.layerFieldsInfo === undefined) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    render() {
        let panel;
        switch (this.page) {
            case ChartAuthoringPages.Data:
                panel = (h(Host, { key: '090070d91c46b9690e2badef9cc9d3939dac7415' }, h("arcgis-charts-config-box-plot-data", { key: '0976cdba92052e3af8a9609463952a9544ec7b0e', model: this.model, layerFieldsInfo: this.layerFieldsInfo })));
                break;
            case ChartAuthoringPages.Series:
                panel = (h(Host, { key: '30f05ea39a30ada3ef720076d8833896c0099a38' }, h("arcgis-charts-config-box-plot-series", { key: '130e32d85130a94c213fc8e39a863e71a030799c', model: this.model, activeColorMatch: this.activeColorMatch, onArcgisChartsConfigBoxPlotSeriesPopoverChange: this.popoverOpen, popoverPlacement: this.popoverPlacement })));
                break;
            case ChartAuthoringPages.Axes:
                panel = (h(Host, { key: '84221ef0c0a3e0cb2f8f6fe983f96b061ce6ff8d' }, h("arcgis-charts-config-axes", { key: '1be58bd9e245ba2a3c087cfbc21f1efd78915276', model: this.model, showMinXBoundOption: false, showMaxXBoundOption: false, showMinYBoundOption: true, showMaxYBoundOption: true, showEnableXLogOption: false, showEnableYLogOption: false, calculatedMinMaxBounds: this.calculatedMinMaxBounds })));
                break;
            case ChartAuthoringPages.Guides:
                panel = (h(Host, { key: 'a752195850fdce70ee2be71d0ee5dc2b51bcb47a' }, h("arcgis-charts-config-guides", { key: '6acaf21fd03f09f17cb4722570b9f18b1cca0768', model: this.model, enableXAxisGuide: false, enableYAxisGuide: true, onArcgisChartsConfigGuidePopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.Format:
                panel = (h(Host, { key: '16afe70fa2535a68e6f6e96b91b4e28e6661fc71' }, h("arcgis-charts-config-format", { key: '7ba59c9cdb58e981bc0c75a1a6b3cd39296f8ee9', model: this.model, onArcgisChartsConfigFormatPopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.General:
                panel = (h(Host, { key: '943b6248b9e9845717de2a513aa233c5e27cdf1b' }, h("arcgis-charts-config-general", { key: 'e2948c75a57d1dc9915d3f51631cf5f59e414f2f', model: this.model })));
                break;
            default:
                panel = h(Host, { key: '5807d4f9f5ff47d827c2fa2edc1ab4403b9d7247' });
                break;
        }
        return panel;
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Private
     */
    async updateFetchLayerFieldsInfo(config) {
        // get feature layer from component prop if exists, otherwise get from current config iLayer
        const currentConfig = config ?? this.model.getConfig();
        let layer = this.layer;
        // if the layer doesn't exist we build one from the config data source
        if (!layer) {
            const iLayer = ty(currentConfig) ? currentConfig.iLayer : undefined;
            if (iLayer) {
                layer = await bc(iLayer);
            }
        }
        if (layer) {
            this.layerFieldsInfo = await Sc(layer, this.usePopupTemplateFieldsInfo);
        }
    }
    get hostElement() { return getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "layer": ["layerChange"],
        "usePopupTemplateFieldsInfo": ["usePopupTemplateFieldsInfoChange"],
        "seriesColor": ["seriesColorChange"]
    }; }
};
ArcGISChartsConfigBoxPlot.style = ArcgisChartsConfigBoxPlotStyle0;

const arcgisChartsConfigHistogramCss = ":host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}";
const ArcgisChartsConfigHistogramStyle0 = arcgisChartsConfigHistogramCss;

const ArcGISChartsConfigHistogram = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * @category Private
         */
        this.popoverElement = null;
        /**
         * @category Event handler
         */
        this.popoverOpen = (e) => {
            const { open = false, element = null } = { ...e.detail };
            if (open === true && this.popoverElement !== element) {
                if (this.popoverElement !== null) {
                    this.popoverElement.open = false;
                }
                this.popoverElement = element;
            }
            else if (open === false && this.popoverElement === element) {
                this.popoverElement = null;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = async (e) => {
            const config = e?.detail.config ?? this.model.getConfig();
            if (this.layer === undefined) {
                await this.updateFetchLayerFieldsInfo(config);
            }
        };
        this.model = undefined;
        this.chartData = undefined;
        this.seriesColor = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.page = undefined;
        this.layer = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.layerFieldsInfo = undefined;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    async layerChange(newValue, oldValue) {
        if (newValue !== undefined && !isEqual(oldValue, newValue)) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    async usePopupTemplateFieldsInfoChange(newValue, oldValue) {
        if (newValue !== undefined && newValue !== oldValue) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * Assigns new color to the bins
     * @param seriesColor
     * @category Watch handler
     */
    seriesColorChange(seriesColor) {
        if (this.model.getColorMatch()) {
            seriesColor?.forEach((fillSymbol) => {
                if (seriesColor?.get(0) !== undefined && !isEqual(this.model.getBinColor(), fillSymbol)) {
                    this.model.setBinColor(fillSymbol);
                }
            });
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        if (this.layer !== undefined) {
            await this.layerChange(this.layer, undefined);
        }
        if (this.seriesColor !== undefined) {
            this.seriesColorChange(this.seriesColor);
        }
        if (this.usePopupTemplateFieldsInfo !== undefined) {
            await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, undefined);
        }
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Lifecycle
     */
    async componentWillRender() {
        // Ensure layerFieldsInfo is defined
        if (this.layerFieldsInfo === undefined) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * @category Lifecycle
     */
    render() {
        let panel;
        switch (this.page) {
            case ChartAuthoringPages.Data:
                panel = (h(Host, { key: 'bf69c59cb6d5c70ec671bd91d4d5ee30bc995972' }, h("arcgis-charts-config-histogram-data", { key: 'de1c5cd480f8e5c5c861940506d50465064e4302', model: this.model, meanValue: this.chartData?.mean, medianValue: this.chartData?.median, standardDevValue: this.chartData?.stddev, minValue: this.chartData?.min, maxValue: this.chartData?.max, sumValue: this.chartData?.sum, nullsValue: this.chartData?.nulls, countValue: this.chartData?.count, layerFieldsInfo: this.layerFieldsInfo, onArcgisChartsConfigHistogramDataPopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.Axes:
                panel = (h(Host, { key: '8a8d6b4604619c7d7215c0132323fb4c8c843d37' }, h("arcgis-charts-config-axes", { key: '100bed9d5efb0dcce256d5044dd98e7ee3e207ce', model: this.model, showMinXBoundOption: false, showMaxXBoundOption: false, showMinYBoundOption: false, showMaxYBoundOption: true, showEnableXLogOption: false, showEnableYLogOption: false, calculatedMinMaxBounds: this.calculatedMinMaxBounds })));
                break;
            case ChartAuthoringPages.Guides:
                panel = (h(Host, { key: '1af8a4323dc02b7db307fe3fdb9637f8e182b453' }, h("arcgis-charts-config-guides", { key: '05c7fc0770f54c11476b6f6634f064c4c37317f4', model: this.model, enableXAxisGuide: false, enableYAxisGuide: true, onArcgisChartsConfigGuidePopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.Format:
                panel = (h(Host, { key: '30a6349b1a11a0fa2dc3f2c5422072d8996d82d3' }, h("arcgis-charts-config-format", { key: '889e13afbe77303039368100851e4ef885e71908', model: this.model, onArcgisChartsConfigFormatPopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.General:
                panel = (h(Host, { key: 'f8bed9bcf296e8513ca33836156fcd378f4a91ea' }, h("arcgis-charts-config-general", { key: '250f049e5cd371c348fc4de7e85b4e438f7ea076', model: this.model })));
                break;
            default:
                panel = h(Host, { key: '9a20d6de0844e3fc0f13f5e3495c64f80082ddfa' });
                break;
        }
        return panel;
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Private
     */
    async updateFetchLayerFieldsInfo(config) {
        // get feature layer from component prop if exists, otherwise get from current config iLayer
        const currentConfig = config ?? this.model.getConfig();
        let layer = this.layer;
        // if the layer doesn't exist we build one from the config data source
        if (!layer) {
            const iLayer = ty(currentConfig) ? currentConfig.iLayer : undefined;
            if (iLayer) {
                layer = await bc(iLayer);
            }
        }
        if (layer) {
            this.layerFieldsInfo = await Sc(layer, this.usePopupTemplateFieldsInfo);
        }
    }
    get hostElement() { return getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "layer": ["layerChange"],
        "usePopupTemplateFieldsInfo": ["usePopupTemplateFieldsInfoChange"],
        "seriesColor": ["seriesColorChange"]
    }; }
};
ArcGISChartsConfigHistogram.style = ArcgisChartsConfigHistogramStyle0;

const arcgisChartsConfigScatterPlotCss = ":host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}";
const ArcgisChartsConfigScatterPlotStyle0 = arcgisChartsConfigScatterPlotCss;

const ArcgisChartsConfigScatterPlot = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.arcgisChartsConfigWebChartChange = createEvent(this, "arcgisChartsConfigWebChartChange", 7);
        /**
         * @category Private
         */
        this.popoverElement = null;
        /**
         * @category Event handler
         */
        this.popoverOpen = (e) => {
            const { open = false, element = null } = { ...e.detail };
            if (open === true && this.popoverElement !== element) {
                if (this.popoverElement !== null) {
                    this.popoverElement.open = false;
                }
                this.popoverElement = element;
            }
            else if (open === false && this.popoverElement === element) {
                this.popoverElement = null;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = async (e) => {
            const config = e?.detail.config ?? this.model.getConfig();
            if (this.layer === undefined) {
                await this.updateFetchLayerFieldsInfo(config);
            }
        };
        this.model = undefined;
        this.popoverPlacement = "leading";
        this.r2 = undefined;
        this.calculatedDataMinMaxBounds = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.page = undefined;
        this.layer = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.layerFieldsInfo = undefined;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * Secures the value assigned to the r2 property
     * @param newR2Value the new r2 value assigned to the component
     * @category Watch handler
     */
    r2Change(newR2Value) {
        // Necessary check because a NaN value for instance will trigger an infinite rendering loop (see issues #2502 & #4079)
        // TODO: find the reason of the infinite loop would help avoiding this check
        if (!Number.isFinite(newR2Value)) {
            this.r2 = undefined;
        }
    }
    async layerChange(newValue, oldValue) {
        if (newValue !== undefined && !isEqual(oldValue, newValue)) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    async usePopupTemplateFieldsInfoChange(newValue, oldValue) {
        if (newValue !== undefined && newValue !== oldValue) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        if (this.layer !== undefined) {
            await this.layerChange(this.layer, undefined);
        }
        if (this.usePopupTemplateFieldsInfo !== undefined) {
            await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, undefined);
        }
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Lifecycle
     */
    async componentWillRender() {
        // Ensure layerFieldsInfo is defined
        if (this.layerFieldsInfo === undefined) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * @category Lifecycle
     */
    render() {
        let panel;
        switch (this.page) {
            case ChartAuthoringPages.Data:
                panel = (h(Host, { key: '1177ff84c3303f2319e3adc276b86965240c51be' }, h("arcgis-charts-config-scatter-plot-data", { key: 'f3930d0e68a6b109cd788738d773c5b8c7f26b14', model: this.model, r2: this.r2, layerFieldsInfo: this.layerFieldsInfo, onArcgisChartsConfigScatterPlotPopoverChange: this.popoverOpen, isTableLayer: this.layer?.isTable })));
                break;
            case ChartAuthoringPages.Axes:
                panel = (h(Host, { key: '95bf7e6445609c9ba51d15fa85295110ae042c76' }, h("arcgis-charts-config-axes", { key: '25d4127c3acd23d77af5b2bf60963e562caa91ac', model: this.model, showMinXBoundOption: true, showMaxXBoundOption: true, showMinYBoundOption: true, showMaxYBoundOption: true, showEnableXLogOption: true, showEnableYLogOption: true, calculatedMinMaxBounds: this.calculatedMinMaxBounds, calculatedDataMinMaxBounds: this.calculatedDataMinMaxBounds })));
                break;
            case ChartAuthoringPages.Guides:
                panel = (h(Host, { key: 'c4810613204181fe41197369bbbc75fd5e4d35c7' }, h("arcgis-charts-config-guides", { key: '9952083d7346d9d7048f247ffd2e233a8fd12e7d', model: this.model, enableXAxisGuide: true, enableYAxisGuide: true, onArcgisChartsConfigGuidePopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.Format:
                panel = (h(Host, { key: 'ca736657d6f9ea7a26cfc5fea667510d6e1a48e8' }, h("arcgis-charts-config-format", { key: '4c64f78d799821bf06ffc7790270a9435bcc2aab', model: this.model, onArcgisChartsConfigFormatPopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.General:
                panel = (h(Host, { key: 'a735be8e6da14cf696d812dedc8a9509774fabd7' }, h("arcgis-charts-config-general", { key: '025f6c334fb4f9b55231ca326332eed8e2c7223f', model: this.model })));
                break;
            default:
                panel = h(Host, { key: '011da87670ca4f4eb958825f05072b66725ab430' });
                break;
        }
        return panel;
    }
    /**
     * @category Private
     */
    async updateFetchLayerFieldsInfo(config) {
        // get feature layer from component prop if exists, otherwise get from current config iLayer
        const currentConfig = config ?? this.model.getConfig();
        let layer = this.layer;
        // if the layer doesn't exist we build one from the config data source
        if (!layer) {
            const iLayer = ty(currentConfig) ? currentConfig.iLayer : undefined;
            if (iLayer) {
                layer = await bc(iLayer);
            }
        }
        if (layer) {
            this.layerFieldsInfo = await Sc(layer, this.usePopupTemplateFieldsInfo);
        }
    }
    get hostElement() { return getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "r2": ["r2Change"],
        "layer": ["layerChange"],
        "usePopupTemplateFieldsInfo": ["usePopupTemplateFieldsInfoChange"]
    }; }
};
ArcgisChartsConfigScatterPlot.style = ArcgisChartsConfigScatterPlotStyle0;

const arcgisChartsConfigPieChartCss = ":host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}";
const ArcgisChartsConfigPieChartStyle0 = arcgisChartsConfigPieChartCss;

const ArcGISChartsConfigPieChart = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.arcgisChartsNoSeriesUpdate = createEvent(this, "arcgisChartsConfigNoSeriesUpdate", 7);
        this.arcgisChartsConfigWebChartChange = createEvent(this, "arcgisChartsConfigWebChartChange", 7);
        /**
         * @category Private
         */
        this.popoverElement = null;
        /**
         * @category Event handler
         */
        this.popoverOpen = (e) => {
            const { open = false, element = null } = { ...e.detail };
            if (open === true && this.popoverElement !== element) {
                if (this.popoverElement !== null) {
                    this.popoverElement.open = false;
                }
                this.popoverElement = element;
            }
            else if (open === false && this.popoverElement === element) {
                this.popoverElement = null;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = async (e) => {
            const config = e?.detail.config ?? this.model.getConfig();
            if (this.layer === undefined) {
                await this.updateFetchLayerFieldsInfo(config);
            }
        };
        this.model = undefined;
        this.popoverPlacement = "leading";
        this.seriesColor = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.page = undefined;
        this.layer = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.filterBySelection = undefined;
        this.layerFieldsInfo = undefined;
        this.chartData = undefined;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    async layerChange(newValue, oldValue) {
        if (newValue !== undefined && !isEqual(oldValue, newValue)) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    async usePopupTemplateFieldsInfoChange(newValue, oldValue) {
        if (newValue !== undefined && newValue !== oldValue) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * Assigns new slices info from payload
     * @param seriesColor
     * @category Watch handler
     */
    seriesColorChange(seriesColor) {
        const { slices, groupedSlices, groupOfSlices } = seriesColor?.get(0) ?? {};
        // If filterBySelection is true, then preserve all current slices while updating the colors instead of overwriting the entire list. This is needed to ensure that the slices that are not part of the selection are not lost, and their colors will therefore be restored upon toggling off the FBS.
        // If filterBySelection is false, then overwrite the entire list of slices with the data from the payload.
        let newSlices = [];
        if (this.filterBySelection === true) {
            newSlices =
                this.model
                    .getSlices()
                    ?.map((currentSlice) => slices?.find((s) => s.sliceId === currentSlice.sliceId) ??
                    groupedSlices?.find((s) => s.sliceId === currentSlice.sliceId) ??
                    currentSlice) ?? [];
        }
        else {
            newSlices = (slices ?? []).concat(groupedSlices ?? []);
        }
        newSlices.forEach((_slice, i) => {
            const currentSlice = this.model.getSlices()?.find((s) => s.sliceId === newSlices[i].sliceId);
            // retain the existing slice properties if they exist
            if (currentSlice) {
                newSlices[i] = { ...newSlices[i], ...currentSlice };
            }
            // make sure the outline color is the same as the fill color
            const fillSymbol = newSlices[i].fillSymbol;
            if (fillSymbol !== undefined && !isEqual(fillSymbol?.outline?.color, fillSymbol?.color)) {
                fillSymbol.outline = {
                    ...(fillSymbol.outline ?? {}),
                    type: RESTSymbolType.SLS,
                    color: fillSymbol.color,
                };
            }
        });
        // save grouped slices to separate list
        const groupedSliceIds = (groupedSlices ?? []).map((eachSlice) => eachSlice.sliceId);
        if (groupedSlices !== undefined && !isEqual(groupedSliceIds, this.model.getGroupedSliceIds())) {
            this.model.setGroupedSliceIds(cloneDeep(groupedSliceIds));
        }
        // save new slices list
        if (!isEqual(newSlices, this.model.getSlices())) {
            this.model.setSlices(cloneDeep(newSlices));
        }
        // save group slice properties to config slice grouping
        if (groupOfSlices !== undefined && !isEqual(groupOfSlices, this.model.getSliceGrouping())) {
            this.model.setSliceGrouping(cloneDeep(groupOfSlices));
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        if (this.layer !== undefined) {
            await this.layerChange(this.layer, undefined);
        }
        if (this.seriesColor !== undefined) {
            this.seriesColorChange(this.seriesColor);
        }
        if (this.usePopupTemplateFieldsInfo !== undefined) {
            await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, undefined);
        }
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Lifecycle
     */
    async componentWillRender() {
        if (this.layerFieldsInfo === undefined) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * @category Lifecycle
     */
    render() {
        let panel;
        switch (this.page) {
            case ChartAuthoringPages.Data:
                panel = (h(Host, { key: '390ed7f37ba62859eaa611e505062552c3d64446' }, h("arcgis-charts-config-pie-chart-data", { key: '248f4efd7cc9a80b15f3c85403b10173ba6ab5b7', model: this.model, layerFieldsInfo: this.layerFieldsInfo })));
                break;
            case ChartAuthoringPages.Slices:
                panel = (h(Host, { key: '1b02a7703b8578702c50894f859dbd3bc2554574' }, h("arcgis-charts-config-pie-chart-slices", { key: '497627b7ac1c8eeb2ad75eeb018acc166acf9622', model: this.model, chartData: this.chartData, onArcgisChartsConfigPieChartSlicesPopoverChange: this.popoverOpen, popoverPlacement: this.popoverPlacement })));
                break;
            case ChartAuthoringPages.Format:
                panel = (h(Host, { key: '28e64c2f73ba5f180b5b79d757ffac9dd8e7b5b3' }, h("arcgis-charts-config-format", { key: 'a7d52b470d48e162b52e8c725229f19cc3882cc7', model: this.model, onArcgisChartsConfigFormatPopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.General:
                panel = (h(Host, { key: '589d6c113a7813c30743903f4ee4bb06e52b3f22' }, h("arcgis-charts-config-general", { key: '5fa3998ae7182a2db9f8755a0187a3e18e151afa', model: this.model })));
                break;
            default:
                panel = h(Host, { key: '606e82253dacc2d36fb0ce9d7665811c6b37e951' });
                break;
        }
        return panel;
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Private
     */
    async updateFetchLayerFieldsInfo(config) {
        // get feature layer from component prop if exists, otherwise get from current config iLayer
        const currentConfig = config ?? this.model.getConfig();
        let layer = this.layer;
        // if the layer doesn't exist we build one from the config data source
        if (!layer) {
            const iLayer = ty(currentConfig) ? currentConfig.iLayer : undefined;
            if (iLayer) {
                layer = await bc(iLayer);
            }
        }
        if (layer) {
            this.layerFieldsInfo = await Sc(layer, this.usePopupTemplateFieldsInfo);
        }
    }
    get hostElement() { return getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "layer": ["layerChange"],
        "usePopupTemplateFieldsInfo": ["usePopupTemplateFieldsInfoChange"],
        "seriesColor": ["seriesColorChange"]
    }; }
};
ArcGISChartsConfigPieChart.style = ArcgisChartsConfigPieChartStyle0;

const arcgisChartsConfigLineChartCss = ":host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}";
const ArcgisChartsConfigLineChartStyle0 = arcgisChartsConfigLineChartCss;

const ArcGISChartsConfigLineChart = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.arcgisChartsNoSeriesUpdate = createEvent(this, "arcgisChartsConfigNoSeriesUpdate", 7);
        /**
         * @category Private
         */
        this.popoverElement = null;
        /**
         * @category Event handler
         */
        this.popoverOpen = (e) => {
            const { open = false, element = null } = { ...e.detail };
            if (open === true && this.popoverElement !== element) {
                if (this.popoverElement !== null) {
                    this.popoverElement.open = false;
                }
                this.popoverElement = element;
            }
            else if (open === false && this.popoverElement === element) {
                this.popoverElement = null;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = async (e) => {
            const config = e?.detail.config ?? this.model.getConfig();
            if (this.layer === undefined) {
                await this.updateFetchLayerFieldsInfo(config);
            }
        };
        this.model = undefined;
        this.timeZone = undefined;
        this.popoverPlacement = "leading";
        this.seriesColor = undefined;
        this.calculatedDataMinMaxBounds = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.page = undefined;
        this.layer = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.layerFieldsInfo = undefined;
        this.activeColorMatch = false;
    }
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    async layerChange(newValue, oldValue) {
        if (newValue && !isEqual(oldValue, newValue)) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    async usePopupTemplateFieldsInfoChange(newValue, oldValue) {
        if (newValue && newValue !== oldValue) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * Assigns new colors to the series
     * @param seriesColor
     * @category Watch handler
     */
    seriesColorChange(seriesColor) {
        this.activeColorMatch = seriesColor?.get(0)?.markerSymbol === undefined;
        if (this.model.getColorMatch()) {
            seriesColor?.forEach((symbol, index) => {
                if (seriesColor?.get(0) !== undefined) {
                    // update line properties of the series
                    if (symbol.lineSymbol?.color !== undefined &&
                        !isEqual(this.model.getSeriesColor(index), symbol.lineSymbol.color)) {
                        this.model.setSeriesColor(symbol.lineSymbol.color, index);
                    }
                    if (symbol.lineSymbol?.style !== undefined &&
                        !isEqual(this.model.getSeriesLineStyle(index), symbol.lineSymbol.style)) {
                        this.model.setSeriesLineStyle(symbol.lineSymbol.style, index);
                    }
                    if (symbol.lineSymbol?.width !== undefined &&
                        !isEqual(this.model.getSeriesLineWidth(index), symbol.lineSymbol.width)) {
                        this.model.setSeriesLineWidth(symbol.lineSymbol.width, index);
                    }
                    // update marker properties of the series
                    if (symbol.markerSymbol?.color !== undefined &&
                        !isEqual(this.model.getSeriesMarkerColor(index), symbol.markerSymbol?.color)) {
                        this.model.setSeriesMarkerColor(symbol.markerSymbol?.color, index);
                    }
                    if (symbol.markerSymbol?.style !== undefined &&
                        !isEqual(this.model.getSeriesMarkerStyle(index), symbol.markerSymbol?.style)) {
                        this.model.setSeriesMarkerStyle(symbol.markerSymbol?.style, index);
                    }
                    if (symbol.markerSymbol?.size !== undefined &&
                        this.model.getSeriesMarkerSize(index) !== symbol.markerSymbol?.size) {
                        this.model.setSeriesMarkerSize(symbol.markerSymbol?.size, index);
                    }
                }
            });
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        if (this.layer !== undefined) {
            await this.layerChange(this.layer, undefined);
        }
        if (this.seriesColor !== undefined) {
            this.seriesColorChange(this.seriesColor);
        }
        if (this.usePopupTemplateFieldsInfo !== undefined) {
            await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, undefined);
        }
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Lifecycle
     */
    async componentWillRender() {
        // Ensure layerFieldsInfo is defined
        if (this.layerFieldsInfo === undefined) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * Render the panels for each of the pages.
     * @category Lifecycle
     */
    render() {
        const xField = this.layerFieldsInfo.find((field) => field.name === this.model.getXAxisField());
        const enableXAxisGuide = xField !== undefined && (Ic(xField) || Tc(xField));
        let panel;
        switch (this.page) {
            case ChartAuthoringPages.Data:
                panel = (h(Host, { key: '51b64dbaa60ab8ae714dc9e19c8bdeff8c21f0c7' }, h("arcgis-charts-config-line-chart-data", { key: 'e0277e2fd26a9947e89358b82d16ff9bb8ca2fb9', model: this.model, resetTimeInterval: this.model.resetTimeInterval, layerFieldsInfo: this.layerFieldsInfo })));
                break;
            case ChartAuthoringPages.Series:
                panel = (h(Host, { key: '31225c635de03841696cd5325af31b5004b6e12f' }, h("arcgis-charts-config-line-chart-series", { key: 'c83b93cae1c76b39ad5f75340dfd49197c2182bc', model: this.model, activeColorMatch: this.activeColorMatch, popoverPlacement: this.popoverPlacement, onArcgisChartsConfigLineChartSeriesPopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.Axes:
                panel = (h(Host, { key: 'a6a5c13dc824e21906908c804050fb32b31459db' }, h("arcgis-charts-config-axes", { key: '541221d19b9110370bebf5b687ae424d9b4f745a', model: this.model, showMinXBoundOption: false, showMaxXBoundOption: false, showMinYBoundOption: true, showMaxYBoundOption: true, showEnableXLogOption: true, showEnableYLogOption: true, calculatedMinMaxBounds: this.calculatedMinMaxBounds, calculatedDataMinMaxBounds: this.calculatedDataMinMaxBounds })));
                break;
            case ChartAuthoringPages.Guides:
                panel = (h(Host, { key: '680a733ccccd3e737006945956dac628de6c420c' }, h("arcgis-charts-config-guides", { key: 'c5b3cdb0579591ad16ec3f5167764ce288aa94ce', model: this.model, timeZone: this.timeZone, calculatedMinMaxBounds: this.calculatedMinMaxBounds, enableXAxisGuide: enableXAxisGuide, enableYAxisGuide: true, onArcgisChartsConfigGuidePopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.Format:
                panel = (h(Host, { key: '36bb851fdad38b852cb493e6c8cf9a1b3a9bbac8' }, h("arcgis-charts-config-format", { key: 'fd55952c7522184413fdd2c12d4e130b5711f015', model: this.model, onArcgisChartsConfigFormatPopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.General:
                panel = (h(Host, { key: 'c643c17d7caab0962c3308781c2a19e58edc6c71' }, h("arcgis-charts-config-general", { key: '6951361c4648022d150557c0adadf15c3ea52f87', model: this.model })));
                break;
            default:
                panel = h(Host, { key: '9f14d9926c84426fa4fb903312515060a582b04f' });
                break;
        }
        return panel;
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Private
     */
    async updateFetchLayerFieldsInfo(config) {
        // get feature layer from component prop if exists, otherwise get from current config iLayer
        const currentConfig = config ?? this.model.getConfig();
        let layer = this.layer;
        // if the layer doesn't exist we build one from the config data source
        if (!layer) {
            const iLayer = ty(currentConfig) ? currentConfig.iLayer : undefined;
            if (iLayer) {
                layer = await bc(iLayer);
            }
        }
        if (layer) {
            this.layerFieldsInfo = await Sc(layer, this.usePopupTemplateFieldsInfo);
        }
    }
    get hostElement() { return getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "layer": ["layerChange"],
        "usePopupTemplateFieldsInfo": ["usePopupTemplateFieldsInfoChange"],
        "seriesColor": ["seriesColorChange"]
    }; }
};
ArcGISChartsConfigLineChart.style = ArcgisChartsConfigLineChartStyle0;

export { ArcGISChartsConfigBarChart as A, ArcGISChartsConfigBoxPlot as a, ArcGISChartsConfigHistogram as b, ArcgisChartsConfigScatterPlot as c, ArcGISChartsConfigPieChart as d, ArcGISChartsConfigLineChart as e };
