/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { proxyCustomElement, HTMLElement, getAssetPath, h, Host } from '@stencil/core/internal/client';
import { M as Mn } from './index2.js';
import { f as isCalciteInputValidNumber, m as modifyCalciteInputStatus, b as UIInputStatus, s as sanitizeNumber, U as UIDefaults } from './chart-ui-utils.js';
import { g as generateAxisMinMaxKey, s as state } from './store.js';
import { f as fetchCommonStrings } from './t9n-strings.js';
import { d as defineCustomElement$2 } from './arcgis-charts-config-category-format2.js';
import { d as defineCustomElement$1 } from './arcgis-charts-config-number-format2.js';
import { d as debounce } from './debounce.js';
import { W as WebChartTypes } from './chart-object-literals.js';

class AxisModelWrapper {
    /**
     * `AxisModelWrapper` constructor.
     * @param model The wrapped chart model.
     * @param isXAxis Whether the wrapper is for X-axis or Y-axis.
     */
    constructor(model, isXAxis) {
        this.model = model;
        this.isXAxis = isXAxis;
    }
    getMaxBound() {
        return (this.isXAxis ? this.model.getMaxXBound() : this.model.getMaxYBound()) ?? Number.NaN;
    }
    async setMaxBound(newMaxBound) {
        if (this.isXAxis) {
            await this.model.setMaxXBound(newMaxBound);
        }
        else {
            await this.model.setMaxYBound(newMaxBound);
        }
    }
    getMinBound() {
        return (this.isXAxis ? this.model.getMinXBound() : this.model.getMinYBound()) ?? Number.NaN;
    }
    async setMinBound(newMinBound) {
        if (this.isXAxis) {
            await this.model.setMinXBound(newMinBound);
        }
        else {
            await this.model.setMinYBound(newMinBound);
        }
    }
    getValueFormat() {
        return this.isXAxis ? this.model.getXAxisValueFormat() : this.model.getYAxisValueFormat();
    }
    async setValueFormat(newValueFormat) {
        if (this.isXAxis) {
            await this.model.setXAxisValueFormat(newValueFormat);
        }
        else {
            await this.model.setYAxisValueFormat(newValueFormat);
        }
    }
    getLogarithmic() {
        return (this.isXAxis ? this.model.getXLogarithmic() : this.model.getYLogarithmic()) ?? false;
    }
    async setLogarithmic(newLogarithmicState) {
        if (this.isXAxis) {
            await this.model.setXLogarithmic(newLogarithmicState);
        }
        else {
            await this.model.setYLogarithmic(newLogarithmicState);
        }
    }
}

const HTMLClasses = {
    linkContainer: "link-container",
    headingLabel: "heading-label",
    label: "label",
    text: "text",
    mb2: "mb-2",
    rtl: "arcgis-charts-rtl",
};

const arcgisChartsConfigAxisCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}calcite-block{width:var(--arcgis-charts-config-calcite-block-width, var(--arcgis-charts-config-calcite-block-default-width));height:var(--arcgis-charts-config-calcite-block-height, var(--arcgis-charts-config-calcite-block-default-height));border:0px;box-shadow:0 0 0 0}:host{display:flex;flex-direction:row}.text{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);width:calc(100% - 1.5rem);height:2rem;margin-bottom:var(--arcgis-charts-config-margin-minor)}.label{display:flex;justify-content:space-between}.mb-2{margin-bottom:var(--arcgis-charts-config-margin-minor)}.link-container{display:flex;justify-content:flex-end;margin-top:-0.75rem}:host(.arcgis-charts-rtl) .text{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}";
const ArcgisChartsConfigAxisStyle0 = arcgisChartsConfigAxisCss;

const ArcGISChartsConfigAxis = /*@__PURE__*/ proxyCustomElement(class ArcGISChartsConfigAxis extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.getAxisBoundsFromStateStore = () => {
            let currAxisBoundData;
            const chartAxesBoundDataMap = state.chartAxesBoundDataMap;
            const currChartId = this.model.getChartId();
            if (currChartId) {
                const key = generateAxisMinMaxKey({
                    chartId: currChartId,
                    isXAxis: this.isXAxis,
                    isLogarithmic: this.axisModel.getLogarithmic(),
                });
                currAxisBoundData = chartAxesBoundDataMap[currChartId]?.[key];
            }
            return currAxisBoundData;
        };
        /**
         * @category Event handler
         */
        this.onShowLogScaleMouseEnter = async () => {
            this.showLogScaleTooltip?.remove();
            if (this.showLogScaleSwitch?.disabled) {
                const commonStrings = await fetchCommonStrings(this.hostElement);
                this.showLogScaleTooltip = document.createElement("calcite-tooltip");
                this.showLogScaleTooltip.textContent = commonStrings.tooltips.logDisabled;
                this.showLogScaleTooltip.open = true;
                this.showLogScaleTooltip.referenceElement = this.showLogScaleSwitch;
                document.body.appendChild(this.showLogScaleTooltip);
            }
        };
        /**
         * @category Event handler
         */
        this.onShowLogScaleMouseLeave = () => {
            this.showLogScaleTooltip?.remove();
        };
        /**
         * @category Event handler
         */
        this.onCategoryFormatChange = async (e) => {
            await this.axisModel.setValueFormat(e.target.categoryFormat);
        };
        this.onMaxBoundsChange = async () => {
            const { value } = this.maxBoundInputElement;
            let { status } = this.maxBoundInputElement;
            // Check for empty string coming from the calcite input
            // TODO: This should ideally be undefined or null
            if (value !== undefined && value !== "") {
                const minValue = this.maxBoundInputElement.min === undefined
                    ? this.axisModel.getMinBound()
                    : Math.max(this.maxBoundInputElement.min, this.axisModel.getMinBound());
                const maxBound = Number.parseFloat(value);
                if (maxBound !== this.axisModel.getMinBound() &&
                    isCalciteInputValidNumber(maxBound, minValue, this.maxBoundInputElement.max)) {
                    if (maxBound !== this.axisModel.getMaxBound()) {
                        await this.axisModel.setMaxBound(maxBound);
                        // update the current max bound in the store
                        const currAxisBoundData = this.getAxisBoundsFromStateStore();
                        if (currAxisBoundData) {
                            currAxisBoundData.currMaxBound = maxBound;
                        }
                    }
                    status = UIInputStatus.IDLE;
                }
                else {
                    status = UIInputStatus.INVALID;
                }
            }
            else {
                status = UIInputStatus.IDLE;
            }
            // Updating the max bound input status
            modifyCalciteInputStatus({
                inputElement: this.maxBoundInputElement,
                status,
            });
            // re-evaluating the status of the min bound input now the max has been changed
            if (status !== UIInputStatus.INVALID && this.minBoundInputElement?.status === UIInputStatus.INVALID) {
                await this.onMinBoundsChange();
            }
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Using a debounce to avoid sending too fast a new max bound value to the chart
         * @category Event handler
         */
        this.onMaxBoundsChangeDebounced = debounce(this.onMaxBoundsChange, UIDefaults.DebounceTimer);
        this.onMinBoundsChange = async () => {
            const { value } = this.minBoundInputElement;
            let { status } = this.minBoundInputElement;
            // Check for empty string coming from the calcite input
            if (value !== undefined && value !== "") {
                const maxValue = this.minBoundInputElement.max === undefined
                    ? this.axisModel.getMaxBound()
                    : Math.min(this.minBoundInputElement.max, this.axisModel.getMaxBound());
                const minBound = Number.parseFloat(value);
                if (minBound !== this.axisModel.getMaxBound() &&
                    isCalciteInputValidNumber(minBound, this.minBoundInputElement.min, maxValue)) {
                    if (minBound !== this.axisModel.getMinBound()) {
                        await this.axisModel.setMinBound(minBound);
                        // update the current min bound in the store
                        const currAxisBoundData = this.getAxisBoundsFromStateStore();
                        if (currAxisBoundData) {
                            currAxisBoundData.currMinBound = minBound;
                        }
                    }
                    status = UIInputStatus.IDLE;
                }
                else {
                    status = UIInputStatus.INVALID;
                }
            }
            else {
                status = UIInputStatus.IDLE;
            }
            // Updating the min bound input status
            modifyCalciteInputStatus({
                inputElement: this.minBoundInputElement,
                status,
            });
            // re-evaluating the status of the max bound input now the min has been changed
            if (status !== UIInputStatus.INVALID && this.maxBoundInputElement?.status === UIInputStatus.INVALID) {
                await this.onMaxBoundsChange();
            }
            // Updating the log scale switch that should be disabled when the data min value is less than 0
            await this.updateEnableLogarithmic(this.axisModel.getLogarithmic() && (this.dataMinValue ?? Number.NaN) > 0);
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Using a debounce to avoid sending too fast a new min bound value to the chart
         * @category Event handler
         */
        this.onMinBoundsChangeDebounced = debounce(this.onMinBoundsChange, UIDefaults.DebounceTimer);
        /**
         * @category Event handler
         */
        this.onNumberFormatChange = async (e) => {
            await this.axisModel.setValueFormat({
                type: WebChartTypes.NumberAxisFormat,
                intlOptions: e.detail,
            });
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Event handler
         */
        this.onRevertMaxBoundsToDefault = async () => {
            if (this.maxBoundInputElement?.status === UIInputStatus.INVALID ||
                this.axisModel.getMaxBound() !== this.defaultMaxBound) {
                const currAxisBoundData = this.getAxisBoundsFromStateStore();
                if (this.axisModel.getMinBound() > this.defaultMaxBound) {
                    await this.axisModel.setMinBound(currAxisBoundData?.defaultMinBound ?? Number.NaN);
                }
                await this.axisModel.setMaxBound(currAxisBoundData?.defaultMaxBound ?? Number.NaN);
                const prevUpdates = this.updatesOccurred;
                this.updatesOccurred = prevUpdates + 1;
            }
        };
        /**
         * @category Event handler
         */
        this.onRevertMinBoundsToDefault = async () => {
            if (this.minBoundInputElement?.status === UIInputStatus.INVALID ||
                this.axisModel.getMinBound() !== this.defaultMinBound) {
                if (this.axisModel.getMaxBound() < this.defaultMinBound) {
                    await this.axisModel.setMaxBound(Number.NaN);
                }
                await this.axisModel.setMinBound(Number.NaN);
                const prevUpdates = this.updatesOccurred;
                this.updatesOccurred = prevUpdates + 1;
            }
        };
        /**
         * @category Event handler
         */
        this.enableLogScale = async (e) => {
            const { checked } = e.target;
            await this.axisModel.setLogarithmic(checked && (this.dataMinValue ?? Number.NaN) > 0);
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        this.model = undefined;
        this.isXAxis = undefined;
        this.axisTitle = undefined;
        this.maxBoundMaxLimit = undefined;
        this.maxBoundMinLimit = undefined;
        this.minBoundMinLimit = undefined;
        this.minBoundMaxLimit = undefined;
        this.showMaxBoundOption = undefined;
        this.showMinBoundOption = undefined;
        this.showEnableLogOption = undefined;
        this.dataMaxValue = undefined;
        this.dataMinValue = undefined;
        this.initialMaxBound = undefined;
        this.initialMinBound = undefined;
        this.disableMaxBoundResetBtn = true;
        this.disableMinBoundResetBtn = true;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        this.axisModel = new AxisModelWrapper(this.model, this.isXAxis);
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * Sets a default minimum bound when it is first calculated by the graph.
     * @param newValue The new minimum value
     * @param oldValue The old minimum value
     * @category Watch handler
     */
    dataMinValueChange(newValue, oldValue) {
        if (Number.isNaN(oldValue) && !Number.isNaN(newValue)) {
            this.defaultMinBound = newValue;
        }
    }
    /**
     * Sets a default maximum bound when it is first calculated by the graph.
     * @param newValue The new maximum value
     * @param oldValue The old maximum value
     * @category Watch handler
     */
    dataMaxValueChange(newValue, oldValue) {
        if (Number.isNaN(oldValue) && !Number.isNaN(newValue)) {
            this.defaultMaxBound = newValue;
        }
    }
    initialMaxBoundChange() {
        // if a custom max bound is set, we need to make sure it gets reapplied to the config.
        if (!Number.isNaN(this.axisModel.getMaxBound())) {
            this.axisModel.setMaxBound(this.axisModel.getMaxBound());
        }
    }
    initialMinBoundChange() {
        // if a custom min bound is set, we need to make sure it gets reapplied to the config.
        if (!Number.isNaN(this.axisModel.getMinBound())) {
            this.axisModel.setMinBound(this.axisModel.getMinBound());
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await Mn(this.hostElement, getAssetPath(`.`)));
        this.modelChange(this.model);
        if (this.dataMinValue !== undefined) {
            this.dataMinValueChange(this.dataMinValue, Number.NaN);
        }
        if (this.dataMaxValue !== undefined) {
            this.dataMaxValueChange(this.dataMaxValue, Number.NaN);
        }
    }
    disableResetButtons() {
        const currAxisBoundData = this.getAxisBoundsFromStateStore();
        if (currAxisBoundData) {
            this.disableMaxBoundResetBtn = currAxisBoundData.defaultMaxBound === currAxisBoundData.currMaxBound;
            this.disableMinBoundResetBtn = currAxisBoundData.defaultMinBound === currAxisBoundData.currMinBound;
        }
    }
    /**
     * @category Lifecycle
     */
    componentDidRender() {
        this.disableResetButtons();
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (h(Host, { key: '59dc6c6435a4feb78cfab0eaf0044a89555843f4', class: { [HTMLClasses.rtl]: this.direction === "rtl" } }, h("calcite-block", { key: '551e14f0dc649f652350a51c9e009d80deac4417', hidden: this.axisModel.getValueFormat()?.type === WebChartTypes.DateAxisFormat, collapsible: false, open: true, heading: this.axisTitle }, this.renderAxis())));
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Render UX
     */
    renderAxis() {
        let renderedContent;
        const format = { ...this.axisModel.getValueFormat() };
        switch (this.axisModel.getValueFormat()?.type) {
            case WebChartTypes.CategoryAxisFormat:
                renderedContent = (h("arcgis-charts-config-category-format", { categoryFormat: format, onArcgisChartsConfigCategoryFormatChange: this.onCategoryFormatChange }));
                break;
            case WebChartTypes.NumberAxisFormat:
                renderedContent = (h("div", null, this.renderShowLogScale(), this.renderMinBound(), this.renderMaxBound(), h("arcgis-charts-config-number-format", { numberFormat: { ...format.intlOptions }, onArcgisChartsConfigNumberFormatChange: this.onNumberFormatChange })));
                break;
            case WebChartTypes.DateAxisFormat:
                renderedContent = null;
                break;
        }
        return renderedContent;
    }
    /**
     * @category Render UX
     */
    renderMaxBound() {
        let showMaxBoundElem;
        if (!this.showMaxBoundOption) {
            showMaxBoundElem = null;
        }
        else {
            const sanitizedMaxBound = sanitizeNumber(this.axisModel.getMaxBound(), this.initialMaxBound);
            showMaxBoundElem = (h("div", null, h("calcite-label", { class: HTMLClasses.label }, this.strings.maxBounds, h("calcite-input", { type: "number", numberButtonType: "none", min: this.maxBoundMinLimit ?? Number.MIN_SAFE_INTEGER, max: this.maxBoundMaxLimit ?? Number.MAX_SAFE_INTEGER, step: "any", value: sanitizedMaxBound, onCalciteInputInput: this.onMaxBoundsChangeDebounced, ref: (e) => {
                    this.maxBoundInputElement = e;
                } })), h("div", { class: HTMLClasses.linkContainer }, h("calcite-button", { disabled: this.disableMaxBoundResetBtn, onClick: this.onRevertMaxBoundsToDefault, appearance: "transparent", iconEnd: "reset" }, this.strings.revertToDefault))));
        }
        return showMaxBoundElem;
    }
    /**
     * @category Render UX
     */
    renderMinBound() {
        let showMinBoundElem;
        if (!this.showMinBoundOption) {
            showMinBoundElem = null;
        }
        else {
            const sanitizedMinBound = sanitizeNumber(this.axisModel.getMinBound(), this.initialMinBound ?? undefined);
            showMinBoundElem = (h("div", null, h("calcite-label", { class: HTMLClasses.label }, this.strings.minBounds, h("calcite-input", { type: "number", numberButtonType: "none", min: this.minBoundMinLimit ?? Number.MIN_SAFE_INTEGER, max: this.minBoundMaxLimit ?? Number.MAX_SAFE_INTEGER, step: "any", value: sanitizedMinBound, onCalciteInputInput: this.onMinBoundsChangeDebounced, ref: (e) => {
                    this.minBoundInputElement = e;
                } })), h("div", { class: HTMLClasses.linkContainer }, h("calcite-button", { disabled: this.disableMinBoundResetBtn, appearance: "transparent", iconEnd: "reset", onClick: this.onRevertMinBoundsToDefault }, this.strings.revertToDefault))));
        }
        return showMinBoundElem;
    }
    /**
     * @category Render UX
     */
    renderShowLogScale() {
        let result;
        if (this.showEnableLogOption) {
            result = (h("calcite-label", { layout: "inline-space-between", class: {
                    [HTMLClasses.label]: true,
                    [HTMLClasses.mb2]: true,
                } }, this.strings.logScale, h("div", { onMouseEnter: this.onShowLogScaleMouseEnter, onMouseLeave: this.onShowLogScaleMouseLeave }, h("calcite-switch", { checked: this.axisModel.getLogarithmic() && (this.dataMinValue ?? Number.NaN) > 0, disabled: (this.dataMinValue ?? Number.NaN) <= 0, onCalciteSwitchChange: this.enableLogScale, ref: (e) => {
                    this.showLogScaleSwitch = e;
                } }))));
        }
        return result;
    }
    /**
     * @category Private
     */
    async updateEnableLogarithmic(enableLogarithmic) {
        // emitting the change event only if there's a change
        if (enableLogarithmic !== this.axisModel.getLogarithmic()) {
            await this.axisModel.setLogarithmic(enableLogarithmic);
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return this; }
    static get watchers() { return {
        "model": ["modelChange"],
        "dataMinValue": ["dataMinValueChange"],
        "dataMaxValue": ["dataMaxValueChange"],
        "initialMaxBound": ["initialMaxBoundChange"],
        "initialMinBound": ["initialMinBoundChange"]
    }; }
    static get style() { return ArcgisChartsConfigAxisStyle0; }
}, [1, "arcgis-charts-config-axis", {
        "model": [16],
        "isXAxis": [4, "is-x-axis"],
        "axisTitle": [1, "axis-title"],
        "maxBoundMaxLimit": [2, "max-bound-max-limit"],
        "maxBoundMinLimit": [2, "max-bound-min-limit"],
        "minBoundMinLimit": [2, "min-bound-min-limit"],
        "minBoundMaxLimit": [2, "min-bound-max-limit"],
        "showMaxBoundOption": [4, "show-max-bound-option"],
        "showMinBoundOption": [4, "show-min-bound-option"],
        "showEnableLogOption": [4, "show-enable-log-option"],
        "dataMaxValue": [2, "data-max-value"],
        "dataMinValue": [2, "data-min-value"],
        "initialMaxBound": [2, "initial-max-bound"],
        "initialMinBound": [2, "initial-min-bound"],
        "disableMaxBoundResetBtn": [32],
        "disableMinBoundResetBtn": [32],
        "updatesOccurred": [32]
    }, undefined, {
        "model": ["modelChange"],
        "dataMinValue": ["dataMinValueChange"],
        "dataMaxValue": ["dataMaxValueChange"],
        "initialMaxBound": ["initialMaxBoundChange"],
        "initialMinBound": ["initialMinBoundChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-charts-config-axis", "arcgis-charts-config-category-format", "arcgis-charts-config-number-format"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-charts-config-axis":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcGISChartsConfigAxis);
            }
            break;
        case "arcgis-charts-config-category-format":
            if (!customElements.get(tagName)) {
                defineCustomElement$2();
            }
            break;
        case "arcgis-charts-config-number-format":
            if (!customElements.get(tagName)) {
                defineCustomElement$1();
            }
            break;
    } });
}
defineCustomElement();

export { AxisModelWrapper as A, ArcGISChartsConfigAxis as a, defineCustomElement as d };
