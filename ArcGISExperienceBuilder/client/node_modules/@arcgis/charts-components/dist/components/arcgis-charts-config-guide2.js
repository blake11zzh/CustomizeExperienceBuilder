/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { proxyCustomElement, HTMLElement, createEvent, getAssetPath, h, Host } from '@stencil/core/internal/client';
import { B as Bn, a6 as Pn, a7 as Nn, a8 as Kl, M as Mn, Z as Zy, r as Qy, a4 as Jc, a9 as po, aa as Qc } from './index2.js';
import { n as nh, R as Rg, N as Ng, D as Dg } from './index3.js';
import { m as modifyCalciteInputStatus, c as createActionTooltip, d as destroyActionTooltip, j as blockNumericE, b as UIInputStatus, k as getLineStyleType } from './chart-ui-utils.js';
import { d as defaultGuide } from './default.js';
import { c as cloneDeep } from './cloneDeep.js';
import { a as RESTSymbolType, d as RESTSimpleLineSymbolStyle } from './interfaces.js';
import { W as WebChartTypes } from './chart-object-literals.js';

const HTMLClasses$1 = {
    row: "row",
    column: "column",
    colorPicker: "color-picker",
};

const HTMLClasses = {
    addGuide: "add-guide",
    noMessages: "no-messages",
};
/**
 * Gets the guide list position based on the guide index and orientation.
 * @param index The index of the guide in the list of guides for the given axis orientation.
 * @param orientation The axis orientation of the guide.
 * @param model The model with guides.
 */
function getGuideListPosition(index, orientation, model) {
    const xGuidesLength = Rg(model) ? (model.getXGuidesLength() ?? 0) : 0;
    return orientation === nh.X ? index : xGuidesLength + index;
}

const arcgisChartsConfigGuideCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}:host{display:flex;flex-direction:column}.row{display:flex;flex-direction:row;-moz-column-gap:var(--arcgis-charts-inter-section-margin);column-gap:var(--arcgis-charts-inter-section-margin)}.column{display:flex;flex-direction:column;flex-wrap:wrap;flex-grow:1}.column>calcite-input{margin-bottom:0.5rem;flex-grow:2}.column>calcite-input[type=number]{margin-bottom:0.5rem}input{padding:0.5rem}.label{display:flex;flex-direction:row;justify-content:space-between;margin-bottom:var(--arcgis-charts-intra-section-margin);flex-grow:1}.color-picker{border:1px solid var(--calcite-color-border-2);box-shadow:none;margin-bottom:var(--arcgis-charts-inter-section-margin)}.delete-guide{display:flex;flex-direction:row-reverse;height:2rem;margin:0 1rem;font-weight:550}:host([dir=rtl]) .delete-guide{flex-direction:row}";
const ArcgisChartsConfigGuideStyle0 = arcgisChartsConfigGuideCss;

const ArcgisChartsConfigGuide = /*@__PURE__*/ proxyCustomElement(class ArcgisChartsConfigGuide extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.arcgisChartsConfigGuideChange = createEvent(this, "arcgisChartsConfigGuideChange", 7);
        this.arcgisChartsConfigGuidePopoverChange = createEvent(this, "arcgisChartsConfigGuidePopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        /**
         * @category Event handler
         */
        this.onColorElementSelect = () => {
            if (this.guidePopover?.open === true) {
                this.removeGuidePopover();
            }
            else {
                this.setupGuidePopover();
            }
        };
        /**
         * @category Event handler
         */
        this.setGuideStart = (e) => {
            const { value } = e.target;
            if (this.startCalciteInput !== undefined) {
                if (value === "") {
                    // Set calcite input status to invalid
                    modifyCalciteInputStatus({
                        inputElement: this.startCalciteInput,
                        status: UIInputStatus.INVALID,
                    });
                }
                else {
                    // Set start value
                    this.model.setGuideStart(value, this.index, this.orientation);
                    this.symbolChange();
                    // Emit guide change event
                    this.arcgisChartsConfigGuideChange.emit({
                        index: this.index,
                        orientation: this.orientation,
                        isDelete: false,
                    });
                    // Set calcite input status to idle
                    modifyCalciteInputStatus({
                        inputElement: this.startCalciteInput,
                        status: UIInputStatus.IDLE,
                    });
                }
            }
            // Make sure popover is closed
            if (this.guidePopover?.open === true) {
                this.removeGuidePopover();
            }
        };
        /**
         * @category Event handler
         */
        this.setGuideEnd = (e) => {
            const { value } = e.target;
            if (this.endCalciteInput !== undefined) {
                // Set end value
                this.model.setGuideEnd(value === "" ? null : value, this.index, this.orientation);
                this.symbolChange();
                // Emit guide change event
                this.arcgisChartsConfigGuideChange.emit({
                    index: this.index,
                    orientation: this.orientation,
                    isDelete: false,
                });
                // Set calcite input status to idle
                modifyCalciteInputStatus({
                    inputElement: this.endCalciteInput,
                    status: UIInputStatus.IDLE,
                });
            }
            // Make sure popover is closed
            if (this.guidePopover?.open === true) {
                this.removeGuidePopover();
            }
        };
        /**
         * @category Event handler
         */
        this.setGuideDateTimeRange = () => {
            const payloadMin = this.calculatedMinMaxBounds?.find((axis) => axis.isXAxis)?.minimum;
            const payloadMax = this.calculatedMinMaxBounds?.find((axis) => axis.isXAxis)?.maximum;
            // get default start and end from the payload if available, otherwise use current date
            const defaultStartDateTime = typeof payloadMin === "number" ? new Date(payloadMin) : new Date();
            const defaultEndDateTime = typeof payloadMax === "number" ? new Date(payloadMax) : new Date();
            const currentTimeZone = new window.Intl.DateTimeFormat().resolvedOptions().timeZone;
            const convertedTimeZone = Bn(this.timeZone) ?? currentTimeZone;
            // get default start date and time strings formatted for calcite date picker
            const defaultStartDateString = Pn(defaultStartDateTime, convertedTimeZone);
            const defaultStartTimeString = Nn(defaultStartDateTime, convertedTimeZone);
            // get default end date and time string formatted for calcite date picker
            const defaultEndDateString = Pn(defaultEndDateTime, convertedTimeZone);
            const defaultEndTimeString = Nn(defaultEndDateTime, convertedTimeZone);
            const startDateStringFromInput = this.startDateCalciteInput?.value ?? "";
            const startDateString = startDateStringFromInput === "" ? defaultStartDateString : startDateStringFromInput;
            const startTimeStringFromInput = this.startTimeCalciteInput?.value ?? "";
            const startTimeString = startTimeStringFromInput === "" ? defaultStartTimeString : startTimeStringFromInput;
            const endDateStringFromInput = this.endDateCalciteInput?.value ?? "";
            const endDateString = endDateStringFromInput === "" ? defaultEndDateString : endDateStringFromInput;
            const endTimeStringFromInput = this.endTimeCalciteInput?.value ?? "";
            const endTimeString = endTimeStringFromInput === "" ? defaultEndTimeString : endTimeStringFromInput;
            let changeOccurred = false;
            // Array is technically a possible type for `startDateString`, though it should not happen since the inputs that trigger this event are not set with `range: true`. But we still have to check it for type validity.
            if (!Array.isArray(startDateString) && startDateString !== undefined && startTimeString !== undefined) {
                const startDateTime = `${startDateString}T${startTimeString}`;
                // Set start value
                this.model.setGuideStart(startDateTime, this.index, this.orientation);
                changeOccurred = true;
            }
            // Array is technically a possible type for `endDateString`, though it should not happen since the inputs that trigger this event are not set with `range: true`. But we still have to check it for type validity.
            if (!Array.isArray(endDateString) && endDateString !== undefined && endTimeString !== undefined) {
                // If neither date nor time is set, set end value to null
                const endDateTime = endDateStringFromInput === "" ? undefined : `${endDateString}T${endTimeString}`;
                // Set end value
                this.model.setGuideEnd(endDateTime, this.index, this.orientation);
                changeOccurred = true;
            }
            if (changeOccurred) {
                this.symbolChange();
                // Emit guide change event
                this.arcgisChartsConfigGuideChange.emit({
                    index: this.index,
                    orientation: this.orientation,
                    isDelete: false,
                });
                // Make sure popover is closed
                if (this.guidePopover?.open === true) {
                    this.removeGuidePopover();
                }
            }
        };
        /**
         * @category Event handler
         */
        this.colorChange = (e) => {
            const color = e.detail;
            const start = this.model.getGuideStart(this.index, this.orientation);
            const end = this.model.getGuideEnd(this.index, this.orientation);
            if (Kl(start, end) === RESTSymbolType.SLS) {
                // Edge Case:
                const defaultStyle = cloneDeep(defaultGuide.style);
                const currentStyle = this.model.getGuideStyle(this.index, this.orientation);
                // Merge the new color into the default and current styles
                const lineStyle = {
                    ...defaultStyle,
                    ...(Jc(currentStyle) ? currentStyle : {}),
                    color,
                };
                this.lineStyleChange({ detail: lineStyle });
            }
            else {
                // Main Case:
                // If the guide is not a line style, set the color directly
                this.setColor(color);
            }
        };
        /**
         * @category Event handler
         */
        this.symbolChange = (e) => {
            const newSymbol = e?.detail;
            const start = this.model.getGuideStart(this.index, this.orientation);
            const end = this.model.getGuideEnd(this.index, this.orientation);
            if (Kl(start, end) === RESTSymbolType.SLS) {
                const defaultStyle = cloneDeep(defaultGuide.style);
                const currentStyle = this.model.getGuideStyle(this.index, this.orientation);
                // Merge the new symbol into the default and current styles
                const lineStyle = {
                    ...defaultStyle,
                    ...(Jc(currentStyle) ? currentStyle : {}),
                    ...(Jc(newSymbol) ? newSymbol : {}),
                };
                this.lineStyleChange({ detail: lineStyle });
            }
            else if (newSymbol?.color !== undefined) {
                // Edge case
                this.setColor(newSymbol.color);
            }
        };
        /**
         * @category Event handler
         */
        this.setGuideName = (e) => {
            const name = e.target.value;
            this.model.setGuideName(name, this.index, this.orientation);
            this.arcgisChartsConfigGuideChange.emit({
                index: this.index,
                orientation: this.orientation,
                isDelete: false,
            });
        };
        /**
         * @category Event handler
         */
        this.setGuideLabel = (e) => {
            const labelText = e.target.value;
            this.model.setGuideLabelText(labelText, this.index, this.orientation);
            this.arcgisChartsConfigGuideChange.emit({
                index: this.index,
                orientation: this.orientation,
                isDelete: false,
            });
        };
        /**
         * @category Event handler
         */
        this.setGuideRendered = (e) => {
            const value = e.target?.selectedItem?.value;
            if (value !== undefined) {
                const above = value === this.strings.inFront;
                this.model.setGuideAbove(above, this.index, this.orientation);
                this.arcgisChartsConfigGuideChange.emit({
                    index: this.index,
                    orientation: this.orientation,
                    isDelete: false,
                });
            }
        };
        /**
         * @category Event handler
         */
        this.lineStyleChange = (e) => {
            const guideStyle = e.detail;
            this.model.setGuideStyle(guideStyle, this.index, this.orientation);
            this.arcgisChartsConfigGuideChange.emit({
                index: this.index,
                orientation: this.orientation,
                isDelete: false,
            });
        };
        /**
         * Creates a tooltip for the hovered action.
         * @category Event handler
         */
        this.createTooltip = (e) => {
            const actionElement = e.target;
            this.tooltip = createActionTooltip(actionElement);
            // Set tooltip content to reflect the associated action
            switch (actionElement.icon) {
                case "view-visible":
                    this.tooltip.innerHTML = this.strings.hideGuide;
                    break;
                case "view-hide":
                    this.tooltip.innerHTML = this.strings.showGuide;
                    break;
                case "trash":
                default:
                    this.tooltip.innerHTML = this.strings.deleteGuide;
                    break;
            }
            // append tooltip to the document body instead of action element
            // to avoid tooltip being cut off by calcite panel header element
            document.body.appendChild(this.tooltip);
        };
        /**
         * Toggles guide visibility from action click.
         * @category Event handler
         */
        this.toggleGuide = () => {
            const showGuide = this.model.getGuideVisibility(this.index, this.orientation);
            this.model.setGuideVisibility(!showGuide, this.index, this.orientation);
        };
        /**
         * Destroys tooltip for the action that was being hovered.
         * @category Event handler
         */
        this.destroyTooltip = () => {
            destroyActionTooltip(this.tooltip);
        };
        /**
         * Deletes guide from action click.
         * @category Event handler
         */
        this.deleteGuide = () => {
            this.destroyTooltip(); // remove any existing tooltip
            // Delete guide from config
            if (this.orientation === nh.X && Rg(this.model)) {
                this.model.deleteXAxisGuide(this.index);
            }
            else if (this.orientation === nh.Y && Ng(this.model)) {
                this.model.deleteYAxisGuide(this.index);
            }
            // Emit guide change event with delete flag
            this.arcgisChartsConfigGuideChange.emit({
                index: this.index,
                orientation: this.orientation,
                isDelete: true,
            });
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        this.model = undefined;
        this.timeZone = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.index = undefined;
        this.orientation = undefined;
        this.latestGuidePosition = 0;
        this.guidePopover = undefined;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await Mn(this.hostElement, getAssetPath(`.`)));
        this.modelChange(this.model);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Render UX
     */
    renderColorElement() {
        const style = this.model.getGuideStyle(this.index, this.orientation);
        const [r, g, b, a] = [...(style?.color ?? [1, 1, 1, 255])];
        const start = this.model.getGuideStart(this.index, this.orientation);
        const end = this.model.getGuideEnd(this.index, this.orientation);
        const lineStyleType = Jc(style) ? getLineStyleType(style.style) : RESTSimpleLineSymbolStyle.Solid;
        const icon = Kl(start, end) === RESTSymbolType.SLS ? `line-${lineStyleType}` : "square-f";
        return (h("calcite-list", { label: "", selectionMode: "single", selectionAppearance: "border" }, h("calcite-list-item", { value: this.strings.style, class: HTMLClasses$1.colorPicker, label: this.strings.style, selected: this.guidePopover?.open, onClick: this.onColorElementSelect, ref: (e) => {
                this.colorElement = e;
            } }, h("calcite-icon", { slot: "content-end", icon: icon, style: { color: `rgba(${r},${g},${b},${a / 255})` } }))));
    }
    get isXAxisDateField() {
        return (this.orientation === nh.X &&
            Dg(this.model) &&
            this.model.getXAxisValueFormat()?.type === WebChartTypes.DateAxisFormat);
    }
    /**
     * @category Lifecycle
     */
    render() {
        const start = this.model.getGuideStart(this.index, this.orientation);
        const end = this.model.getGuideEnd(this.index, this.orientation);
        const name = this.model.getGuideName(this.index, this.orientation);
        const labelText = this.model.getGuideLabelText(this.index, this.orientation);
        const above = this.model.getGuideAbove(this.index, this.orientation);
        const showGuide = this.model.getGuideVisibility(this.index, this.orientation);
        const isXAxisDateField = this.isXAxisDateField;
        return (h(Host, { key: '8c817eeb752ad9b070e4d6dd883fd72629bbd6cc' }, h("calcite-block", { key: 'f93e4030a29f72881d4c83832d3f100fc80a2fa5', heading: name ?? "", open: this.latestGuidePosition === getGuideListPosition(this.index, this.orientation, this.model), collapsible: true, messageOverrides: {
                expand: this.strings.expand,
                collapse: this.strings.collapse,
            } }, h("calcite-action", { key: '8f99980a235427e5304a37684a6206491074f3d8', slot: "control", text: "", icon: showGuide ? "view-visible" : "view-hide", onClick: this.toggleGuide, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip }), h("calcite-action", { key: '03cab56e010731d07d4aebe5a6cb49d194194cd1', slot: "control", text: "", icon: "trash", onClick: this.deleteGuide, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip }), h("div", { key: 'f74039a1d4d8ca7f1858688e3b4674a2f96ebb7b', class: HTMLClasses$1.row }, h("calcite-label", { key: '8b924bedf8f4e5f012c972b0da0cb34847fa855e', class: HTMLClasses$1.column }, this.strings.start, isXAxisDateField ? (h("calcite-input-date-picker", { value: this.getDateStringFromBound(start), required: true, scale: "s", placement: "bottom-end", onCalciteInputDatePickerChange: this.setGuideDateTimeRange, ref: (el) => {
                this.startDateCalciteInput = el;
            } })) : (h("calcite-input", { type: "number", required: true, onCalciteInputInput: this.setGuideStart, onKeyDown: blockNumericE, numberButtonType: "none", value: start?.toString(), ref: (el) => {
                this.startCalciteInput = el;
            } }))), h("calcite-label", { key: '26b1f9e3b4d569297e03cf6968b865ffcfc36bec', class: HTMLClasses$1.column }, this.strings.end, isXAxisDateField ? (h("calcite-input-date-picker", { value: this.getDateStringFromBound(end), scale: "s", placement: "bottom-end", onCalciteInputDatePickerChange: this.setGuideDateTimeRange, ref: (el) => {
                this.endDateCalciteInput = el;
            } })) : (h("calcite-input", { type: "number", onCalciteInputInput: this.setGuideEnd, onKeyDown: blockNumericE, numberButtonType: "none", value: end?.toString(), ref: (el) => {
                this.endCalciteInput = el;
            } })))), isXAxisDateField ? (h("div", { key: "time-picker-row", class: HTMLClasses$1.row }, start !== null && start !== undefined ? (h("calcite-label", { class: HTMLClasses$1.column }, h("calcite-input-time-picker", { value: this.getTimeStringFromBound(start), scale: "s", onCalciteInputTimePickerChange: this.setGuideDateTimeRange, ref: (el) => {
                this.startTimeCalciteInput = el;
            } }))) : null, end !== null && end !== undefined ? (h("calcite-label", { class: HTMLClasses$1.column }, h("calcite-input-time-picker", { value: this.getTimeStringFromBound(end), scale: "s", onCalciteInputTimePickerChange: this.setGuideDateTimeRange, ref: (el) => {
                this.endTimeCalciteInput = el;
            } }))) : null)) : null, h("div", { key: '904ad5c5337e020effc9a20758a30973757cda1f', class: HTMLClasses$1.row }, h("div", { key: '19598c5782c32c77e9717c0d658163971cf1286a', class: HTMLClasses$1.column }, this.renderColorElement())), h("div", { key: '82f0ef20f9572c9b5726ac25e2aef8f6102c692b', class: HTMLClasses$1.row }, h("calcite-label", { key: 'ebf579dcebf2569d3da5291a270bdb38ced9d5e2', class: HTMLClasses$1.column }, this.strings.guideName, h("calcite-input", { key: '0d5f0b13f83348201acddea06647952befa120ba', type: "text", value: name, onCalciteInputInput: this.setGuideName }))), h("div", { key: '976a0a1d3ba08738b791bc442d8a4f6a640301c0', class: HTMLClasses$1.row }, h("calcite-label", { key: 'b05e8ed9ba5d38cdb6eb3088b1dbf888e6a620ca', class: HTMLClasses$1.column }, this.strings.guideLabel, h("calcite-input", { key: '0ec3d3fdb8e1f6eedefa7a0d48172fb6f9f9c29a', type: "text", value: labelText, onCalciteInputInput: this.setGuideLabel }))), h("div", { key: '5c35220f7c9e12328deec72b26b804b5fd0f5132', class: HTMLClasses$1.row }, h("calcite-label", { key: '9df5baefa3123ffb10eed331504a4682eb1e1d05', class: HTMLClasses$1.column }, this.strings.display, h("calcite-segmented-control", { key: '731fb5d3dd5d6f4ff334e88c2142b1c8deb7bab4', onCalciteSegmentedControlChange: this.setGuideRendered, scale: "s" }, h("calcite-segmented-control-item", { key: '58815926a592769fb1707e25d6ecb2b3560337f0', checked: above, value: this.strings.inFront }, this.strings.inFront), h("calcite-segmented-control-item", { key: '8b0056b2a87b1a767d382d7fa0055a7fc64c93ae', checked: !above, value: this.strings.inBack }, this.strings.inBack)))))));
    }
    /**
     * @category Lifecycle
     */
    componentDidLoad() {
        if (this.isXAxisDateField) {
            this.setGuideDateTimeRange();
        }
    }
    /**
     * @category Private
     */
    guidePopoverChange(open) {
        this.arcgisChartsConfigGuidePopoverChange.emit({
            open,
            element: this.guidePopover,
        });
        this.arcgisChartsConfigPopoverOpenChange.emit({
            open,
        });
    }
    /**
     * @category Private
     */
    setupGuidePopover() {
        if (this.guidePopover === undefined) {
            // guidePopover config
            const popoverConfig = {
                colorChange: this.colorChange,
                symbolChange: this.symbolChange,
                popoverDismiss: (e) => {
                    this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
                },
                popoverClose: () => {
                    this.guidePopoverChange(false);
                    this.removeGuidePopover();
                },
            };
            // create a new guidePopover
            this.guidePopover = Zy(Qy.GuidePopover, popoverConfig);
        }
        const currentStyle = this.model.getGuideStyle(this.index, this.orientation);
        const start = this.model.getGuideStart(this.index, this.orientation);
        const end = this.model.getGuideEnd(this.index, this.orientation);
        if (Kl(start, end) === RESTSymbolType.SLS) {
            this.guidePopover.selectedElement = Jc(currentStyle) ? currentStyle : undefined;
        }
        else {
            this.guidePopover.selectedElement = currentStyle?.color;
        }
        this.guidePopover.referenceElement = this.colorElement;
        if (Array.isArray(currentStyle?.color)) {
            this.guidePopover.open = true;
            this.addGuidePopover();
        }
        else {
            this.guidePopover.open = false;
            this.removeGuidePopover();
        }
    }
    /**
     * @category Private
     */
    removeGuidePopover() {
        this.guidePopover?.remove();
        this.guidePopoverChange(false);
        this.guidePopover = undefined;
    }
    /**
     * @category Private
     */
    addGuidePopover() {
        if (this.guidePopover !== undefined && !document.body.contains(this.guidePopover)) {
            document.body.appendChild(this.guidePopover);
        }
        this.guidePopoverChange(true);
    }
    /**
     * @param fillColor
     * @category Private
     */
    setColor(fillColor) {
        // Creating a transparent outline to avoid ac-js to create a default more opaque outline
        const outline = po({ opacity: 0 });
        const currentStyle = this.model.getGuideStyle(this.index, this.orientation);
        const guideStyle = {
            ...(Qc(currentStyle) ? currentStyle : {}),
            type: RESTSymbolType.SFS,
            color: fillColor,
            outline,
        };
        this.model.setGuideStyle(guideStyle, this.index, this.orientation);
        this.arcgisChartsConfigGuideChange.emit({
            index: this.index,
            orientation: this.orientation,
            isDelete: false,
        });
    }
    /**
     * Gets the date string from the bound value in ISO format.
     * @category Private
     */
    getDateStringFromBound(bound) {
        return typeof bound === "string" ? bound.split("T")[0] : "";
    }
    /**
     * Gets the time string from the bound value in ISO format.
     * @category Private
     */
    getTimeStringFromBound(bound) {
        return typeof bound === "string" ? bound.split("T")[1] : "";
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return this; }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
    static get style() { return ArcgisChartsConfigGuideStyle0; }
}, [1, "arcgis-charts-config-guide", {
        "model": [16],
        "timeZone": [513, "time-zone"],
        "calculatedMinMaxBounds": [16],
        "index": [514],
        "orientation": [513],
        "latestGuidePosition": [2, "latest-guide-position"],
        "guidePopover": [32],
        "updatesOccurred": [32]
    }, undefined, {
        "model": ["modelChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-charts-config-guide"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-charts-config-guide":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcgisChartsConfigGuide);
            }
            break;
    } });
}
defineCustomElement();

export { ArcgisChartsConfigGuide as A, HTMLClasses as H, defineCustomElement as d, getGuideListPosition as g };
