/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';
import { s as bc, S as Sc, t as ty } from './index2.js';
import { a as RESTSymbolType, C as ChartAuthoringPages } from './interfaces.js';
import { d as defineCustomElement$6 } from './arcgis-charts-config-field-select2.js';
import { d as defineCustomElement$5 } from './arcgis-charts-config-format2.js';
import { d as defineCustomElement$4 } from './arcgis-charts-config-general2.js';
import { d as defineCustomElement$3 } from './arcgis-charts-config-invalid-input-message2.js';
import { d as defineCustomElement$2 } from './arcgis-charts-config-pie-chart-data2.js';
import { d as defineCustomElement$1 } from './arcgis-charts-config-pie-chart-slices2.js';
import { i as isEqual } from './isEqual.js';
import { c as cloneDeep } from './cloneDeep.js';

const arcgisChartsConfigPieChartCss = ":host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}";
const ArcgisChartsConfigPieChartStyle0 = arcgisChartsConfigPieChartCss;

const ArcGISChartsConfigPieChart = /*@__PURE__*/ proxyCustomElement(class ArcGISChartsConfigPieChart extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.arcgisChartsNoSeriesUpdate = createEvent(this, "arcgisChartsConfigNoSeriesUpdate", 7);
        this.arcgisChartsConfigWebChartChange = createEvent(this, "arcgisChartsConfigWebChartChange", 7);
        /**
         * @category Private
         */
        this.popoverElement = null;
        /**
         * @category Event handler
         */
        this.popoverOpen = (e) => {
            const { open = false, element = null } = { ...e.detail };
            if (open === true && this.popoverElement !== element) {
                if (this.popoverElement !== null) {
                    this.popoverElement.open = false;
                }
                this.popoverElement = element;
            }
            else if (open === false && this.popoverElement === element) {
                this.popoverElement = null;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = async (e) => {
            const config = e?.detail.config ?? this.model.getConfig();
            if (this.layer === undefined) {
                await this.updateFetchLayerFieldsInfo(config);
            }
        };
        this.model = undefined;
        this.popoverPlacement = "leading";
        this.seriesColor = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.page = undefined;
        this.layer = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.filterBySelection = undefined;
        this.layerFieldsInfo = undefined;
        this.chartData = undefined;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    async layerChange(newValue, oldValue) {
        if (newValue !== undefined && !isEqual(oldValue, newValue)) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    async usePopupTemplateFieldsInfoChange(newValue, oldValue) {
        if (newValue !== undefined && newValue !== oldValue) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * Assigns new slices info from payload
     * @param seriesColor
     * @category Watch handler
     */
    seriesColorChange(seriesColor) {
        const { slices, groupedSlices, groupOfSlices } = seriesColor?.get(0) ?? {};
        // If filterBySelection is true, then preserve all current slices while updating the colors instead of overwriting the entire list. This is needed to ensure that the slices that are not part of the selection are not lost, and their colors will therefore be restored upon toggling off the FBS.
        // If filterBySelection is false, then overwrite the entire list of slices with the data from the payload.
        let newSlices = [];
        if (this.filterBySelection === true) {
            newSlices =
                this.model
                    .getSlices()
                    ?.map((currentSlice) => slices?.find((s) => s.sliceId === currentSlice.sliceId) ??
                    groupedSlices?.find((s) => s.sliceId === currentSlice.sliceId) ??
                    currentSlice) ?? [];
        }
        else {
            newSlices = (slices ?? []).concat(groupedSlices ?? []);
        }
        newSlices.forEach((_slice, i) => {
            const currentSlice = this.model.getSlices()?.find((s) => s.sliceId === newSlices[i].sliceId);
            // retain the existing slice properties if they exist
            if (currentSlice) {
                newSlices[i] = { ...newSlices[i], ...currentSlice };
            }
            // make sure the outline color is the same as the fill color
            const fillSymbol = newSlices[i].fillSymbol;
            if (fillSymbol !== undefined && !isEqual(fillSymbol?.outline?.color, fillSymbol?.color)) {
                fillSymbol.outline = {
                    ...(fillSymbol.outline ?? {}),
                    type: RESTSymbolType.SLS,
                    color: fillSymbol.color,
                };
            }
        });
        // save grouped slices to separate list
        const groupedSliceIds = (groupedSlices ?? []).map((eachSlice) => eachSlice.sliceId);
        if (groupedSlices !== undefined && !isEqual(groupedSliceIds, this.model.getGroupedSliceIds())) {
            this.model.setGroupedSliceIds(cloneDeep(groupedSliceIds));
        }
        // save new slices list
        if (!isEqual(newSlices, this.model.getSlices())) {
            this.model.setSlices(cloneDeep(newSlices));
        }
        // save group slice properties to config slice grouping
        if (groupOfSlices !== undefined && !isEqual(groupOfSlices, this.model.getSliceGrouping())) {
            this.model.setSliceGrouping(cloneDeep(groupOfSlices));
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        if (this.layer !== undefined) {
            await this.layerChange(this.layer, undefined);
        }
        if (this.seriesColor !== undefined) {
            this.seriesColorChange(this.seriesColor);
        }
        if (this.usePopupTemplateFieldsInfo !== undefined) {
            await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, undefined);
        }
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Lifecycle
     */
    async componentWillRender() {
        if (this.layerFieldsInfo === undefined) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * @category Lifecycle
     */
    render() {
        let panel;
        switch (this.page) {
            case ChartAuthoringPages.Data:
                panel = (h(Host, { key: '390ed7f37ba62859eaa611e505062552c3d64446' }, h("arcgis-charts-config-pie-chart-data", { key: '248f4efd7cc9a80b15f3c85403b10173ba6ab5b7', model: this.model, layerFieldsInfo: this.layerFieldsInfo })));
                break;
            case ChartAuthoringPages.Slices:
                panel = (h(Host, { key: '1b02a7703b8578702c50894f859dbd3bc2554574' }, h("arcgis-charts-config-pie-chart-slices", { key: '497627b7ac1c8eeb2ad75eeb018acc166acf9622', model: this.model, chartData: this.chartData, onArcgisChartsConfigPieChartSlicesPopoverChange: this.popoverOpen, popoverPlacement: this.popoverPlacement })));
                break;
            case ChartAuthoringPages.Format:
                panel = (h(Host, { key: '28e64c2f73ba5f180b5b79d757ffac9dd8e7b5b3' }, h("arcgis-charts-config-format", { key: 'a7d52b470d48e162b52e8c725229f19cc3882cc7', model: this.model, onArcgisChartsConfigFormatPopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.General:
                panel = (h(Host, { key: '589d6c113a7813c30743903f4ee4bb06e52b3f22' }, h("arcgis-charts-config-general", { key: '5fa3998ae7182a2db9f8755a0187a3e18e151afa', model: this.model })));
                break;
            default:
                panel = h(Host, { key: '606e82253dacc2d36fb0ce9d7665811c6b37e951' });
                break;
        }
        return panel;
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Private
     */
    async updateFetchLayerFieldsInfo(config) {
        // get feature layer from component prop if exists, otherwise get from current config iLayer
        const currentConfig = config ?? this.model.getConfig();
        let layer = this.layer;
        // if the layer doesn't exist we build one from the config data source
        if (!layer) {
            const iLayer = ty(currentConfig) ? currentConfig.iLayer : undefined;
            if (iLayer) {
                layer = await bc(iLayer);
            }
        }
        if (layer) {
            this.layerFieldsInfo = await Sc(layer, this.usePopupTemplateFieldsInfo);
        }
    }
    get hostElement() { return this; }
    static get watchers() { return {
        "model": ["modelChange"],
        "layer": ["layerChange"],
        "usePopupTemplateFieldsInfo": ["usePopupTemplateFieldsInfoChange"],
        "seriesColor": ["seriesColorChange"]
    }; }
    static get style() { return ArcgisChartsConfigPieChartStyle0; }
}, [1, "arcgis-charts-config-pie-chart", {
        "model": [16],
        "popoverPlacement": [513, "popover-placement"],
        "seriesColor": [16],
        "calculatedMinMaxBounds": [16],
        "page": [513],
        "layer": [16],
        "usePopupTemplateFieldsInfo": [4, "use-popup-template-fields-info"],
        "filterBySelection": [4, "filter-by-selection"],
        "chartData": [16],
        "layerFieldsInfo": [32]
    }, undefined, {
        "model": ["modelChange"],
        "layer": ["layerChange"],
        "usePopupTemplateFieldsInfo": ["usePopupTemplateFieldsInfoChange"],
        "seriesColor": ["seriesColorChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-charts-config-pie-chart", "arcgis-charts-config-field-select", "arcgis-charts-config-format", "arcgis-charts-config-general", "arcgis-charts-config-invalid-input-message", "arcgis-charts-config-pie-chart-data", "arcgis-charts-config-pie-chart-slices"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-charts-config-pie-chart":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcGISChartsConfigPieChart);
            }
            break;
        case "arcgis-charts-config-field-select":
            if (!customElements.get(tagName)) {
                defineCustomElement$6();
            }
            break;
        case "arcgis-charts-config-format":
            if (!customElements.get(tagName)) {
                defineCustomElement$5();
            }
            break;
        case "arcgis-charts-config-general":
            if (!customElements.get(tagName)) {
                defineCustomElement$4();
            }
            break;
        case "arcgis-charts-config-invalid-input-message":
            if (!customElements.get(tagName)) {
                defineCustomElement$3();
            }
            break;
        case "arcgis-charts-config-pie-chart-data":
            if (!customElements.get(tagName)) {
                defineCustomElement$2();
            }
            break;
        case "arcgis-charts-config-pie-chart-slices":
            if (!customElements.get(tagName)) {
                defineCustomElement$1();
            }
            break;
    } });
}
defineCustomElement();

export { ArcGISChartsConfigPieChart as A, defineCustomElement as d };
