/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { proxyCustomElement, HTMLElement, createEvent, getAssetPath, h, Host } from '@stencil/core/internal/client';
import { a2 as Jy, M as Mn, ad as oa, Z as Zy, r as Qy, ae as Zn } from './index2.js';
import { r as rh } from './index3.js';
import { c as createActionTooltip, d as destroyActionTooltip, s as sanitizeNumber, U as UIDefaults } from './chart-ui-utils.js';
import { d as debounce } from './debounce.js';
import { i as isEmpty } from './isEmpty.js';
import { t as toNumber } from './toNumber.js';
import { a as RESTSymbolType } from './interfaces.js';

const HTMLClasses = {
    sectionLabel: "section-label",
    label: "label",
    sliceList: "slice-list",
    radioGroup: "radio-group",
    pieDonutLabelsContainer: "pie-donut-labels-container",
    sliderInputContainer: "slider-input-container",
    groupingLabelContainer: "grouping-label-container",
    numberInput: "number-input",
};

const arcgisChartsConfigPieChartSlicesCss = ":host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}.section-label{display:flex;margin:var(--arcgis-charts-config-margin-major) var(--arcgis-charts-config-margin-minor);justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}.label{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.label .grouping-label-container{display:flex;justify-content:space-between}.label .slider-input-container{display:flex}.label .slider-input-container calcite-slider{--calcite-label-margin-bottom:var(--arcgis-charts-intra-section-margin) !important;margin-right:var(--arcgis-charts-config-margin-minor);flex-grow:1}.label .slider-input-container .number-input{width:8rem}.slice-list{margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-major)}.radio-group{margin-top:var(--arcgis-charts-config-margin-minor)}.pie-donut-labels-container{display:flex;justify-content:space-between;margin-top:calc(var(--arcgis-charts-config-margin-minor) * -3)}";
const ArcgisChartsConfigPieChartSlicesStyle0 = arcgisChartsConfigPieChartSlicesCss;

const ArcGISChartsConfigPieChartSlices = /*@__PURE__*/ proxyCustomElement(class ArcGISChartsConfigPieChartSlices extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.arcgisChartsConfigPieChartSlicesPopoverChange = createEvent(this, "arcgisChartsConfigPieChartSlicesPopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        /**
         * @category Private
         */
        this.slicesPopover = null;
        /**
         * @category Event handler
         */
        this.onDonutSizeSliderChange = debounce(() => {
            if (Number.isInteger(this.donutSizeSliderElement.value)) {
                this.model.setInnerRadiusSize(this.donutSizeSliderElement.value ?? oa);
            }
        }, UIDefaults.SliderTimer);
        /**
         * @category Event handler
         */
        this.onGroupingThresholdSliderChange = debounce(() => {
            const thresholdValue = this.groupingThresholdSliderElement.value;
            if (!Number.isNaN(thresholdValue)) {
                this.groupingThresholdElement.value = thresholdValue.toString();
                this.groupingThresholdSliderElement.value = thresholdValue;
                this.model.setGroupingThreshold(thresholdValue);
            }
            else {
                this.model.setGroupingThreshold(0);
            }
        }, UIDefaults.SliderTimer);
        /**
         * @category Event handler
         */
        this.onGroupingThresholdChange = (e) => {
            const rawValue = e.target.value;
            let value = Number.parseInt(rawValue);
            if (value > 100) {
                value = 100;
            }
            else if (value < 0) {
                value = 0;
            }
            if (!Number.isNaN(value)) {
                this.groupingThresholdElement.value = value.toString();
                this.model.setGroupingThreshold(value);
                this.groupingThresholdSliderElement.value = value;
            }
            else {
                this.model.setGroupingThreshold(0);
            }
        };
        /**
         * @category Event handler
         */
        this.onLabelCharacterLimitChange = (e) => {
            const rawValue = e.target.value;
            let value = Number.parseInt(rawValue);
            if (value < 1) {
                value = 1;
            }
            if (!Number.isNaN(value)) {
                this.labelCharacterLimitElement.value = value.toString();
                this.model.setLabelCharacterLimit(value);
            }
            else {
                this.model.setLabelCharacterLimit(null);
            }
        };
        /**
         * @category Event handler
         */
        this.onDecimalPlacesChange = (e) => {
            const rawValue = e.target.value;
            let value = Number.parseInt(rawValue);
            if (value < 0) {
                value = 0;
            }
            else if (value > 20) {
                value = 20;
            }
            if (!Number.isNaN(value)) {
                this.decimalPlacesElement.value = value.toString();
                this.model.setDecimalPlaces(value);
            }
            else {
                this.model.setDecimalPlaces(0);
            }
        };
        /**
         * @category Event handler
         */
        this.onDisplayTypeChange = (e) => {
            const displayType = e.target.selectedItem;
            this.model.setDisplayType(displayType.value);
        };
        /**
         * @category Event handler
         */
        this.resetSlicesOriginal = () => {
            this.configSliceOpen = false;
            this.selectedSliceId = undefined;
            this.model.setColorMatch(true);
            this.model.resetSlices();
        };
        /**
         * @category Event handler
         */
        this.sliceNameChange = (event) => {
            if (event.detail !== null || event.detail !== undefined) {
                const name = event.detail?.name;
                const index = this.model.getSlices()?.findIndex((s) => s.sliceId === this.selectedSliceId);
                const sliceGrouping = this.model.getSliceGrouping();
                if (index !== undefined && index !== null && index >= 0) {
                    this.model.setSliceName(name, index);
                }
                else if (sliceGrouping?.sliceId === this.selectedSliceId && sliceGrouping !== undefined) {
                    this.model.setSliceGrouping({
                        ...sliceGrouping,
                        label: name,
                    });
                }
            }
        };
        /**
         * @category Event handler
         */
        this.sliceColorChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { color } = e.detail;
                const index = this.model.getSlices()?.findIndex((s) => s.sliceId === this.selectedSliceId);
                const sliceGrouping = this.model.getSliceGrouping();
                if (index !== undefined && index !== null && index >= 0) {
                    this.model.setColorMatch(false);
                    this.model.setSliceColor(color, index);
                }
                else if (sliceGrouping?.sliceId === this.selectedSliceId && sliceGrouping !== undefined) {
                    this.model.setColorMatch(false);
                    this.model.setSliceGrouping({
                        ...sliceGrouping,
                        fillSymbol: {
                            ...sliceGrouping.fillSymbol,
                            type: RESTSymbolType.SFS,
                            color,
                        },
                    });
                }
            }
        };
        /**
         * @category Event handler
         */
        this.onCalciteListOrderChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { newIndex, oldIndex } = e.detail;
                this.model.moveSeries(oldIndex, newIndex);
            }
        };
        /**
         * @category Event handler
         */
        this.slicesPopoverClose = () => {
            this.selectedSliceId = undefined;
            this.configSliceOpen = false;
        };
        /**
         * @category Event handler
         */
        this.slicesPopoverChange = (open) => {
            this.arcgisChartsConfigPieChartSlicesPopoverChange.emit({
                open,
                element: this.slicesPopover,
            });
        };
        /**
         * @category Event handler
         */
        this.openSlicesPopover = (event) => {
            // The target can be either the list item or the icon
            const target = event.target;
            const listItem = target.localName === "calcite-list-item"
                ? target
                : target.parentNode;
            const negateConfigSliceOpen = !this.configSliceOpen;
            this.configSliceOpen = this.selectedSliceId === listItem.value ? negateConfigSliceOpen : true;
            if (this.configSliceOpen) {
                if (listItem.value === this.model.getSliceGrouping()?.sliceId) {
                    this.selectedSliceId = this.model.getSliceGrouping()?.sliceId;
                }
                else {
                    this.selectedSliceId = listItem.value;
                }
            }
            else {
                this.selectedSliceId = undefined;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Emit event on open popover.
         * @param e
         * @category Private
         */
        this.openChange = (e) => {
            this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
        };
        /**
         * Creates a tooltip for the hovered action.
         * @category Event handler
         */
        this.createTooltip = (e) => {
            const iconElement = e.target;
            this.tooltip = createActionTooltip(iconElement);
            this.tooltip.innerHTML = this.strings.groupingInfo;
            // append tooltip to the document body instead of action element
            // to avoid tooltip being cut off by calcite panel header element
            document.body.appendChild(this.tooltip);
        };
        /**
         * Destroys tooltip for the action that was being hovered.
         * @category Event handler
         */
        this.destroyTooltip = () => {
            destroyActionTooltip(this.tooltip);
        };
        this.model = undefined;
        this.configSliceOpen = false;
        this.popoverPlacement = "leading";
        this.chartData = undefined;
        this.selectedSliceId = undefined;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Watch handler
     */
    selectedSliceIdChange() {
        if (!isEmpty(this.selectedSliceId) && this.configSliceOpen) {
            this.setupSlicesPopover();
            if (this.slicesPopover !== null) {
                const slices = this.model.getSlices();
                const sliceGrouping = this.model.getSliceGrouping();
                // sync back to slicesPopover
                if (this.selectedSliceId === sliceGrouping?.sliceId) {
                    this.slicesPopover.selectedName = sliceGrouping?.label;
                    this.slicesPopover.selectedColor = sliceGrouping?.fillSymbol?.color;
                }
                else if (slices !== undefined) {
                    const index = slices.findIndex((slice) => slice.sliceId === this.selectedSliceId);
                    this.slicesPopover.selectedName = this.model.getSliceName(index);
                    this.slicesPopover.selectedColor = this.model.getSliceColor(index);
                }
                if (!this.slicesPopover.open) {
                    this.slicesPopover.open = true;
                }
            }
            this.addSlicesPopover();
        }
    }
    /**
     * @category Private
     */
    removeSlicesPopover() {
        if (this.slicesPopover !== undefined && this.slicesPopover !== null) {
            this.slicesPopover.open = false;
            this.slicesPopover.selectedName = undefined;
            this.slicesPopover.selectedColor = undefined;
            this.slicesPopover = Jy(this.slicesPopover);
        }
        this.slicesPopoverChange(false);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await Mn(this.hostElement, getAssetPath(`.`)));
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removeSlicesPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Render UX
     */
    buildSliceListItem() {
        let iconColor = "#CCCCCC";
        let icon = "minus-square";
        const sliceList = [];
        let slices = this.model.getSlices();
        const chartData = this.chartData?.dataItems;
        // Filter the slices based on the processed data
        if (chartData) {
            slices = slices?.filter((slice) => chartData?.findIndex((item) => item.arcgis_charts_slice_id === slice.sliceId) !== -1);
        }
        slices?.forEach((eachSlice) => {
            // If `undefined` is provided for the slice, we default the color icon to a grey minus square
            if (eachSlice.fillSymbol?.color !== undefined) {
                icon = "square-f";
                const [r, g, b, a] = [...eachSlice.fillSymbol.color];
                iconColor = `rgba(${r},${g},${b},${a / 255})`;
            }
            if (eachSlice !== undefined && !this.model.getGroupedSliceIds().includes(eachSlice.sliceId)) {
                let description = eachSlice.sliceId;
                // handling the special case of `null` and empty slices values, by replacing the technical slice id by a t9n label
                if (description === Zn.emptySliceId) {
                    description = this.strings.emptySlice;
                }
                else if (description === Zn.nullSliceId) {
                    description = this.strings.nullSlice;
                }
                sliceList?.push(h("calcite-list-item", { key: eachSlice.sliceId, label: eachSlice.label ?? eachSlice.sliceId, description: description, value: eachSlice.sliceId, selected: this.selectedSliceId === eachSlice.sliceId, onClick: this.openSlicesPopover }, h("calcite-icon", { slot: "content-end", icon: icon, style: { color: iconColor } })));
            }
        });
        const sliceGrouping = this.model.getSliceGrouping();
        if (sliceGrouping?.fillSymbol?.color !== undefined) {
            icon = "square-f";
            const [r, g, b, a] = [...sliceGrouping.fillSymbol.color];
            iconColor = `rgba(${r},${g},${b},${a / 255})`;
        }
        if (this.model.getGroupedSliceIds().length > 0) {
            sliceList?.push(h("calcite-list-item", { key: sliceGrouping?.sliceId, label: sliceGrouping?.label ?? sliceGrouping?.sliceId ?? "", description: this.strings.groupedSlices, value: sliceGrouping?.sliceId ?? "", selected: this.selectedSliceId === sliceGrouping?.sliceId, onClick: this.openSlicesPopover }, h("calcite-icon", { slot: "content-end", icon: icon, style: { color: iconColor } })));
        }
        return sliceList;
    }
    /**
     * @category Render UX
     */
    buildGroupedSlicesListItem() {
        let iconColor = "#CCCCCC";
        let icon = "minus-square";
        const sliceList = [];
        this.model.getSlices()?.forEach((eachSlice) => {
            // If `undefined` is provided for the slice, we default the color icon to a grey minus square
            if (eachSlice.fillSymbol?.color !== undefined) {
                icon = "square-f";
                const [r, g, b, a] = [...eachSlice.fillSymbol.color];
                iconColor = `rgba(${r},${g},${b},${a / 255})`;
            }
            if (eachSlice !== undefined && this.model.getGroupedSliceIds().includes(eachSlice.sliceId)) {
                sliceList?.push(h("calcite-list-item", { key: eachSlice.sliceId, label: eachSlice.label ?? eachSlice.sliceId, description: eachSlice.sliceId, value: eachSlice.sliceId, selected: this.selectedSliceId === eachSlice.sliceId, onClick: this.openSlicesPopover }, h("calcite-icon", { slot: "content-end", icon: icon, style: { color: iconColor } })));
            }
        });
        return sliceList;
    }
    /**
     * @category Render UX
     */
    buildSliceList() {
        return (h("calcite-list", { label: "", class: HTMLClasses.sliceList, selectionMode: "single", selectionAppearance: "border", onCalciteListOrderChange: this.onCalciteListOrderChange }, this.buildSliceListItem()));
    }
    /**
     * @category Render UX
     */
    buildGroupedSliceList() {
        return (h("calcite-list", { label: "", class: HTMLClasses.sliceList, selectionMode: "single", selectionAppearance: "border", onCalciteListOrderChange: this.onCalciteListOrderChange }, this.buildGroupedSlicesListItem()));
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (h(Host, { key: '293ddf3eb0fc2a0f6ddee6d6d7d67f83a581eddc' }, h("div", { key: '33736708d4bf2fd7ab4f2daea0250348000f0091', class: HTMLClasses.sectionLabel }, this.strings.settings), h("calcite-label", { key: 'b460ef6df43c4fa27874da0627067cc9da9be74c', class: HTMLClasses.label }, this.strings.shape, h("calcite-slider", { key: '4d2a71ed4ff75b3490872ac514d2662504ee6f70', labelHandles: false, min: 0, max: 100, step: 1, snap: true, value: this.model.getInnerRadiusSize() ?? oa, onCalciteSliderChange: this.onDonutSizeSliderChange, ref: (e) => {
                this.donutSizeSliderElement = e;
            } })), h("div", { key: '55b78f6fbaae0f57e5ac7ff8cda76d037fe5224f', class: HTMLClasses.pieDonutLabelsContainer }, h("calcite-label", { key: '2be88abd27cb7dd021ec4a50572a1062fa68f1a1', class: HTMLClasses.label }, this.strings.pie), h("calcite-label", { key: '3ebc0cb1e920ea29098a3985707b014eb0fb21cf', class: HTMLClasses.label }, this.strings.donut)), h("calcite-label", { key: '30ade5368a4b77b8c437403885e05f2ef1a47cf0', class: HTMLClasses.label }, h("div", { key: '692439e410c9d1ae400b14535511b03a6f5d4472', class: HTMLClasses.groupingLabelContainer }, h("div", { key: 'd9731959878d99243a0595d5bd217676cb265e16' }, this.strings.groupingPercent), h("calcite-icon", { key: '3c1d5035d3f130efc26ae9dd983cdd1b1b4fac34', icon: "information", scale: "s", flipRtl: true, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip })), h("div", { key: '0055f28f084b6786d9975ab003d8acda8972933c', class: HTMLClasses.sliderInputContainer }, h("calcite-slider", { key: 'd8984e35a7e76fc265b80d7ebc7153411a4af28f', labelHandles: false, min: 0, max: 50, step: 1, snap: true, value: toNumber(sanitizeNumber(this.model.getGroupingThreshold() ?? 0)), onCalciteSliderChange: this.onGroupingThresholdSliderChange, ref: (e) => {
                this.groupingThresholdSliderElement = e;
            } }), h("calcite-input", { key: 'af4d17930b74105701c70bd659f13a30eb8b05a0', class: HTMLClasses.numberInput, type: "number", min: 0, max: 100, step: 1, suffixText: "%", value: sanitizeNumber(this.model.getGroupingThreshold() ?? 0), onCalciteInputInput: this.onGroupingThresholdChange, ref: (e) => {
                this.groupingThresholdElement = e;
                this.groupingThresholdElement.addEventListener("click", (event) => {
                    // TODO: This is a temp fix. Remove this listener and its logic when calcite team fixes the issue - https://github.com/Esri/calcite-components/issues/5070
                    // stop propagation of click event to the nearby slider element
                    event.stopPropagation();
                });
            } }))), h("div", { key: '9b59c69fac201710189b16ff7165c0f8f78ca566', class: HTMLClasses.sectionLabel }, this.strings.labels), h("calcite-label", { key: '8b00f14ac794850d5d17d8b3810f1ee03d27f1ab', class: HTMLClasses.label }, this.strings.labelCharacterLimit, h("calcite-input", { key: 'c4fa9c3397c4e11350cb2508b8347d79e41b8658', type: "number", min: 1, step: 1, value: sanitizeNumber(this.model.getLabelCharacterLimit()), onCalciteInputInput: this.onLabelCharacterLimitChange, ref: (e) => {
                this.labelCharacterLimitElement = e;
            } })), h("calcite-label", { key: '6d43bcb7ba905e78457f2f87cd78a29b4fdc3c56', class: HTMLClasses.label }, this.strings.decimalPlaces, h("calcite-input", { key: 'df34a75495d81b26be2afc05bdce1fd5b1e3d490', type: "number", min: 0, max: 20, step: 1, value: sanitizeNumber(this.model.getDecimalPlaces()), onCalciteInputInput: this.onDecimalPlacesChange, ref: (e) => {
                this.decimalPlacesElement = e;
            } })), h("calcite-label", { key: '504bd5145c4f3da5388ae41f9887cae7469b5490', class: HTMLClasses.label }, this.strings.display, h("calcite-radio-button-group", { key: 'abbcc323977b72eaa00283be8f7ef7f861b090a9', class: HTMLClasses.radioGroup, name: "display", layout: "vertical", onCalciteRadioButtonGroupChange: this.onDisplayTypeChange }, h("calcite-label", { key: '402b87bd856dc1b81298d3be73aba87e05df9a66', layout: "inline" }, h("calcite-radio-button", { key: '252d104dcf622fac9099913dec3f1c4c6f97c33c', value: rh.Value, checked: this.model.getDisplayType() === rh.Value }), this.strings.value), h("calcite-label", { key: 'eb97a15177a32a39c6837e7bc80ca9258aa87af6', layout: "inline" }, h("calcite-radio-button", { key: 'df37ae7085998b12708b1395e90c60f57b7d747b', value: rh.Percentage, checked: this.model.getDisplayType() === rh.Percentage }), this.strings.percentage), h("calcite-label", { key: 'acd24bb6ebf731490a84854e50cb328dfdc42475', layout: "inline" }, h("calcite-radio-button", { key: 'fe31aa327b130225544b0cbfd88c50c053ae8004', value: rh.Both, checked: this.model.getDisplayType() === rh.Both }), this.strings.both))), h("div", { key: 'cce8d301acb22ef81d523e376319b014b0a27102', class: HTMLClasses.sectionLabel }, this.strings.slices, h("calcite-button", { key: '25e0ff6b850ffcfff2b2ec105d3343e2a2c21b44', onClick: this.resetSlicesOriginal, disabled: !this.model.resetAvailable(), appearance: "transparent", iconEnd: "reset" }, this.strings.reset)), this.buildSliceList(), h("div", { key: '1a8965ba5c7a444779f4b2eb5b78b5a05180de20', class: HTMLClasses.sectionLabel }, this.strings.groupedSlices), this.buildGroupedSliceList()));
    }
    /**
     * @category Private
     */
    setupSlicesPopover() {
        if (this.slicesPopover === null && this.hostElement !== undefined) {
            // slicesPopover config
            const popoverConfig = {
                referenceElement: this.hostElement,
                placement: this.popoverPlacement,
                sliceNameChange: this.sliceNameChange,
                sliceColorChange: this.sliceColorChange,
                openChange: this.openChange,
                popoverClose: this.slicesPopoverClose,
            };
            // create a new slicesPopover
            this.slicesPopover = Zy(Qy.PieChartSlicesPopover, popoverConfig);
        }
    }
    /**
     * @category Private
     */
    addSlicesPopover() {
        if (this.slicesPopover != null && !document.body.contains(this.slicesPopover)) {
            document.body.appendChild(this.slicesPopover);
        }
        this.slicesPopoverChange(true);
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return this; }
    static get watchers() { return {
        "model": ["modelChange"],
        "selectedSliceId": ["selectedSliceIdChange"]
    }; }
    static get style() { return ArcgisChartsConfigPieChartSlicesStyle0; }
}, [1, "arcgis-charts-config-pie-chart-slices", {
        "model": [16],
        "configSliceOpen": [1028, "config-slice-open"],
        "popoverPlacement": [1, "popover-placement"],
        "chartData": [16],
        "selectedSliceId": [32],
        "updatesOccurred": [32]
    }, undefined, {
        "model": ["modelChange"],
        "selectedSliceId": ["selectedSliceIdChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-charts-config-pie-chart-slices"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-charts-config-pie-chart-slices":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcGISChartsConfigPieChartSlices);
            }
            break;
    } });
}
defineCustomElement();

export { ArcGISChartsConfigPieChartSlices as A, defineCustomElement as d };
