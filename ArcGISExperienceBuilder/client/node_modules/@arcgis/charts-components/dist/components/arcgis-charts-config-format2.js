/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { proxyCustomElement, HTMLElement, createEvent, h, getAssetPath, Host } from '@stencil/core/internal/client';
import { a4 as Jc, a5 as ey, M as Mn, a2 as Jy, Z as Zy, r as Qy } from './index2.js';
import { o as oh, i as ih, L as Lg, D as Dg, M as Mg, B as Bg, U as Ug, T as Tg, a as ah, O as Og } from './index3.js';
import { a as RESTSymbolType, g as RESTFontDecoration, h as RESTFontStyle, i as RESTFontWeight, d as RESTSimpleLineSymbolStyle } from './interfaces.js';
import { h as getFormatIcon } from './chart-ui-utils.js';
import { i as isEmpty } from './isEmpty.js';
import { c as cloneDeep } from './cloneDeep.js';
import { i as isArray } from './_Map.js';
import { c as createAssigner, b as baseMerge } from './_baseMerge.js';
import { a as isObject } from './isObject.js';

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});

const mergeWith$1 = mergeWith;

const defaultTextProps = {
    type: RESTSymbolType.TS,
    color: [1, 1, 1, 255],
    font: {
        family: "Tahoma",
        size: 12,
        decoration: RESTFontDecoration.None,
        style: RESTFontStyle.Normal,
        weight: RESTFontWeight.Normal,
    },
};
const defaultSymbolProps = {
    type: RESTSymbolType.SLS,
    color: [1, 1, 1, 255],
    style: RESTSimpleLineSymbolStyle.Solid,
    width: 2,
};

const HTMLClasses = {
    element: "chart-element",
    elementList: "element-list",
    sectionLabel: "section-label",
};

const arcgisChartsConfigFormatCss = ":host{width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}.section-label{display:flex;margin:var(--arcgis-charts-config-margin-major) var(--arcgis-charts-config-margin-minor);justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}.element-list{margin:var(--arcgis-charts-config-margin-minor)}.element{-webkit-user-select:none;-moz-user-select:none;user-select:none}";
const ArcgisChartsConfigFormatStyle0 = arcgisChartsConfigFormatCss;

const ArcgisChartsConfigFormat = /*@__PURE__*/ proxyCustomElement(class ArcgisChartsConfigFormat extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.arcgisChartsConfigFormatPopoverChange = createEvent(this, "arcgisChartsConfigFormatPopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        /**
         * @category Private
         */
        this.formatPopover = null;
        /**
         * List of text selectable text elements
         * @category Private
         */
        this.selectableElements = [];
        /**
         * List to store text property keys used for current chart.
         * @category Private
         */
        this.textProperties = [];
        /**
         * List to store symbol property keys used for current chart.
         * @category Private
         */
        this.symbolProperties = [];
        /**
         * @category Render UX
         */
        this.renderTextElement = (valueKey, callback) => {
            const icon = getFormatIcon(valueKey);
            const value = this.getFormatValue(valueKey);
            const textValue = typeof value === "string" ? value : "";
            const selected = this.selectedTexts.includes(valueKey) ||
                this.selectedSymbols.includes(valueKey) ||
                this.selectedBackground.includes(valueKey);
            return (h("calcite-list-item", { class: HTMLClasses.element, label: this.strings[valueKey], description: textValue, value: valueKey, selected: selected, onClick: callback, ref: (e) => {
                    const element = e;
                    if (!this.selectableElements.includes(element)) {
                        this.selectableElements.push(element);
                    }
                } }, icon !== undefined ? h("calcite-icon", { slot: "content-start", scale: "s", icon: icon }) : null));
        };
        /**
         * Corrects selected text elements in DOM to match selected texts list
         * @category Event handler
         */
        this.correctTextElementSelection = () => {
            for (const element of this.selectableElements) {
                const selected = this.selectedTexts.includes(element.value) ||
                    this.selectedSymbols.includes(element.value) ||
                    this.selectedBackground.includes(element.value);
                element.selected = selected;
            }
        };
        /**
         * @category Event handler
         */
        this.symbolPropertyChange = (e) => {
            let key;
            if (e.target?.localName === "calcite-list-item") {
                key = e.target?.value;
            }
            else {
                key = e.target?.parentNode?.value;
            }
            // empty the selected text props.
            this.selectedTexts = [];
            this.selectedBackground = [];
            if (this.selectedSymbols.includes(key)) {
                this.selectedSymbols = [];
                this.updateSelectedElement(this.selectedSymbols);
            }
            else {
                const value = this.getFormatValue(key);
                this.selectedSymbols = [key];
                this.initSelectedSymbols(Jc(value) ? value : defaultSymbolProps);
            }
            this.setupFormatPopover();
        };
        /**
         * @category Event handler
         */
        this.textPropertyChange = (e) => {
            let key;
            if (e.target?.localName === "calcite-list-item") {
                key = e.target?.value;
            }
            else {
                key = e.target?.parentNode?.value;
            }
            // empty the selected symbols.
            this.selectedSymbols = [];
            this.selectedBackground = [];
            if (e.shiftKey) {
                this.selectedTexts = [];
                // find start and end of shift selection range
                const start = this.textProperties.indexOf(this.lastSelectedText);
                const end = this.textProperties.indexOf(key);
                this.textProperties.forEach((textProperty, i) => {
                    // check if each text prop is in the shift selection range
                    if (i >= Math.min(start, end) && i <= Math.max(start, end)) {
                        this.selectedTexts.push(textProperty);
                    }
                });
                this.updateSelectedElement(this.selectedTexts);
                this.setupFormatPopover();
            }
            else if (e.ctrlKey) {
                if (this.selectedTexts.includes(key)) {
                    this.selectedTexts = this.selectedTexts.filter((text) => text !== key);
                    this.updateSelectedElement(this.selectedTexts);
                }
                else {
                    this.selectedTexts = [...this.selectedTexts, key];
                    this.updateSelectedElement(this.selectedTexts);
                }
                this.setupFormatPopover();
            }
            else if (this.selectedTexts.includes(key)) {
                this.selectedTexts = [];
                this.updateSelectedElement(this.selectedTexts);
                this.setupFormatPopover();
            }
            else {
                const value = this.getFormatValue(key);
                this.selectedTexts = [key];
                this.initSelectedTexts(ey(value) ? value : defaultTextProps);
                this.setupFormatPopover();
            }
            this.lastSelectedText = key;
        };
        /**
         * @category Event handler
         */
        this.backgroundChange = (e) => {
            let value;
            if (e.target?.localName === "calcite-list-item") {
                value = e.target?.value;
            }
            else {
                value = e.target?.parentNode
                    ?.value;
            }
            this.selectedSymbols = [];
            this.selectedTexts = [];
            if (this.selectedBackground.includes(value)) {
                this.selectedBackground = [];
                this.selectedElement = {};
            }
            else {
                this.selectedBackground = [value];
                this.selectedElement = !isEmpty(this.getFormatValue(value)) ? this.getFormatValue(value) : undefined;
            }
            this.setupFormatPopover();
        };
        /**
         * @category Event handler
         */
        this.updateSymbolProps = (e) => {
            const symbolProps = e.detail;
            this.selectedSymbols.forEach((symbol) => {
                this.setFormatValue(symbol, symbolProps);
            });
            this.selectedElement = cloneDeep(e.target.selectedElement);
        };
        /**
         * @category Event handler
         */
        this.updateBackground = (e) => {
            this.setFormatValue(oh.Background, e.detail);
            this.selectedElement = e.detail;
        };
        /**
         * @category Event handler
         */
        this.updateTextProps = (e) => {
            const { font, color } = e.detail;
            this.selectedTexts.forEach((symbol) => {
                const rawTextSymbol = this.getFormatValue(symbol);
                const currentSymbol = ey(rawTextSymbol) ? rawTextSymbol : undefined;
                // we should only update the color with the value from the payload if it is defined
                this.setFormatValue(symbol, {
                    ...currentSymbol,
                    type: RESTSymbolType.TS,
                    font: { ...currentSymbol?.font, ...font },
                    color: color ?? currentSymbol?.color,
                });
            });
            this.selectedElement = cloneDeep(e.target.selectedElement);
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Private
         */
        this.formatPopoverClose = (e) => {
            if (this.formatPopover === e?.target) {
                this.selectedTexts = [];
                this.selectedSymbols = [];
                this.selectedBackground = [];
                this.selectedElement = {};
                this.removeFormatPopover();
            }
        };
        /**
         * @category Private
         */
        this.mergeFormatValues = (format1, format2) => {
            let isSame = false;
            if (isArray(format1) && isArray(format2)) {
                isSame = true;
            }
            else if (isObject(format1) && isObject(format2)) {
                isSame = true;
            }
            else {
                isSame = format1 === format2;
            }
            const diffReturn = typeof format1 === "number" || typeof format2 === "number" ? Number.NaN : "";
            return isSame ? undefined : diffReturn;
        };
        /**
         * Emit event on open popover.
         * @param e
         * @category Private
         */
        this.openChange = (e) => {
            this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
        };
        this.model = undefined;
        this.selectedSymbols = [];
        this.selectedTexts = [];
        this.selectedBackground = [];
        this.selectedElement = undefined;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        // T.B.D issue with lang getting set correctly when this component used as a child
        ({ strings: this.strings } = await Mn(this.hostElement, getAssetPath(`.`)));
        this.modelChange(this.model);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removeFormatPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * render and store format UI elements
     * @returns textElements and symbolElements
     */
    renderFormatElements() {
        // initialize with all possible text props
        this.textProperties = [
            ih.Title,
            ...(Lg(this.model) ? [ih.XAxisTitle] : []),
            ...(Dg(this.model) ? [ih.YAxisTitle] : []),
            ...(Mg(this.model) ? [ih.LegendTitle] : []),
            ih.Description,
            ...(Mg(this.model) ? [ih.LegendText] : []),
            ...(Lg(this.model) ? [ih.AxisLabels] : []),
            ...(Bg(this.model) ? [ih.GuideLabels] : []),
            ...(Ug(this.model) ? [ih.DataLabels] : []),
        ];
        // hide "data labels" for scatter plot
        if (Tg(this.model)) {
            this.textProperties = this.textProperties.filter((prop) => prop !== ih.DataLabels);
        }
        // initialize with all possible symbol props
        this.symbolProperties = [
            ih.Background,
            ...(Lg(this.model) ? [ah.AxisLines] : []),
            ...(Dg(this.model) ? [ah.GridLines] : []),
            ...(Og(this.model) ? [ah.LeaderLines] : []),
        ];
        const textElements = this.textProperties.map((prop) => this.renderTextElement(prop, this.textPropertyChange));
        const symbolElements = this.symbolProperties.map((prop) => prop === ih.Background
            ? this.renderTextElement(prop, this.backgroundChange)
            : this.renderTextElement(prop, this.symbolPropertyChange));
        return { textElements, symbolElements };
    }
    /**
     * @category Lifecycle
     */
    render() {
        const { textElements, symbolElements } = this.renderFormatElements();
        return (h(Host, { key: '523a0c782757f1694dc7017fa56e93fe22cbe295' }, h("div", { key: 'baf66725033a7be92829d53938f1049fc6825297', class: HTMLClasses.sectionLabel }, this.strings.textElements), h("calcite-list", { key: '4414c67b550748c4cd85e1c32635bbc1ec8a7d7c', label: "", class: HTMLClasses.elementList, selectionMode: "multiple", selectionAppearance: "border", onCalciteListChange: this.correctTextElementSelection }, textElements), h("div", { key: 'b779db76e4266dcc9db878698a17a32ecf3124c4', class: HTMLClasses.sectionLabel }, this.strings.symbolElements), h("calcite-list", { key: '5ca5aaf463f6506566e67c85aee7a87b80d99944', label: "", class: HTMLClasses.elementList, selectionMode: "single", selectionAppearance: "border" }, symbolElements)));
    }
    /**
     * @category Private
     */
    formatPopoverChange(open) {
        this.arcgisChartsConfigFormatPopoverChange.emit({
            open,
            element: this.formatPopover,
        });
        this.arcgisChartsConfigPopoverOpenChange.emit({
            open,
        });
    }
    /**
     * @param keys
     * @param elementValue
     * @category Private
     */
    updateSelectedElement(keys, elementValue) {
        this.selectedElement = undefined;
        if (elementValue === undefined) {
            const initValue = cloneDeep(this.getFormatValue(keys[0]));
            this.selectedElement = keys?.reduce((acc, text) => {
                const textProp = this.getFormatValue(text);
                const newTextProp = mergeWith$1(acc, textProp, this.mergeFormatValues);
                return newTextProp;
            }, initValue);
        }
        else {
            let defaultValue = cloneDeep(elementValue);
            if (isEmpty(elementValue)) {
                if (this.selectedSymbols?.length > 0) {
                    defaultValue = cloneDeep(defaultSymbolProps);
                }
                if (this.selectedTexts?.length > 0) {
                    defaultValue = cloneDeep(defaultTextProps);
                }
            }
            this.selectedElement = defaultValue;
        }
    }
    /**
     * @param value
     * @category Private
     */
    initSelectedTexts(value) {
        let defaultValue = cloneDeep(value);
        if (isEmpty(value)) {
            defaultValue = cloneDeep(defaultTextProps);
        }
        this.selectedElement = defaultValue;
    }
    /**
     * @param value
     * @category Private
     */
    initSelectedSymbols(value) {
        let defaultValue = cloneDeep(value);
        if (isEmpty(value)) {
            defaultValue = cloneDeep(defaultSymbolProps);
        }
        this.selectedElement = defaultValue;
    }
    /**
     * @category Private
     */
    setupFormatPopover() {
        // remove formatPopover
        this.formatPopover = Jy(this.formatPopover);
        const element = this.selectedElement;
        // formatPopover config
        const popoverConfig = {
            selectedElement: this.selectedElement,
            referenceElement: this.hostElement,
            updateSymbolProps: this.updateSymbolProps,
            updateTextProps: this.updateTextProps,
            updateBackground: this.updateBackground,
            openChange: this.openChange,
            hostElement: this.hostElement,
            placement: "auto",
            popoverClose: this.formatPopoverClose,
        };
        // create a new formatPopover
        this.formatPopover = Zy(Qy.FormatPopover, popoverConfig);
        if (element?.type === RESTSymbolType.TS ||
            element?.type === RESTSymbolType.SLS ||
            // To check if the selected element is background.
            Array.isArray(this.selectedElement)) {
            this.formatPopover.open = true;
            this.addFormatPopover();
        }
        else {
            this.formatPopover.open = false;
            this.removeFormatPopover();
        }
    }
    /**
     * @category Private
     */
    removeFormatPopover() {
        if (this.formatPopover !== null) {
            this.formatPopover.open = false;
            this.formatPopover = Jy(this.formatPopover);
        }
        this.formatPopoverChange(false);
    }
    /**
     * @category Private
     */
    addFormatPopover() {
        if (this.formatPopover !== null && !document.body.contains(this.formatPopover)) {
            document.body.appendChild(this.formatPopover);
        }
        this.formatPopoverChange(true);
    }
    /**
     * @category Private
     */
    getFormatValue(formatKey) {
        switch (formatKey) {
            case ih.Title:
                return this.model.getTitleSymbol();
            case ih.Description:
                return this.model.getDescriptionSymbol();
            case ih.XAxisTitle:
                return Lg(this.model) ? this.model.getXAxisTitleSymbol() : undefined;
            case ih.YAxisTitle:
                return Dg(this.model) ? this.model.getYAxisTitleSymbol() : undefined;
            case ih.AxisLabels:
                return Lg(this.model) ? this.model.getAxisLabelsSymbol() : undefined;
            case ih.GuideLabels:
                return Bg(this.model) ? this.model.getGuideLabelsSymbol() : undefined;
            case ih.LegendText:
                return Mg(this.model) ? this.model.getLegendTextSymbol() : undefined;
            case ih.LegendTitle:
                return Mg(this.model) ? this.model.getLegendTitleSymbol() : undefined;
            case ih.DataLabels:
                return Ug(this.model) ? this.model.getDataLabelsSymbol() : undefined;
            case ah.AxisLines:
                return Lg(this.model) ? this.model.getAxisLinesSymbol() : undefined;
            case ah.GridLines:
                return Dg(this.model) ? this.model.getGridLinesSymbol() : undefined;
            case ah.LeaderLines:
                return Og(this.model) ? this.model.getLeaderLinesSymbol() : undefined;
            case ih.Background:
                return this.model.getBackgroundColor();
            default:
                return undefined;
        }
    }
    /**
     * @category Private
     */
    setFormatValue(formatKey, value) {
        switch (formatKey) {
            case ih.Title:
                if (ey(value)) {
                    this.model.setTitleSymbol(value);
                }
                break;
            case ih.Description:
                if (ey(value)) {
                    this.model.setDescriptionSymbol(value);
                }
                break;
            case ih.XAxisTitle:
                if (Lg(this.model) && ey(value)) {
                    this.model.setXAxisTitleSymbol(value);
                }
                break;
            case ih.YAxisTitle:
                if (Dg(this.model) && ey(value)) {
                    this.model.setYAxisTitleSymbol(value);
                }
                break;
            case ih.AxisLabels:
                if (Lg(this.model) && ey(value)) {
                    this.model.setAxisLabelsSymbol(value);
                }
                break;
            case ih.GuideLabels:
                if (Bg(this.model) && ey(value)) {
                    this.model.setGuideLabelsSymbol(value);
                }
                break;
            case ih.LegendText:
                if (Mg(this.model) && ey(value)) {
                    this.model.setLegendTextSymbol(value);
                }
                break;
            case ih.LegendTitle:
                if (Mg(this.model) && ey(value)) {
                    this.model.setLegendTitleSymbol(value);
                }
                break;
            case ih.DataLabels:
                if (Ug(this.model) && ey(value)) {
                    this.model.setDataLabelsSymbol(value);
                }
                break;
            case ah.AxisLines:
                if (Lg(this.model) && Jc(value)) {
                    this.model.setAxisLinesSymbol(value);
                }
                break;
            case ah.GridLines:
                if (Dg(this.model) && Jc(value)) {
                    this.model.setGridLinesSymbol(value);
                }
                break;
            case ah.LeaderLines:
                if (Og(this.model) && Jc(value)) {
                    this.model.setLeaderLinesSymbol(value);
                }
                break;
            case ih.Background:
                if (Array.isArray(value)) {
                    this.model.setBackgroundColor(value);
                }
                break;
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return this; }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
    static get style() { return ArcgisChartsConfigFormatStyle0; }
}, [1, "arcgis-charts-config-format", {
        "model": [16],
        "selectedSymbols": [32],
        "selectedTexts": [32],
        "selectedBackground": [32],
        "selectedElement": [32],
        "updatesOccurred": [32]
    }, undefined, {
        "model": ["modelChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-charts-config-format"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-charts-config-format":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcgisChartsConfigFormat);
            }
            break;
    } });
}
defineCustomElement();

export { ArcgisChartsConfigFormat as A, defineCustomElement as d };
