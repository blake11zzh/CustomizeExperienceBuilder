/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';
import { s as bc, S as Sc, T as Tc, t as ty } from './index2.js';
import { C as ChartAuthoringPages } from './interfaces.js';
import { d as defineCustomElement$c } from './arcgis-charts-config-axes2.js';
import { d as defineCustomElement$b } from './arcgis-charts-config-axis2.js';
import { d as defineCustomElement$a } from './arcgis-charts-config-bar-chart-data2.js';
import { d as defineCustomElement$9 } from './arcgis-charts-config-bar-chart-series2.js';
import { d as defineCustomElement$8 } from './arcgis-charts-config-category-format2.js';
import { d as defineCustomElement$7 } from './arcgis-charts-config-field-select2.js';
import { d as defineCustomElement$6 } from './arcgis-charts-config-format2.js';
import { d as defineCustomElement$5 } from './arcgis-charts-config-general2.js';
import { d as defineCustomElement$4 } from './arcgis-charts-config-guide2.js';
import { d as defineCustomElement$3 } from './arcgis-charts-config-guides2.js';
import { d as defineCustomElement$2 } from './arcgis-charts-config-invalid-input-message2.js';
import { d as defineCustomElement$1 } from './arcgis-charts-config-number-format2.js';
import { i as isEqual } from './isEqual.js';

const arcgisChartsConfigBarChartCss = ":host{overflow-y:auto;overflow-x:hidden;margin-bottom:var(--arcgis-charts-intra-section-margin);margin-top:var(--arcgis-charts-intra-section-margin);height:100%}";
const ArcgisChartsConfigBarChartStyle0 = arcgisChartsConfigBarChartCss;

const ArcGISChartsConfigBarChart = /*@__PURE__*/ proxyCustomElement(class ArcGISChartsConfigBarChart extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.arcgisChartsNoSeriesUpdate = createEvent(this, "arcgisChartsConfigNoSeriesUpdate", 7);
        /**
         * @category Private
         */
        this.popoverElement = null;
        /**
         * @category Event handler
         */
        this.popoverOpen = (e) => {
            const { open = false, element = null } = { ...e.detail };
            if (open === true && this.popoverElement !== element) {
                if (this.popoverElement !== null) {
                    this.popoverElement.open = false;
                }
                this.popoverElement = element;
            }
            else if (open === false && this.popoverElement === element) {
                this.popoverElement = null;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = async (e) => {
            const config = e?.detail.config ?? this.model.getConfig();
            if (this.layer === undefined) {
                await this.updateFetchLayerFieldsInfo(config);
            }
        };
        this.model = undefined;
        this.timeZone = undefined;
        this.popoverPlacement = "leading";
        this.seriesColor = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.page = undefined;
        this.layer = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.layerFieldsInfo = undefined;
        this.activeColorMatch = false;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    async layerChange(newValue, oldValue) {
        if (newValue !== undefined && !isEqual(oldValue, newValue)) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    async usePopupTemplateFieldsInfoChange(newValue, oldValue) {
        if (newValue !== undefined && newValue !== oldValue) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * Assigns new colors to the series
     * @param seriesColor
     * @category Watch handler
     */
    seriesColorChange(seriesColor) {
        this.activeColorMatch = seriesColor?.get(0) === undefined;
        if (this.model.getColorMatch()) {
            seriesColor?.forEach((fillSymbol, index) => {
                if (seriesColor?.get(0) !== undefined &&
                    fillSymbol?.color !== undefined &&
                    !isEqual(this.model.getSeriesColor(index), fillSymbol?.color)) {
                    this.model.setSeriesColor(fillSymbol?.color, index);
                }
            });
        }
    }
    /**
     * update the data filter `where` clause with the layer definitionExpression if they are different
     */
    async updateDataFilters() {
        const savedDataFilter = this.model.getDataFilter();
        const whereFilter = savedDataFilter?.where;
        // NOTE: definitionalExpression is returned as null if it is not set
        const definitionExpressionFromLayer = this.layer?.definitionExpression ?? undefined;
        if (!isEqual(whereFilter, definitionExpressionFromLayer)) {
            await this.model.setDataFilter({
                ...savedDataFilter,
                where: definitionExpressionFromLayer,
            });
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        if (this.layer !== undefined) {
            await this.layerChange(this.layer, undefined);
        }
        if (this.seriesColor !== undefined) {
            this.seriesColorChange(this.seriesColor);
        }
        if (this.usePopupTemplateFieldsInfo !== undefined) {
            await this.usePopupTemplateFieldsInfoChange(this.usePopupTemplateFieldsInfo, undefined);
        }
        this.modelChange(this.model);
        this.onModelConfigChange();
        this.updateDataFilters();
    }
    /**
     * @category Lifecycle
     */
    async componentWillRender() {
        // Ensure layerFieldsInfo is defined
        if (this.layerFieldsInfo === undefined) {
            await this.updateFetchLayerFieldsInfo();
        }
    }
    /**
     * Render the panels for each of the pages.
     * @category Lifecycle
     */
    render() {
        const categoryField = this.layerFieldsInfo.find((field) => field.name === this.model.getXAxisField());
        const enableXAxisGuide = categoryField !== undefined && Tc(categoryField);
        let panel;
        switch (this.page) {
            case ChartAuthoringPages.Data:
                panel = (h(Host, { key: '38f81554721a81aea0f101162f6067fef002479a' }, h("arcgis-charts-config-bar-chart-data", { key: '9b9d4ee22a2e8527c1d1504f5f16352f49012166', model: this.model, layerFieldsInfo: this.layerFieldsInfo })));
                break;
            case ChartAuthoringPages.Series:
                panel = (h(Host, { key: 'adae67c5e8f9cc05bb64912c326ed2a7e2480234' }, h("arcgis-charts-config-bar-chart-series", { key: 'cfbc4ae6a8d265ee504d24569604f2155cabf339', model: this.model, activeColorMatch: this.activeColorMatch, onArcgisChartsConfigBarChartSeriesPopoverChange: this.popoverOpen, popoverPlacement: this.popoverPlacement })));
                break;
            case ChartAuthoringPages.Axes:
                panel = (h(Host, { key: '7d60be19d23299c5bca7dc1969f4bc2c79cc48f6' }, h("arcgis-charts-config-axes", { key: '38a6a0224ea7479109813d51f5a3f4b0b44cbf42', model: this.model, showMinXBoundOption: false, showMaxXBoundOption: false, showMinYBoundOption: false, showMaxYBoundOption: true, showEnableXLogOption: false, showEnableYLogOption: false, calculatedMinMaxBounds: this.calculatedMinMaxBounds })));
                break;
            case ChartAuthoringPages.Guides:
                panel = (h(Host, { key: '90c15c898e0c3e097d4f3d99d1948b2d1111d4a9' }, h("arcgis-charts-config-guides", { key: '7ca16420980680735352bc6303a67c16559f43df', model: this.model, timeZone: this.timeZone, enableXAxisGuide: enableXAxisGuide, enableYAxisGuide: true, calculatedMinMaxBounds: this.calculatedMinMaxBounds, onArcgisChartsConfigGuidePopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.Format:
                panel = (h(Host, { key: 'b78ddf8c5e70f338e465a701b4e320b5b4b3317b' }, h("arcgis-charts-config-format", { key: '06c9bf969430192bf56620fe250b6dc6fcf4be58', model: this.model, onArcgisChartsConfigFormatPopoverChange: this.popoverOpen })));
                break;
            case ChartAuthoringPages.General:
                panel = (h(Host, { key: '485101f708f3adf85199d955bf2c91e3242707e2' }, h("arcgis-charts-config-general", { key: 'd90af83fb5cb597331a369f8b486ffe7d27c84aa', model: this.model })));
                break;
            default:
                panel = h(Host, { key: 'd5e7aa173cd16ed363ce2af2d7ce92f635874344' });
                break;
        }
        return panel;
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Private
     */
    async updateFetchLayerFieldsInfo(config) {
        // get feature layer from component prop if exists, otherwise get from current config iLayer
        const currentConfig = config ?? this.model.getConfig();
        let layer = this.layer;
        // if the layer doesn't exist we build one from the config data source
        if (!layer) {
            const iLayer = ty(currentConfig) ? currentConfig.iLayer : undefined;
            if (iLayer) {
                layer = await bc(iLayer);
            }
        }
        if (layer) {
            this.layerFieldsInfo = await Sc(layer, this.usePopupTemplateFieldsInfo);
        }
    }
    get hostElement() { return this; }
    static get watchers() { return {
        "model": ["modelChange"],
        "layer": ["layerChange"],
        "usePopupTemplateFieldsInfo": ["usePopupTemplateFieldsInfoChange"],
        "seriesColor": ["seriesColorChange"]
    }; }
    static get style() { return ArcgisChartsConfigBarChartStyle0; }
}, [1, "arcgis-charts-config-bar-chart", {
        "model": [16],
        "timeZone": [513, "time-zone"],
        "popoverPlacement": [513, "popover-placement"],
        "seriesColor": [16],
        "calculatedMinMaxBounds": [16],
        "page": [513],
        "layer": [16],
        "usePopupTemplateFieldsInfo": [4, "use-popup-template-fields-info"],
        "layerFieldsInfo": [32],
        "activeColorMatch": [32]
    }, undefined, {
        "model": ["modelChange"],
        "layer": ["layerChange"],
        "usePopupTemplateFieldsInfo": ["usePopupTemplateFieldsInfoChange"],
        "seriesColor": ["seriesColorChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-charts-config-bar-chart", "arcgis-charts-config-axes", "arcgis-charts-config-axis", "arcgis-charts-config-bar-chart-data", "arcgis-charts-config-bar-chart-series", "arcgis-charts-config-category-format", "arcgis-charts-config-field-select", "arcgis-charts-config-format", "arcgis-charts-config-general", "arcgis-charts-config-guide", "arcgis-charts-config-guides", "arcgis-charts-config-invalid-input-message", "arcgis-charts-config-number-format"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-charts-config-bar-chart":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcGISChartsConfigBarChart);
            }
            break;
        case "arcgis-charts-config-axes":
            if (!customElements.get(tagName)) {
                defineCustomElement$c();
            }
            break;
        case "arcgis-charts-config-axis":
            if (!customElements.get(tagName)) {
                defineCustomElement$b();
            }
            break;
        case "arcgis-charts-config-bar-chart-data":
            if (!customElements.get(tagName)) {
                defineCustomElement$a();
            }
            break;
        case "arcgis-charts-config-bar-chart-series":
            if (!customElements.get(tagName)) {
                defineCustomElement$9();
            }
            break;
        case "arcgis-charts-config-category-format":
            if (!customElements.get(tagName)) {
                defineCustomElement$8();
            }
            break;
        case "arcgis-charts-config-field-select":
            if (!customElements.get(tagName)) {
                defineCustomElement$7();
            }
            break;
        case "arcgis-charts-config-format":
            if (!customElements.get(tagName)) {
                defineCustomElement$6();
            }
            break;
        case "arcgis-charts-config-general":
            if (!customElements.get(tagName)) {
                defineCustomElement$5();
            }
            break;
        case "arcgis-charts-config-guide":
            if (!customElements.get(tagName)) {
                defineCustomElement$4();
            }
            break;
        case "arcgis-charts-config-guides":
            if (!customElements.get(tagName)) {
                defineCustomElement$3();
            }
            break;
        case "arcgis-charts-config-invalid-input-message":
            if (!customElements.get(tagName)) {
                defineCustomElement$2();
            }
            break;
        case "arcgis-charts-config-number-format":
            if (!customElements.get(tagName)) {
                defineCustomElement$1();
            }
            break;
    } });
}
defineCustomElement();

export { ArcGISChartsConfigBarChart as A, defineCustomElement as d };
