/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { proxyCustomElement, HTMLElement, createEvent, getAssetPath, h, Host } from '@stencil/core/internal/client';
import { M as Mn, y as eu } from './index2.js';
import { R as Rg, n as nh, N as Ng } from './index3.js';
import { d as defineCustomElement$1, g as getGuideListPosition, H as HTMLClasses } from './arcgis-charts-config-guide2.js';
import { d as defaultGuide } from './default.js';
import { c as cloneDeep } from './cloneDeep.js';

const arcgisChartsConfigGuidesCss = ":host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}.add-guide{display:flex;justify-content:center;padding:0.5rem}.add-guide-btn{width:100%}.no-guides{border-radius:2rem}.no-messages{text-align:center}.guide-icon{padding-left:0.5rem;padding-top:0.5rem;width:1.5rem;height:1.5rem}";
const ArcgisChartsConfigGuidesStyle0 = arcgisChartsConfigGuidesCss;

const ArcgisChartsConfigGuides = /*@__PURE__*/ proxyCustomElement(class ArcgisChartsConfigGuides extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.arcgisChartsConfigGuidePopoverChange = createEvent(this, "arcgisChartsConfigGuidePopoverChange", 7);
        /**
         * @category Private
         */
        this.addXGuide = () => {
            if (Rg(this.model)) {
                const name = this.getUniqueName(this.strings.xAxisGuide);
                const index = this.model.getXGuidesLength() ?? 0;
                this.model.addXAxisGuide(name, index);
                this.model.setGuideStyle(cloneDeep(defaultGuide.style), index, nh.X);
                this.latestGuidePosition = getGuideListPosition(index, nh.X, this.model);
                this.togglePopOver();
                // TODO: This is hopefully a temporary fix. There is an issue with the way Stencil components apply boolean
                // attributes in JSX. See https://github.com/ionic-team/stencil-ds-output-targets/issues/123.
                // Collapse all other guide blocks after adding a new one
                const guideBlocks = this.hostElement.shadowRoot?.querySelectorAll("calcite-block") ?? [];
                guideBlocks.forEach((guideBlock, i) => {
                    if (i !== this.latestGuidePosition) {
                        guideBlock.open = false;
                    }
                });
            }
        };
        /**
         * @category Private
         */
        this.addYGuide = () => {
            if (Ng(this.model)) {
                const name = this.getUniqueName(this.strings.yAxisGuide);
                const index = this.model.getYGuidesLength() ?? 0;
                this.model.addYAxisGuide(name, index);
                this.model.setGuideStyle(cloneDeep(defaultGuide.style), index, nh.Y);
                this.latestGuidePosition = getGuideListPosition(index, nh.Y, this.model);
                this.togglePopOver();
                // TODO: This is hopefully a temporary fix. There is an issue with the way Stencil components apply boolean
                // attributes in JSX. See https://github.com/ionic-team/stencil-ds-output-targets/issues/123.
                // Collapse all other guide blocks after adding a new one
                for (const guideBlock of this.hostElement.shadowRoot?.querySelectorAll("calcite-block") ?? []) {
                    guideBlock.open = false;
                }
            }
        };
        /**
         * @category Private
         */
        this.closeAddPopOver = () => {
            this.showAddButton = true;
        };
        /**
         * @category Private
         */
        this.togglePopOver = () => {
            if (this.enableXAxisGuide && this.enableYAxisGuide) {
                this.showAddButton = !this.showAddButton;
            }
        };
        /**
         * @category Event handler
         */
        this.setChangedGuide = (e) => {
            const { index, orientation, isDelete } = e.detail;
            const listPosition = getGuideListPosition(index, orientation, this.model);
            // Decrement latest guide position if deleted guide was before it
            if (isDelete &&
                listPosition !== undefined &&
                listPosition <= this.latestGuidePosition &&
                this.latestGuidePosition > 0) {
                this.latestGuidePosition -= 1;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        this.model = undefined;
        this.timeZone = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.enableXAxisGuide = true;
        this.enableYAxisGuide = true;
        this.open = false;
        this.showAddButton = true;
        this.latestGuidePosition = 0;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await Mn(this.hostElement, getAssetPath(`.`)));
        this.modelChange(this.model);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * Gets the total number of guides.
     * @category Private
     */
    getAllGuidesLength() {
        const xGuidesLength = Rg(this.model) ? (this.model.getXGuidesLength() ?? 0) : 0;
        const yGuidesLength = Ng(this.model) ? (this.model.getYGuidesLength() ?? 0) : 0;
        return xGuidesLength + yGuidesLength;
    }
    /**
     * @param guide
     * @category Render UX
     */
    renderGuide(index, orientation) {
        let guideElement;
        if ((this.enableXAxisGuide && orientation === nh.X) ||
            (this.enableYAxisGuide && orientation === nh.Y)) {
            guideElement = (h("arcgis-charts-config-guide", { model: this.model, timeZone: this.timeZone, calculatedMinMaxBounds: this.calculatedMinMaxBounds, index: index, orientation: orientation, latestGuidePosition: this.latestGuidePosition, onArcgisChartsConfigGuideChange: this.setChangedGuide }));
        }
        return guideElement;
    }
    /**
     * @category Render UX
     */
    renderGuides() {
        const guidesUI = [];
        if (Rg(this.model)) {
            const xGuidesLength = this.model.getXGuidesLength() ?? 0;
            for (let i = 0; i < xGuidesLength; i += 1) {
                guidesUI.push(this.renderGuide(i, nh.X));
            }
        }
        if (Ng(this.model)) {
            const yGuidesLength = this.model.getYGuidesLength() ?? 0;
            for (let i = 0; i < yGuidesLength; i += 1) {
                guidesUI.push(this.renderGuide(i, nh.Y));
            }
        }
        return guidesUI;
    }
    /**
     * @param callBack
     * @category Render UX
     */
    renderAddGuideButton(callBack) {
        return (h("calcite-fab", { slot: "fab", appearance: "outline-fill", kind: "neutral", hidden: false, textEnabled: true, text: this.strings.addGuide, label: this.strings.addGuide, onClick: callBack, scale: "s" }));
    }
    /**
     * @category Lifecycle
     */
    render() {
        const allGuidesLength = this.getAllGuidesLength();
        const isGuidesAvailable = allGuidesLength > 0;
        const isAddBtnRequired = this.showAddButton && this.enableXAxisGuide && this.enableYAxisGuide;
        const isAddXGuide = this.enableXAxisGuide && !this.enableYAxisGuide;
        const isAddYGuide = !this.enableXAxisGuide && this.enableYAxisGuide;
        return (h(Host, { key: '3044b147d444eb3c4cba0b73fbab3bcea53f3367' }, h("calcite-popover", { key: '968d5535eda83cdf9db30eb208f8db9e46bfee80', open: !this.showAddButton, referenceElement: this.addGuideButton, flipDisabled: true, pointerDisabled: true, offsetDistance: -18, onCalcitePopoverClose: this.closeAddPopOver, placement: allGuidesLength === 0 ? "bottom" : "top", ref: (e) => {
                this.popoverElement = e;
            }, label: "" }, h("calcite-panel", { key: 'b7339ced53c59530569fc0a4ce9814eaf169ef94', heading: this.strings.guideType }, h("calcite-action", { key: 'fd123c6df0859541956b7f0cb6985c9cc93cad4e', text: "", slot: "header-actions-end", icon: "x", onClick: this.closeAddPopOver }), this.enableXAxisGuide ? (h("calcite-action", { label: this.strings.addXAxisGuide, text: this.strings.addXAxisGuide, onClick: this.addXGuide, icon: "x-axis-guide", textEnabled: true })) : null, this.enableYAxisGuide ? (h("calcite-action", { label: this.strings.addYAxisGuide, text: this.strings.addYAxisGuide, onClick: this.addYGuide, icon: "y-axis-guide", textEnabled: true })) : null)), isGuidesAvailable ? this.renderGuides() : h("div", { class: HTMLClasses.noMessages }, this.strings.noGuidesMsg), h("div", { key: '72a79ff0a7aa89fa13e7c46697d1ef4bb19764b5', class: HTMLClasses.addGuide, ref: (el) => {
                this.addGuideButton = el;
            } }, isAddBtnRequired && this.renderAddGuideButton(this.togglePopOver), isAddXGuide && this.renderAddGuideButton(this.addXGuide), isAddYGuide && this.renderAddGuideButton(this.addYGuide))));
    }
    /**
     * @category Lifecycle
     */
    componentDidRender() {
        eu(this.popoverElement, !this.showAddButton);
    }
    /**
     * @param guideNameTemplate
     * @param count
     * @category Private
     */
    getUniqueName(guideNameTemplate, count = 1) {
        const name = `${guideNameTemplate} ${count}`;
        let nameAlreadyUsed = false;
        if (Rg(this.model)) {
            const xGuidesLength = this.model.getXGuidesLength() ?? 0;
            for (let i = 0; i < xGuidesLength && !nameAlreadyUsed; i += 1) {
                const guideName = this.model.getGuideName(i, nh.X);
                if (guideName === name) {
                    nameAlreadyUsed = true;
                }
            }
        }
        if (Ng(this.model)) {
            const yGuidesLength = this.model.getYGuidesLength() ?? 0;
            for (let i = 0; i < yGuidesLength && !nameAlreadyUsed; i += 1) {
                const guideName = this.model.getGuideName(i, nh.Y);
                if (guideName === name) {
                    nameAlreadyUsed = true;
                }
            }
        }
        return !nameAlreadyUsed ? name : this.getUniqueName(guideNameTemplate, count + 1);
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return this; }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
    static get style() { return ArcgisChartsConfigGuidesStyle0; }
}, [1, "arcgis-charts-config-guides", {
        "model": [16],
        "timeZone": [513, "time-zone"],
        "calculatedMinMaxBounds": [16],
        "enableXAxisGuide": [4, "enable-x-axis-guide"],
        "enableYAxisGuide": [4, "enable-y-axis-guide"],
        "open": [516],
        "showAddButton": [32],
        "latestGuidePosition": [32],
        "updatesOccurred": [32]
    }, undefined, {
        "model": ["modelChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-charts-config-guides", "arcgis-charts-config-guide"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-charts-config-guides":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcgisChartsConfigGuides);
            }
            break;
        case "arcgis-charts-config-guide":
            if (!customElements.get(tagName)) {
                defineCustomElement$1();
            }
            break;
    } });
}
defineCustomElement();

export { ArcgisChartsConfigGuides as A, defineCustomElement as d };
