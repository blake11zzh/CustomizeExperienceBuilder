/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { proxyCustomElement, HTMLElement, createEvent, getAssetPath, h, Host } from '@stencil/core/internal/client';
import { M as Mn, w as ta, J as ia, y as eu, L as jl, A as Tl, C as Cc, I as Ic } from './index2.js';
import { L as LineChartDataPopoverKinds, b as RESTFieldType } from './interfaces.js';
import { e as emitNumericFieldsChange, a as aggregationList, U as UIDefaults, i as itemMatchesSelectedContent, s as sanitizeNumber } from './chart-ui-utils.js';
import { i as isEqual } from './isEqual.js';
import { c as WebChartTimeAggregationTypes, d as WebChartTimeIntervalUnits } from './chart-object-literals.js';

const HTMLClasses = {
    jsAppFlyout: "js-app-flyout",
    name: "line-chart-data-popover",
    numericFieldPickList: "line-chart-data-numeric-fields-pick-list",
    header: "header",
    fab: "fab",
    pickListItemLabel: "pick-list-item-label",
    rotateClass: "sort-y-axis",
    sizeSection: "size-section",
    applyButton: "apply-button",
};

const arcgisChartsConfigLineChartPopoverCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}.name{display:flex;flex-direction:column;margin:0.5rem;padding:0.5rem;background:white;min-width:250px}.header{margin:0;font-weight:bolder}.fab{display:flex;justify-content:stretch}.pick-list-item-label{font-size:small}.sort-icon-color{color:black}.sort-y-axis{transform:rotate(90deg)}calcite-panel{max-height:60vh}calcite-panel .size-section{width:19rem;margin:1rem 0;display:flex;flex-wrap:wrap;justify-content:space-evenly}calcite-panel .size-section calcite-label{width:8rem;margin-bottom:0.25rem}calcite-panel .apply-button{width:17rem}";
const ArcgisChartsConfigLineChartPopoverStyle0 = arcgisChartsConfigLineChartPopoverCss;

const ArcgisChartsConfigLineChartPopover = /*@__PURE__*/ proxyCustomElement(class ArcgisChartsConfigLineChartPopover extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.arcgisChartsConfigLineChartDataPopoverChange = createEvent(this, "arcgisChartsConfigLineChartDataPopoverChange", 7);
        this.arcgisChartsConfigLineChartPopoverClose = createEvent(this, "arcgisChartsConfigLineChartPopoverClose", 7);
        /**
         * @category Private
         */
        this.placement = "leading";
        /**
         * @category Private
         */
        this.offsetDistance = -200;
        /**
         * @category Private
         */
        this.pickListHasChanged = false;
        /**
         * @category Event handler
         */
        this.closePopover = () => {
            if (this.contentKind === LineChartDataPopoverKinds.numericFields) {
                const numericFieldsChangeProps = {
                    pickListElement: this.picklist,
                    eventEmitter: this.arcgisChartsConfigLineChartDataPopoverChange,
                    contentKind: this.contentKind,
                };
                emitNumericFieldsChange(numericFieldsChangeProps);
            }
            this.open = false;
            this.arcgisChartsConfigLineChartPopoverClose.emit(this.pickListHasChanged);
        };
        /**
         * @category Event handler
         * @param e
         */
        this.onDataContentTypeChange = (e) => {
            this.pickListHasChanged = true;
            const selectedItems = e.target.selectedItems;
            this.arcgisChartsConfigLineChartDataPopoverChange.emit({
                contentKind: this.contentKind,
                value: selectedItems.map((item) => item.value),
            });
            this.open = false;
        };
        /**
         * @category Event handler
         */
        this.intervalChange = () => {
            const intervalSize = Number.parseInt(this.intervalSizeElement?.value ?? "");
            const intervalUnits = this.intervalTypeElement?.selectedOption?.value;
            if (!Number.isNaN(intervalSize) && intervalSize > 0) {
                this.arcgisChartsConfigLineChartDataPopoverChange.emit({
                    contentKind: this.contentKind,
                    value: [{ intervalSize, intervalUnits }],
                });
            }
            this.open = false;
        };
        /**
         * @category Event handler
         * @param e
         */
        this.onNumericFieldsChange = (e) => {
            if (e.target !== null) {
                this.selectedContent = e.target.selectedItems.map((item) => item.value);
            }
        };
        /**
         * @category Event handler
         */
        this.onNumericFieldSelectionDone = () => {
            if (this.pickListHasChanged) {
                this.closePopover();
            }
        };
        this.headingTitle = undefined;
        this.referenceElement = undefined;
        this.open = undefined;
        this.contentKind = undefined;
        this.layerFieldsInfo = undefined;
        this.selectedContent = undefined;
    }
    /**
     * Watches for change to selected content to record if there was a pick list change.
     * @param newSelectedContent
     * @param oldSelectedContent
     * @category Watch handler
     */
    selectedContentChange(newSelectedContent, oldSelectedContent) {
        this.pickListHasChanged = !isEqual(newSelectedContent, oldSelectedContent);
    }
    /**
     * Calls `reposition()` method on popover element.
     * @category Public
     */
    async reposition() {
        await this.popoverElement?.reposition();
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await Mn(this.hostElement, getAssetPath(`.`)));
    }
    /**
     * @category Lifecycle
     */
    async componentWillRender() {
        const aggregationPromises = aggregationList.map(async (item) => await ta(item));
        this.aggregationLabels = await Promise.all(aggregationPromises);
        // time aggregation type labels
        const timeAggregationList = [WebChartTimeAggregationTypes.Start, WebChartTimeAggregationTypes.End];
        const timeAggregationPromises = timeAggregationList.map(async (item) => await ia(item));
        this.timeAggregationLabels = await Promise.all(timeAggregationPromises);
    }
    /**
     * @category Lifestyle
     */
    componentDidRender() {
        setTimeout(async () => {
            if (typeof this.picklist?.setFocus === "function") {
                await this.picklist?.setFocus();
            }
        }, UIDefaults.PopoverTimer);
        eu(this.popoverElement, this.open);
    }
    /**
     * @category Lifecycle
     */
    componentDidUpdate() {
        setTimeout(() => {
            this.popoverElement?.reposition();
        }, UIDefaults.PopoverTimer);
    }
    /**
     * @category Render UX
     */
    renderAggregationType() {
        const items = this.buildAggregationPickListItems();
        return (h("calcite-list", { label: "", class: HTMLClasses.pickListItemLabel, selectionMode: "single", selectionAppearance: "border", filterEnabled: false, onCalciteListChange: this.onDataContentTypeChange }, items));
    }
    /**
     * @category Render UX
     */
    buildAggregationPickListItems() {
        return aggregationList.map((item, index) => (h("calcite-list-item", { label: this.aggregationLabels[index], key: item, value: item, selected: itemMatchesSelectedContent(item, this.selectedContent) })));
    }
    /**
     * @category Render UX
     */
    renderXAxisField() {
        const items = this.buildPickListItems(LineChartDataPopoverKinds.xAxisField);
        return (h("calcite-list", { label: "", class: HTMLClasses.pickListItemLabel, selectionMode: "single", selectionAppearance: "border", filterEnabled: true, onCalciteListChange: this.onDataContentTypeChange, ref: (e) => {
                this.picklist = e;
            } }, items));
    }
    /**
     * @category Render UX
     */
    renderNumericFields() {
        const items = this.buildPickListItems(LineChartDataPopoverKinds.numericFields);
        return (h("calcite-list", { label: "", class: HTMLClasses.numericFieldPickList, selectionMode: "multiple", filterEnabled: true, onCalciteListChange: this.onNumericFieldsChange, ref: (e) => {
                this.picklist = e;
            } }, items));
    }
    /**
     * @category Render UX
     */
    renderSplitByField() {
        const items = this.buildPickListItems(LineChartDataPopoverKinds.splitByField);
        return (h("calcite-list", { label: "", class: HTMLClasses.pickListItemLabel, selectionMode: "single", selectionAppearance: "border", filterEnabled: true, onCalciteListChange: this.onDataContentTypeChange, ref: (e) => {
                this.picklist = e;
            } }, items));
    }
    /**
     * @category Render UX
     */
    renderIntervalAlignment() {
        const items = this.buildIntervalAlignmentPickListItems();
        return (h("calcite-list", { label: "", class: HTMLClasses.pickListItemLabel, selectionMode: "single", selectionAppearance: "border", filterEnabled: false, onCalciteListChange: this.onDataContentTypeChange }, items));
    }
    /**
     * @category Render UX
     */
    renderInterval() {
        const intervalProps = this.selectedContent;
        const intervalUnitsList = [
            WebChartTimeIntervalUnits.Seconds,
            WebChartTimeIntervalUnits.Minutes,
            WebChartTimeIntervalUnits.Hours,
            WebChartTimeIntervalUnits.Days,
            WebChartTimeIntervalUnits.Weeks,
            WebChartTimeIntervalUnits.Months,
            WebChartTimeIntervalUnits.Years,
        ];
        return (h("div", null, h("div", { class: HTMLClasses.sizeSection }, h("calcite-label", { scale: "m" }, this.strings.intervalSize, h("calcite-input", { type: "number", scale: "m", min: 1, step: "any",
            // TODO: Pull default from a util function getDefaultTimeIntervalSize instead
            value: sanitizeNumber(intervalProps?.timeIntervalSize, 1), ref: (e) => {
                this.intervalSizeElement = e;
            } })), h("calcite-label", { scale: "m" }, this.strings.intervalType, h("calcite-select", { label: this.strings.intervalType, ref: (e) => {
                this.intervalTypeElement = e;
            } }, intervalUnitsList.map((unit) => (h("calcite-option", { value: unit, label: jl(unit, this.strings), selected: intervalProps?.timeIntervalUnits === unit }))))), h("calcite-button", { class: HTMLClasses.applyButton, appearance: "outline", onClick: this.intervalChange }, this.strings.apply))));
    }
    /**
     * @category Render UX
     */
    buildIntervalAlignmentPickListItems() {
        const timeAggregationTypes = [WebChartTimeAggregationTypes.Start, WebChartTimeAggregationTypes.End];
        return timeAggregationTypes.map((item, index) => (h("calcite-list-item", { label: this.timeAggregationLabels[index], key: item, value: item, selected: itemMatchesSelectedContent(item, this.selectedContent) })));
    }
    /**
     * @param field
     * @category Render UX
     */
    buildPickListItem(field) {
        return (h("calcite-list-item", { key: field.name, label: Tl(this.layerFieldsInfo, field.name), value: field.name, selected: itemMatchesSelectedContent(field.name, this.selectedContent) }));
    }
    /**
     * @param itemKind
     * @category Render UX
     */
    buildPickListItems(itemKind) {
        const fieldCount = this.layerFieldsInfo?.length ?? 0;
        const pickListItems = [];
        switch (itemKind) {
            case LineChartDataPopoverKinds.numericFields: {
                for (let i = 0; i < fieldCount; i += 1) {
                    const field = this.layerFieldsInfo[i];
                    if (Ic(field)) {
                        pickListItems.push(this.buildPickListItem(field));
                    }
                }
                break;
            }
            case LineChartDataPopoverKinds.xAxisField: {
                for (let i = 0; i < fieldCount; i += 1) {
                    const field = this.layerFieldsInfo[i];
                    if (Ic(field) || field.type === RESTFieldType.Date) {
                        pickListItems.push(this.buildPickListItem(field));
                    }
                }
                break;
            }
            case LineChartDataPopoverKinds.splitByField: {
                pickListItems.push(h("calcite-list-item", { label: "\u00A0", key: "\u00A0", value: "\u00A0", selected: itemMatchesSelectedContent("", this.selectedContent) }));
                for (let i = 0; i < fieldCount; i += 1) {
                    const field = this.layerFieldsInfo[i];
                    if (Cc(field) || field.type === RESTFieldType.String) {
                        pickListItems.push(this.buildPickListItem(field));
                    }
                }
                break;
            }
        }
        return pickListItems;
    }
    /**
     * @category Render UX
     */
    renderPopoverInfo() {
        let content;
        switch (this.contentKind) {
            case LineChartDataPopoverKinds.aggregation:
                content = this.renderAggregationType();
                break;
            case LineChartDataPopoverKinds.xAxisField:
                content = this.renderXAxisField();
                break;
            case LineChartDataPopoverKinds.numericFields:
                content = this.renderNumericFields();
                break;
            case LineChartDataPopoverKinds.splitByField:
                content = this.renderSplitByField();
                break;
            case LineChartDataPopoverKinds.intervalAlignment:
                content = this.renderIntervalAlignment();
                break;
            case LineChartDataPopoverKinds.interval:
                content = this.renderInterval();
                break;
        }
        return content;
    }
    /**
     * @category Lifecycle
     */
    render() {
        let footerButton;
        if (this.contentKind === LineChartDataPopoverKinds.numericFields) {
            footerButton = (h("div", { key: '17c7c5f289350e3670c8d0c469ff33bbc5efacd9', slot: "footer" }, h("calcite-fab", { key: 'ee8dce86161de64488c24068a45bb811efec43fd', class: HTMLClasses.fab, appearance: "outline-fill", kind: "neutral", icon: "", label: this.strings.selectionDone, scale: "s", "text-enabled": true, text: this.strings.selectionDone, onClick: this.onNumericFieldSelectionDone })));
        }
        return (h(Host, { key: '4bebc3c07023e0476ecdf6d65ea4ced497e902ef', class: HTMLClasses.jsAppFlyout }, h("calcite-popover", { key: '2f392573289924c3d058e00d5f0b072d98852fff', class: HTMLClasses.name, referenceElement: this.referenceElement, placement: this.placement, offsetDistance: this.offsetDistance, onCalcitePopoverClose: this.closePopover, open: this.open, label: "", ref: (e) => {
                this.popoverElement = e;
            } }, h("calcite-panel", { key: 'd2dcd7cae97f969a61fbe2006aedf69374d3611a', closable: true, closed: !this.open, onCalcitePanelClose: this.closePopover }, h("div", { key: '044b4117611319a8bb869dce168e0b0d4a02205a', slot: "header-content", class: HTMLClasses.header }, this.headingTitle ?? ""), this.renderPopoverInfo(), footerButton))));
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return this; }
    static get watchers() { return {
        "selectedContent": ["selectedContentChange"]
    }; }
    static get style() { return ArcgisChartsConfigLineChartPopoverStyle0; }
}, [1, "arcgis-charts-config-line-chart-popover", {
        "headingTitle": [513, "heading-title"],
        "referenceElement": [16],
        "open": [1540],
        "contentKind": [1, "content-kind"],
        "layerFieldsInfo": [16],
        "selectedContent": [1, "selected-content"],
        "reposition": [64]
    }, undefined, {
        "selectedContent": ["selectedContentChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-charts-config-line-chart-popover"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-charts-config-line-chart-popover":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcgisChartsConfigLineChartPopover);
            }
            break;
    } });
}
defineCustomElement();

export { ArcgisChartsConfigLineChartPopover as A, defineCustomElement as d };
