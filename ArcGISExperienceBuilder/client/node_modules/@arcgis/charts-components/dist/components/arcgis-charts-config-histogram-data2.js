/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
import { proxyCustomElement, HTMLElement, createEvent, getAssetPath, h, Host } from '@stencil/core/internal/client';
import { M as Mn, a2 as Jy, A as Tl, ab as no, Z as Zy, r as Qy, ac as oo } from './index2.js';
import { a as RESTSymbolType, H as HistogramDataPopoverKinds, j as HistogramOverlays, k as HistogramStatistics } from './interfaces.js';
import { m as modifyCalciteInputStatus, s as sanitizeNumber, l as formatNumberToLocale, U as UIDefaults, f as isCalciteInputValidNumber, b as UIInputStatus, D as DefaultStatNumberFormat } from './chart-ui-utils.js';
import { d as deleteMinMaxAxisKey, s as state } from './store.js';
import { d as defineCustomElement$1 } from './arcgis-charts-config-field-select2.js';
import { d as debounce } from './debounce.js';
import { b as WebChartDataTransformations } from './chart-object-literals.js';

const HTMLClasses = {
    label: "label",
    text: "text",
    row: "row",
    binCountContainer: "bin-count-container",
    iconSelect: "icon-select",
    sectionLabel: "section-label",
    binTextPadding: "bin-text-padding",
    rtl: "arcgis-charts-rtl",
    histogramStatsList: "histogram-stats-list",
};

const arcgisChartsConfigHistogramDataCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}:host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}calcite-list-item{margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor)}.label{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.text{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);width:calc(100% - 1.5rem);height:2rem;margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.row{padding-top:1rem}.bin-count-container{display:flex;flex-wrap:wrap;padding:var(--arcgis-charts-config-margin-minor)}.bin-count-container>calcite-slider{flex-grow:10;min-width:50%}.bin-count-container>calcite-input{margin-bottom:0.5rem;margin-top:var(--arcgis-charts-config-margin-minor);margin-left:var(--arcgis-charts-config-margin-minor);width:5rem}.section-label{display:flex;margin:var(--arcgis-charts-config-margin-major) var(--arcgis-charts-config-margin-minor);justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}.bin-text-padding{margin-left:var(--arcgis-charts-config-margin-minor)}:host(.arcgis-charts-rtl) .text{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}:host(.arcgis-charts-rtl) .bin-count-container>calcite-input{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}:host(.arcgis-charts-rtl) .heading-text{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}:host(.arcgis-charts-rtl) .bin-text-padding{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}.histogram-stats-list{pointer-events:none;margin-bottom:var(--arcgis-charts-config-margin-minor)}";
const ArcgisChartsConfigHistogramDataStyle0 = arcgisChartsConfigHistogramDataCss;

const ArcGISChartsConfigHistogramData = /*@__PURE__*/ proxyCustomElement(class ArcGISChartsConfigHistogramData extends HTMLElement {
    constructor() {
        super();
        this.__registerHost();
        this.__attachShadow();
        this.arcgisChartsConfigHistogramDataPopoverChange = createEvent(this, "arcgisChartsConfigHistogramDataPopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        this.arcgisChartsConfigDataChangeError = createEvent(this, "arcgisChartsConfigDataChangeError", 7);
        /**
         * @category Private
         */
        this.histogramPopover = null;
        /**
         * @category Event handler
         */
        this.onBinCountChange = debounce(() => {
            const { value } = this.binInputElement;
            if (value !== undefined && isCalciteInputValidNumber(value, this.binInputElement.min, this.binInputElement.max)) {
                this.binCountChange(value);
            }
            else {
                modifyCalciteInputStatus({
                    inputElement: this.binInputElement,
                    status: UIInputStatus.INVALID,
                });
            }
        }, UIDefaults.DebounceTimer);
        /**
         * @category Event handler
         */
        this.onBinCountSliderChange = debounce(() => {
            this.binCountChange(this.binSliderElement.value?.toString() ?? "");
        }, UIDefaults.DebounceTimer);
        /**
         * @category Event handler
         */
        this.binCountChange = (value) => {
            const binCount = Number.parseInt(value);
            if (this.model.getBinCount() !== binCount) {
                this.model.setBinCount(binCount);
                modifyCalciteInputStatus({
                    inputElement: this.binInputElement,
                    status: UIInputStatus.IDLE,
                });
            }
        };
        /**
         * @category Event handler
         */
        this.onColorElementSelect = (elementColor, popoverHeading, overlaySectionElement) => {
            if (elementColor.type === RESTSymbolType.SFS) {
                this.selectedOverlaySymbol = undefined;
                this.selectedBinColorSymbol = elementColor;
                this.contentKind = HistogramDataPopoverKinds.fillSymbol;
            }
            else {
                this.selectedBinColorSymbol = undefined;
                this.selectedOverlaySymbol = elementColor;
                this.overlaySectionElement = overlaySectionElement;
                this.contentKind = HistogramDataPopoverKinds.lineSymbol;
            }
            this.popoverHeading = popoverHeading;
            this.setupPopover();
        };
        /**
         * @category Event handler
         */
        this.onNumericFieldSelect = () => {
            this.selectedNumericalField = this.model.getNumericField();
            this.contentKind = HistogramDataPopoverKinds.numericFields;
            this.setupPopover();
        };
        /**
         * @category Event handler
         */
        this.onTransformationSelect = () => {
            this.selectedTransformationType = this.model.getDataTransformationType();
            this.contentKind = HistogramDataPopoverKinds.transformation;
            this.setupPopover();
        };
        /**
         * @category Event handler
         */
        this.onBinColorSelect = () => {
            this.onColorElementSelect(this.model.getBinColor(), this.strings.binColor);
        };
        /**
         * @category Event handler
         */
        this.onNormalDistColorSelect = () => {
            this.onColorElementSelect(this.model.getNormalDistColor(), this.strings.normalDistStyle, this.normalDistOverlayElement);
        };
        /**
         * @category Event handler
         */
        this.onMeanColorSelect = () => {
            this.onColorElementSelect(this.model.getMeanColor(), this.strings.meanStyle, this.meanOverlayElement);
        };
        /**
         * @category Event handler
         */
        this.onMedianColorSelect = () => {
            this.onColorElementSelect(this.model.getMedianColor(), this.strings.medianStyle, this.medianOverlayElement);
        };
        /**
         * @category Event handler
         */
        this.onStandardDevColorSelect = () => {
            this.onColorElementSelect(this.model.getStandardDevColor(), this.strings.standardDevStyle, this.standardDevOverlayElement);
        };
        /**
         * @category Event handler
         */
        this.onBinColorChange = (e) => {
            this.model.setColorMatch(false);
            this.model.setBinColor(e.detail);
        };
        /**
         * @category Event handler
         */
        this.onMeanStyleChange = (e) => {
            this.model.setMeanColor(e.detail);
        };
        /**
         * @category Event handler
         */
        this.onMedianStyleChange = (e) => {
            this.model.setMedianColor(e.detail);
        };
        /**
         * @category Event handler
         */
        this.onStandardDevStyleChange = (e) => {
            this.model.setStandardDevColor(e.detail);
        };
        /**
         * @category Event handler
         */
        this.onNormalDistStyleChange = (e) => {
            this.model.setNormalDistColor(e.detail);
        };
        /**
         * @category Event handler
         */
        this.onShowDataLabelsChange = (e) => {
            this.model.setDataLabelsVisibility(e.target.checked);
        };
        /**
         * @category Event handler
         */
        this.onOverlayListChange = (e) => {
            const overlayList = e.target.selectedItems.map((item) => item.value);
            const hasMean = overlayList.includes(HistogramOverlays.Mean);
            const hasMedian = overlayList.includes(HistogramOverlays.Median);
            const hasStandardDev = overlayList.includes(HistogramOverlays.StandardDev);
            const hasNormalDist = overlayList.includes(HistogramOverlays.NormalDist);
            if (this.meanOverlayVisible !== hasMean) {
                this.model.setShowMeanOverlay(hasMean);
                this.meanOverlayVisible = hasMean;
            }
            if (this.medianOverlayVisible !== hasMedian) {
                this.model.setShowMedianOverlay(hasMedian);
                this.medianOverlayVisible = hasMedian;
            }
            if (this.standardDevOverlayVisible !== hasStandardDev) {
                this.model.setShowStandardDevOverlay(hasStandardDev);
                this.standardDevOverlayVisible = hasStandardDev;
            }
            if (this.normalDistOverlayVisible !== hasNormalDist) {
                this.model.setShowNormalDistOverlay(hasNormalDist);
                this.normalDistOverlayVisible = hasNormalDist;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Emit event on open popover.
         * @param e
         * @category Private
         */
        this.openChange = (e) => {
            this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
        };
        /**
         * @category Event handler
         */
        this.updateProps = async (e) => {
            try {
                if (e.detail !== null && e.detail !== undefined) {
                    const { contentKind } = e.detail;
                    const { value } = e.detail;
                    // reset axes bounds for this chart in stencil store
                    deleteMinMaxAxisKey(state);
                    switch (contentKind) {
                        case HistogramDataPopoverKinds.transformation:
                            this.model.setDataTransformationType(value ?? WebChartDataTransformations.None);
                            break;
                        case HistogramDataPopoverKinds.numericFields:
                            await this.model.setNumericField(value ?? "");
                            break;
                    }
                }
            }
            catch (error) {
                this.arcgisChartsConfigDataChangeError.emit({ error, model: this.model });
                throw error;
            }
            this.removeHistogramDataPopover();
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Event handler
         */
        this.updateSymbolProps = (e) => {
            if (this.selectedBinColorSymbol !== undefined) {
                this.onBinColorChange(e);
            }
            else {
                switch (this.selectedOverlayKind) {
                    case HistogramOverlays.Mean:
                        this.onMeanStyleChange(e);
                        break;
                    case HistogramOverlays.Median:
                        this.onMedianStyleChange(e);
                        break;
                    case HistogramOverlays.StandardDev:
                        this.onStandardDevStyleChange(e);
                        break;
                    case HistogramOverlays.NormalDist:
                        this.onNormalDistStyleChange(e);
                        break;
                }
            }
        };
        /**
         * @category Private
         */
        this.popoverClose = () => {
            this.selectedOverlaySymbol = undefined;
            this.selectedBinColorSymbol = undefined;
            this.selectedNumericalField = undefined;
            this.selectedTransformationType = undefined;
        };
        this.model = undefined;
        this.meanValue = undefined;
        this.medianValue = undefined;
        this.standardDevValue = undefined;
        this.minValue = undefined;
        this.maxValue = undefined;
        this.sumValue = undefined;
        this.nullsValue = undefined;
        this.countValue = undefined;
        this.layerFieldsInfo = undefined;
        this.open = true;
        this.selectedBinColorSymbol = undefined;
        this.selectedOverlaySymbol = undefined;
        this.selectedNumericalField = undefined;
        this.selectedTransformationType = undefined;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removeHistogramDataPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await Mn(this.hostElement, getAssetPath(`.`)));
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * Removing the popover whenever disconnected.
     * @category Private
     */
    removeHistogramDataPopover() {
        if (this.histogramPopover !== null) {
            this.histogramPopover.open = false;
            this.histogramPopover = Jy(this.histogramPopover);
        }
        this.histogramPopoverChange(false);
    }
    /**
     * @param field
     * @category Render UX
     */
    renderFieldSelect() {
        return (h("arcgis-charts-config-field-select", { label: Tl(this.layerFieldsInfo, this.model.getNumericField()), ref: (e) => {
                this.numericalFieldSelectionElement = e;
            }, onClick: this.onNumericFieldSelect }));
    }
    /**
     * @category Render UX
     */
    renderDataTransformationType() {
        return (h("arcgis-charts-config-field-select", { label: this.getDataTransformationLabel(), ref: (e) => {
                this.transformationSelectionElement = e;
            }, onClick: this.onTransformationSelect }));
    }
    /**
     * @category Private
     */
    getDataTransformationLabel() {
        let label;
        switch (this.model.getDataTransformationType()) {
            case WebChartDataTransformations.None:
                label = this.strings.none;
                break;
            case WebChartDataTransformations.Log:
                label = this.strings.log;
                break;
            case WebChartDataTransformations.Sqrt:
                label = this.strings.sqRt;
                break;
            default:
                label = this.strings.none;
                break;
        }
        return label;
    }
    /**
     * @param props
     * @category Render UX
     */
    // TODO: to see for better pattern to move TSX based utility methods.
    renderColorListItem(props) {
        const { textLabel, key, value, selected, ref, colorAction, color } = props;
        const [r, g, b, a] = [...(color ?? oo())];
        return (h("calcite-list-item", { label: textLabel ?? "", key: key, value: value, selected: selected, ref: ref ?? undefined }, h("calcite-action", { text: "color", slot: "actions-end", appearance: "transparent", onClick: colorAction }, h("calcite-icon", { icon: "line-solid", style: r !== undefined ? { color: `rgba(${r},${g},${b},${(a ?? 0) / 255})` } : {} }))));
    }
    /**
     * @category Render UX
     */
    renderBinColorElement() {
        const [r, g, b, a] = [...(this.model.getBinColor()?.color ?? no(0))];
        return (h("calcite-list", { label: "", selectionMode: "single", selectionAppearance: "border" }, h("calcite-list-item", { label: this.strings.binColor, value: "selectTrendLine", ref: (e) => {
                this.binColorSectionElement = e;
            }, onClick: this.onBinColorSelect }, h("calcite-icon", { slot: "content-end", icon: "square-f", style: { color: `rgba(${r},${g},${b},${a / 255})` }, class: HTMLClasses.iconSelect }))));
    }
    /**
     * @category Render UX
     */
    renderNormalDistOverlay() {
        this.normalDistOverlayVisible = this.model.getShowNormalDistOverlay();
        return this.renderColorListItem({
            textLabel: this.strings.normalDist,
            color: this.model.getNormalDistColor()?.color,
            key: HistogramOverlays.NormalDist,
            value: HistogramOverlays.NormalDist,
            selected: this.model.getShowNormalDistOverlay(),
            ref: (e) => {
                this.normalDistOverlayElement = e;
            },
            colorAction: this.onNormalDistColorSelect,
        });
    }
    /**
     * @category Render UX
     */
    renderMeanOverlay() {
        this.meanOverlayVisible = this.model.getShowMeanOverlay();
        return this.renderColorListItem({
            textLabel: this.strings.mean,
            textDescription: this.meanValue,
            color: this.model.getMeanColor()?.color,
            key: HistogramOverlays.Mean,
            value: HistogramOverlays.Mean,
            selected: this.model.getShowMeanOverlay(),
            ref: (e) => {
                this.meanOverlayElement = e;
            },
            colorAction: this.onMeanColorSelect,
        });
    }
    /**
     * @category Render UX
     */
    renderStandardDevOverlay() {
        this.standardDevOverlayVisible = this.model.getShowStandardDevOverlay();
        return this.renderColorListItem({
            textLabel: this.strings.standardDev,
            textDescription: this.standardDevValue,
            color: this.model.getStandardDevColor()?.color,
            key: HistogramOverlays.StandardDev,
            value: HistogramOverlays.StandardDev,
            selected: this.model.getShowStandardDevOverlay(),
            ref: (e) => {
                this.standardDevOverlayElement = e;
            },
            colorAction: this.onStandardDevColorSelect,
        });
    }
    /**
     * @category Render UX
     */
    renderMedianOverlay() {
        this.medianOverlayVisible = this.model.getShowMedianOverlay();
        return this.renderColorListItem({
            textLabel: this.strings.median,
            textDescription: this.medianValue,
            color: this.model.getMedianColor()?.color,
            key: HistogramOverlays.Median,
            value: HistogramOverlays.Median,
            selected: this.model.getShowMedianOverlay(),
            ref: (e) => {
                this.medianOverlayElement = e;
            },
            colorAction: this.onMedianColorSelect,
        });
    }
    /**
     * @category Render UX
     */
    renderOverlayList() {
        return (h("calcite-list", { label: "", selectionMode: "multiple", onCalciteListChange: this.onOverlayListChange }, this.renderNormalDistOverlay(), this.renderMeanOverlay(), this.renderMedianOverlay(), this.renderStandardDevOverlay()));
    }
    /**
     * @param statName
     * @category Render UX
     */
    renderStatItem(statName) {
        return (h("calcite-list-item", { label: this.strings[statName], description: this.getStatValue(statName), key: statName, value: statName }));
    }
    /**
     * @category Render UX
     */
    renderStats() {
        const otherStats = Object.values(HistogramStatistics);
        return (h("calcite-list", { label: "", class: HTMLClasses.histogramStatsList }, otherStats.map((value) => this.renderStatItem(value))));
    }
    /**
     * @category Render UX
     */
    renderShowDataLabels() {
        return (h("div", { class: HTMLClasses.row }, h("calcite-label", { class: HTMLClasses.label, layout: "inline-space-between" }, this.strings.showDataLabels, h("calcite-switch", { checked: this.model.getDataLabelsVisibility(), onCalciteSwitchChange: this.onShowDataLabelsChange }))));
    }
    /**
     * @category Render UX
     */
    renderBinsSection() {
        return (h("div", { class: HTMLClasses.binCountContainer }, h("calcite-slider", { labelHandles: true, min: 1, max: 64, step: 1, snap: true, value: this.model.getBinCount(), ref: (e) => {
                this.binSliderElement = e;
            }, onCalciteSliderChange: this.onBinCountSliderChange }), h("calcite-input", { type: "number", min: 1, max: 64, step: 1, value: sanitizeNumber(this.model.getBinCount()), onCalciteInputInput: this.onBinCountChange, ref: (e) => {
                this.binInputElement = e;
            } })));
    }
    /**
     * @category Lifecycle
     */
    render() {
        const fieldSelectUI = this.renderFieldSelect();
        const transformationUI = this.renderDataTransformationType();
        return (h(Host, { key: '437ac8257c7316b1a29f8bb2ffb91311c7a1a42b', class: { [HTMLClasses.rtl]: this.direction === "rtl" } }, h("div", { key: '0c5c164d9362be063d5533b925e4cf69b8e69f28', class: HTMLClasses.sectionLabel }, this.strings.variables), h("calcite-label", { key: '8ee73ae612e7e52d03d2afaf839c701e36febbad', class: HTMLClasses.label }, this.strings.number, fieldSelectUI), h("calcite-label", { key: '07fd6197abe0dbbb3ef43808a12cef53b49d078c', class: HTMLClasses.label }, this.strings.withTransformation, transformationUI), h("div", { key: 'c6bd23a4f4a24143f94fa5f668d1d5d8a09c942b', class: HTMLClasses.sectionLabel }, this.strings.bins), h("p", { key: '058f0ea15093c1c2d8ae07c633ac3401cb7de01d', class: HTMLClasses.binTextPadding }, this.strings.numberOfBins), this.renderBinsSection(), this.renderBinColorElement(), h("div", { key: 'd48ec21d02b4c6a89ecb088191b0e4634078fcc6', class: HTMLClasses.sectionLabel }, this.strings.overlays), this.renderOverlayList(), this.renderShowDataLabels(), h("div", { key: 'bb7cd7facaf52137b6104a9065ac0597d17c2535', class: HTMLClasses.sectionLabel }, this.strings.statistics), this.renderStats()));
    }
    /**
     * @param statName
     * @category Private
     */
    getStatValue(statName) {
        let statValue;
        switch (statName) {
            case HistogramStatistics.Min:
                statValue = this.minValue;
                break;
            case HistogramStatistics.Max:
                statValue = this.maxValue;
                break;
            case HistogramStatistics.Sum:
                statValue = this.sumValue;
                break;
            case HistogramStatistics.Nulls:
                statValue = this.nullsValue;
                break;
            case HistogramStatistics.Count:
                // Inferring this stat from the stats Count and Nulls
                statValue = this.countValue + this.nullsValue;
                break;
            case HistogramStatistics.CountExcludingNulls:
                statValue = this.countValue;
                break;
            case HistogramStatistics.Mean:
                statValue = this.meanValue;
                break;
            case HistogramStatistics.Median:
                statValue = this.medianValue;
                break;
            case HistogramStatistics.StandardDev:
                statValue = this.standardDevValue;
                break;
            default:
                statValue = undefined;
                break;
        }
        statValue = formatNumberToLocale(statValue, DefaultStatNumberFormat);
        return statValue;
    }
    /**
     * @category Private
     */
    histogramPopoverChange(open) {
        this.arcgisChartsConfigHistogramDataPopoverChange.emit({
            open,
            element: this.histogramPopover,
        });
    }
    /**
     * @category Private
     */
    // Popover related functions
    // TODO: Move these and other popover functions to common utility methods
    setupPopover() {
        // remove already existing chart popover
        // TODO: this is a hotfix for https://devtopia.esri.com/webgis/arcgis-charts/issues/5366
        // have to find a better way to do this
        this.removeHistogramDataPopover();
        // histogramPopover config
        const popoverConfig = {
            layerFieldsInfo: this.layerFieldsInfo,
            updateProps: this.updateProps,
            updateSymbolProps: this.updateSymbolProps,
            popoverClose: this.popoverClose,
            openChange: this.openChange,
        };
        // create a histogramPopover
        this.histogramPopover = Zy(Qy.HistogramDataPopover, popoverConfig);
        if (this.histogramPopover !== undefined && this.histogramPopover !== null) {
            switch (this.contentKind) {
                case HistogramDataPopoverKinds.transformation:
                    this.histogramPopover.selectedTransformationType = this.selectedTransformationType;
                    this.histogramPopover.referenceElement = this.transformationSelectionElement;
                    this.histogramPopover.placement = "trailing";
                    this.histogramPopover.selectedBinColor = undefined;
                    this.histogramPopover.selectedOverlaySymbol = undefined;
                    this.histogramPopover.selectedNumericField = undefined;
                    break;
                case HistogramDataPopoverKinds.numericFields:
                    this.histogramPopover.selectedNumericField = this.selectedNumericalField;
                    this.histogramPopover.referenceElement = this.numericalFieldSelectionElement;
                    this.histogramPopover.placement = "trailing";
                    this.histogramPopover.selectedBinColor = undefined;
                    this.histogramPopover.selectedOverlaySymbol = undefined;
                    this.histogramPopover.selectedTransformationType = undefined;
                    break;
                case HistogramDataPopoverKinds.fillSymbol:
                    this.histogramPopover.referenceElement = this.binColorSectionElement;
                    this.histogramPopover.selectedBinColor = this.selectedBinColorSymbol;
                    this.histogramPopover.headingTitle = this.popoverHeading;
                    this.histogramPopover.placement = "leading";
                    this.histogramPopover.selectedOverlaySymbol = undefined;
                    this.histogramPopover.selectedTransformationType = undefined;
                    this.histogramPopover.selectedNumericField = undefined;
                    break;
                case HistogramDataPopoverKinds.lineSymbol:
                    this.selectedOverlayKind = this.overlaySectionElement.value;
                    this.histogramPopover.referenceElement = this.overlaySectionElement;
                    this.histogramPopover.selectedOverlaySymbol = this.selectedOverlaySymbol;
                    this.histogramPopover.headingTitle = this.popoverHeading;
                    this.histogramPopover.placement = "leading";
                    this.histogramPopover.selectedBinColor = undefined;
                    this.histogramPopover.selectedTransformationType = undefined;
                    this.histogramPopover.selectedNumericField = undefined;
                    break;
            }
            this.histogramPopover.contentKind = this.contentKind;
            this.histogramPopover.open = true;
            this.addPopover();
        }
    }
    /**
     * @category Private
     */
    addPopover() {
        if (this.histogramPopover !== undefined && this.histogramPopover !== null) {
            if (!document.body.contains(this.histogramPopover)) {
                document.body.appendChild(this.histogramPopover);
            }
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return this; }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
    static get style() { return ArcgisChartsConfigHistogramDataStyle0; }
}, [1, "arcgis-charts-config-histogram-data", {
        "model": [16],
        "meanValue": [2, "mean-value"],
        "medianValue": [2, "median-value"],
        "standardDevValue": [2, "standard-dev-value"],
        "minValue": [2, "min-value"],
        "maxValue": [2, "max-value"],
        "sumValue": [2, "sum-value"],
        "nullsValue": [2, "nulls-value"],
        "countValue": [2, "count-value"],
        "layerFieldsInfo": [16],
        "open": [516],
        "selectedBinColorSymbol": [32],
        "selectedOverlaySymbol": [32],
        "selectedNumericalField": [32],
        "selectedTransformationType": [32],
        "updatesOccurred": [32]
    }, undefined, {
        "model": ["modelChange"]
    }]);
function defineCustomElement() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = ["arcgis-charts-config-histogram-data", "arcgis-charts-config-field-select"];
    components.forEach(tagName => { switch (tagName) {
        case "arcgis-charts-config-histogram-data":
            if (!customElements.get(tagName)) {
                customElements.define(tagName, ArcGISChartsConfigHistogramData);
            }
            break;
        case "arcgis-charts-config-field-select":
            if (!customElements.get(tagName)) {
                defineCustomElement$1();
            }
            break;
    } });
}
defineCustomElement();

export { ArcGISChartsConfigHistogramData as A, defineCustomElement as d };
