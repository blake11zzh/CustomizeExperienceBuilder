import type { AxisLabelFormatCallback, ChartOptions, GaugeInnerLabelFormatCallback, GuideTooltipFormatCallback, MessageOptions, NotifyOptions, PieChartLegendValueLabelFormatCallback, PreRenderCallback } from "@arcgis/charts-js";
import type { ChartModel } from "@arcgis/charts-model";
import type { ActionModes, ChartElementLimit, CursorRange, DataWarningObject, PieSlicesSymbols, SelectionData, SelectionTheme, SeriesSymbolsMap, ValidationStatus } from "@arcgis/charts-shared-utils";
import { ErrorPolicy, LayerFieldsChangePolicy, LayerFilterChangePolicy, LayerRendererChangePolicy } from "@arcgis/charts-shared-utils";
import type { CalculatedMinMaxBoundsPayload, LegendItemVisibility, SupportedLayer, WebChartDataFilters, WebChartDataTypes, WebChartLegendPositions, WebMapWebChart } from "@arcgis/charts-spec";
import type MapView from "@arcgis/core/views/MapView";
import type SceneView from "@arcgis/core/views/SceneView";
import type FeatureLayerView from "@arcgis/core/views/layers/FeatureLayerView";
import type { EventEmitter } from "../../stencil-public-runtime";
import type { AxesMinMaxChangePayload, DataProcessCompletePayload, LegendItemVisibilityChangePayload, NoRenderPropChangePayload, SelectionCompletePayload, SeriesColorChangePayload } from "../../utils/event-payloads";
import type { MissingSplitBySeriesProps, WebChartComponentVersion } from "../../utils/interfaces";
/**
 * @slot action-bar - A slot for adding charts-action-bar component or calcite-action-bar.
 */
export declare class ArcGISChart {
    /**
     * A reference to the DOM node inside which chart is created
     * @type {HTMLDivElement | undefined}
     * @category Private
     */
    private chartRef?;
    /**
     * The instance of the rendered chart
     * @type {ChartInstance | undefined}
     * @category Private
     */
    private chart?;
    /**
     * Internal chart model in case the user only provides a config to the public model prop.
     * @type {ChartModel | undefined}
     * @category Private
     */
    private _model?;
    /**
     * The bar chart HTML element.
     * @type {HTMLArcgisChartElement}
     * @element
     */
    el: HTMLArcgisChartElement;
    /**
     * Whether to use the stable version of the component or the beta's.
     * @type {WebChartComponentVersion}
     * @category Public
     * @default "stable"
     */
    componentVersion: WebChartComponentVersion;
    /**
     * Instance of an ArcGIS Chart Model. Provides an API to interact with the chart's configuration.
     *
     * **Note:** This property has a union type of `ChartModel | WebMapWebChart` meaning a raw chart config object can be passed to it instead, however it is recommended to use a `ChartModel` instance whenever possible.
     *
     * @type {ChartModel | WebMapWebChart | undefined}
     * @default undefined
     */
    model: ChartModel | WebMapWebChart | undefined;
    /**
     * Whether to use features uniquely designed for a chart currently being configured by a user via the UI.
     * @type {boolean}
     * @category Public
     * @default false
     */
    enableConfiguration: boolean;
    /**
     * Whether to synchronize the selection between chart components from the same layer.
     * @type {boolean}
     * @category Public
     * @default false
     */
    syncSelection: boolean;
    /**
     * Helps identifying an update triggered after a view extent change.
     * This is used to support a selection workflow while the filter by extent mode is enabled.
     * @type {boolean | undefined}
     * @category Private
     * @default undefined
     */
    private viewExtentUpdated?;
    /**
     * Applicable to bar chart, line chart, combo bar-line and box plot.
     * When `true`, the chart is rotated 90 degrees so that the x-axis becomes vertical and the y-axis becomes horizontal.
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    rotation?: boolean;
    /**
     * Not applicable to gauge.
     * Defines the cursor behavior on the chart (zoom, selection...).
     * @type {ActionModes | undefined}
     * @category Public
     * @default undefined
     */
    actionMode?: ActionModes;
    /**
     * Sets the cursor range:
     * - CursorRange.MultiAxes: allows to draw a free rectangle
     * - CursorRange.XAxis: allows to draw a rectangle bound to the x-axis
     * - CursorRange.YAxis: allows to draw a rectangle bound to the y-axis
     * - undefined: defaults to a preset behavior according to the chart type and action mode
     *
     * @remarks
     * Not applicable to gauge.
     * Applies only when the action mode is set to zoom or multi-selection.
     *
     * @type {CursorRange | undefined}
     * @category Public
     * @default undefined
     */
    cursorRange?: CursorRange;
    /**
     * Used to set the legend's position on the chart.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {WebChartLegendPositions | undefined}
     * @category Public
     * @default undefined
     */
    legendPosition?: WebChartLegendPositions;
    /**
     * When `true`, the legend is visible on the chart.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    legendVisibility?: boolean;
    /**
     * When `true`, the empty series are completely hidden from the chart and the legend.
     * For example a series can be empty after applying a data filter, filter by attribute or geometry (as when using the filter by extent).
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    hideEmptySeries?: boolean;
    /**
     * When `true`, the chart's dataItems associated with empty (no value) categories (from only a `Count` aggregation)
     * will be pouplated with 0s, via the `completeDataForEmptyCategoriesWithZeros` method.
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    replaceNoValueCategoryWithZero?: boolean;
    /**
     * When `true`, disables the default setting that uses debounce functions to handle the visibility of markers
     * that are outside of the plotting area when the min/max bound changes and/or when a zoom action is performed
     * (via chart cursor or scrollbar), to increase performance.
     * This property will be set when the chart is created and cannot be updated after that.
     * It's recommended that this property should only be set to true for small datasets.
     * When left `undefined`, will be treated as `false`.
     *
     * @remarks
     * Applicable to line chart only.
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    ignoreSmoothRenderingLimit?: boolean;
    /**
     * Lifecycle function executed after the data has been processed and before the chart renders.
     * Can be used to alter the config from information extracted from the data for instance.
     *
     * @remarks
     * Applicable to gauge and pie chart only.
     *
     * @type {PreRenderCallback | undefined}
     * @category Public
     * @default undefined
     */
    chartWillRender?: PreRenderCallback;
    /**
     * A callback function used to format the legend value labels. If the returned string contains HTML tags they will be
     * interpreted as such.
     * If provided, the formatter will be used if at least `WebChartPieChartLegend.displayNumericValue` or `WebChartPieChartLegend.displayPercentage` is true.
     *
     * @remarks
     * Applicable to pie chart only.
     *
     * @type {PieChartLegendValueLabelFormatCallback | undefined}
     * @category Public
     * @default undefined
     */
    legendValueLabelFormatter?: PieChartLegendValueLabelFormatCallback;
    /**
     * Used to set a custom time zone for the chart.
     * @type {MapView["timeZone"] | undefined}
     * @category Public
     * @default undefined
     */
    timeZone?: MapView["timeZone"];
    /**
     * Used to access the LayerView instance in order to perform client-side queries.
     * @type {MapView | SceneView | undefined}
     * @category Public
     * @default undefined
     */
    view?: MapView | SceneView;
    /**
     * Used to perform queries.
     * If the layer is a FeatureLayerView or if the layer and the `view` property are both provided, the queries will be executed client-side.
     * @type {SupportedLayer | FeatureLayerView | undefined}
     * @category Public
     * @default undefined
     */
    layer?: FeatureLayerView | SupportedLayer;
    /**
     * When this property is set, it will apply a selection on the chart matching the provided selection.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {SelectionData | undefined}
     * @category Public
     * @default undefined
     */
    selectionData?: SelectionData;
    /**
     * When `true`, the object ids will be computed whenever a selection is made on or passed to the chart.
     * Only considered for a data source using a feature layer.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    returnSelectionOIDs?: boolean;
    /**
     * When `true`, the selection indexes will be computed whenever a selection is made on or passed to the chart.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    returnSelectionIndexes?: boolean;
    /**
     * When `true`, the features extent will be returned through the `arcgisDataProcessComplete` and `arcgisSelectionComplete` events payload.
     * Applies only to:
     * - charts using an aggregation
     * - data source using a feature layer compatible with envelope aggregation
     * The extent (IExtent) is returned through a property called `arcgis_charts_features_extent`.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    returnFeaturesExtent?: boolean;
    /**
     * When `true`, all chart elements are filtered based on selection.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    filterBySelection?: boolean;
    /**
     * When `true`, all chart elements are filtered based on view extent.
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    filterByExtent?: boolean;
    /**
     * Disables all interactions on the chart.
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    disableInteractions?: boolean;
    /**
     * Builds the charts one by one rather than all at the same time.
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    queueChartCreation?: boolean;
    /**
     * Enables the animations on the chart.
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    useAnimatedCharts?: boolean;
    /**
     * Hides the license watermark.
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    hideLicenseWatermark?: boolean;
    /**
     * Enables the responsive features.
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    enableResponsiveFeatures?: boolean;
    /**
     * Auto-disposes the chart when a new one is created in the same container.
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    autoDisposeChart?: boolean;
    /**
     * The index of the feature to be rendered.
     * Only used when the gauge is a feature-based gauge.
     *
     * @remarks
     * Applicable to gauge only.
     *
     * @type {number | undefined}
     * @category Public
     * @default undefined
     */
    featureIndex?: number;
    /**
     * A placeholder string to provides a brief hint to the user indicating needed information for creating a chart.
     * @type {string | undefined}
     * @category Public
     * @default undefined
     */
    placeholder?: string;
    /**
     * Used to provide a customized theme for the selected and non selected elements.
     * If no style is provided for the selected elements, a default selection is applied.
     * If no style is provided for the non selected elements, the chart's style is applied.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {SelectionTheme | undefined}
     * @category Public
     * @default undefined
     */
    selectionTheme?: SelectionTheme;
    /**
     * When `true`, the series properties `timeIntervalUnits` and `timeIntervalSize` become optional and will be automatically set to values that fit the data set. Used when creating or updating a chart compatible with time binning.
     *
     * @remarks
     * Only applicable to charts using the temporal binning feature (bar and line chart).
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    setTimeBinningInfoWhenNotProvided?: boolean;
    /**
     * Used to customize the number maximum of bars allowed on the chart.
     * The chart's behavior once that limit is reached can be adjusted through the `behaviorAfterLimit` nested property, to either reject the creation
     * or update of the chart, or render the elements up to the given limits.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {ChartElementLimit | undefined}
     * @category Public
     * @default undefined
     */
    chartLimits?: ChartElementLimit;
    /**
     * A callback function used to format the tooltips. If the returned string contains HTML tags they will be interpreted as such.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {BarAndLineTooltipFormatCallback | undefined}
     * @category Public
     * @default undefined
     */
    tooltipFormatter?: ChartOptions["tooltipFormatter"];
    /**
     * A callback function used to format the data labels. If the returned string contains HTML tags they will be interpreted as such.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @type {BarAndLineDataLabelFormatCallback | undefined}
     * @category Public
     * @default undefined
     */
    dataLabelFormatter?: ChartOptions["dataLabelFormatter"];
    /**
     * A callback function used to format the axes guides tooltip. If the returned string contains HTML tags they will be interpreted as such.
     *
     * @remarks
     * Not applicable to pie chart.
     *
     * @type {GuideTooltipFormatCallback | undefined}
     * @category Public
     * @default undefined
     */
    guideTooltipFormatter?: GuideTooltipFormatCallback;
    /**
     * Indicates whether to show the ArcGIS charts notify panel. False by default
     * A callback function used to format the x-axis labels. If the returned string contains HTML tags they will be interpreted as such.
     *
     * @remarks
     * Not applicable to pie chart.
     *
     * @type {AxisLabelFormatCallback | undefined}
     * @category Public
     * @default undefined
     */
    xAxisLabelFormatter?: AxisLabelFormatCallback;
    /**
     * A callback function used to format the y-axis labels. If the returned string contains HTML tags they will be interpreted as such.
     *
     * @remarks
     * Not applicable to pie chart nor gauge.
     *
     * @type {AxisLabelFormatCallback | undefined}
     * @category Public
     * @default undefined
     */
    yAxisLabelFormatter?: AxisLabelFormatCallback;
    /**
     * A callback function used to format the secondary y-axis labels. If the returned string contains HTML tags they will be interpreted as such.
     * The property will be effective only if 3 axes are defined (dual axis chart).
     *
     * @remarks
     * Not applicable to pie chart nor gauge.
     *
     * @type {AxisLabelFormatCallback | undefined}
     * @category Public
     * @default undefined
     */
    secondaryYAxisLabelFormatter?: AxisLabelFormatCallback;
    /**
     * A callback function used to format the gauge inner label. If the returned string contains HTML tags they will be
     * interpreted as such.
     *
     * @remarks
     * Applicable to gauge only.
     *
     * @type {GaugeInnerLabelFormatCallback | undefined}
     * @category Public
     * @default undefined
     */
    gaugeInnerLabelFormatter?: GaugeInnerLabelFormatCallback;
    /**
     * Used to set the options available to handle specific messages displayed by the chart.
     * @type {MessageOptions | undefined}
     * @category Public
     * @default undefined
     */
    messageOptions?: MessageOptions;
    /**
     * Whether to display an error alert and hide the chart when it can't be created or updated.
     * @type {ErrorPolicy}
     * @default "throw"
     */
    errorPolicy: ErrorPolicy;
    /**
     * Disables the toggling of series via the legend items.
     *
     * @remarks
     * Only applicable to multi-series charts.
     *
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    disableTogglingLegendItems?: boolean;
    /**
     * Hides the loader animation (curtain and spinner), showed by default at every update.
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    hideLoaderAnimation?: boolean;
    /**
     * Applies runtime data filters to the chart's.
     * @type {WebChartDataFilters | undefined}
     * @category Public
     * @default undefined
     */
    runtimeDataFilters?: WebChartDataFilters;
    /**
     * Allows the use of the fields alias from the layer.popupTemplate when rendering the field names on the chart (e.g. tooltips, axes, legend).
     * @type {boolean | undefined}
     * @category Public
     * @default undefined
     */
    usePopupTemplateFieldsInfo?: boolean;
    /**
     * Whether the chart should be refreshed when the layer's filter (`definitionExpression`) changes.
     * @type {LayerFilterChangePolicy}
     * @category Public
     * @default "refresh"
     */
    layerFilterChangePolicy: LayerFilterChangePolicy;
    /**
     * Allows the chart to update automatically when the layer's renderer changes.
     * Applies when the color match feature is enabled.
     *
     * @remarks
     * Even though that property is set to Ignore the chart will use the layer's renderer information when the data is updated.
     *
     * @type {LayerRendererChangePolicy}
     * @category Public
     * @default "refresh"
     */
    layerRendererChangePolicy: LayerRendererChangePolicy;
    /**
     * Allows the chart to update automatically when the layer's fields change.
     * Applies when the field list (`fields`) in the feature layer is updated.
     *
     * @type {LayerFieldsChangePolicy}
     * @category Public
     * @default "refresh"
     */
    layerFieldsChangePolicy: LayerFieldsChangePolicy;
    /**
     * This property will be effective when the component's `view` is provided or when the `layer` is set to a FeatureLayerView.
     * By default the queries made by the chart will consider the view's extent as the unique geometry filter applicable. This implies ignoring any
     * geometry passed through the config (component.config.dataFilters) or the runtime filters (component.runtimeDataFilters).
     * Setting this property to `false` signals the queries to ignore the view's extent, whether an additional geometry filter is provided or not.
     * @type boolean
     * @category Public
     * @default false
     */
    ignoreViewExtent: boolean;
    /**
     * Whether to update the series when the data updates while the chart uses a split-by field configuration.
     * If `addMissingSeries` is set to `true` the missing series will be added to cover the split-by values not referenced
     * by the config.
     * The default information from the property `updateSplitBySeries.seriesTemplate` will be applied to the new series.
     *
     * @remarks
     * Only applicable to bar chart, line chart and box plot, when they use a split-by field.
     *
     * @type {MissingSplitBySeriesProps | undefined}
     * @category Public
     * @default undefined
     */
    updateSplitBySeries?: MissingSplitBySeriesProps;
    /**
     * Shows the notify panel to display any sort of information.
     * @type {boolean}
     * @category Private
     * @default false
     */
    private showNotifyPanel;
    /**
     * ArcGIS Chart Specification that defines the chart component
     * @type {WebMapWebChart | undefined}
     * @category Private
     * @default undefined
     */
    private config?;
    /**
     * Skips the next update.
     * @type {boolean}
     * @category Private
     * @default false
     */
    private skipNextUpdate;
    /**
     * Hold the processing state of the chart
     * @type {Promise<ChartInstance> | undefined}
     * @category Private
     */
    private chartCreationProcessing?;
    /**
     * The heading text for the chart's notify panel.
     * @type {string | undefined}
     * @category Private
     */
    private notifyHeading?;
    /**
     * The message text for the chart's notify panel.
     * @type {string | undefined}
     * @category Private
     */
    private notifyMessage?;
    /**
     * The optional parameters for the chart's notify panel.
     * @type {PanelOptions | undefined}
     * @category Private
     */
    private notifyOptions?;
    /**
     * Localized common strings
     * @type {CommonStrings}
     * @category Private
     */
    private commonStrings;
    /**
     * Localized error strings
     * @type {ErrorStrings}
     * @category Private
     */
    private errorStrings;
    /**
     * List of props which should not trigger a render when changed
     * @type {string[]}
     * @category Private
     */
    private noRenderProps;
    /**
     * List of props which should trigger a data update
     * @type {string[]}
     * @category Private
     */
    private dataUpdateNeededProps;
    /**
     * List of all the properties updated since the last update. Useful when multiple properties are updated
     * within the same time frame, while some of them require some extra logic to be applied.
     * @type {Set<string>}
     * @category Private
     */
    private updatedProps;
    /**
     * Listener on the layer's definition expression
     * @type {IHandle | undefined}
     * @category Private
     */
    private layerFilterListener;
    /**
     * Listener on the layer's renderer
     * @type {IHandle | undefined}
     * @category Private
     */
    private layerRendererListener;
    /**
     * Listener on the layer's fields
     * @type {IHandle | undefined}
     * @category Private
     */
    private layerFieldsListener;
    /**
     * Listeners used to update the chart's data when the view's extent changes
     * @type {IHandle[] | undefined}
     * @category Private
     */
    private extentChangeListeners;
    /**
     * Function in charge of calling for a chart update.
     * @type {queueAsPromised<void, void>}
     * @category Private
     */
    private debouncedChartUpdate;
    /**
     * The action bar element.
     * @type {HTMLArcgisChartsActionBarElement | undefined}
     * @category Private
     */
    private actionBarElement;
    /**
     * The last model function that was called.
     * @type {string | undefined}
     * @category Private
     */
    private lastModelFunctionCalled;
    /**
     * Event triggered when an error occurred that prevents the chart from being created or updated
     * @type {EventEmitter}
     * @event
     */
    arcgisRuntimeError: EventEmitter;
    /**
     * Event triggered when an error occurred while fetching of processing the data for the chart
     * @type {EventEmitter}
     * @event
     */
    arcgisDataProcessError: EventEmitter;
    /**
     * Event triggered once the chart data has been processed
     * @type {EventEmitter<DataProcessCompletePayload>}
     * @event
     */
    arcgisDataProcessComplete: EventEmitter<DataProcessCompletePayload>;
    /**
     * Event triggered once the chart data has been fetched but not yet fully processed.
     * For instance it can be useful for a pie chart to see all the slices before they get grouped into an 'other' slice during the post-processing step.
     * @type {EventEmitter<WebChartDataTypes>}
     * @event
     */
    arcgisDataFetchComplete: EventEmitter<WebChartDataTypes>;
    /**
     * Event triggered once a legend item visibility has been changed
     * @type {EventEmitter<LegendItemVisibilityChangePayload>}
     * @event
     */
    arcgisLegendItemVisibilityChange: EventEmitter<LegendItemVisibilityChangePayload>;
    /**
     * Event triggered once the chart is updated
     * @type {EventEmitter<ValidationStatus>}
     * @event
     */
    arcgisUpdateComplete: EventEmitter<ValidationStatus>;
    /**
     * Event triggered when an error is detected with the data set
     * @type {EventEmitter<DataWarningObject>}
     * @event
     */
    arcgisBadDataWarningRaise: EventEmitter<DataWarningObject>;
    /**
     * Event triggered once the chart series color have been assigned
     * @type {EventEmitter<SeriesColorChangePayload>}
     * @event
     */
    arcgisSeriesColorChange: EventEmitter<SeriesColorChangePayload>;
    /**
     * Event triggered once the chart axes min/max values are computed
     * @type {EventEmitter<AxesMinMaxChangePayload>}
     * @event
     */
    arcgisAxesMinMaxChange: EventEmitter<AxesMinMaxChangePayload>;
    /**
     * Event triggered when a selection is applied to the chart
     * @type {EventEmitter<SelectionCompletePayload>}
     * @event
     */
    arcgisSelectionComplete: EventEmitter<SelectionCompletePayload>;
    /**
     * Event triggered when a no-render prop is changed
     * @type {EventEmitter<NoRenderPropChangePayload>}
     * @event
     */
    arcgisNoRenderPropChange: EventEmitter<NoRenderPropChangePayload>;
    /**
     * Event carrying the series id as they have been sorted following the `orderOptions` instructions
     * @event
     */
    arcgisSeriesOrder: EventEmitter<string[]>;
    /**
     * Event triggered when the chart config is changed
     * @type {EventEmitter<WebMapWebChart>}
     * @event
     */
    arcgisConfigChange: EventEmitter<{
        newConfig: WebMapWebChart | undefined;
        oldConfig: WebMapWebChart | undefined;
        functionCalled: string | undefined;
    }>;
    /**
     * Listener on event coming from the chart container indicating the chart data has been processed
     * emitting an event carrying the data
     * @param {CustomEvent<WebChartDataTypes>} event The event carrying the chart data processed by the core
     * @category Custom-event handler
     */
    handleDataProcessComplete(event: CustomEvent<WebChartDataTypes>): void;
    /**
     * Listener on event coming from the chart container when the chart data has been fetched but not yet fully processed.
     * For instance it can be useful for a pie chart to see all the slices before they get grouped into an 'other' slice during the post-processing step.
     * @param {CustomEvent<WebChartDataTypes>} event The event carrying the fetched data
     * @category Custom-event handler
     */
    handleDataFetchComplete(event: CustomEvent<WebChartDataTypes>): void;
    /**
     * Listener on event coming from the chart container indicating a legend item visibility has been changed
     * emitting an event carrying the item id and its new visibility
     * @param {CustomEvent} event The event carrying the item id and its new visibility
     * @category Custom-event handler
     */
    handleLegendItemVisibilityChanged(event: CustomEvent<LegendItemVisibility>): void;
    /**
     * Listener on event coming from the chart container indicating a chart is updated
     * @param {CustomEvent} event The event carrying the ValidationStatus
     * @category Custom-event handler
     */
    handleUpdateCompleted(event: CustomEvent): void;
    /**
     * Listener on event coming from the chart container indicating an error in the data set
     * @param {CustomEvent} event The event carrying details about the error
     * @category Custom-event handler
     */
    handleBadDataWarningRaise(event: CustomEvent): void;
    /**
     * Listener on event coming from the chart container indicating the chart series color
     * have been assigned
     * @param {CustomEvent<SeriesSymbolsMap>} event The event carrying the series colors
     * @category Custom-event handler
     */
    handleSeriesColorsChange(event: CustomEvent<{
        data: PieSlicesSymbols | SeriesSymbolsMap;
        colorMatchApplied: boolean;
        chartId: string | undefined;
    }>): void;
    /**
     * Listener on event coming from the chart container indicating a selection has been applied to the chart.
     * @param {CustomEvent<SelectionData>} event The event carrying the selected elements
     * @category Custom-event handler
     */
    handleSelection(event: CustomEvent<SelectionData>): void;
    /**
     * Listener on event coming from the chart container
     * when more elements than the authorized limit have been selected.
     * @category Custom-event handler
     */
    handleTooManySelectedElements(): void;
    /**
     * Listener on event coming from the closure of a calcite-alert.
     * The handler helps keeping in sync the boolean `showNotifyPanel` with the panel's state.
     * @param {CustomEvent} event
     * @category Custom-event handler
     */
    handleAlertClosed(event: CustomEvent): void;
    /**
     * Listener on event coming from the chart container indicating the chart axes
     * min and max values have been computed
     * @param {CustomEvent} event The event carrying the axes min and max
     * @category Custom-event handler
     */
    handleAxesMinMaxChange(event: CustomEvent<CalculatedMinMaxBoundsPayload[]>): void;
    /**
     * Listener on event coming from the chart container indicating a the series order changed on the chart.
     * @param event The event carrying a list of series id as they are visually ordered on the chart
     * @category Custom-event handler
     */
    handleSeriesOrder(event: CustomEvent<string[]>): void;
    /**
     * Called every time the model property is updated.
     * @category Watch handler
     */
    modelChange(): Promise<void>;
    /**
     * Called every time the view property is updated.
     * Add a listener to it to keep the chart in sync.
     * @param {MapView | SceneView | undefined} newView The new view
     * @param {MapView | SceneView | undefined} oldView The old view
     * @category Watch handler
     */
    viewChange(newView: MapView | SceneView | undefined, oldView: MapView | SceneView | undefined): Promise<void>;
    /**
     * Called every time the layer property is updated.
     * Adds listeners to it to keep the chart in sync.
     * @category Watch handler
     */
    layerChange(): Promise<void>;
    /**
     * Called every time the `runtimeDataFilters` property is updated.
     * The property name is added to the `updatedProps` list in order to trigger later a data update.
     * The mechanism is also done by `componentShouldUpdate` but doesn't always work when multiple properties are
     * updated at the same time (e.g. only 1 `componentShouldUpdate` is called while 2 properties were changed).
     * For that reason all the properties implying a data update (see this.dataUpdateNeededProps) need a @Watch
     * to ensure the chart update to consider them properly.
     * Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6095
     * @category Watch handler
     */
    runtimeDataFiltersChange(): Promise<void>;
    /**
     * Called every time the `returnFeaturesExtent` property is updated.
     * The property name is added to the `updatedProps` list in order to trigger later a data update.
     * The mechanism is also done by `componentShouldUpdate` but doesn't always work when multiple properties are
     * updated at the same time (e.g. only 1 `componentShouldUpdate` is called while 2 properties were changed).
     * For that reason all the properties implying a data update (see this.dataUpdateNeededProps) need a @Watch
     * to ensure the chart update to consider them properly.
     * Refer to https://devtopia.esri.com/WebGIS/arcgis-charts/issues/6095
     * @category Watch handler
     */
    returnFeaturesExtentChange(): Promise<void>;
    /**
     * Called every time the feature index is updated.
     * @type {number} newFeatureIndex The new gauge feature index to render
     * @type {number | undefined} oldFeatureIndex The old gauge feature index to remove
     * @param newFeatureIndex The new gauge feature index to render
     * @category Watch handler
     */
    featureIndexChange(newFeatureIndex: number, oldFeatureIndex?: number): void;
    /**
     * Called every time the disableInteractions property is updated.
     * Helps setting a css class on the chart to either enable or disable the chart interactions.
     * @param {boolean} newValue The new value for the disableInteractions property
     */
    disableInteractionsChange(newValue: boolean): Promise<void>;
    /**
     * Called every time the rotation property is updated
     * @param {boolean} newRotation The new rotation value for the chart
     * @category Watch handler
     */
    rotationChange(newRotation: boolean): void;
    /**
     * Called every time the position of the legend is updated
     * @param {WebChartLegendPositions} newLegendPosition The new position of the legend
     * @category Watch handler
     */
    legendPositionChange(newLegendPosition: WebChartLegendPositions): void;
    /**
     * Called every time the visibility of the legend is updated
     * @param {boolean} newLegendVisibility The new visibility of the legend
     * @category Watch handler
     */
    legendVisibilityChange(newLegendVisibility: boolean): void;
    /**
     * Called every time the time zone is updated
     * @category Watch handler
     */
    timeZoneChange(): void;
    /**
     * Called every time the filter by selection is updated.
     * Resets the axes min/max.
     * @category Watch handler
     */
    filterBySelectionChanged(): void;
    /**
     * Called every time when the property `layerFilterChangePolicy` changes
     * Adds a listener on the layer's filter when the property is `true`, removes it otherwise.
     * @param {LayerFilterChangePolicy | undefined} newRefreshOnLayerFilter The new value of refresh on layer filter
     * @category Watch handler
     */
    layerFilterChangePolicyCallBack(newRefreshOnLayerFilter: LayerFilterChangePolicy | undefined): void;
    /**
     * Called every time when the property `layerRendererChangePolicy` changes
     * Adds a listener on the layer's renderer when the property is `true`, removes it otherwise.
     * @param {LayerRendererChangePolicy | undefined} newRefreshOnLayerRenderer The new value of refresh on layer renderer
     * @category Watch handler
     */
    layerRendererChangePolicyCallBack(newRefreshOnLayerRenderer: LayerRendererChangePolicy | undefined): void;
    /**
     * Called every time when the property `filterByExtent` changes
     * Adds a listener on the layer's renderer when the property is `true`, removes it otherwise.
     * @category Watch handler
     */
    filterByExtentChanged(newValue: boolean | undefined): Promise<void>;
    /**
     * Called every time the property `config` changes.
     * @category Watch handler
     */
    configChange(newConfig: WebMapWebChart | undefined, oldConfig: WebMapWebChart | undefined): Promise<void>;
    /**
     * Called every time when the property `layerFieldsChangePolicy` changes
     * Adds a listener on the layer's fields when the property is `true`, removes it otherwise.
     * @param {LayerFieldsChangePolicy | undefined} newRefreshOnLayerFields The new value of refresh on layer fields
     * @category Watch handler
     */
    layerFieldsChangePolicyCallBack(newRefreshOnLayerFields: LayerFieldsChangePolicy | undefined): void;
    /**
     * Notify method allows passing external messages to the chart component.
     * It can be used to pass validation or information messages.
     * In a situation where a config update is overriding your notification modal,
     * consider waiting for the `arcgisUpdateComplete` event.
     * @category Public
     * @param {string | undefined} [message] The message to display in the notification panel.
     * @param {string | undefined} [heading] The heading to display in the notification panel.
     * @param {NotifyOptions | undefined} [options] The options to apply to the notification panel.
     */
    notify(message?: string, heading?: string, options?: NotifyOptions): Promise<void>;
    /**
     * Triggers an alert to display an error message.
     * @category Public
     * @param {string | undefined} [errorMessage]
     */
    errorAlert(errorMessage?: string): Promise<void>;
    /**
     * Resets the chart zoom to bring it back to full extent
     *
     * @remarks
     * Applicable to XY charts only.
     *
     * @category Public
     */
    resetZoom(): Promise<void>;
    /**
     * Switches the selection on the chart.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @category Public
     */
    switchSelection(): Promise<void>;
    /**
     * Clears all selection on the chart.
     *
     * @remarks
     * Not applicable to gauge.
     *
     * @category Public
     */
    clearSelection(): Promise<void>;
    /**
     * Re-render the chart.
     * @param {boolean} [props.updateData] Indicates whether to fetch new data. Default: true.
     * @param {boolean} [props.updateExtent] Indicates whether the view's extent is to update. Default: false.
     * @param {boolean} [props.resetAxesBounds] Option to reset the axes bounds along with the refresh. Default: false;
     * @category Public
     */
    refresh(props?: {
        updateData?: boolean;
        resetAxesBounds?: boolean;
        updateExtent?: boolean;
    }): Promise<void>;
    /**
     * Export the current chart to an image
     * @param {"png" | "jpg"} [props.format] image format to export the chart to. Supports 'png' | 'jpg'
     * @param {number | undefined} [props.quality] quality of the image should be 0 - 1. If outside of the range, it will default to 1
     * @param {number | undefined} [props.maxWidth] max width in px
     * @param {number | undefined} [props.minWidth] min width in px
     * @param {number | undefined} [props.maxHeight] max height in px
     * @param {number | undefined} [props.minHeight] min height in px
     * @returns
     */
    exportImage(props: {
        format: "jpg" | "png";
        quality?: number;
        maxWidth?: number;
        minWidth?: number;
        maxHeight?: number;
        minHeight?: number;
    }): Promise<File>;
    /**
     * Called when the component is added to the DOM.
     * @category Lifecycle
     */
    connectedCallback(): void;
    /**
     * Adds listeners for events from charts config UI.
     * @category Private
     */
    private addConfigListeners;
    /**
     * Removes listeners for events from charts config UI.
     * @category Private
     */
    private removeConfigListeners;
    /**
     * Handles the selection event from an external chart component. If the selection is from a chart component using the same layer, we sync the selection on this chart component.
     * @category Event handler
     */
    private handleExternalSelection;
    /**
     * Called when a charts config UI component's panel number changes.
     * @category Event handler
     */
    private configPanelNumberChange;
    /**
     * Called when a charts config UI component throws a data change error.
     * @category Event handler
     */
    private configDataChangeError;
    /**
     * Called when a charts config UI component's popover open state changes.
     * @category Event handler
     */
    private configPopoverOpenChange;
    /**
     * Prevents render for noRenderProps
     * @category Lifecycle
     */
    componentShouldUpdate(...args: [any, any, string]): boolean;
    /**
     * @category Lifecycle
     */
    componentWillLoad(): Promise<void>;
    /**
     * @category Lifecycle
     */
    componentDidLoad(): Promise<void>;
    /**
     * @category Lifecycle
     */
    componentDidUpdate(): Promise<void>;
    /**
     * Called when the component is removed from the DOM.
     * @category Lifecycle
     */
    disconnectedCallback(): Promise<void>;
    /**
     * Adds the listener to the model to listen to the config changes
     * @category Private
     */
    private addModelListeners;
    /**
     * Adds the listener to listen to the layer definitionExpression and renderer changes
     * @category Private
     */
    private addLayerListeners;
    /**
     * Adds the listener to listen to the layer definitionExpression changes
     * @category Private
     */
    private setLayerFilterListener;
    /**
     * Adds a listener to listen to the layer's renderer changes when color match is enabled for a layer data source
     * @category Private
     */
    private setLayerRendererListener;
    /**
     * Adds a listener to listen to the layer's fields changes
     * @category Private
     */
    private setLayerFieldsListener;
    /**
     * Adds a listener to listen to the view's extent change
     * @category Private
     */
    private setExtentChangeListener;
    /**
     * Removes the listeners added to listen to the layer definitionExpression and renderer changes
     * @category Private
     */
    private removeLayerListeners;
    /**
     * Removes the layer filter listener when layer definitionExpression changes
     * @category Private
     */
    private removeLayerFilterListener;
    /**
     * Removes the layer renderer listener when layer renderer changes
     * @category Private
     */
    private removeLayerRendererListener;
    /**
     * Removes the layer fields listener when layer fields change
     * @category Private
     */
    private removeLayerFieldsListener;
    /**
     * Removes the listeners added to listen to the view's extent change
     * @category Private
     */
    private removeExtentChangeListeners;
    /**
     * Applies the placeholder message for a partial config.
     * @param {WebMapWebChart | undefined} config
     * @category Private
     */
    private applyPlaceholderForPartialConfig;
    /**
     * If the chart config version is newer than the current one, display a message in a popup.
     * @category Private
     */
    private checkForIncompatibleChartVersion;
    /**
     * Checks if this chart component's model exists in provided the model list.
     * @param {ChartModel[]} modelList
     * @category Private
     */
    private ourModelExistsIn;
    /**
     * Updates the config's time zone if needed.
     * @category Private
     */
    private updateConfigTimeZone;
    /**
     * Gathers the component's runtime chart options
     * @param dataUpdated
     * @returns
     */
    private gatherComponentOptions;
    /**
     * creates arcgis chart instance
     * @param {boolean} firstCreation Indicates whether it's the first time the component is created
     * @category Private
     */
    private createChartInstance;
    /**
     * @category Lifecycle
     */
    render(): HTMLDivElement;
}
