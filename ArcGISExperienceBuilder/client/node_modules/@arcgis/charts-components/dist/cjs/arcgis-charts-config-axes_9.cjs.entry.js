/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2e64cfc1.js');
const restJsObjectLiterals = require('./rest-js-object-literals-acb59afb.js');
const chartUiUtils = require('./chart-ui-utils-ba499862.js');
const store = require('./store-fbc7ac07.js');
const axisModelWrapper = require('./axis-model-wrapper-340f3f39.js');
const t9nStrings = require('./t9n-strings-ceef62aa.js');
const debounce = require('./debounce-2f0b5b14.js');
const chartObjectLiterals = require('./chart-object-literals-a706ca0f.js');
const index$1 = require('./index-e5a6a075.js');
const isEmpty = require('./isEmpty-b0fd430d.js');
const cloneDeep = require('./cloneDeep-3503ada6.js');
const _Map = require('./_Map-d0ba2c83.js');
const _baseMerge = require('./_baseMerge-846a06cb.js');
const isObject = require('./isObject-b063d8a9.js');
const _default = require('./default-92107337.js');
require('./interfaces-28e1772a.js');
require('./toNumber-b227ab04.js');
require('./_getTag-66a55d52.js');
require('./_Uint8Array-9bd4a4da.js');
require('./_initCloneObject-76ab9e25.js');
require('./_getAllKeys-facd90a6.js');

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = _baseMerge.createAssigner(function(object, source, srcIndex, customizer) {
  _baseMerge.baseMerge(object, source, srcIndex, customizer);
});

const mergeWith$1 = mergeWith;

const arcgisChartsConfigAxesCss = ":host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width)}";
const ArcgisChartsConfigAxesStyle0 = arcgisChartsConfigAxesCss;

const ArcGISChartsConfigAxes = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.model = undefined;
        this.calculatedDataMinMaxBounds = undefined;
        this.open = false;
        this.showMinXBoundOption = true;
        this.showMaxXBoundOption = true;
        this.showMinYBoundOption = true;
        this.showMaxYBoundOption = true;
        this.showEnableXLogOption = true;
        this.showEnableYLogOption = true;
        this.calculatedMinMaxBounds = undefined;
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
    }
    /**
     * @category private
     */
    getMinFromCalculatedDataBounds(xAxis) {
        const dataMin = this.calculatedDataMinMaxBounds?.find((bound) => bound.isXAxis === xAxis)
            ?.minimum ?? Number.NaN;
        return dataMin;
    }
    /**
     * @category private
     */
    getMaxFromCalculatedDataBounds(xAxis) {
        const dataMax = this.calculatedDataMinMaxBounds?.find((bound) => bound.isXAxis === xAxis)
            ?.maximum ?? Number.NaN;
        return dataMax;
    }
    /**
     * @category Lifecycle
     */
    render() {
        const calculatedXBounds = this.calculatedMinMaxBounds?.find((payload) => payload.isXAxis);
        const calculatedYBounds = this.calculatedMinMaxBounds?.find((payload) => !payload.isXAxis);
        return (index.h(index.Host, { key: '001e1c475d054c28f319928ef29f7cd73aabaa31' }, index.h("arcgis-charts-config-axis", { key: 'fbd8b1f0ee87d8a03fd976865933f3813fcd9d9b', model: this.model, isXAxis: true, axisTitle: this.strings.xAxis, showMinBoundOption: this.showMinXBoundOption, showMaxBoundOption: this.showMaxXBoundOption, showEnableLogOption: this.showEnableXLogOption, dataMinValue: this.getMinFromCalculatedDataBounds(true), dataMaxValue: this.getMaxFromCalculatedDataBounds(true), initialMaxBound: calculatedXBounds?.maximum, initialMinBound: calculatedXBounds?.minimum }), index.h("arcgis-charts-config-axis", { key: '0711b7f0b85d58b3796ab3a51640b855681c9a78', model: this.model, isXAxis: false, axisTitle: this.strings.yAxis, showMinBoundOption: this.showMinYBoundOption, showMaxBoundOption: this.showMaxYBoundOption, showEnableLogOption: this.showEnableYLogOption, dataMinValue: this.getMinFromCalculatedDataBounds(false), dataMaxValue: this.getMaxFromCalculatedDataBounds(false), initialMaxBound: calculatedYBounds?.maximum, initialMinBound: calculatedYBounds?.minimum })));
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
};
ArcGISChartsConfigAxes.style = ArcgisChartsConfigAxesStyle0;

const HTMLClasses$7 = {
    linkContainer: "link-container",
    headingLabel: "heading-label",
    label: "label",
    text: "text",
    mb2: "mb-2",
    rtl: "arcgis-charts-rtl",
};

const arcgisChartsConfigAxisCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}calcite-block{width:var(--arcgis-charts-config-calcite-block-width, var(--arcgis-charts-config-calcite-block-default-width));height:var(--arcgis-charts-config-calcite-block-height, var(--arcgis-charts-config-calcite-block-default-height));border:0px;box-shadow:0 0 0 0}:host{display:flex;flex-direction:row}.text{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);width:calc(100% - 1.5rem);height:2rem;margin-bottom:var(--arcgis-charts-config-margin-minor)}.label{display:flex;justify-content:space-between}.mb-2{margin-bottom:var(--arcgis-charts-config-margin-minor)}.link-container{display:flex;justify-content:flex-end;margin-top:-0.75rem}:host(.arcgis-charts-rtl) .text{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}";
const ArcgisChartsConfigAxisStyle0 = arcgisChartsConfigAxisCss;

const ArcGISChartsConfigAxis = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.getAxisBoundsFromStateStore = () => {
            let currAxisBoundData;
            const chartAxesBoundDataMap = store.state.chartAxesBoundDataMap;
            const currChartId = this.model.getChartId();
            if (currChartId) {
                const key = store.generateAxisMinMaxKey({
                    chartId: currChartId,
                    isXAxis: this.isXAxis,
                    isLogarithmic: this.axisModel.getLogarithmic(),
                });
                currAxisBoundData = chartAxesBoundDataMap[currChartId]?.[key];
            }
            return currAxisBoundData;
        };
        /**
         * @category Event handler
         */
        this.onShowLogScaleMouseEnter = async () => {
            this.showLogScaleTooltip?.remove();
            if (this.showLogScaleSwitch?.disabled) {
                const commonStrings = await t9nStrings.fetchCommonStrings(this.hostElement);
                this.showLogScaleTooltip = document.createElement("calcite-tooltip");
                this.showLogScaleTooltip.textContent = commonStrings.tooltips.logDisabled;
                this.showLogScaleTooltip.open = true;
                this.showLogScaleTooltip.referenceElement = this.showLogScaleSwitch;
                document.body.appendChild(this.showLogScaleTooltip);
            }
        };
        /**
         * @category Event handler
         */
        this.onShowLogScaleMouseLeave = () => {
            this.showLogScaleTooltip?.remove();
        };
        /**
         * @category Event handler
         */
        this.onCategoryFormatChange = async (e) => {
            await this.axisModel.setValueFormat(e.target.categoryFormat);
        };
        this.onMaxBoundsChange = async () => {
            const { value } = this.maxBoundInputElement;
            let { status } = this.maxBoundInputElement;
            // Check for empty string coming from the calcite input
            // TODO: This should ideally be undefined or null
            if (value !== undefined && value !== "") {
                const minValue = this.maxBoundInputElement.min === undefined
                    ? this.axisModel.getMinBound()
                    : Math.max(this.maxBoundInputElement.min, this.axisModel.getMinBound());
                const maxBound = Number.parseFloat(value);
                if (maxBound !== this.axisModel.getMinBound() &&
                    chartUiUtils.isCalciteInputValidNumber(maxBound, minValue, this.maxBoundInputElement.max)) {
                    if (maxBound !== this.axisModel.getMaxBound()) {
                        await this.axisModel.setMaxBound(maxBound);
                        // update the current max bound in the store
                        const currAxisBoundData = this.getAxisBoundsFromStateStore();
                        if (currAxisBoundData) {
                            currAxisBoundData.currMaxBound = maxBound;
                        }
                    }
                    status = chartUiUtils.UIInputStatus.IDLE;
                }
                else {
                    status = chartUiUtils.UIInputStatus.INVALID;
                }
            }
            else {
                status = chartUiUtils.UIInputStatus.IDLE;
            }
            // Updating the max bound input status
            chartUiUtils.modifyCalciteInputStatus({
                inputElement: this.maxBoundInputElement,
                status,
            });
            // re-evaluating the status of the min bound input now the max has been changed
            if (status !== chartUiUtils.UIInputStatus.INVALID && this.minBoundInputElement?.status === chartUiUtils.UIInputStatus.INVALID) {
                await this.onMinBoundsChange();
            }
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Using a debounce to avoid sending too fast a new max bound value to the chart
         * @category Event handler
         */
        this.onMaxBoundsChangeDebounced = debounce.debounce(this.onMaxBoundsChange, chartUiUtils.UIDefaults.DebounceTimer);
        this.onMinBoundsChange = async () => {
            const { value } = this.minBoundInputElement;
            let { status } = this.minBoundInputElement;
            // Check for empty string coming from the calcite input
            if (value !== undefined && value !== "") {
                const maxValue = this.minBoundInputElement.max === undefined
                    ? this.axisModel.getMaxBound()
                    : Math.min(this.minBoundInputElement.max, this.axisModel.getMaxBound());
                const minBound = Number.parseFloat(value);
                if (minBound !== this.axisModel.getMaxBound() &&
                    chartUiUtils.isCalciteInputValidNumber(minBound, this.minBoundInputElement.min, maxValue)) {
                    if (minBound !== this.axisModel.getMinBound()) {
                        await this.axisModel.setMinBound(minBound);
                        // update the current min bound in the store
                        const currAxisBoundData = this.getAxisBoundsFromStateStore();
                        if (currAxisBoundData) {
                            currAxisBoundData.currMinBound = minBound;
                        }
                    }
                    status = chartUiUtils.UIInputStatus.IDLE;
                }
                else {
                    status = chartUiUtils.UIInputStatus.INVALID;
                }
            }
            else {
                status = chartUiUtils.UIInputStatus.IDLE;
            }
            // Updating the min bound input status
            chartUiUtils.modifyCalciteInputStatus({
                inputElement: this.minBoundInputElement,
                status,
            });
            // re-evaluating the status of the max bound input now the min has been changed
            if (status !== chartUiUtils.UIInputStatus.INVALID && this.maxBoundInputElement?.status === chartUiUtils.UIInputStatus.INVALID) {
                await this.onMaxBoundsChange();
            }
            // Updating the log scale switch that should be disabled when the data min value is less than 0
            await this.updateEnableLogarithmic(this.axisModel.getLogarithmic() && (this.dataMinValue ?? Number.NaN) > 0);
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Using a debounce to avoid sending too fast a new min bound value to the chart
         * @category Event handler
         */
        this.onMinBoundsChangeDebounced = debounce.debounce(this.onMinBoundsChange, chartUiUtils.UIDefaults.DebounceTimer);
        /**
         * @category Event handler
         */
        this.onNumberFormatChange = async (e) => {
            await this.axisModel.setValueFormat({
                type: chartObjectLiterals.WebChartTypes.NumberAxisFormat,
                intlOptions: e.detail,
            });
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Event handler
         */
        this.onRevertMaxBoundsToDefault = async () => {
            if (this.maxBoundInputElement?.status === chartUiUtils.UIInputStatus.INVALID ||
                this.axisModel.getMaxBound() !== this.defaultMaxBound) {
                const currAxisBoundData = this.getAxisBoundsFromStateStore();
                if (this.axisModel.getMinBound() > this.defaultMaxBound) {
                    await this.axisModel.setMinBound(currAxisBoundData?.defaultMinBound ?? Number.NaN);
                }
                await this.axisModel.setMaxBound(currAxisBoundData?.defaultMaxBound ?? Number.NaN);
                const prevUpdates = this.updatesOccurred;
                this.updatesOccurred = prevUpdates + 1;
            }
        };
        /**
         * @category Event handler
         */
        this.onRevertMinBoundsToDefault = async () => {
            if (this.minBoundInputElement?.status === chartUiUtils.UIInputStatus.INVALID ||
                this.axisModel.getMinBound() !== this.defaultMinBound) {
                if (this.axisModel.getMaxBound() < this.defaultMinBound) {
                    await this.axisModel.setMaxBound(Number.NaN);
                }
                await this.axisModel.setMinBound(Number.NaN);
                const prevUpdates = this.updatesOccurred;
                this.updatesOccurred = prevUpdates + 1;
            }
        };
        /**
         * @category Event handler
         */
        this.enableLogScale = async (e) => {
            const { checked } = e.target;
            await this.axisModel.setLogarithmic(checked && (this.dataMinValue ?? Number.NaN) > 0);
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        this.model = undefined;
        this.isXAxis = undefined;
        this.axisTitle = undefined;
        this.maxBoundMaxLimit = undefined;
        this.maxBoundMinLimit = undefined;
        this.minBoundMinLimit = undefined;
        this.minBoundMaxLimit = undefined;
        this.showMaxBoundOption = undefined;
        this.showMinBoundOption = undefined;
        this.showEnableLogOption = undefined;
        this.dataMaxValue = undefined;
        this.dataMinValue = undefined;
        this.initialMaxBound = undefined;
        this.initialMinBound = undefined;
        this.disableMaxBoundResetBtn = true;
        this.disableMinBoundResetBtn = true;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        this.axisModel = new axisModelWrapper.AxisModelWrapper(this.model, this.isXAxis);
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * Sets a default minimum bound when it is first calculated by the graph.
     * @param newValue The new minimum value
     * @param oldValue The old minimum value
     * @category Watch handler
     */
    dataMinValueChange(newValue, oldValue) {
        if (Number.isNaN(oldValue) && !Number.isNaN(newValue)) {
            this.defaultMinBound = newValue;
        }
    }
    /**
     * Sets a default maximum bound when it is first calculated by the graph.
     * @param newValue The new maximum value
     * @param oldValue The old maximum value
     * @category Watch handler
     */
    dataMaxValueChange(newValue, oldValue) {
        if (Number.isNaN(oldValue) && !Number.isNaN(newValue)) {
            this.defaultMaxBound = newValue;
        }
    }
    initialMaxBoundChange() {
        // if a custom max bound is set, we need to make sure it gets reapplied to the config.
        if (!Number.isNaN(this.axisModel.getMaxBound())) {
            this.axisModel.setMaxBound(this.axisModel.getMaxBound());
        }
    }
    initialMinBoundChange() {
        // if a custom min bound is set, we need to make sure it gets reapplied to the config.
        if (!Number.isNaN(this.axisModel.getMinBound())) {
            this.axisModel.setMinBound(this.axisModel.getMinBound());
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
        if (this.dataMinValue !== undefined) {
            this.dataMinValueChange(this.dataMinValue, Number.NaN);
        }
        if (this.dataMaxValue !== undefined) {
            this.dataMaxValueChange(this.dataMaxValue, Number.NaN);
        }
    }
    disableResetButtons() {
        const currAxisBoundData = this.getAxisBoundsFromStateStore();
        if (currAxisBoundData) {
            this.disableMaxBoundResetBtn = currAxisBoundData.defaultMaxBound === currAxisBoundData.currMaxBound;
            this.disableMinBoundResetBtn = currAxisBoundData.defaultMinBound === currAxisBoundData.currMinBound;
        }
    }
    /**
     * @category Lifecycle
     */
    componentDidRender() {
        this.disableResetButtons();
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (index.h(index.Host, { key: '59dc6c6435a4feb78cfab0eaf0044a89555843f4', class: { [HTMLClasses$7.rtl]: this.direction === "rtl" } }, index.h("calcite-block", { key: '551e14f0dc649f652350a51c9e009d80deac4417', hidden: this.axisModel.getValueFormat()?.type === chartObjectLiterals.WebChartTypes.DateAxisFormat, collapsible: false, open: true, heading: this.axisTitle }, this.renderAxis())));
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Render UX
     */
    renderAxis() {
        let renderedContent;
        const format = { ...this.axisModel.getValueFormat() };
        switch (this.axisModel.getValueFormat()?.type) {
            case chartObjectLiterals.WebChartTypes.CategoryAxisFormat:
                renderedContent = (index.h("arcgis-charts-config-category-format", { categoryFormat: format, onArcgisChartsConfigCategoryFormatChange: this.onCategoryFormatChange }));
                break;
            case chartObjectLiterals.WebChartTypes.NumberAxisFormat:
                renderedContent = (index.h("div", null, this.renderShowLogScale(), this.renderMinBound(), this.renderMaxBound(), index.h("arcgis-charts-config-number-format", { numberFormat: { ...format.intlOptions }, onArcgisChartsConfigNumberFormatChange: this.onNumberFormatChange })));
                break;
            case chartObjectLiterals.WebChartTypes.DateAxisFormat:
                renderedContent = null;
                break;
        }
        return renderedContent;
    }
    /**
     * @category Render UX
     */
    renderMaxBound() {
        let showMaxBoundElem;
        if (!this.showMaxBoundOption) {
            showMaxBoundElem = null;
        }
        else {
            const sanitizedMaxBound = chartUiUtils.sanitizeNumber(this.axisModel.getMaxBound(), this.initialMaxBound);
            showMaxBoundElem = (index.h("div", null, index.h("calcite-label", { class: HTMLClasses$7.label }, this.strings.maxBounds, index.h("calcite-input", { type: "number", numberButtonType: "none", min: this.maxBoundMinLimit ?? Number.MIN_SAFE_INTEGER, max: this.maxBoundMaxLimit ?? Number.MAX_SAFE_INTEGER, step: "any", value: sanitizedMaxBound, onCalciteInputInput: this.onMaxBoundsChangeDebounced, ref: (e) => {
                    this.maxBoundInputElement = e;
                } })), index.h("div", { class: HTMLClasses$7.linkContainer }, index.h("calcite-button", { disabled: this.disableMaxBoundResetBtn, onClick: this.onRevertMaxBoundsToDefault, appearance: "transparent", iconEnd: "reset" }, this.strings.revertToDefault))));
        }
        return showMaxBoundElem;
    }
    /**
     * @category Render UX
     */
    renderMinBound() {
        let showMinBoundElem;
        if (!this.showMinBoundOption) {
            showMinBoundElem = null;
        }
        else {
            const sanitizedMinBound = chartUiUtils.sanitizeNumber(this.axisModel.getMinBound(), this.initialMinBound ?? undefined);
            showMinBoundElem = (index.h("div", null, index.h("calcite-label", { class: HTMLClasses$7.label }, this.strings.minBounds, index.h("calcite-input", { type: "number", numberButtonType: "none", min: this.minBoundMinLimit ?? Number.MIN_SAFE_INTEGER, max: this.minBoundMaxLimit ?? Number.MAX_SAFE_INTEGER, step: "any", value: sanitizedMinBound, onCalciteInputInput: this.onMinBoundsChangeDebounced, ref: (e) => {
                    this.minBoundInputElement = e;
                } })), index.h("div", { class: HTMLClasses$7.linkContainer }, index.h("calcite-button", { disabled: this.disableMinBoundResetBtn, appearance: "transparent", iconEnd: "reset", onClick: this.onRevertMinBoundsToDefault }, this.strings.revertToDefault))));
        }
        return showMinBoundElem;
    }
    /**
     * @category Render UX
     */
    renderShowLogScale() {
        let result;
        if (this.showEnableLogOption) {
            result = (index.h("calcite-label", { layout: "inline-space-between", class: {
                    [HTMLClasses$7.label]: true,
                    [HTMLClasses$7.mb2]: true,
                } }, this.strings.logScale, index.h("div", { onMouseEnter: this.onShowLogScaleMouseEnter, onMouseLeave: this.onShowLogScaleMouseLeave }, index.h("calcite-switch", { checked: this.axisModel.getLogarithmic() && (this.dataMinValue ?? Number.NaN) > 0, disabled: (this.dataMinValue ?? Number.NaN) <= 0, onCalciteSwitchChange: this.enableLogScale, ref: (e) => {
                    this.showLogScaleSwitch = e;
                } }))));
        }
        return result;
    }
    /**
     * @category Private
     */
    async updateEnableLogarithmic(enableLogarithmic) {
        // emitting the change event only if there's a change
        if (enableLogarithmic !== this.axisModel.getLogarithmic()) {
            await this.axisModel.setLogarithmic(enableLogarithmic);
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "dataMinValue": ["dataMinValueChange"],
        "dataMaxValue": ["dataMaxValueChange"],
        "initialMaxBound": ["initialMaxBoundChange"],
        "initialMinBound": ["initialMinBoundChange"]
    }; }
};
ArcGISChartsConfigAxis.style = ArcgisChartsConfigAxisStyle0;

const HTMLClasses$6 = {
    container: "container",
    label: "label",
    numberInput: "number-input",
    rtl: "arcgis-charts-rtl",
};

const arcgisChartsConfigCategoryFormatCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}.container{width:var(--arcgis-charts-config-calcite-block-width, var(--arcgis-charts-config-calcite-block-default-width));height:var(--arcgis-charts-config-calcite-block-height, var(--arcgis-charts-config-calcite-block-default-height))}.container>.number-input{margin-bottom:0.5rem;display:flex}.container>.number-input>div{width:100%}:host{display:flex;flex-direction:row}.label{display:flex;margin-bottom:0.5rem}";
const ArcgisChartsConfigCategoryFormatStyle0 = arcgisChartsConfigCategoryFormatCss;

const ArcgisChartsConfigCategoryFormat = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigCategoryFormatChange = index.createEvent(this, "arcgisChartsConfigCategoryFormatChange", 7);
        /**
         * @category Event handler
         */
        this.onCharacterLimitChange = () => {
            const { value } = this.characterLimitInputElement;
            const numericValue = Math.floor(Number(value));
            // check if the character limit value is a valid positive integer
            const isValidCharacterLimit = numericValue === Number(value) && numericValue >= 0;
            if (value !== undefined &&
                isValidCharacterLimit &&
                chartUiUtils.isCalciteInputValidNumber(value, this.characterLimitInputElement.min, this.characterLimitInputElement.max)) {
                const characterLimit = Number.parseInt(value);
                this.updateCategoryFormat({ type: this.categoryFormat.type, characterLimit });
                this.arcgisChartsConfigCategoryFormatChange.emit();
                chartUiUtils.modifyCalciteInputStatus({
                    inputElement: this.characterLimitInputElement,
                    status: chartUiUtils.UIInputStatus.IDLE,
                });
            }
            else {
                chartUiUtils.modifyCalciteInputStatus({
                    inputElement: this.characterLimitInputElement,
                    status: chartUiUtils.UIInputStatus.INVALID,
                });
            }
        };
        this.categoryFormat = undefined;
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        // T.B.D issue with lang getting set correctly when this component used as a child
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (index.h(index.Host, { key: '5d4c040febc2b35949603f5fda023a366038d3a7', class: { [HTMLClasses$6.rtl]: this.direction === "rtl" } }, index.h("div", { key: '85ce8ba09fd5a24e5975bd87ea7274fa9a5b0a55', class: HTMLClasses$6.container }, index.h("calcite-label", { key: '03aa5145d58226e7f180b71bd48c445ee5ff660d', class: HTMLClasses$6.label }, this.strings.labelCharacterLmt, index.h("calcite-input", { key: '47f4405443e49c89a11bf0286ea10999ea83ea98', type: "number", class: HTMLClasses$6.numberInput, min: 1, max: 100, step: 1, value: chartUiUtils.sanitizeNumber(this.categoryFormat?.characterLimit, 11), onCalciteInputInput: this.onCharacterLimitChange, ref: (e) => {
                this.characterLimitInputElement = e;
            } })))));
    }
    /**
     * @param prop
     * @category Private
     */
    updateCategoryFormat(prop) {
        this.categoryFormat = {
            ...this.categoryFormat,
            ...prop,
        };
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
};
ArcgisChartsConfigCategoryFormat.style = ArcgisChartsConfigCategoryFormatStyle0;

const defaultTextProps = {
    type: restJsObjectLiterals.RESTSymbolType.TS,
    color: [1, 1, 1, 255],
    font: {
        family: "Tahoma",
        size: 12,
        decoration: restJsObjectLiterals.RESTFontDecoration.None,
        style: restJsObjectLiterals.RESTFontStyle.Normal,
        weight: restJsObjectLiterals.RESTFontWeight.Normal,
    },
};
const defaultSymbolProps = {
    type: restJsObjectLiterals.RESTSymbolType.SLS,
    color: [1, 1, 1, 255],
    style: restJsObjectLiterals.RESTSimpleLineSymbolStyle.Solid,
    width: 2,
};

const HTMLClasses$5 = {
    element: "chart-element",
    elementList: "element-list",
    sectionLabel: "section-label",
};

const arcgisChartsConfigFormatCss = ":host{width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}.section-label{display:flex;margin:var(--arcgis-charts-config-margin-major) var(--arcgis-charts-config-margin-minor);justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}.element-list{margin:var(--arcgis-charts-config-margin-minor)}.element{-webkit-user-select:none;-moz-user-select:none;user-select:none}";
const ArcgisChartsConfigFormatStyle0 = arcgisChartsConfigFormatCss;

const ArcgisChartsConfigFormat = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigFormatPopoverChange = index.createEvent(this, "arcgisChartsConfigFormatPopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = index.createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        /**
         * @category Private
         */
        this.formatPopover = null;
        /**
         * List of text selectable text elements
         * @category Private
         */
        this.selectableElements = [];
        /**
         * List to store text property keys used for current chart.
         * @category Private
         */
        this.textProperties = [];
        /**
         * List to store symbol property keys used for current chart.
         * @category Private
         */
        this.symbolProperties = [];
        /**
         * @category Render UX
         */
        this.renderTextElement = (valueKey, callback) => {
            const icon = chartUiUtils.getFormatIcon(valueKey);
            const value = this.getFormatValue(valueKey);
            const textValue = typeof value === "string" ? value : "";
            const selected = this.selectedTexts.includes(valueKey) ||
                this.selectedSymbols.includes(valueKey) ||
                this.selectedBackground.includes(valueKey);
            return (index.h("calcite-list-item", { class: HTMLClasses$5.element, label: this.strings[valueKey], description: textValue, value: valueKey, selected: selected, onClick: callback, ref: (e) => {
                    const element = e;
                    if (!this.selectableElements.includes(element)) {
                        this.selectableElements.push(element);
                    }
                } }, icon !== undefined ? index.h("calcite-icon", { slot: "content-start", scale: "s", icon: icon }) : null));
        };
        /**
         * Corrects selected text elements in DOM to match selected texts list
         * @category Event handler
         */
        this.correctTextElementSelection = () => {
            for (const element of this.selectableElements) {
                const selected = this.selectedTexts.includes(element.value) ||
                    this.selectedSymbols.includes(element.value) ||
                    this.selectedBackground.includes(element.value);
                element.selected = selected;
            }
        };
        /**
         * @category Event handler
         */
        this.symbolPropertyChange = (e) => {
            let key;
            if (e.target?.localName === "calcite-list-item") {
                key = e.target?.value;
            }
            else {
                key = e.target?.parentNode?.value;
            }
            // empty the selected text props.
            this.selectedTexts = [];
            this.selectedBackground = [];
            if (this.selectedSymbols.includes(key)) {
                this.selectedSymbols = [];
                this.updateSelectedElement(this.selectedSymbols);
            }
            else {
                const value = this.getFormatValue(key);
                this.selectedSymbols = [key];
                this.initSelectedSymbols(restJsObjectLiterals.Jc(value) ? value : defaultSymbolProps);
            }
            this.setupFormatPopover();
        };
        /**
         * @category Event handler
         */
        this.textPropertyChange = (e) => {
            let key;
            if (e.target?.localName === "calcite-list-item") {
                key = e.target?.value;
            }
            else {
                key = e.target?.parentNode?.value;
            }
            // empty the selected symbols.
            this.selectedSymbols = [];
            this.selectedBackground = [];
            if (e.shiftKey) {
                this.selectedTexts = [];
                // find start and end of shift selection range
                const start = this.textProperties.indexOf(this.lastSelectedText);
                const end = this.textProperties.indexOf(key);
                this.textProperties.forEach((textProperty, i) => {
                    // check if each text prop is in the shift selection range
                    if (i >= Math.min(start, end) && i <= Math.max(start, end)) {
                        this.selectedTexts.push(textProperty);
                    }
                });
                this.updateSelectedElement(this.selectedTexts);
                this.setupFormatPopover();
            }
            else if (e.ctrlKey) {
                if (this.selectedTexts.includes(key)) {
                    this.selectedTexts = this.selectedTexts.filter((text) => text !== key);
                    this.updateSelectedElement(this.selectedTexts);
                }
                else {
                    this.selectedTexts = [...this.selectedTexts, key];
                    this.updateSelectedElement(this.selectedTexts);
                }
                this.setupFormatPopover();
            }
            else if (this.selectedTexts.includes(key)) {
                this.selectedTexts = [];
                this.updateSelectedElement(this.selectedTexts);
                this.setupFormatPopover();
            }
            else {
                const value = this.getFormatValue(key);
                this.selectedTexts = [key];
                this.initSelectedTexts(restJsObjectLiterals.ey(value) ? value : defaultTextProps);
                this.setupFormatPopover();
            }
            this.lastSelectedText = key;
        };
        /**
         * @category Event handler
         */
        this.backgroundChange = (e) => {
            let value;
            if (e.target?.localName === "calcite-list-item") {
                value = e.target?.value;
            }
            else {
                value = e.target?.parentNode
                    ?.value;
            }
            this.selectedSymbols = [];
            this.selectedTexts = [];
            if (this.selectedBackground.includes(value)) {
                this.selectedBackground = [];
                this.selectedElement = {};
            }
            else {
                this.selectedBackground = [value];
                this.selectedElement = !isEmpty.isEmpty(this.getFormatValue(value)) ? this.getFormatValue(value) : undefined;
            }
            this.setupFormatPopover();
        };
        /**
         * @category Event handler
         */
        this.updateSymbolProps = (e) => {
            const symbolProps = e.detail;
            this.selectedSymbols.forEach((symbol) => {
                this.setFormatValue(symbol, symbolProps);
            });
            this.selectedElement = cloneDeep.cloneDeep(e.target.selectedElement);
        };
        /**
         * @category Event handler
         */
        this.updateBackground = (e) => {
            this.setFormatValue(index$1.oh.Background, e.detail);
            this.selectedElement = e.detail;
        };
        /**
         * @category Event handler
         */
        this.updateTextProps = (e) => {
            const { font, color } = e.detail;
            this.selectedTexts.forEach((symbol) => {
                const rawTextSymbol = this.getFormatValue(symbol);
                const currentSymbol = restJsObjectLiterals.ey(rawTextSymbol) ? rawTextSymbol : undefined;
                // we should only update the color with the value from the payload if it is defined
                this.setFormatValue(symbol, {
                    ...currentSymbol,
                    type: restJsObjectLiterals.RESTSymbolType.TS,
                    font: { ...currentSymbol?.font, ...font },
                    color: color ?? currentSymbol?.color,
                });
            });
            this.selectedElement = cloneDeep.cloneDeep(e.target.selectedElement);
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Private
         */
        this.formatPopoverClose = (e) => {
            if (this.formatPopover === e?.target) {
                this.selectedTexts = [];
                this.selectedSymbols = [];
                this.selectedBackground = [];
                this.selectedElement = {};
                this.removeFormatPopover();
            }
        };
        /**
         * @category Private
         */
        this.mergeFormatValues = (format1, format2) => {
            let isSame = false;
            if (_Map.isArray(format1) && _Map.isArray(format2)) {
                isSame = true;
            }
            else if (isObject.isObject(format1) && isObject.isObject(format2)) {
                isSame = true;
            }
            else {
                isSame = format1 === format2;
            }
            const diffReturn = typeof format1 === "number" || typeof format2 === "number" ? Number.NaN : "";
            return isSame ? undefined : diffReturn;
        };
        /**
         * Emit event on open popover.
         * @param e
         * @category Private
         */
        this.openChange = (e) => {
            this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
        };
        this.model = undefined;
        this.selectedSymbols = [];
        this.selectedTexts = [];
        this.selectedBackground = [];
        this.selectedElement = undefined;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        // T.B.D issue with lang getting set correctly when this component used as a child
        ({ strings: this.strings } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removeFormatPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * render and store format UI elements
     * @returns textElements and symbolElements
     */
    renderFormatElements() {
        // initialize with all possible text props
        this.textProperties = [
            index$1.ih.Title,
            ...(index$1.Lg(this.model) ? [index$1.ih.XAxisTitle] : []),
            ...(index$1.Dg(this.model) ? [index$1.ih.YAxisTitle] : []),
            ...(index$1.Mg(this.model) ? [index$1.ih.LegendTitle] : []),
            index$1.ih.Description,
            ...(index$1.Mg(this.model) ? [index$1.ih.LegendText] : []),
            ...(index$1.Lg(this.model) ? [index$1.ih.AxisLabels] : []),
            ...(index$1.Bg(this.model) ? [index$1.ih.GuideLabels] : []),
            ...(index$1.Ug(this.model) ? [index$1.ih.DataLabels] : []),
        ];
        // hide "data labels" for scatter plot
        if (index$1.Tg(this.model)) {
            this.textProperties = this.textProperties.filter((prop) => prop !== index$1.ih.DataLabels);
        }
        // initialize with all possible symbol props
        this.symbolProperties = [
            index$1.ih.Background,
            ...(index$1.Lg(this.model) ? [index$1.ah.AxisLines] : []),
            ...(index$1.Dg(this.model) ? [index$1.ah.GridLines] : []),
            ...(index$1.Og(this.model) ? [index$1.ah.LeaderLines] : []),
        ];
        const textElements = this.textProperties.map((prop) => this.renderTextElement(prop, this.textPropertyChange));
        const symbolElements = this.symbolProperties.map((prop) => prop === index$1.ih.Background
            ? this.renderTextElement(prop, this.backgroundChange)
            : this.renderTextElement(prop, this.symbolPropertyChange));
        return { textElements, symbolElements };
    }
    /**
     * @category Lifecycle
     */
    render() {
        const { textElements, symbolElements } = this.renderFormatElements();
        return (index.h(index.Host, { key: '523a0c782757f1694dc7017fa56e93fe22cbe295' }, index.h("div", { key: 'baf66725033a7be92829d53938f1049fc6825297', class: HTMLClasses$5.sectionLabel }, this.strings.textElements), index.h("calcite-list", { key: '4414c67b550748c4cd85e1c32635bbc1ec8a7d7c', label: "", class: HTMLClasses$5.elementList, selectionMode: "multiple", selectionAppearance: "border", onCalciteListChange: this.correctTextElementSelection }, textElements), index.h("div", { key: 'b779db76e4266dcc9db878698a17a32ecf3124c4', class: HTMLClasses$5.sectionLabel }, this.strings.symbolElements), index.h("calcite-list", { key: '5ca5aaf463f6506566e67c85aee7a87b80d99944', label: "", class: HTMLClasses$5.elementList, selectionMode: "single", selectionAppearance: "border" }, symbolElements)));
    }
    /**
     * @category Private
     */
    formatPopoverChange(open) {
        this.arcgisChartsConfigFormatPopoverChange.emit({
            open,
            element: this.formatPopover,
        });
        this.arcgisChartsConfigPopoverOpenChange.emit({
            open,
        });
    }
    /**
     * @param keys
     * @param elementValue
     * @category Private
     */
    updateSelectedElement(keys, elementValue) {
        this.selectedElement = undefined;
        if (elementValue === undefined) {
            const initValue = cloneDeep.cloneDeep(this.getFormatValue(keys[0]));
            this.selectedElement = keys?.reduce((acc, text) => {
                const textProp = this.getFormatValue(text);
                const newTextProp = mergeWith$1(acc, textProp, this.mergeFormatValues);
                return newTextProp;
            }, initValue);
        }
        else {
            let defaultValue = cloneDeep.cloneDeep(elementValue);
            if (isEmpty.isEmpty(elementValue)) {
                if (this.selectedSymbols?.length > 0) {
                    defaultValue = cloneDeep.cloneDeep(defaultSymbolProps);
                }
                if (this.selectedTexts?.length > 0) {
                    defaultValue = cloneDeep.cloneDeep(defaultTextProps);
                }
            }
            this.selectedElement = defaultValue;
        }
    }
    /**
     * @param value
     * @category Private
     */
    initSelectedTexts(value) {
        let defaultValue = cloneDeep.cloneDeep(value);
        if (isEmpty.isEmpty(value)) {
            defaultValue = cloneDeep.cloneDeep(defaultTextProps);
        }
        this.selectedElement = defaultValue;
    }
    /**
     * @param value
     * @category Private
     */
    initSelectedSymbols(value) {
        let defaultValue = cloneDeep.cloneDeep(value);
        if (isEmpty.isEmpty(value)) {
            defaultValue = cloneDeep.cloneDeep(defaultSymbolProps);
        }
        this.selectedElement = defaultValue;
    }
    /**
     * @category Private
     */
    setupFormatPopover() {
        // remove formatPopover
        this.formatPopover = restJsObjectLiterals.Jy(this.formatPopover);
        const element = this.selectedElement;
        // formatPopover config
        const popoverConfig = {
            selectedElement: this.selectedElement,
            referenceElement: this.hostElement,
            updateSymbolProps: this.updateSymbolProps,
            updateTextProps: this.updateTextProps,
            updateBackground: this.updateBackground,
            openChange: this.openChange,
            hostElement: this.hostElement,
            placement: "auto",
            popoverClose: this.formatPopoverClose,
        };
        // create a new formatPopover
        this.formatPopover = restJsObjectLiterals.Zy(restJsObjectLiterals.Qy.FormatPopover, popoverConfig);
        if (element?.type === restJsObjectLiterals.RESTSymbolType.TS ||
            element?.type === restJsObjectLiterals.RESTSymbolType.SLS ||
            // To check if the selected element is background.
            Array.isArray(this.selectedElement)) {
            this.formatPopover.open = true;
            this.addFormatPopover();
        }
        else {
            this.formatPopover.open = false;
            this.removeFormatPopover();
        }
    }
    /**
     * @category Private
     */
    removeFormatPopover() {
        if (this.formatPopover !== null) {
            this.formatPopover.open = false;
            this.formatPopover = restJsObjectLiterals.Jy(this.formatPopover);
        }
        this.formatPopoverChange(false);
    }
    /**
     * @category Private
     */
    addFormatPopover() {
        if (this.formatPopover !== null && !document.body.contains(this.formatPopover)) {
            document.body.appendChild(this.formatPopover);
        }
        this.formatPopoverChange(true);
    }
    /**
     * @category Private
     */
    getFormatValue(formatKey) {
        switch (formatKey) {
            case index$1.ih.Title:
                return this.model.getTitleSymbol();
            case index$1.ih.Description:
                return this.model.getDescriptionSymbol();
            case index$1.ih.XAxisTitle:
                return index$1.Lg(this.model) ? this.model.getXAxisTitleSymbol() : undefined;
            case index$1.ih.YAxisTitle:
                return index$1.Dg(this.model) ? this.model.getYAxisTitleSymbol() : undefined;
            case index$1.ih.AxisLabels:
                return index$1.Lg(this.model) ? this.model.getAxisLabelsSymbol() : undefined;
            case index$1.ih.GuideLabels:
                return index$1.Bg(this.model) ? this.model.getGuideLabelsSymbol() : undefined;
            case index$1.ih.LegendText:
                return index$1.Mg(this.model) ? this.model.getLegendTextSymbol() : undefined;
            case index$1.ih.LegendTitle:
                return index$1.Mg(this.model) ? this.model.getLegendTitleSymbol() : undefined;
            case index$1.ih.DataLabels:
                return index$1.Ug(this.model) ? this.model.getDataLabelsSymbol() : undefined;
            case index$1.ah.AxisLines:
                return index$1.Lg(this.model) ? this.model.getAxisLinesSymbol() : undefined;
            case index$1.ah.GridLines:
                return index$1.Dg(this.model) ? this.model.getGridLinesSymbol() : undefined;
            case index$1.ah.LeaderLines:
                return index$1.Og(this.model) ? this.model.getLeaderLinesSymbol() : undefined;
            case index$1.ih.Background:
                return this.model.getBackgroundColor();
            default:
                return undefined;
        }
    }
    /**
     * @category Private
     */
    setFormatValue(formatKey, value) {
        switch (formatKey) {
            case index$1.ih.Title:
                if (restJsObjectLiterals.ey(value)) {
                    this.model.setTitleSymbol(value);
                }
                break;
            case index$1.ih.Description:
                if (restJsObjectLiterals.ey(value)) {
                    this.model.setDescriptionSymbol(value);
                }
                break;
            case index$1.ih.XAxisTitle:
                if (index$1.Lg(this.model) && restJsObjectLiterals.ey(value)) {
                    this.model.setXAxisTitleSymbol(value);
                }
                break;
            case index$1.ih.YAxisTitle:
                if (index$1.Dg(this.model) && restJsObjectLiterals.ey(value)) {
                    this.model.setYAxisTitleSymbol(value);
                }
                break;
            case index$1.ih.AxisLabels:
                if (index$1.Lg(this.model) && restJsObjectLiterals.ey(value)) {
                    this.model.setAxisLabelsSymbol(value);
                }
                break;
            case index$1.ih.GuideLabels:
                if (index$1.Bg(this.model) && restJsObjectLiterals.ey(value)) {
                    this.model.setGuideLabelsSymbol(value);
                }
                break;
            case index$1.ih.LegendText:
                if (index$1.Mg(this.model) && restJsObjectLiterals.ey(value)) {
                    this.model.setLegendTextSymbol(value);
                }
                break;
            case index$1.ih.LegendTitle:
                if (index$1.Mg(this.model) && restJsObjectLiterals.ey(value)) {
                    this.model.setLegendTitleSymbol(value);
                }
                break;
            case index$1.ih.DataLabels:
                if (index$1.Ug(this.model) && restJsObjectLiterals.ey(value)) {
                    this.model.setDataLabelsSymbol(value);
                }
                break;
            case index$1.ah.AxisLines:
                if (index$1.Lg(this.model) && restJsObjectLiterals.Jc(value)) {
                    this.model.setAxisLinesSymbol(value);
                }
                break;
            case index$1.ah.GridLines:
                if (index$1.Dg(this.model) && restJsObjectLiterals.Jc(value)) {
                    this.model.setGridLinesSymbol(value);
                }
                break;
            case index$1.ah.LeaderLines:
                if (index$1.Og(this.model) && restJsObjectLiterals.Jc(value)) {
                    this.model.setLeaderLinesSymbol(value);
                }
                break;
            case index$1.ih.Background:
                if (Array.isArray(value)) {
                    this.model.setBackgroundColor(value);
                }
                break;
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
};
ArcgisChartsConfigFormat.style = ArcgisChartsConfigFormatStyle0;

const HTMLClasses$4 = {
    textInput: "text-input",
    disableResize: "disable-resize",
    label: "label",
    labelContainer: "label-container",
    select: "select",
};

const arcgisChartsConfigGeneralCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}:host{display:flex;flex-direction:column;margin-top:var(--arcgis-charts-top-section-margin)}.text-input{margin-bottom:var(--arcgis-charts-inter-section-margin)}.select{margin-bottom:var(--arcgis-charts-inter-section-margin)}.label{display:flex;justify-content:space-between}.label-container{display:flex;flex-direction:column;margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}";
const ArcgisChartsConfigGeneralStyle0 = arcgisChartsConfigGeneralCss;

const ArcGISChartsConfigGeneral = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        /**
         * @category Event handler
         */
        this.setChartTitle = (e) => {
            const { value: chartTitle } = e.target;
            this.isChartTitleInvalid = isEmpty.isEmpty(chartTitle.trim());
            chartUiUtils.modifyCalciteInputStatus({
                inputElement: this.characterLimitInputElement,
                status: this.isChartTitleInvalid ? chartUiUtils.UIInputStatus.INVALID : chartUiUtils.UIInputStatus.IDLE,
            });
            if (!this.isChartTitleInvalid) {
                this.model.setTitleText(chartTitle);
            }
        };
        /**
         * @category Event handler
         */
        this.setChartLegendTitle = (e) => {
            const { value } = e.target;
            if (value !== undefined && index$1.Mg(this.model)) {
                this.model.setLegendTitleText(value);
            }
        };
        /**
         * @category Event handler
         */
        this.setChartXAxisTitle = (e) => {
            const { value } = e.target;
            if (value !== undefined && index$1.Lg(this.model)) {
                this.model.setXAxisTitleText(value);
            }
        };
        /**
         * @category Event handler
         */
        this.setChartYAxisTitle = (e) => {
            const { value } = e.target;
            if (value !== undefined && index$1.Dg(this.model)) {
                this.model.setYAxisTitleText(value);
            }
        };
        /**
         * @category Event handler
         */
        this.setChartDescription = (e) => {
            const { value } = e.target;
            if (value !== undefined) {
                this.model.setDescriptionText(value);
            }
        };
        /**
         * @category Event handler
         */
        this.enableChartTitle = (e) => {
            const value = e.target.checked;
            this.model.setChartTitleVisibility(value);
        };
        /**
         * @category Event handler
         */
        this.enableXAxisTitle = (e) => {
            const value = e.target.checked;
            if (index$1.Lg(this.model)) {
                this.model.setXAxisTitleVisibility(value);
            }
        };
        /**
         * @category Event handler
         */
        this.enableYAxisTitle = (e) => {
            const value = e.target.checked;
            if (index$1.Dg(this.model)) {
                this.model.setYAxisTitleVisibility(value);
            }
        };
        /**
         * @category Event handler
         */
        this.enableLegendTitle = (e) => {
            const value = e.target.checked;
            if (index$1.Mg(this.model)) {
                this.model.setLegendTitleVisibility(value);
            }
        };
        /**
         * @category Event handler
         */
        this.enableDescription = (e) => {
            const value = e.target.checked;
            this.model.setDescriptionVisibility(value);
        };
        /**
         * @category Event handler
         */
        this.legendPositionChange = (e) => {
            const selectedItem = e.target?.selectedItems[0];
            const alignment = selectedItem?.value;
            if (index$1.Mg(this.model)) {
                this.model.setLegendPosition(alignment);
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        this.model = undefined;
        this.open = false;
        this.isChartTitleInvalid = false;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * Renders the options for a dropdown list of legend positions
     * @category Render UX
     */
    renderLegendPositions() {
        const options = index$1.Mg(this.model)
            ? [
                index.h("calcite-combobox-item", { value: chartObjectLiterals.WebChartLegendPositions.Right, textLabel: this.strings.legendRightPosition, selected: this.model.getLegendPosition() === chartObjectLiterals.WebChartLegendPositions.Right, icon: "right-edge" }),
                index.h("calcite-combobox-item", { value: chartObjectLiterals.WebChartLegendPositions.Left, textLabel: this.strings.legendLeftPosition, selected: this.model.getLegendPosition() === chartObjectLiterals.WebChartLegendPositions.Left, icon: "left-edge" }),
                index.h("calcite-combobox-item", { value: chartObjectLiterals.WebChartLegendPositions.Top, textLabel: this.strings.legendTopPosition, selected: this.model.getLegendPosition() === chartObjectLiterals.WebChartLegendPositions.Top, icon: "upload-to" }),
                index.h("calcite-combobox-item", { value: chartObjectLiterals.WebChartLegendPositions.Bottom, textLabel: this.strings.legendBottomPosition, selected: this.model.getLegendPosition() === chartObjectLiterals.WebChartLegendPositions.Bottom, icon: "download-to" }),
            ]
            : [];
        return options;
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (index.h(index.Host, { key: '8620e8fa7bb1ac7d7ec1a3bc8c4a43af2367c4b3' }, index.h("div", { key: '1f3972cabb8e1fdfe97e8f579b56219e61f5c063', class: HTMLClasses$4.labelContainer }, index.h("calcite-label", { key: '76e3786bac4b09177f3a86f3a114d8991707ff12', layout: "inline-space-between", class: HTMLClasses$4.label }, this.strings.chartTitle, index.h("calcite-switch", { key: '82e83d84250f8ebbf8e7053ed4354eb170a9110d', checked: this.model.getChartTitleVisibility(), onCalciteSwitchChange: this.enableChartTitle })), index.h("calcite-input", { key: '0185f7c4a559287ffb0d25547d788a5fce2021e3', class: HTMLClasses$4.textInput, type: "text", disabled: !this.model.getChartTitleVisibility(), value: this.model.getTitleText(), onCalciteInputInput: this.setChartTitle, ref: (e) => {
                this.characterLimitInputElement = e;
            } }), index.h("arcgis-charts-config-invalid-input-message", { key: '9b6b9b5ccc83d9f02231ef2ed526dc62a03e1c00', invalidInputMessage: this.strings.emptyChartTitle, isInvalid: this.isChartTitleInvalid })), index$1.Lg(this.model)
            ? [
                index.h("div", { class: HTMLClasses$4.labelContainer }, index.h("calcite-label", { layout: "inline-space-between", class: HTMLClasses$4.label }, this.strings.xAxisTitle, index.h("calcite-switch", { checked: this.model.getXAxisTitleVisibility(), onCalciteSwitchChange: this.enableXAxisTitle })), index.h("calcite-input", { class: HTMLClasses$4.textInput, type: "text", disabled: !this.model.getXAxisTitleVisibility(), value: this.model.getXAxisTitleText(), onCalciteInputInput: this.setChartXAxisTitle })),
                index$1.Dg(this.model) ? (index.h("div", { class: HTMLClasses$4.labelContainer }, index.h("calcite-label", { layout: "inline-space-between", class: HTMLClasses$4.label }, this.strings.yAxisTitle, index.h("calcite-switch", { checked: this.model.getYAxisTitleVisibility(), onCalciteSwitchChange: this.enableYAxisTitle })), index.h("calcite-input", { class: HTMLClasses$4.textInput, tabindex: "1", type: "text", disabled: !this.model.getYAxisTitleVisibility(), value: this.model.getYAxisTitleText(), onCalciteInputInput: this.setChartYAxisTitle }))) : null,
            ]
            : null, index$1.Mg(this.model) ? (index.h("div", { class: HTMLClasses$4.labelContainer }, index.h("calcite-label", { layout: "inline-space-between", class: HTMLClasses$4.label }, this.strings.legendTitle, index.h("calcite-switch", { checked: this.model.getLegendTitleVisibility(), onCalciteSwitchChange: this.enableLegendTitle })), index.h("calcite-input", { class: HTMLClasses$4.textInput, type: "text", disabled: !this.model.getLegendTitleVisibility(), value: this.model.getLegendTitleText(), onCalciteInputInput: this.setChartLegendTitle }))) : null, index.h("div", { key: '104bf24dd4fff16d40d71356104518687f7e53f2', class: HTMLClasses$4.labelContainer }, index.h("calcite-label", { key: '88742246b76c54dc2d31b01f8b80500c95a162a9', layout: "inline-space-between", class: HTMLClasses$4.label }, this.strings.legendPosition), index.h("calcite-combobox", { key: '7491128f64be6ce5a624098da71c43f744f909eb', clearDisabled: true, label: "", class: HTMLClasses$4.select, onCalciteComboboxChange: this.legendPositionChange, "selection-mode": "single" }, this.renderLegendPositions())), index.h("div", { key: '808bd77c5bc9dfa32b8b9e4d7a09740791c1931c', class: HTMLClasses$4.labelContainer }, index.h("calcite-label", { key: 'c288b1b80312b866c765dea7e0b54beb4dea2fdc', layout: "inline-space-between", class: HTMLClasses$4.label }, this.strings.description, index.h("calcite-switch", { key: '5c709f597c9e05b6b02d72296b7cbfb6c23e3bf1', checked: this.model.getDescriptionVisibility(), onCalciteSwitchChange: this.enableDescription })), index.h("calcite-text-area", { key: '8ebf5b74430ec33c07c739330d1549d05d03a58c', disabled: !this.model.getDescriptionVisibility(), value: this.model.getDescriptionText(), onCalciteTextAreaInput: this.setChartDescription }))));
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
};
ArcGISChartsConfigGeneral.style = ArcgisChartsConfigGeneralStyle0;

const HTMLClasses$3 = {
    row: "row",
    column: "column",
    colorPicker: "color-picker",
};

const HTMLClasses$2 = {
    addGuide: "add-guide",
    noMessages: "no-messages",
};
/**
 * Gets the guide list position based on the guide index and orientation.
 * @param index The index of the guide in the list of guides for the given axis orientation.
 * @param orientation The axis orientation of the guide.
 * @param model The model with guides.
 */
function getGuideListPosition(index, orientation, model) {
    const xGuidesLength = index$1.Rg(model) ? (model.getXGuidesLength() ?? 0) : 0;
    return orientation === index$1.nh.X ? index : xGuidesLength + index;
}

const arcgisChartsConfigGuideCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}:host{display:flex;flex-direction:column}.row{display:flex;flex-direction:row;-moz-column-gap:var(--arcgis-charts-inter-section-margin);column-gap:var(--arcgis-charts-inter-section-margin)}.column{display:flex;flex-direction:column;flex-wrap:wrap;flex-grow:1}.column>calcite-input{margin-bottom:0.5rem;flex-grow:2}.column>calcite-input[type=number]{margin-bottom:0.5rem}input{padding:0.5rem}.label{display:flex;flex-direction:row;justify-content:space-between;margin-bottom:var(--arcgis-charts-intra-section-margin);flex-grow:1}.color-picker{border:1px solid var(--calcite-color-border-2);box-shadow:none;margin-bottom:var(--arcgis-charts-inter-section-margin)}.delete-guide{display:flex;flex-direction:row-reverse;height:2rem;margin:0 1rem;font-weight:550}:host([dir=rtl]) .delete-guide{flex-direction:row}";
const ArcgisChartsConfigGuideStyle0 = arcgisChartsConfigGuideCss;

const ArcgisChartsConfigGuide = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigGuideChange = index.createEvent(this, "arcgisChartsConfigGuideChange", 7);
        this.arcgisChartsConfigGuidePopoverChange = index.createEvent(this, "arcgisChartsConfigGuidePopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = index.createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        /**
         * @category Event handler
         */
        this.onColorElementSelect = () => {
            if (this.guidePopover?.open === true) {
                this.removeGuidePopover();
            }
            else {
                this.setupGuidePopover();
            }
        };
        /**
         * @category Event handler
         */
        this.setGuideStart = (e) => {
            const { value } = e.target;
            if (this.startCalciteInput !== undefined) {
                if (value === "") {
                    // Set calcite input status to invalid
                    chartUiUtils.modifyCalciteInputStatus({
                        inputElement: this.startCalciteInput,
                        status: chartUiUtils.UIInputStatus.INVALID,
                    });
                }
                else {
                    // Set start value
                    this.model.setGuideStart(value, this.index, this.orientation);
                    this.symbolChange();
                    // Emit guide change event
                    this.arcgisChartsConfigGuideChange.emit({
                        index: this.index,
                        orientation: this.orientation,
                        isDelete: false,
                    });
                    // Set calcite input status to idle
                    chartUiUtils.modifyCalciteInputStatus({
                        inputElement: this.startCalciteInput,
                        status: chartUiUtils.UIInputStatus.IDLE,
                    });
                }
            }
            // Make sure popover is closed
            if (this.guidePopover?.open === true) {
                this.removeGuidePopover();
            }
        };
        /**
         * @category Event handler
         */
        this.setGuideEnd = (e) => {
            const { value } = e.target;
            if (this.endCalciteInput !== undefined) {
                // Set end value
                this.model.setGuideEnd(value === "" ? null : value, this.index, this.orientation);
                this.symbolChange();
                // Emit guide change event
                this.arcgisChartsConfigGuideChange.emit({
                    index: this.index,
                    orientation: this.orientation,
                    isDelete: false,
                });
                // Set calcite input status to idle
                chartUiUtils.modifyCalciteInputStatus({
                    inputElement: this.endCalciteInput,
                    status: chartUiUtils.UIInputStatus.IDLE,
                });
            }
            // Make sure popover is closed
            if (this.guidePopover?.open === true) {
                this.removeGuidePopover();
            }
        };
        /**
         * @category Event handler
         */
        this.setGuideDateTimeRange = () => {
            const payloadMin = this.calculatedMinMaxBounds?.find((axis) => axis.isXAxis)?.minimum;
            const payloadMax = this.calculatedMinMaxBounds?.find((axis) => axis.isXAxis)?.maximum;
            // get default start and end from the payload if available, otherwise use current date
            const defaultStartDateTime = typeof payloadMin === "number" ? new Date(payloadMin) : new Date();
            const defaultEndDateTime = typeof payloadMax === "number" ? new Date(payloadMax) : new Date();
            const currentTimeZone = new window.Intl.DateTimeFormat().resolvedOptions().timeZone;
            const convertedTimeZone = restJsObjectLiterals.Bn(this.timeZone) ?? currentTimeZone;
            // get default start date and time strings formatted for calcite date picker
            const defaultStartDateString = restJsObjectLiterals.Pn(defaultStartDateTime, convertedTimeZone);
            const defaultStartTimeString = restJsObjectLiterals.Nn(defaultStartDateTime, convertedTimeZone);
            // get default end date and time string formatted for calcite date picker
            const defaultEndDateString = restJsObjectLiterals.Pn(defaultEndDateTime, convertedTimeZone);
            const defaultEndTimeString = restJsObjectLiterals.Nn(defaultEndDateTime, convertedTimeZone);
            const startDateStringFromInput = this.startDateCalciteInput?.value ?? "";
            const startDateString = startDateStringFromInput === "" ? defaultStartDateString : startDateStringFromInput;
            const startTimeStringFromInput = this.startTimeCalciteInput?.value ?? "";
            const startTimeString = startTimeStringFromInput === "" ? defaultStartTimeString : startTimeStringFromInput;
            const endDateStringFromInput = this.endDateCalciteInput?.value ?? "";
            const endDateString = endDateStringFromInput === "" ? defaultEndDateString : endDateStringFromInput;
            const endTimeStringFromInput = this.endTimeCalciteInput?.value ?? "";
            const endTimeString = endTimeStringFromInput === "" ? defaultEndTimeString : endTimeStringFromInput;
            let changeOccurred = false;
            // Array is technically a possible type for `startDateString`, though it should not happen since the inputs that trigger this event are not set with `range: true`. But we still have to check it for type validity.
            if (!Array.isArray(startDateString) && startDateString !== undefined && startTimeString !== undefined) {
                const startDateTime = `${startDateString}T${startTimeString}`;
                // Set start value
                this.model.setGuideStart(startDateTime, this.index, this.orientation);
                changeOccurred = true;
            }
            // Array is technically a possible type for `endDateString`, though it should not happen since the inputs that trigger this event are not set with `range: true`. But we still have to check it for type validity.
            if (!Array.isArray(endDateString) && endDateString !== undefined && endTimeString !== undefined) {
                // If neither date nor time is set, set end value to null
                const endDateTime = endDateStringFromInput === "" ? undefined : `${endDateString}T${endTimeString}`;
                // Set end value
                this.model.setGuideEnd(endDateTime, this.index, this.orientation);
                changeOccurred = true;
            }
            if (changeOccurred) {
                this.symbolChange();
                // Emit guide change event
                this.arcgisChartsConfigGuideChange.emit({
                    index: this.index,
                    orientation: this.orientation,
                    isDelete: false,
                });
                // Make sure popover is closed
                if (this.guidePopover?.open === true) {
                    this.removeGuidePopover();
                }
            }
        };
        /**
         * @category Event handler
         */
        this.colorChange = (e) => {
            const color = e.detail;
            const start = this.model.getGuideStart(this.index, this.orientation);
            const end = this.model.getGuideEnd(this.index, this.orientation);
            if (restJsObjectLiterals.Kl(start, end) === restJsObjectLiterals.RESTSymbolType.SLS) {
                // Edge Case:
                const defaultStyle = cloneDeep.cloneDeep(_default.defaultGuide.style);
                const currentStyle = this.model.getGuideStyle(this.index, this.orientation);
                // Merge the new color into the default and current styles
                const lineStyle = {
                    ...defaultStyle,
                    ...(restJsObjectLiterals.Jc(currentStyle) ? currentStyle : {}),
                    color,
                };
                this.lineStyleChange({ detail: lineStyle });
            }
            else {
                // Main Case:
                // If the guide is not a line style, set the color directly
                this.setColor(color);
            }
        };
        /**
         * @category Event handler
         */
        this.symbolChange = (e) => {
            const newSymbol = e?.detail;
            const start = this.model.getGuideStart(this.index, this.orientation);
            const end = this.model.getGuideEnd(this.index, this.orientation);
            if (restJsObjectLiterals.Kl(start, end) === restJsObjectLiterals.RESTSymbolType.SLS) {
                const defaultStyle = cloneDeep.cloneDeep(_default.defaultGuide.style);
                const currentStyle = this.model.getGuideStyle(this.index, this.orientation);
                // Merge the new symbol into the default and current styles
                const lineStyle = {
                    ...defaultStyle,
                    ...(restJsObjectLiterals.Jc(currentStyle) ? currentStyle : {}),
                    ...(restJsObjectLiterals.Jc(newSymbol) ? newSymbol : {}),
                };
                this.lineStyleChange({ detail: lineStyle });
            }
            else if (newSymbol?.color !== undefined) {
                // Edge case
                this.setColor(newSymbol.color);
            }
        };
        /**
         * @category Event handler
         */
        this.setGuideName = (e) => {
            const name = e.target.value;
            this.model.setGuideName(name, this.index, this.orientation);
            this.arcgisChartsConfigGuideChange.emit({
                index: this.index,
                orientation: this.orientation,
                isDelete: false,
            });
        };
        /**
         * @category Event handler
         */
        this.setGuideLabel = (e) => {
            const labelText = e.target.value;
            this.model.setGuideLabelText(labelText, this.index, this.orientation);
            this.arcgisChartsConfigGuideChange.emit({
                index: this.index,
                orientation: this.orientation,
                isDelete: false,
            });
        };
        /**
         * @category Event handler
         */
        this.setGuideRendered = (e) => {
            const value = e.target?.selectedItem?.value;
            if (value !== undefined) {
                const above = value === this.strings.inFront;
                this.model.setGuideAbove(above, this.index, this.orientation);
                this.arcgisChartsConfigGuideChange.emit({
                    index: this.index,
                    orientation: this.orientation,
                    isDelete: false,
                });
            }
        };
        /**
         * @category Event handler
         */
        this.lineStyleChange = (e) => {
            const guideStyle = e.detail;
            this.model.setGuideStyle(guideStyle, this.index, this.orientation);
            this.arcgisChartsConfigGuideChange.emit({
                index: this.index,
                orientation: this.orientation,
                isDelete: false,
            });
        };
        /**
         * Creates a tooltip for the hovered action.
         * @category Event handler
         */
        this.createTooltip = (e) => {
            const actionElement = e.target;
            this.tooltip = chartUiUtils.createActionTooltip(actionElement);
            // Set tooltip content to reflect the associated action
            switch (actionElement.icon) {
                case "view-visible":
                    this.tooltip.innerHTML = this.strings.hideGuide;
                    break;
                case "view-hide":
                    this.tooltip.innerHTML = this.strings.showGuide;
                    break;
                case "trash":
                default:
                    this.tooltip.innerHTML = this.strings.deleteGuide;
                    break;
            }
            // append tooltip to the document body instead of action element
            // to avoid tooltip being cut off by calcite panel header element
            document.body.appendChild(this.tooltip);
        };
        /**
         * Toggles guide visibility from action click.
         * @category Event handler
         */
        this.toggleGuide = () => {
            const showGuide = this.model.getGuideVisibility(this.index, this.orientation);
            this.model.setGuideVisibility(!showGuide, this.index, this.orientation);
        };
        /**
         * Destroys tooltip for the action that was being hovered.
         * @category Event handler
         */
        this.destroyTooltip = () => {
            chartUiUtils.destroyActionTooltip(this.tooltip);
        };
        /**
         * Deletes guide from action click.
         * @category Event handler
         */
        this.deleteGuide = () => {
            this.destroyTooltip(); // remove any existing tooltip
            // Delete guide from config
            if (this.orientation === index$1.nh.X && index$1.Rg(this.model)) {
                this.model.deleteXAxisGuide(this.index);
            }
            else if (this.orientation === index$1.nh.Y && index$1.Ng(this.model)) {
                this.model.deleteYAxisGuide(this.index);
            }
            // Emit guide change event with delete flag
            this.arcgisChartsConfigGuideChange.emit({
                index: this.index,
                orientation: this.orientation,
                isDelete: true,
            });
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        this.model = undefined;
        this.timeZone = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.index = undefined;
        this.orientation = undefined;
        this.latestGuidePosition = 0;
        this.guidePopover = undefined;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Render UX
     */
    renderColorElement() {
        const style = this.model.getGuideStyle(this.index, this.orientation);
        const [r, g, b, a] = [...(style?.color ?? [1, 1, 1, 255])];
        const start = this.model.getGuideStart(this.index, this.orientation);
        const end = this.model.getGuideEnd(this.index, this.orientation);
        const lineStyleType = restJsObjectLiterals.Jc(style) ? chartUiUtils.getLineStyleType(style.style) : restJsObjectLiterals.RESTSimpleLineSymbolStyle.Solid;
        const icon = restJsObjectLiterals.Kl(start, end) === restJsObjectLiterals.RESTSymbolType.SLS ? `line-${lineStyleType}` : "square-f";
        return (index.h("calcite-list", { label: "", selectionMode: "single", selectionAppearance: "border" }, index.h("calcite-list-item", { value: this.strings.style, class: HTMLClasses$3.colorPicker, label: this.strings.style, selected: this.guidePopover?.open, onClick: this.onColorElementSelect, ref: (e) => {
                this.colorElement = e;
            } }, index.h("calcite-icon", { slot: "content-end", icon: icon, style: { color: `rgba(${r},${g},${b},${a / 255})` } }))));
    }
    get isXAxisDateField() {
        return (this.orientation === index$1.nh.X &&
            index$1.Dg(this.model) &&
            this.model.getXAxisValueFormat()?.type === chartObjectLiterals.WebChartTypes.DateAxisFormat);
    }
    /**
     * @category Lifecycle
     */
    render() {
        const start = this.model.getGuideStart(this.index, this.orientation);
        const end = this.model.getGuideEnd(this.index, this.orientation);
        const name = this.model.getGuideName(this.index, this.orientation);
        const labelText = this.model.getGuideLabelText(this.index, this.orientation);
        const above = this.model.getGuideAbove(this.index, this.orientation);
        const showGuide = this.model.getGuideVisibility(this.index, this.orientation);
        const isXAxisDateField = this.isXAxisDateField;
        return (index.h(index.Host, { key: '8c817eeb752ad9b070e4d6dd883fd72629bbd6cc' }, index.h("calcite-block", { key: 'f93e4030a29f72881d4c83832d3f100fc80a2fa5', heading: name ?? "", open: this.latestGuidePosition === getGuideListPosition(this.index, this.orientation, this.model), collapsible: true, messageOverrides: {
                expand: this.strings.expand,
                collapse: this.strings.collapse,
            } }, index.h("calcite-action", { key: '8f99980a235427e5304a37684a6206491074f3d8', slot: "control", text: "", icon: showGuide ? "view-visible" : "view-hide", onClick: this.toggleGuide, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip }), index.h("calcite-action", { key: '03cab56e010731d07d4aebe5a6cb49d194194cd1', slot: "control", text: "", icon: "trash", onClick: this.deleteGuide, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip }), index.h("div", { key: 'f74039a1d4d8ca7f1858688e3b4674a2f96ebb7b', class: HTMLClasses$3.row }, index.h("calcite-label", { key: '8b924bedf8f4e5f012c972b0da0cb34847fa855e', class: HTMLClasses$3.column }, this.strings.start, isXAxisDateField ? (index.h("calcite-input-date-picker", { value: this.getDateStringFromBound(start), required: true, scale: "s", placement: "bottom-end", onCalciteInputDatePickerChange: this.setGuideDateTimeRange, ref: (el) => {
                this.startDateCalciteInput = el;
            } })) : (index.h("calcite-input", { type: "number", required: true, onCalciteInputInput: this.setGuideStart, onKeyDown: chartUiUtils.blockNumericE, numberButtonType: "none", value: start?.toString(), ref: (el) => {
                this.startCalciteInput = el;
            } }))), index.h("calcite-label", { key: '26b1f9e3b4d569297e03cf6968b865ffcfc36bec', class: HTMLClasses$3.column }, this.strings.end, isXAxisDateField ? (index.h("calcite-input-date-picker", { value: this.getDateStringFromBound(end), scale: "s", placement: "bottom-end", onCalciteInputDatePickerChange: this.setGuideDateTimeRange, ref: (el) => {
                this.endDateCalciteInput = el;
            } })) : (index.h("calcite-input", { type: "number", onCalciteInputInput: this.setGuideEnd, onKeyDown: chartUiUtils.blockNumericE, numberButtonType: "none", value: end?.toString(), ref: (el) => {
                this.endCalciteInput = el;
            } })))), isXAxisDateField ? (index.h("div", { key: "time-picker-row", class: HTMLClasses$3.row }, start !== null && start !== undefined ? (index.h("calcite-label", { class: HTMLClasses$3.column }, index.h("calcite-input-time-picker", { value: this.getTimeStringFromBound(start), scale: "s", onCalciteInputTimePickerChange: this.setGuideDateTimeRange, ref: (el) => {
                this.startTimeCalciteInput = el;
            } }))) : null, end !== null && end !== undefined ? (index.h("calcite-label", { class: HTMLClasses$3.column }, index.h("calcite-input-time-picker", { value: this.getTimeStringFromBound(end), scale: "s", onCalciteInputTimePickerChange: this.setGuideDateTimeRange, ref: (el) => {
                this.endTimeCalciteInput = el;
            } }))) : null)) : null, index.h("div", { key: '904ad5c5337e020effc9a20758a30973757cda1f', class: HTMLClasses$3.row }, index.h("div", { key: '19598c5782c32c77e9717c0d658163971cf1286a', class: HTMLClasses$3.column }, this.renderColorElement())), index.h("div", { key: '82f0ef20f9572c9b5726ac25e2aef8f6102c692b', class: HTMLClasses$3.row }, index.h("calcite-label", { key: 'ebf579dcebf2569d3da5291a270bdb38ced9d5e2', class: HTMLClasses$3.column }, this.strings.guideName, index.h("calcite-input", { key: '0d5f0b13f83348201acddea06647952befa120ba', type: "text", value: name, onCalciteInputInput: this.setGuideName }))), index.h("div", { key: '976a0a1d3ba08738b791bc442d8a4f6a640301c0', class: HTMLClasses$3.row }, index.h("calcite-label", { key: 'b05e8ed9ba5d38cdb6eb3088b1dbf888e6a620ca', class: HTMLClasses$3.column }, this.strings.guideLabel, index.h("calcite-input", { key: '0ec3d3fdb8e1f6eedefa7a0d48172fb6f9f9c29a', type: "text", value: labelText, onCalciteInputInput: this.setGuideLabel }))), index.h("div", { key: '5c35220f7c9e12328deec72b26b804b5fd0f5132', class: HTMLClasses$3.row }, index.h("calcite-label", { key: '9df5baefa3123ffb10eed331504a4682eb1e1d05', class: HTMLClasses$3.column }, this.strings.display, index.h("calcite-segmented-control", { key: '731fb5d3dd5d6f4ff334e88c2142b1c8deb7bab4', onCalciteSegmentedControlChange: this.setGuideRendered, scale: "s" }, index.h("calcite-segmented-control-item", { key: '58815926a592769fb1707e25d6ecb2b3560337f0', checked: above, value: this.strings.inFront }, this.strings.inFront), index.h("calcite-segmented-control-item", { key: '8b0056b2a87b1a767d382d7fa0055a7fc64c93ae', checked: !above, value: this.strings.inBack }, this.strings.inBack)))))));
    }
    /**
     * @category Lifecycle
     */
    componentDidLoad() {
        if (this.isXAxisDateField) {
            this.setGuideDateTimeRange();
        }
    }
    /**
     * @category Private
     */
    guidePopoverChange(open) {
        this.arcgisChartsConfigGuidePopoverChange.emit({
            open,
            element: this.guidePopover,
        });
        this.arcgisChartsConfigPopoverOpenChange.emit({
            open,
        });
    }
    /**
     * @category Private
     */
    setupGuidePopover() {
        if (this.guidePopover === undefined) {
            // guidePopover config
            const popoverConfig = {
                colorChange: this.colorChange,
                symbolChange: this.symbolChange,
                popoverDismiss: (e) => {
                    this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
                },
                popoverClose: () => {
                    this.guidePopoverChange(false);
                    this.removeGuidePopover();
                },
            };
            // create a new guidePopover
            this.guidePopover = restJsObjectLiterals.Zy(restJsObjectLiterals.Qy.GuidePopover, popoverConfig);
        }
        const currentStyle = this.model.getGuideStyle(this.index, this.orientation);
        const start = this.model.getGuideStart(this.index, this.orientation);
        const end = this.model.getGuideEnd(this.index, this.orientation);
        if (restJsObjectLiterals.Kl(start, end) === restJsObjectLiterals.RESTSymbolType.SLS) {
            this.guidePopover.selectedElement = restJsObjectLiterals.Jc(currentStyle) ? currentStyle : undefined;
        }
        else {
            this.guidePopover.selectedElement = currentStyle?.color;
        }
        this.guidePopover.referenceElement = this.colorElement;
        if (Array.isArray(currentStyle?.color)) {
            this.guidePopover.open = true;
            this.addGuidePopover();
        }
        else {
            this.guidePopover.open = false;
            this.removeGuidePopover();
        }
    }
    /**
     * @category Private
     */
    removeGuidePopover() {
        this.guidePopover?.remove();
        this.guidePopoverChange(false);
        this.guidePopover = undefined;
    }
    /**
     * @category Private
     */
    addGuidePopover() {
        if (this.guidePopover !== undefined && !document.body.contains(this.guidePopover)) {
            document.body.appendChild(this.guidePopover);
        }
        this.guidePopoverChange(true);
    }
    /**
     * @param fillColor
     * @category Private
     */
    setColor(fillColor) {
        // Creating a transparent outline to avoid ac-js to create a default more opaque outline
        const outline = restJsObjectLiterals.po({ opacity: 0 });
        const currentStyle = this.model.getGuideStyle(this.index, this.orientation);
        const guideStyle = {
            ...(restJsObjectLiterals.Qc(currentStyle) ? currentStyle : {}),
            type: restJsObjectLiterals.RESTSymbolType.SFS,
            color: fillColor,
            outline,
        };
        this.model.setGuideStyle(guideStyle, this.index, this.orientation);
        this.arcgisChartsConfigGuideChange.emit({
            index: this.index,
            orientation: this.orientation,
            isDelete: false,
        });
    }
    /**
     * Gets the date string from the bound value in ISO format.
     * @category Private
     */
    getDateStringFromBound(bound) {
        return typeof bound === "string" ? bound.split("T")[0] : "";
    }
    /**
     * Gets the time string from the bound value in ISO format.
     * @category Private
     */
    getTimeStringFromBound(bound) {
        return typeof bound === "string" ? bound.split("T")[1] : "";
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
};
ArcgisChartsConfigGuide.style = ArcgisChartsConfigGuideStyle0;

const arcgisChartsConfigGuidesCss = ":host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}.add-guide{display:flex;justify-content:center;padding:0.5rem}.add-guide-btn{width:100%}.no-guides{border-radius:2rem}.no-messages{text-align:center}.guide-icon{padding-left:0.5rem;padding-top:0.5rem;width:1.5rem;height:1.5rem}";
const ArcgisChartsConfigGuidesStyle0 = arcgisChartsConfigGuidesCss;

const ArcgisChartsConfigGuides = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigGuidePopoverChange = index.createEvent(this, "arcgisChartsConfigGuidePopoverChange", 7);
        /**
         * @category Private
         */
        this.addXGuide = () => {
            if (index$1.Rg(this.model)) {
                const name = this.getUniqueName(this.strings.xAxisGuide);
                const index = this.model.getXGuidesLength() ?? 0;
                this.model.addXAxisGuide(name, index);
                this.model.setGuideStyle(cloneDeep.cloneDeep(_default.defaultGuide.style), index, index$1.nh.X);
                this.latestGuidePosition = getGuideListPosition(index, index$1.nh.X, this.model);
                this.togglePopOver();
                // TODO: This is hopefully a temporary fix. There is an issue with the way Stencil components apply boolean
                // attributes in JSX. See https://github.com/ionic-team/stencil-ds-output-targets/issues/123.
                // Collapse all other guide blocks after adding a new one
                const guideBlocks = this.hostElement.shadowRoot?.querySelectorAll("calcite-block") ?? [];
                guideBlocks.forEach((guideBlock, i) => {
                    if (i !== this.latestGuidePosition) {
                        guideBlock.open = false;
                    }
                });
            }
        };
        /**
         * @category Private
         */
        this.addYGuide = () => {
            if (index$1.Ng(this.model)) {
                const name = this.getUniqueName(this.strings.yAxisGuide);
                const index = this.model.getYGuidesLength() ?? 0;
                this.model.addYAxisGuide(name, index);
                this.model.setGuideStyle(cloneDeep.cloneDeep(_default.defaultGuide.style), index, index$1.nh.Y);
                this.latestGuidePosition = getGuideListPosition(index, index$1.nh.Y, this.model);
                this.togglePopOver();
                // TODO: This is hopefully a temporary fix. There is an issue with the way Stencil components apply boolean
                // attributes in JSX. See https://github.com/ionic-team/stencil-ds-output-targets/issues/123.
                // Collapse all other guide blocks after adding a new one
                for (const guideBlock of this.hostElement.shadowRoot?.querySelectorAll("calcite-block") ?? []) {
                    guideBlock.open = false;
                }
            }
        };
        /**
         * @category Private
         */
        this.closeAddPopOver = () => {
            this.showAddButton = true;
        };
        /**
         * @category Private
         */
        this.togglePopOver = () => {
            if (this.enableXAxisGuide && this.enableYAxisGuide) {
                this.showAddButton = !this.showAddButton;
            }
        };
        /**
         * @category Event handler
         */
        this.setChangedGuide = (e) => {
            const { index, orientation, isDelete } = e.detail;
            const listPosition = getGuideListPosition(index, orientation, this.model);
            // Decrement latest guide position if deleted guide was before it
            if (isDelete &&
                listPosition !== undefined &&
                listPosition <= this.latestGuidePosition &&
                this.latestGuidePosition > 0) {
                this.latestGuidePosition -= 1;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        this.model = undefined;
        this.timeZone = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.enableXAxisGuide = true;
        this.enableYAxisGuide = true;
        this.open = false;
        this.showAddButton = true;
        this.latestGuidePosition = 0;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * Gets the total number of guides.
     * @category Private
     */
    getAllGuidesLength() {
        const xGuidesLength = index$1.Rg(this.model) ? (this.model.getXGuidesLength() ?? 0) : 0;
        const yGuidesLength = index$1.Ng(this.model) ? (this.model.getYGuidesLength() ?? 0) : 0;
        return xGuidesLength + yGuidesLength;
    }
    /**
     * @param guide
     * @category Render UX
     */
    renderGuide(index$2, orientation) {
        let guideElement;
        if ((this.enableXAxisGuide && orientation === index$1.nh.X) ||
            (this.enableYAxisGuide && orientation === index$1.nh.Y)) {
            guideElement = (index.h("arcgis-charts-config-guide", { model: this.model, timeZone: this.timeZone, calculatedMinMaxBounds: this.calculatedMinMaxBounds, index: index$2, orientation: orientation, latestGuidePosition: this.latestGuidePosition, onArcgisChartsConfigGuideChange: this.setChangedGuide }));
        }
        return guideElement;
    }
    /**
     * @category Render UX
     */
    renderGuides() {
        const guidesUI = [];
        if (index$1.Rg(this.model)) {
            const xGuidesLength = this.model.getXGuidesLength() ?? 0;
            for (let i = 0; i < xGuidesLength; i += 1) {
                guidesUI.push(this.renderGuide(i, index$1.nh.X));
            }
        }
        if (index$1.Ng(this.model)) {
            const yGuidesLength = this.model.getYGuidesLength() ?? 0;
            for (let i = 0; i < yGuidesLength; i += 1) {
                guidesUI.push(this.renderGuide(i, index$1.nh.Y));
            }
        }
        return guidesUI;
    }
    /**
     * @param callBack
     * @category Render UX
     */
    renderAddGuideButton(callBack) {
        return (index.h("calcite-fab", { slot: "fab", appearance: "outline-fill", kind: "neutral", hidden: false, textEnabled: true, text: this.strings.addGuide, label: this.strings.addGuide, onClick: callBack, scale: "s" }));
    }
    /**
     * @category Lifecycle
     */
    render() {
        const allGuidesLength = this.getAllGuidesLength();
        const isGuidesAvailable = allGuidesLength > 0;
        const isAddBtnRequired = this.showAddButton && this.enableXAxisGuide && this.enableYAxisGuide;
        const isAddXGuide = this.enableXAxisGuide && !this.enableYAxisGuide;
        const isAddYGuide = !this.enableXAxisGuide && this.enableYAxisGuide;
        return (index.h(index.Host, { key: '3044b147d444eb3c4cba0b73fbab3bcea53f3367' }, index.h("calcite-popover", { key: '968d5535eda83cdf9db30eb208f8db9e46bfee80', open: !this.showAddButton, referenceElement: this.addGuideButton, flipDisabled: true, pointerDisabled: true, offsetDistance: -18, onCalcitePopoverClose: this.closeAddPopOver, placement: allGuidesLength === 0 ? "bottom" : "top", ref: (e) => {
                this.popoverElement = e;
            }, label: "" }, index.h("calcite-panel", { key: 'b7339ced53c59530569fc0a4ce9814eaf169ef94', heading: this.strings.guideType }, index.h("calcite-action", { key: 'fd123c6df0859541956b7f0cb6985c9cc93cad4e', text: "", slot: "header-actions-end", icon: "x", onClick: this.closeAddPopOver }), this.enableXAxisGuide ? (index.h("calcite-action", { label: this.strings.addXAxisGuide, text: this.strings.addXAxisGuide, onClick: this.addXGuide, icon: "x-axis-guide", textEnabled: true })) : null, this.enableYAxisGuide ? (index.h("calcite-action", { label: this.strings.addYAxisGuide, text: this.strings.addYAxisGuide, onClick: this.addYGuide, icon: "y-axis-guide", textEnabled: true })) : null)), isGuidesAvailable ? this.renderGuides() : index.h("div", { class: HTMLClasses$2.noMessages }, this.strings.noGuidesMsg), index.h("div", { key: '72a79ff0a7aa89fa13e7c46697d1ef4bb19764b5', class: HTMLClasses$2.addGuide, ref: (el) => {
                this.addGuideButton = el;
            } }, isAddBtnRequired && this.renderAddGuideButton(this.togglePopOver), isAddXGuide && this.renderAddGuideButton(this.addXGuide), isAddYGuide && this.renderAddGuideButton(this.addYGuide))));
    }
    /**
     * @category Lifecycle
     */
    componentDidRender() {
        restJsObjectLiterals.eu(this.popoverElement, !this.showAddButton);
    }
    /**
     * @param guideNameTemplate
     * @param count
     * @category Private
     */
    getUniqueName(guideNameTemplate, count = 1) {
        const name = `${guideNameTemplate} ${count}`;
        let nameAlreadyUsed = false;
        if (index$1.Rg(this.model)) {
            const xGuidesLength = this.model.getXGuidesLength() ?? 0;
            for (let i = 0; i < xGuidesLength && !nameAlreadyUsed; i += 1) {
                const guideName = this.model.getGuideName(i, index$1.nh.X);
                if (guideName === name) {
                    nameAlreadyUsed = true;
                }
            }
        }
        if (index$1.Ng(this.model)) {
            const yGuidesLength = this.model.getYGuidesLength() ?? 0;
            for (let i = 0; i < yGuidesLength && !nameAlreadyUsed; i += 1) {
                const guideName = this.model.getGuideName(i, index$1.nh.Y);
                if (guideName === name) {
                    nameAlreadyUsed = true;
                }
            }
        }
        return !nameAlreadyUsed ? name : this.getUniqueName(guideNameTemplate, count + 1);
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
};
ArcgisChartsConfigGuides.style = ArcgisChartsConfigGuidesStyle0;

const HTMLClasses$1 = {
    invalidMessageColor: "invalid-message-color",
};

const arcgisChartsConfigInvalidInputMessageCss = ":host{display:block}.invalid-message-color{color:red}";
const ArcgisChartsConfigInvalidInputMessageStyle0 = arcgisChartsConfigInvalidInputMessageCss;

const ArcgisChartsConfigInvalidInputMessage = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.invalidInputMessage = undefined;
        this.isInvalid = false;
    }
    render() {
        return (index.h(index.Host, { key: 'a39c1b1904aefe902a875b75dbbdff19f230dad3' }, this.isInvalid ? (index.h("calcite-input-message", { status: chartUiUtils.UIInputStatus.INVALID, icon: "exclamationMarkTriangle", hidden: !this.isInvalid, class: HTMLClasses$1.invalidMessageColor }, this.invalidInputMessage)) : null));
    }
    get hostElement() { return index.getElement(this); }
};
ArcgisChartsConfigInvalidInputMessage.style = ArcgisChartsConfigInvalidInputMessageStyle0;

const HTMLClasses = {
    container: "container",
    label: "label",
    numberInput: "number-input",
    rtl: "arcgis-charts-rtl",
};

const arcgisChartsConfigNumberFormatCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}.container{width:var(--arcgis-charts-config-calcite-block-width, var(--arcgis-charts-config-calcite-block-default-width));height:var(--arcgis-charts-config-calcite-block-height, var(--arcgis-charts-config-calcite-block-default-height));margin-top:0.5rem}.container>.number-input{margin-bottom:0.5rem;display:flex}.container>.number-input>div{width:100%}:host{display:flex;flex-direction:row}.label{display:flex;margin-bottom:0.5rem;justify-content:space-between}";
const ArcgisChartsConfigNumberFormatStyle0 = arcgisChartsConfigNumberFormatCss;

const ArcgisChartsConfigNumberFormat = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigNumberFormatChange = index.createEvent(this, "arcgisChartsConfigNumberFormatChange", 7);
        /**
         * @category Event handler
         */
        this.onDecimalPlacesChange = () => {
            const { value } = this.decimalPlacesInputElement;
            const numericValue = Math.floor(Number(value));
            // check if the character limit value is a valid positive integer
            const isValidCharacterLimit = numericValue === Number(value) && numericValue >= 0;
            if (value !== undefined &&
                isValidCharacterLimit &&
                chartUiUtils.isCalciteInputValidNumber(value, this.decimalPlacesInputElement.min, this.decimalPlacesInputElement.max)) {
                const maximumFractionDigits = Number.parseInt(value);
                const newNumberFormat = {
                    minimumFractionDigits: this.numberFormat.minimumFractionDigits,
                    maximumFractionDigits,
                };
                if (newNumberFormat.maximumFractionDigits !== undefined &&
                    newNumberFormat.minimumFractionDigits !== undefined &&
                    newNumberFormat.minimumFractionDigits > newNumberFormat.maximumFractionDigits) {
                    newNumberFormat.minimumFractionDigits = newNumberFormat.maximumFractionDigits;
                }
                const updatedNumberFormat = this.getUpdatedNumberFormat(newNumberFormat);
                this.arcgisChartsConfigNumberFormatChange.emit(updatedNumberFormat);
                chartUiUtils.modifyCalciteInputStatus({
                    inputElement: this.decimalPlacesInputElement,
                    status: chartUiUtils.UIInputStatus.IDLE,
                });
            }
            else {
                chartUiUtils.modifyCalciteInputStatus({
                    inputElement: this.decimalPlacesInputElement,
                    status: chartUiUtils.UIInputStatus.INVALID,
                });
            }
        };
        /**
         * @category Event handler
         */
        this.onShowThousandsSeparatorChange = (e) => {
            const useGrouping = e.target.checked;
            const updatedNumberFormat = this.getUpdatedNumberFormat({
                useGrouping,
            });
            this.arcgisChartsConfigNumberFormatChange.emit(updatedNumberFormat);
        };
        this.numberFormat = undefined;
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        // T.B.D issue with lang getting set correctly when this component used as a child
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (index.h(index.Host, { key: '01a68dc41515f1ab1ef989c9609c6107950f5c61', class: { [HTMLClasses.rtl]: this.direction === "rtl" } }, index.h("div", { key: '5529f7f0fcaba32ac905a810289acdc6f1978952', class: HTMLClasses.container }, index.h("calcite-label", { key: '3b0e8772506ca611fede807fcb532f50e45e6a38', class: HTMLClasses.label }, this.strings.decimalPlaces, index.h("calcite-input", { key: 'ed1c257a0f7b1e68ae5b685b1e6df01da0b3344a', type: "number", class: HTMLClasses.numberInput, min: 0, max: 20, step: 1, value: chartUiUtils.sanitizeNumber(this.numberFormat.maximumFractionDigits, 2), onCalciteInputInput: this.onDecimalPlacesChange, ref: (e) => {
                this.decimalPlacesInputElement = e;
            } })), index.h("calcite-label", { key: 'b1a20806ba33b7d49cca3041baa74013c1165677', layout: "inline-space-between", class: HTMLClasses.label }, this.strings.showThousandSeparators, index.h("calcite-switch", { key: '431583cb00f7e409f75844ea2d2202bd2d1e1cbc', name: "useGrouping", checked: this.numberFormat.useGrouping ?? true, onCalciteSwitchChange: this.onShowThousandsSeparatorChange })))));
    }
    /**
     * @param prop
     * @category Private
     */
    getUpdatedNumberFormat(prop) {
        return {
            ...this.numberFormat,
            ...prop,
        };
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
};
ArcgisChartsConfigNumberFormat.style = ArcgisChartsConfigNumberFormatStyle0;

exports.arcgis_charts_config_axes = ArcGISChartsConfigAxes;
exports.arcgis_charts_config_axis = ArcGISChartsConfigAxis;
exports.arcgis_charts_config_category_format = ArcgisChartsConfigCategoryFormat;
exports.arcgis_charts_config_format = ArcgisChartsConfigFormat;
exports.arcgis_charts_config_general = ArcGISChartsConfigGeneral;
exports.arcgis_charts_config_guide = ArcgisChartsConfigGuide;
exports.arcgis_charts_config_guides = ArcgisChartsConfigGuides;
exports.arcgis_charts_config_invalid_input_message = ArcgisChartsConfigInvalidInputMessage;
exports.arcgis_charts_config_number_format = ArcgisChartsConfigNumberFormat;
