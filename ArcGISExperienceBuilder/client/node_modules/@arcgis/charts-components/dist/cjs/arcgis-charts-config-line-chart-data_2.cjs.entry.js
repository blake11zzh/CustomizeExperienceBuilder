/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2e64cfc1.js');
const restJsObjectLiterals = require('./rest-js-object-literals-acb59afb.js');
const interfaces = require('./interfaces-28e1772a.js');
const store = require('./store-fbc7ac07.js');
const chartObjectLiterals = require('./chart-object-literals-a706ca0f.js');
const chartUiUtils = require('./chart-ui-utils-ba499862.js');
require('./index-e5a6a075.js');

const HTMLClasses = {
    label: "label",
    text: "text",
    fieldList: "field-list",
    fab: "fab",
    disabledLabel: "disabled-label",
    rtl: "arcgis-charts-rtl",
    timeBinningHeader: "time-binning-header",
    linkContainer: "link-container",
    dimText: "dim-text",
};

const arcgisChartsConfigLineChartDataCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}:host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin);margin-top:var(--arcgis-charts-top-section-margin)}.label,.disabled-label{display:flex;margin-left:0.5rem;margin-right:0.5rem;margin-bottom:0.5rem;justify-content:space-between}.time-binning-header{display:flex;font-weight:bold;margin-left:0.5rem;margin-right:0.5rem;justify-content:space-between}.text{display:flex;margin-left:0.5rem;width:calc(100% - 1.5rem);height:2rem;margin-bottom:0.5rem;justify-content:space-between}.field-list{max-height:50vh;overflow-y:auto}.disabled-label{pointer-events:none}.fab{display:flex;margin-left:0.5rem;margin-right:0.5rem;margin-bottom:1.5rem;justify-content:center}.link-container{display:flex;justify-content:flex-end}:host(.arcgis-chart-rtl) .text{margin-left:0rem;margin-right:0.5rem}";
const ArcgisChartsConfigLineChartDataStyle0 = arcgisChartsConfigLineChartDataCss;

const ArcGISChartsConfigLineChartData = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigLineChartDataNumericFieldValidate = index.createEvent(this, "arcgisChartsConfigLineChartDataNumericFieldValidate", 7);
        this.arcgisChartsConfigDataChangeError = index.createEvent(this, "arcgisChartsConfigDataChangeError", 7);
        this.arcgisChartsConfigCustomizedTimeInterval = index.createEvent(this, "arcgisChartsConfigCustomizedTimeInterval", 7);
        this.arcgisChartsConfigResetTimeInterval = index.createEvent(this, "arcgisChartsConfigResetTimeInterval", 7);
        /**
         * @category Private
         */
        this.lineChartPopover = null;
        /**
         * @category Private
         */
        this.resetTimeIntervalOriginal = (e) => {
            this.popoverClose(e);
            if (this.model.resetTimeInterval !== undefined) {
                this.model.resetTimeInterval();
                this.arcgisChartsConfigResetTimeInterval.emit();
            }
        };
        /**
         * @category Event handler
         *
         * called when the aggregation type is clicked
         */
        this.onAggregationSelect = () => {
            this.contentKind = interfaces.LineChartDataPopoverKinds.aggregation;
            this.setupPopover();
        };
        /**
         * @category Event handler
         *
         * called when the xAxisField is clicked
         */
        this.onXAxisFieldSelect = () => {
            this.contentKind = interfaces.LineChartDataPopoverKinds.xAxisField;
            this.setupPopover();
        };
        /**
         * @category Event handler
         *
         * called when the splitBy is clicked
         */
        this.onSplitBySelect = () => {
            if (!this.splitByFieldElement.disabled) {
                this.contentKind = interfaces.LineChartDataPopoverKinds.splitByField;
                this.setupPopover();
            }
        };
        /**
         * @category Event handler
         *
         * called when the add numeric fields button is clicked
         */
        this.onAddNumericFields = () => {
            this.contentKind = interfaces.LineChartDataPopoverKinds.numericFields;
            this.setupPopover();
        };
        /**
         * @category Event handler
         *
         * Called when individual numeric field item is removed.
         */
        this.onRemoveNumericField = async (removedItemEvent) => {
            const removedField = removedItemEvent.target.value;
            await this.model.setNumericFields(this.model.getNumericFields().filter((field) => field !== removedField));
        };
        /**
         * @category Event handler
         *
         * called when the intervalAlignment is clicked
         */
        this.onIntervalAlignmentSelect = () => {
            if (!this.intervalAlignmentElement.disabled) {
                this.contentKind = interfaces.LineChartDataPopoverKinds.intervalAlignment;
                this.setupPopover();
            }
        };
        /**
         * @category Event handler
         *
         * called when the interval is clicked
         */
        this.onIntervalSelect = () => {
            if (!this.intervalElement.disabled) {
                this.contentKind = interfaces.LineChartDataPopoverKinds.interval;
                this.setupPopover();
            }
        };
        /**
         * @category Event handler
         *
         * called in response to the arcgisChartsConfigLineChartDataPopoverChange event
         */
        this.onLineChartDataChange = async (e) => {
            try {
                if (e.detail !== null && e.detail?.value !== undefined) {
                    const { contentKind } = e.detail;
                    const newValue = [...e.detail.value];
                    // reset axes bounds for this chart in stencil store
                    store.deleteMinMaxAxisKey(store.state);
                    switch (contentKind) {
                        case interfaces.LineChartDataPopoverKinds.aggregation:
                            await this.model.setAggregationType(newValue[0] !== restJsObjectLiterals.RESTStatisticType.NoAggregation ? newValue[0] : restJsObjectLiterals.RESTStatisticType.NoAggregation);
                            break;
                        case interfaces.LineChartDataPopoverKinds.xAxisField: {
                            const newXAxisField = newValue[0]?.trim() || "";
                            await this.model.setXAxisField(newXAxisField);
                            this.arcgisChartsConfigResetTimeInterval.emit();
                            break;
                        }
                        case interfaces.LineChartDataPopoverKinds.numericFields:
                            await this.model.setNumericFields(newValue);
                            if (this.model.getNumericFields().length > 0 &&
                                this.model.getAggregationType() === restJsObjectLiterals.RESTStatisticType.Count &&
                                this.model.getNumericFields()[0] !== restJsObjectLiterals.wc(this.layerFieldsInfo)) {
                                await this.model.setAggregationType(restJsObjectLiterals.RESTStatisticType.Sum);
                            }
                            break;
                        case interfaces.LineChartDataPopoverKinds.splitByField: {
                            const newSplitByField = newValue[0]?.trim() || "";
                            await this.model.setSplitByField(newSplitByField);
                            this.model.setColorMatch(true);
                            break;
                        }
                        case interfaces.LineChartDataPopoverKinds.interval:
                            this.model.setTimeIntervalSize(newValue[0]?.intervalSize);
                            this.model.setTimeIntervalUnits(newValue[0]?.intervalUnits);
                            this.arcgisChartsConfigCustomizedTimeInterval.emit();
                            break;
                        case interfaces.LineChartDataPopoverKinds.intervalAlignment:
                            this.model.setTimeAggregationType(newValue[0] ?? "");
                            break;
                    }
                }
            }
            catch (error) {
                this.arcgisChartsConfigDataChangeError.emit({ error, model: this.model });
                throw error;
            }
            this.removeLineChartDataPopover();
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Event handler
         */
        this.onShowDataLabelsChange = (e) => {
            this.model.setDataLabelsVisibility(e.target.checked);
        };
        /**
         * @category Event handler
         */
        this.onTrimIncompleteIntervalChange = (e) => {
            this.model.setTrimIncompleteTimeInterval(e.target.checked);
        };
        /**
         * @category Event handler
         */
        this.onNullPolicyChange = (e) => {
            this.model.setNullPolicy(e.target.selectedItem.value);
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Private
         */
        this.popoverClose = (e) => {
            if (this.lineChartPopover === e?.target) {
                this.removeLineChartDataPopover();
            }
        };
        this.model = undefined;
        this.resetTimeInterval = undefined;
        this.layerFieldsInfo = undefined;
        this.open = true;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removeLineChartDataPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Lifecycle
     */
    async componentWillRender() {
        this.aggregationLabel = await restJsObjectLiterals.ta(this.model.getAggregationType());
        const timeAggregationType = this.model.getTimeAggregationType();
        if (timeAggregationType !== undefined) {
            this.timeAggregationLabel = await restJsObjectLiterals.ia(timeAggregationType);
        }
        this.disableSplitBy = this.model.getNumericFields().length > 1;
    }
    /**
     * @category Render UX
     */
    renderAggregation() {
        return (index.h("arcgis-charts-config-field-select", { label: this.model.getAggregationType() === restJsObjectLiterals.RESTStatisticType.NoAggregation
                ? this.strings.noAggregation
                : this.aggregationLabel, ref: (e) => {
                this.aggregationElement = e;
            }, onClick: this.onAggregationSelect }));
    }
    /**
     * @category Render UX
     */
    renderXAxisField() {
        const xAxisFieldString = this.getCorrectedXAxisValue();
        return (index.h("arcgis-charts-config-field-select", { label: xAxisFieldString, ref: (e) => {
                this.xAxisFieldElement = e;
            }, onClick: this.onXAxisFieldSelect }));
    }
    /**
     * @category Render UX
     */
    renderSplitBy() {
        const splitByString = this.getCorrectedSplitByValue();
        return (index.h("arcgis-charts-config-field-select", { label: splitByString, disabled: this.disableSplitBy, ref: (e) => {
                this.splitByFieldElement = e;
            }, onClick: this.onSplitBySelect }));
    }
    /**
     * @category Render UX
     */
    renderNumericFields(fields) {
        const objectIdField = restJsObjectLiterals.wc(this.layerFieldsInfo);
        const fieldList = [];
        for (let i = 0; i < fields.length; i += 1) {
            if (fields[i] !== objectIdField) {
                fieldList.push(this.buildNumericFieldItem(fields[i]));
            }
        }
        return (index.h("calcite-list", { label: "", class: HTMLClasses.fieldList, ref: (e) => {
                this.numericFieldsElement = e;
            } }, fieldList));
    }
    /**
     * @category Render UX
     */
    renderInterval() {
        const invalidTimeInterval = (this.model.getTimeIntervalSize() ?? 0) <= 0;
        const timeIntervalSize = this.model.getTimeIntervalSize() ?? "";
        const timeIntervalUnitLabel = restJsObjectLiterals.jl(this.model.getTimeIntervalUnits() ?? chartObjectLiterals.WebChartTimeIntervalUnits.Seconds, this.strings) ??
            "";
        return [
            index.h("calcite-list", { label: "", selectionAppearance: "border" }, index.h("calcite-list-item", { value: invalidTimeInterval ? "" : `${timeIntervalSize} ${timeIntervalUnitLabel}`, label: invalidTimeInterval ? "" : `${timeIntervalSize} ${timeIntervalUnitLabel}`, ref: (e) => {
                    this.intervalElement = e;
                }, onClick: invalidTimeInterval ? () => { } : this.onIntervalSelect }, index.h("calcite-icon", { slot: "content-end", icon: "pencil" }))),
            index.h("div", { class: HTMLClasses.linkContainer }, index.h("calcite-button", { appearance: "transparent", scale: "s", iconEnd: "reset", onClick: this.resetTimeIntervalOriginal }, this.strings.reset)),
        ];
    }
    /**
     * @category Render UX
     */
    renderIntervalAlignment() {
        return (index.h("arcgis-charts-config-field-select", { label: this.timeAggregationLabel, disabled: false, ref: (e) => {
                this.intervalAlignmentElement = e;
            }, onClick: this.onIntervalAlignmentSelect }));
    }
    /**
     * @category Render UX
     */
    renderEmptyBins() {
        return (index.h("calcite-radio-button-group", { name: "empty-bins", layout: "vertical", onCalciteRadioButtonGroupChange: this.onNullPolicyChange }, index.h("calcite-label", { layout: "inline" }, index.h("calcite-radio-button", { value: chartObjectLiterals.WebChartNullPolicyTypes.Zero, checked: this.model.getNullPolicy() === chartObjectLiterals.WebChartNullPolicyTypes.Zero }), this.strings.treatAsZero), index.h("calcite-label", { layout: "inline" }, index.h("calcite-radio-button", { value: chartObjectLiterals.WebChartNullPolicyTypes.Interpolate, checked: this.model.getNullPolicy() === chartObjectLiterals.WebChartNullPolicyTypes.Interpolate }), this.strings.connectLine), index.h("calcite-label", { layout: "inline" }, index.h("calcite-radio-button", { value: chartObjectLiterals.WebChartNullPolicyTypes.Null, checked: this.model.getNullPolicy() === chartObjectLiterals.WebChartNullPolicyTypes.Null }), this.strings.breakLine)));
    }
    /**
     * @category Render UX
     * @param field
     */
    buildNumericFieldItem(field) {
        return (index.h("calcite-list-item", { label: restJsObjectLiterals.Tl(this.layerFieldsInfo, field), value: field, key: field, closable: true, onCalciteListItemClose: this.onRemoveNumericField }));
    }
    /**
     * @category Lifecycle
     */
    render() {
        const aggregationUI = this.renderAggregation();
        const xAxisFieldUI = this.renderXAxisField();
        const splitByUI = this.renderSplitBy();
        const numericFieldsUI = this.renderNumericFields([...this.model.getNumericFields()]);
        const intervalUI = this.renderInterval();
        const intervalAlignmentUI = this.renderIntervalAlignment();
        const emptyBinsUI = this.renderEmptyBins();
        return (index.h(index.Host, { key: 'b6451eb6ec2b1d61dabc871233690263e1e794d9', class: { [HTMLClasses.rtl]: this.direction === "rtl" } }, index.h("calcite-label", { key: '06c94128f7c237740b6d13aecc4f3f558f4b5467', class: HTMLClasses.label }, this.strings.xAxisField, xAxisFieldUI), index.h("calcite-label", { key: '5f811e5ccc7b591b235eb0e9f29c263d136faca3', class: HTMLClasses.label }, this.strings.aggregation, aggregationUI), index.h("calcite-label", { key: '32789b718f017c6a838269ee6fc6aed3dee48ed4', class: HTMLClasses.label }, this.strings.numericFields, numericFieldsUI), index.h("div", { key: 'b4d894b98efbebf17b59c3369aa9276541d9d246', class: HTMLClasses.fab }, index.h("calcite-fab", { key: 'f430a7551f1939969dc87e9ca4362847703c8884', appearance: "outline-fill", kind: "neutral", scale: "m", label: this.strings.selectNumericFields, "text-enabled": true, text: this.strings.selectNumericFields, icon: "plus", onClick: this.onAddNumericFields })), index.h("calcite-label", { key: '55fd93a584f2c08e835f2dd892e69c3206996174', class: HTMLClasses.label }, index.h("span", { key: '81f68686c3a64f9747f5f5bf08afecd1496cf2e0', class: this.disableSplitBy ? HTMLClasses.dimText : "" }, this.strings.splitBy), splitByUI), index.h("div", { key: 'b249e03ec9f0ac5692730e15cf2df636ddc73e0e', hidden: !this.shouldShowTimeBinning() }, index.h("h3", { key: 'af2c5bca4a508f8ef25b47f8b302bbd511c1e916', class: HTMLClasses.timeBinningHeader }, this.strings.timeBinningOptions), index.h("calcite-label", { key: 'dd23237541552296bfd92831efaca1a4b2b5dac3', class: HTMLClasses.label }, this.strings.interval, intervalUI), index.h("calcite-label", { key: '022b35e04bf70f525630e6ae160181882790c317', class: HTMLClasses.label }, this.strings.intervalAlignment, intervalAlignmentUI), index.h("calcite-label", { key: '4cc20bb8cdb6f7d780188a10b3af8a5929d841c8', class: HTMLClasses.label, layout: "inline-space-between" }, this.strings.trimIncompleteInterval, index.h("calcite-switch", { key: 'fffe1ad70264153507220b9a7125e5c9c2dd1235', checked: this.model.getTrimIncompleteTimeInterval(), onCalciteSwitchChange: this.onTrimIncompleteIntervalChange })), index.h("calcite-label", { key: 'e0e359e36873a557d6b9ed2e6c990fb5bc2b656b', class: HTMLClasses.label }, this.strings.emptyBins, emptyBinsUI)), index.h("calcite-label", { key: 'be1c2ad0ed5fe37e8a4206df7a51e6f5f4c2e040', class: HTMLClasses.label, layout: "inline-space-between" }, this.strings.showDataLabels, index.h("calcite-switch", { key: 'ce968955a4afcf74795da6cfa5b345a37bf4858e', checked: this.model.getDataLabelsVisibility(), onCalciteSwitchChange: this.onShowDataLabelsChange }))));
    }
    /**
     * Get the split by value based on the current model's split by field.
     *
     * **NOTE**: If the split by field is empty or there are more than one numeric fields, return an empty string.
     * @category Private
     * @returns {string} - The corrected split by value.
     */
    getCorrectedSplitByValue() {
        return this.model.getSplitByField() === "" || this.model.getNumericFields().length > 1
            ? ""
            : restJsObjectLiterals.Tl(this.layerFieldsInfo, this.model.getSplitByField());
    }
    /**
     * Get the x-axis field value based on the current model's x-axis field.
     *
     * **NOTE**: If the x-axis field is empty or set to the default value (`arcgis_charts_bar_line_from_fields_name`),
     * return an empty string.
     * @category Private
     * @returns {string} - The corrected x-axis field value.
     */
    getCorrectedXAxisValue() {
        return this.model.getXAxisField() === chartUiUtils.defaultBarLineFromFieldsName || this.model.getXAxisField().trim() === ""
            ? ""
            : restJsObjectLiterals.Tl(this.layerFieldsInfo, this.model.getXAxisField());
    }
    /**
     * @category Private
     */
    shouldShowTimeBinning() {
        const xAxisFieldObject = this.layerFieldsInfo.find((field) => field.name === this.model.getXAxisField());
        const isDateField = xAxisFieldObject?.type === restJsObjectLiterals.RESTFieldType.Date;
        const isUsingAggregation = this.model.getAggregationType() !== restJsObjectLiterals.RESTStatisticType.NoAggregation;
        return isDateField && isUsingAggregation;
    }
    /**
     * @category Private
     */
    setupPopover() {
        // remove already existing chart popover
        // TODO: this is a hotfix for https://devtopia.esri.com/webgis/arcgis-charts/issues/5366
        // have to find a better way to do this
        this.removeLineChartDataPopover();
        // lineChartPopover config
        const popoverConfig = {
            layerFieldsInfo: this.layerFieldsInfo,
            onLineChartDataChange: this.onLineChartDataChange,
            popoverClose: this.popoverClose,
        };
        // create a new lineChartPopover
        this.lineChartPopover = restJsObjectLiterals.Zy(restJsObjectLiterals.Qy.LineChartDataPopover, popoverConfig);
        if (this.lineChartPopover !== null) {
            const timeIntervalProps = {
                timeIntervalSize: this.model.getTimeIntervalSize() ?? 1,
                timeIntervalUnits: this.model.getTimeIntervalUnits() ?? chartObjectLiterals.WebChartTimeIntervalUnits.Seconds,
            };
            switch (this.contentKind) {
                case interfaces.LineChartDataPopoverKinds.aggregation:
                    this.lineChartPopover.referenceElement = this.aggregationElement;
                    this.lineChartPopover.headingTitle = this.strings.aggregationHeader;
                    this.lineChartPopover.selectedContent = this.model.getAggregationType();
                    break;
                case interfaces.LineChartDataPopoverKinds.xAxisField:
                    this.lineChartPopover.referenceElement = this.xAxisFieldElement;
                    this.lineChartPopover.headingTitle = this.strings.xAxisFieldHeader;
                    this.lineChartPopover.selectedContent = this.model.getXAxisField();
                    break;
                case interfaces.LineChartDataPopoverKinds.numericFields:
                    this.lineChartPopover.referenceElement = this.numericFieldsElement;
                    this.lineChartPopover.headingTitle = this.strings.numericFieldsHeader;
                    this.lineChartPopover.selectedContent = this.model.getNumericFields();
                    break;
                case interfaces.LineChartDataPopoverKinds.splitByField:
                    this.lineChartPopover.referenceElement = this.splitByFieldElement;
                    this.lineChartPopover.headingTitle = this.strings.splitByFieldHeader;
                    this.lineChartPopover.selectedContent = this.model.getSplitByField();
                    break;
                case interfaces.LineChartDataPopoverKinds.interval:
                    this.lineChartPopover.referenceElement = this.intervalElement;
                    this.lineChartPopover.headingTitle = this.strings.editInterval;
                    this.lineChartPopover.selectedContent = timeIntervalProps;
                    break;
                case interfaces.LineChartDataPopoverKinds.intervalAlignment:
                    this.lineChartPopover.referenceElement = this.intervalAlignmentElement;
                    this.lineChartPopover.headingTitle = this.strings.intervalAlignment;
                    this.lineChartPopover.selectedContent = this.model.getTimeAggregationType() ?? "";
                    break;
            }
            this.lineChartPopover.contentKind = this.contentKind;
            this.lineChartPopover.open = true;
            this.addPopover();
        }
    }
    /**
     * @category Private
     */
    addPopover() {
        if (!document.body.contains(this.lineChartPopover) && this.lineChartPopover !== null) {
            document.body.appendChild(this.lineChartPopover);
        }
    }
    /**
     * Remove line chart data popover
     * @category Private
     */
    removeLineChartDataPopover() {
        if (this.lineChartPopover !== null) {
            this.lineChartPopover.open = false;
            this.lineChartPopover = restJsObjectLiterals.Jy(this.lineChartPopover);
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
};
ArcGISChartsConfigLineChartData.style = ArcgisChartsConfigLineChartDataStyle0;

const arcgisChartsConfigLineChartSeriesCss = ":host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}";
const ArcgisChartsConfigLineChartSeriesStyle0 = arcgisChartsConfigLineChartSeriesCss;

const ArcGISChartsConfigLineChartSeries = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigLineChartSeriesPopoverChange = index.createEvent(this, "arcgisChartsConfigLineChartSeriesPopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = index.createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        /**
         * @category Private
         */
        this.seriesPopover = null;
        /**
         * @category Private
         */
        this.resetSeriesOriginal = async () => {
            this.configSeriesOpen = false;
            this.selectedSeriesIndex = undefined;
            // reset series styling
            await this.model.resetSeriesStyling();
        };
        /**
         * @category Event handler
         */
        this.seriesNameChange = (event) => {
            if (event.detail !== null || event.detail !== undefined) {
                const name = event.detail?.name;
                this.model.setSeriesName(name, this.selectedSeriesIndex ?? -1);
            }
        };
        /**
         * @category Event handler
         */
        this.seriesColorChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { color } = e.detail;
                // update line and marker color of the selected series
                this.model.setColorMatch(false);
                if (color !== undefined) {
                    this.model.setSeriesColor(color, this.selectedSeriesIndex ?? -1);
                    this.model.setSeriesMarkerColor(color, this.selectedSeriesIndex ?? -1);
                }
            }
        };
        /**
         * @category Event handler
         */
        this.seriesLineStyleChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { lineStyle } = e.detail;
                if (lineStyle !== undefined) {
                    this.model.setSeriesLineStyle(lineStyle, this.selectedSeriesIndex ?? -1);
                }
            }
        };
        /**
         * @category Event handler
         */
        this.seriesLineWidthChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { lineWidth } = e.detail;
                if (lineWidth !== undefined) {
                    this.model.setSeriesLineWidth(lineWidth, this.selectedSeriesIndex ?? -1);
                    this.model.setSeriesMarkerSize(lineWidth * 2, this.selectedSeriesIndex ?? -1);
                }
            }
        };
        /**
         * @category Event handler
         */
        this.onCalciteListOrderChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { newIndex, oldIndex } = e.detail;
                this.model.moveSeries(oldIndex, newIndex);
            }
        };
        /**
         * @category Event handler
         */
        this.seriesPopoverClose = () => {
            this.selectedSeriesIndex = undefined;
            this.configSeriesOpen = false;
        };
        /**
         * @category Event handler
         */
        this.seriesPopoverChange = (open) => {
            this.arcgisChartsConfigLineChartSeriesPopoverChange.emit({
                open,
                element: this.seriesPopover,
            });
        };
        /**
         * @category Event handler
         */
        this.openSeriesPopOver = (event) => {
            // The target can be either the list item or the icon
            const target = event.target;
            const listItem = target.localName === "calcite-list-item"
                ? target
                : target.parentNode;
            const negateConfigSeriesOpen = !this.configSeriesOpen;
            const seriesIndex = this.model.getSeriesIndex(listItem.value);
            this.configSeriesOpen = this.selectedSeriesIndex === seriesIndex ? negateConfigSeriesOpen : true;
            if (this.configSeriesOpen) {
                this.selectedSeriesIndex = seriesIndex;
            }
            else {
                this.selectedSeriesIndex = undefined;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Emit event on open popover.
         * @param e
         * @category Private
         */
        this.openChange = (e) => {
            this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
        };
        this.model = undefined;
        this.configSeriesOpen = false;
        this.activeColorMatch = false;
        this.popoverPlacement = "leading";
        this.selectedSeriesIndex = undefined;
        this.updatesOccurred = 0;
        this.isResetAvailable = false;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Watch handler
     */
    selectedSeriesIndexChange() {
        if (this.selectedSeriesIndex !== undefined && this.configSeriesOpen) {
            this.setupSeriesPopover();
            if (this.seriesPopover !== null) {
                // sync back to seriesPopover
                this.seriesPopover.selectedName = this.model.getSeriesName(this.selectedSeriesIndex);
                this.seriesPopover.selectedColor = this.model.getSeriesColor(this.selectedSeriesIndex);
                this.seriesPopover.selectedLineStyle = this.model.getSeriesLineStyle(this.selectedSeriesIndex);
                this.seriesPopover.selectedLineWidth = this.model.getSeriesLineWidth(this.selectedSeriesIndex);
                if (!this.seriesPopover.open) {
                    this.seriesPopover.open = true;
                }
            }
            this.addSeriesPopover();
        }
        else {
            this.removeSeriesPopover();
        }
    }
    /**
     * @category Private
     */
    removeSeriesPopover() {
        if (this.seriesPopover !== undefined && this.seriesPopover !== null) {
            this.seriesPopover.open = false;
            this.seriesPopover = restJsObjectLiterals.Jy(this.seriesPopover);
        }
        this.seriesPopoverChange(false);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removeSeriesPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Render UX
     */
    buildSeriesListItems() {
        const seriesLength = this.model.getSeriesLength();
        const seriesListItems = [];
        for (let index$1 = 0; index$1 < seriesLength; index$1 += 1) {
            const id = this.model.getSeriesId(index$1);
            const color = this.model.getSeriesColor(index$1);
            const name = this.model.getSeriesName(index$1);
            const chartSubType = this.model.getChartSubType();
            const description = chartSubType === restJsObjectLiterals.ml.BarAndLineFromFields ? this.strings.series : id;
            const style = this.model.getSeriesLineStyle(index$1);
            const lineStyleType = chartUiUtils.getLineStyleType(style);
            // If `undefined` is provided for the series, we default the color icon to a grey minus circle
            let iconColor = "#CCCCCC";
            let icon = "minus-circle";
            if ((seriesLength > 1 || !this.activeColorMatch) && color !== undefined) {
                icon = `line-${lineStyleType}`;
                const [r, g, b, a] = [...color];
                iconColor = `rgba(${r},${g},${b},${a / 255})`;
            }
            seriesListItems.push(index.h("calcite-list-item", { key: id, label: name ?? id ?? "", description: description, value: id, selected: this.selectedSeriesIndex === index$1, onClick: this.openSeriesPopOver }, index.h("calcite-icon", { slot: "content-end", icon: icon, style: { color: iconColor } })));
        }
        return seriesListItems;
    }
    /**
     * @category Render UX
     */
    buildSeriesList() {
        return (index.h("calcite-list", { label: "", dragEnabled: true, selectionMode: "single", selectionAppearance: "border", onCalciteListOrderChange: this.onCalciteListOrderChange }, this.buildSeriesListItems()));
    }
    async componentWillRender() {
        this.isResetAvailable = await this.model.resetAvailable();
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (index.h(index.Host, { key: '10ea150c44b98f9f5a5f8431b8461eafcc26182b' }, index.h("calcite-panel", { key: '964f2b000510d2938b33a54dbe6441270b0e74c0', heading: this.strings.series }, index.h("calcite-button", { key: '25c4f310b15036faea7bc08f9ff830fdba49c08d', slot: "header-actions-end", onClick: this.resetSeriesOriginal, disabled: !this.isResetAvailable, appearance: "transparent", scale: "s", iconEnd: "reset" }, this.strings.reset), this.buildSeriesList())));
    }
    /**
     * @category Private
     */
    setupSeriesPopover() {
        if (this.seriesPopover === null && this.hostElement !== undefined) {
            // seriesPopover config
            const popoverConfig = {
                referenceElement: this.hostElement,
                placement: this.popoverPlacement,
                seriesNameChange: this.seriesNameChange,
                seriesColorChange: this.seriesColorChange,
                seriesLineStyleChange: this.seriesLineStyleChange,
                seriesLineWidthChange: this.seriesLineWidthChange,
                openChange: this.openChange,
                popoverClose: this.seriesPopoverClose,
            };
            // create a new seriesPopover
            this.seriesPopover = restJsObjectLiterals.Zy(restJsObjectLiterals.Qy.LineChartSeriesPopover, popoverConfig);
        }
    }
    /**
     * @category Private
     */
    addSeriesPopover() {
        if (this.seriesPopover != null && !document.body.contains(this.seriesPopover)) {
            document.body.appendChild(this.seriesPopover);
        }
        this.seriesPopoverChange(true);
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "selectedSeriesIndex": ["selectedSeriesIndexChange"]
    }; }
};
ArcGISChartsConfigLineChartSeries.style = ArcgisChartsConfigLineChartSeriesStyle0;

exports.arcgis_charts_config_line_chart_data = ArcGISChartsConfigLineChartData;
exports.arcgis_charts_config_line_chart_series = ArcGISChartsConfigLineChartSeries;
