/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
'use strict';

const restJsObjectLiterals = require('./rest-js-object-literals-acb59afb.js');
const index = require('./index-e5a6a075.js');
const interfaces = require('./interfaces-28e1772a.js');

const defaultPieFromFieldsName = "arcgis_charts_pie_from_fields_name";
const defaultBarLineFromFieldsName = "arcgis_charts_bar_line_from_fields_name";

const UIDefaults = {
    DebounceTimer: 400,
    SliderTimer: 100,
    PopoverTimer: 60,
    customSortLimit: 100,
};
const DefaultStatNumberFormat = {
    style: "decimal",
    minimumFractionDigits: 0,
    maximumFractionDigits: 3,
};
const aggregationList = [
    restJsObjectLiterals.RESTStatisticType.Count,
    restJsObjectLiterals.RESTStatisticType.Sum,
    restJsObjectLiterals.RESTStatisticType.Average,
    restJsObjectLiterals.RESTStatisticType.ContinuousPercentile,
    restJsObjectLiterals.RESTStatisticType.Minimum,
    restJsObjectLiterals.RESTStatisticType.Maximum,
    restJsObjectLiterals.RESTStatisticType.NoAggregation,
];
const pieAggregationList = [restJsObjectLiterals.RESTStatisticType.Count, restJsObjectLiterals.RESTStatisticType.Sum];
function getFormatIcon(formatKey) {
    let formatIcon;
    switch (formatKey) {
        case index.ih.Title:
        case index.ih.XAxisTitle:
        case index.ih.YAxisTitle:
        case index.ih.LegendTitle: {
            formatIcon = interfaces.FormatIcons.Title;
            break;
        }
        case index.ih.Description:
        case index.ih.LegendText: {
            formatIcon = interfaces.FormatIcons.Text;
            break;
        }
        case index.ih.AxisLabels:
        case index.ih.GuideLabels:
        case index.ih.DataLabels: {
            formatIcon = interfaces.FormatIcons.Label;
            break;
        }
        case index.ih.Background:
        case index.ih.LeaderLines:
        case index.ih.AxisLines:
        case index.ih.GridLines: {
            formatIcon = interfaces.FormatIcons.Palette;
            break;
        }
    }
    return formatIcon;
}
/**
 * Validates a value entered in a numeric calcite-input.
 * Controls that the value is not undefined, not empty (invalid) and in between the [min, max] range if provided
 * @param value
 * @param min
 * @param max
 */
function isCalciteInputValidNumber(value, min, max) {
    let isValid = false;
    const numericValue = typeof value === "string" ? Number.parseFloat(value) : value;
    const minValue = typeof min === "string" ? Number.parseFloat(min) : min;
    const maxValue = typeof max === "string" ? Number.parseFloat(max) : max;
    if (!Number.isNaN(numericValue)) {
        isValid =
            (minValue === undefined || Number.isNaN(minValue) || numericValue >= minValue) &&
                (maxValue === undefined || Number.isNaN(maxValue) || numericValue <= maxValue);
    }
    return isValid;
}
/**
 * Secures a provided number by returning either the same number, or a default value, or undefined.
 * The actual value is typed as "string" because the calcite-input inputs returns a string value
 * no matter the type of input used (text, number, textarea...).
 *   - If the value is valid (not NaN, finite), the value is returned
 *   - If not and if a valid default value is provided, the default value is returned
 *   - If not, an empty string is returned
 * @param value
 * @param defaultValue
 */
function sanitizeNumber(value, defaultValue) {
    let returnedValue;
    if (value !== null) {
        const testedValue = typeof value === "string" ? Number.parseFloat(value) : value;
        if (restJsObjectLiterals.Ml(testedValue)) {
            returnedValue = testedValue;
        }
        else if (restJsObjectLiterals.Ml(defaultValue)) {
            returnedValue = defaultValue;
        }
    }
    return returnedValue === undefined ? "" : `${returnedValue}`;
}
/**
 * Modifies a calcite-input status
 * @param props
 */
function modifyCalciteInputStatus(props) {
    const { inputElement, status } = props;
    inputElement.status = status;
}
const UIInputStatus = {
    IDLE: "idle",
    VALID: "valid",
    INVALID: "invalid",
};
/**
 * Formats a number according to the locale and optionally rounds it
 * @param value
 * @param precision
 */
function formatNumberToLocale(value, formatOptions) {
    let formattedValue = "";
    if (value !== undefined && !Number.isNaN(value)) {
        const { formatLocale } = restJsObjectLiterals.jn();
        // eslint-disable-next-line new-cap
        formattedValue = Intl.NumberFormat(formatLocale, formatOptions).format(value);
    }
    return formattedValue;
}
/**
 * Indicates whether the item matches the provided string,
 * or one of the strings in the array of strings.
 * @param item
 * @param selectedContent
 */
function itemMatchesSelectedContent(item, selectedContent) {
    let matches = false;
    if (selectedContent !== undefined) {
        const trimmedContent = typeof selectedContent === "string" ? selectedContent.trim() : selectedContent;
        const trimmedItem = item.trim();
        if (typeof selectedContent === "string") {
            matches =
                trimmedContent === trimmedItem || (trimmedContent === defaultBarLineFromFieldsName && trimmedItem === "");
        }
        else {
            matches = trimmedContent.includes(trimmedItem);
        }
    }
    return matches;
}
/**
 * Returns the offset distance based on the provided placement option of a popover;
 * For now, the popover will display either on top of the target element using the 'trailing' placement option,
 * or to the left of the target element using the 'leading' placement option.
 * @param placement
 */
function getPopoverOffsetDistance(placement) {
    let offsetDistance;
    switch (placement) {
        case "trailing":
            offsetDistance = -200;
            break;
        case "leading":
            offsetDistance = 20;
            break;
        default:
            offsetDistance = 0;
            break;
    }
    return offsetDistance;
}
/**
 * Helper function to sanitize a color with NaNs
 *  - Returns null if color is undefined or contains NaN values
 *  - Returns the color otherwise
 * @param color RGB | undefined
 */
function sanitizeColor(color) {
    return color === undefined || Number.isNaN(color.r) || Number.isNaN(color.g) || Number.isNaN(color.b) ? null : color;
}
/**
 * Handler for "keydown" event on numberic input element. Prevents input of "e" character.
 * @param e Input element "keydown" event
 */
const blockNumericE = (e) => {
    if (["e", "E"].includes(e.key)) {
        e.preventDefault();
    }
};
/**
 * Creates a tooltip for the hovered action.
 * @param actionElement
 */
const createActionTooltip = (actionElement) => {
    const tooltip = document.createElement("calcite-tooltip");
    tooltip.referenceElement = actionElement;
    tooltip.open = true;
    tooltip.placement = "top";
    tooltip.style.setProperty("opacity", "1");
    tooltip.style.zIndex = "var(--calcite-floating-ui-z-index)";
    return tooltip;
};
/**
 * Destroys tooltip for the action that was being hovered.
 * @param tooltip
 */
const destroyActionTooltip = (tooltip) => {
    if (tooltip !== undefined) {
        tooltip.style.removeProperty("opacity");
        tooltip.remove();
    }
};
/**
 * emit numeric field change event
 * @param props.pickListElement
 * @param props.eventEmitter
 * @param props.contentKind
 * @category Public
 */
const emitNumericFieldsChange = (props) => {
    if (props.pickListElement !== undefined) {
        const selectedItems = props.pickListElement.selectedItems;
        props.eventEmitter.emit({
            contentKind: props.contentKind,
            value: selectedItems.map((item) => item.value),
        });
    }
};
/**
 * Returns the line style type based on the provided line style.
 * @param lineStyle
 */
function getLineStyleType(lineStyle) {
    let lineStyleType = "solid";
    switch (lineStyle) {
        case restJsObjectLiterals.RESTSimpleLineSymbolStyle.Dash:
            lineStyleType = "dashed";
            break;
        case restJsObjectLiterals.RESTSimpleLineSymbolStyle.Dot:
            lineStyleType = "dotted";
            break;
        case restJsObjectLiterals.RESTSimpleLineSymbolStyle.Solid:
        default:
            lineStyleType = "solid";
            break;
    }
    return lineStyleType;
}

exports.DefaultStatNumberFormat = DefaultStatNumberFormat;
exports.UIDefaults = UIDefaults;
exports.UIInputStatus = UIInputStatus;
exports.aggregationList = aggregationList;
exports.blockNumericE = blockNumericE;
exports.createActionTooltip = createActionTooltip;
exports.defaultBarLineFromFieldsName = defaultBarLineFromFieldsName;
exports.defaultPieFromFieldsName = defaultPieFromFieldsName;
exports.destroyActionTooltip = destroyActionTooltip;
exports.emitNumericFieldsChange = emitNumericFieldsChange;
exports.formatNumberToLocale = formatNumberToLocale;
exports.getFormatIcon = getFormatIcon;
exports.getLineStyleType = getLineStyleType;
exports.getPopoverOffsetDistance = getPopoverOffsetDistance;
exports.isCalciteInputValidNumber = isCalciteInputValidNumber;
exports.itemMatchesSelectedContent = itemMatchesSelectedContent;
exports.modifyCalciteInputStatus = modifyCalciteInputStatus;
exports.pieAggregationList = pieAggregationList;
exports.sanitizeColor = sanitizeColor;
exports.sanitizeNumber = sanitizeNumber;
