/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2e64cfc1.js');
const index$1 = require('./index-e5a6a075.js');
const restJsObjectLiterals = require('./rest-js-object-literals-acb59afb.js');
const interfaces = require('./interfaces-28e1772a.js');
const store = require('./store-fbc7ac07.js');
const chartUiUtils = require('./chart-ui-utils-ba499862.js');
const isEqual = require('./isEqual-7c4e90f5.js');
const chartObjectLiterals = require('./chart-object-literals-a706ca0f.js');
const isNil = require('./isNil-a7f84422.js');
require('./_Uint8Array-9bd4a4da.js');
require('./_Map-d0ba2c83.js');
require('./isObject-b063d8a9.js');
require('./_getAllKeys-facd90a6.js');
require('./_getTag-66a55d52.js');

const HTMLClasses$1 = {
    label: "label",
    text: "text",
    fieldList: "field-list",
    fab: "fab",
    disabledLabel: "disabled-label",
    dimText: "dim-text",
    rtl: "arcgis-charts-rtl",
    list: "list",
    customSortButtons: "custom-sort-buttons",
};

const arcgisChartsConfigBoxPlotDataCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}:host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin);margin-top:var(--arcgis-charts-top-section-margin)}.label,.disabled-label{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.text{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);width:calc(100% - 1.5rem);height:2rem;margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.field-list{max-height:50vh;overflow-y:auto}.disabled-label{pointer-events:none}.fab{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:1.5rem;justify-content:center}:host(.arcgis-chart-rtl) .text{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}.list{margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-major)}.custom-sort-buttons{display:flex;justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}";
const ArcgisChartsConfigBoxPlotDataStyle0 = arcgisChartsConfigBoxPlotDataCss;

const ArcGISChartsConfigBoxPlotData = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigDataChangeError = index.createEvent(this, "arcgisChartsConfigDataChangeError", 7);
        /**
         * @category Private
         */
        this.boxPlotPopover = null;
        /**
         * @category Private
         * List of original custom sort labels
         * Used to reset the custom sort labels
         */
        this.originalCustomSortLabels = [];
        /**
         * @category Private
         *
         * Flag to disable the custom sort list.
         */
        this.isCustomSortDisabled = false;
        /**
         * @category Event handler
         */
        this.onCalciteListOrderChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { newIndex, oldIndex } = e.detail;
                this.model.moveCustomSortValuesInOrderByList(oldIndex, newIndex);
                this.customSortLabels = this.model.getOrderByList();
            }
        };
        /**
         * @category Event handler
         */
        this.onCustomSortItemSelected = (e) => {
            const { id } = e.target;
            // unselect the custom sort item in the custom sort' values list if it is already selected
            this.selectedCustomSortItemId = this.selectedCustomSortItemId === id ? "" : id;
        };
        /**
         * @category Event handler
         */
        this.onCustomSortItemMoved = (e) => {
            const { id } = e.target;
            let toIndex = this.customSortLabels.length;
            const fromIndex = this.customSortLabels.indexOf(this.selectedCustomSortItemId);
            // calculate the index to move the selected item to
            if (id === interfaces.ButtonDirections.Up) {
                toIndex = fromIndex - 1;
            }
            else if (id === interfaces.ButtonDirections.Down) {
                toIndex = fromIndex + 1;
            }
            // move the selected item to the calculated index only within the valid list bound
            if (fromIndex >= 0 && toIndex >= 0 && toIndex < this.customSortLabels.length) {
                this.model.moveCustomSortValuesInOrderByList(fromIndex, toIndex);
                this.customSortLabels = this.model.getOrderByList();
            }
        };
        /**
         * @category Event handler
         *
         * called when the category is clicked
         */
        this.onCategorySelect = () => {
            if (!this.categoryElement.disabled) {
                this.contentKind = interfaces.BoxPlotDataPopoverKinds.category;
                this.setupPopover();
            }
        };
        /**
         * @category Event handler
         *
         * Called when individual numeric field item is removed.
         */
        this.onRemoveNumericField = async (removedItemEvent) => {
            const removedField = removedItemEvent.target.value;
            await this.model.setNumericFields(this.model.getNumericFields().filter((field) => field !== removedField));
            // update custom sort's value list if the numeric fields are changed
            await this.updateCustomSortProps();
            this.model.setOrderByList(this.customSortLabels);
        };
        /**
         * @category Private
         *
         * Update custom sort properties
         */
        this.updateCustomSortProps = async () => {
            const customSortValues = await this.model.getCustomSortValues();
            this.customSortLabels = customSortValues;
            this.originalCustomSortLabels = [...customSortValues];
            // enable/disable the custom sort list based on the number of custom sort labels
            const isCustomSortDisabled = customSortValues.length > chartUiUtils.UIDefaults.customSortLimit;
            if (isCustomSortDisabled) {
                this.sortOrderElement.label = this.strings.xAxisAsc;
                this.model.setSortOrder(index$1.Zf.xAxisAsc);
            }
            this.isCustomSortDisabled = isCustomSortDisabled;
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Event handler
         */
        this.onStandardizeValuesChange = async (e) => {
            await this.model.setStandardizeValues(e.target.checked);
        };
        /**
         * @category Event handler
         */
        this.onShowOutliersChange = async (e) => {
            await this.model.setShowOutliers(e.target.checked);
        };
        /**
         * @category Event handler
         *
         * called when the category is clicked
         */
        this.onSplitBySelect = () => {
            if (!this.splitByFieldElement.disabled) {
                this.contentKind = interfaces.BoxPlotDataPopoverKinds.splitByField;
                this.setupPopover();
            }
        };
        /**
         * @category Event handler
         *
         * called when the sort order is clicked
         */
        this.onSortOrderSelect = () => {
            this.contentKind = interfaces.BoxPlotDataPopoverKinds.sortOrder;
            this.setupPopover();
        };
        /**
         * @category Event handler
         *
         * called when the add numeric fields button is clicked
         */
        this.onAddNumericFields = () => {
            this.contentKind = interfaces.BoxPlotDataPopoverKinds.numericFields;
            this.setupPopover();
        };
        /**
         * Close box plot popover
         * @category Private
         */
        this.popoverClose = (e) => {
            if (this.boxPlotPopover === e?.target) {
                this.boxPlotPopover = restJsObjectLiterals.Jy(this.boxPlotPopover);
            }
        };
        /**
         * @category Event handler
         *
         * called in response to the arcgisChartsConfigBoxPlotDataPopoverChange event
         */
        this.onBoxPlotDataChange = async (e) => {
            try {
                if (e.detail !== null && e.detail?.value !== undefined) {
                    const { contentKind } = e.detail;
                    const newValue = [...e.detail.value];
                    // reset axes bounds for this chart in stencil store
                    store.deleteMinMaxAxisKey(store.state);
                    switch (contentKind) {
                        case interfaces.BoxPlotDataPopoverKinds.category: {
                            const newCategory = newValue[0]?.trim() || restJsObjectLiterals.eo;
                            await this.model.setCategory(newCategory);
                            // update custom sort's value list if the category field is changed
                            await this.updateCustomSortProps();
                            this.model.setOrderByList(this.customSortLabels);
                            break;
                        }
                        case interfaces.BoxPlotDataPopoverKinds.numericFields: {
                            await this.model.setNumericFields(newValue);
                            // check whether selectedValues has multiple numeric fields
                            const isMultipleFields = newValue.length > 1;
                            // we only apply z-score for the box plot with multiple numeric fields
                            await this.model.setStandardizeValues(isMultipleFields);
                            // update custom sort's value list if the numeric fields are changed
                            await this.updateCustomSortProps();
                            this.model.setOrderByList(this.customSortLabels);
                            break;
                        }
                        case interfaces.BoxPlotDataPopoverKinds.splitByField: {
                            const newSplitByField = newValue[0]?.trim() || "";
                            await this.model.setSplitByField(newSplitByField);
                            break;
                        }
                        case interfaces.BoxPlotDataPopoverKinds.sortOrder:
                            {
                                const newSortOrder = newValue[0];
                                if (newSortOrder === index$1.Zf.customSort) {
                                    await this.updateCustomSortProps();
                                    this.model.setSortOrder(newSortOrder, this.customSortLabels);
                                }
                                else {
                                    this.model.setSortOrder(newSortOrder);
                                }
                            }
                            break;
                    }
                }
            }
            catch (error) {
                this.arcgisChartsConfigDataChangeError.emit({ error, model: this.model });
                throw error;
            }
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Private
         */
        this.resetToOriginalCustomSortLabels = () => {
            this.selectedCustomSortItemId = "";
            this.model.setOrderByList([...this.originalCustomSortLabels]);
        };
        this.model = undefined;
        this.layerFieldsInfo = undefined;
        this.selectedCustomSortItemId = undefined;
        this.updatesOccurred = 0;
        this.customSortLabels = [];
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.boxPlotPopover = restJsObjectLiterals.Jy(this.boxPlotPopover);
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
        this.onModelConfigChange();
        this.currentDataFilter = this.model.getDataFilter();
        this.updateCustomSortProps();
    }
    /**
     * @category Lifecycle
     */
    componentWillRender() {
        const savedDataFilter = this.model.getDataFilter();
        if (!isEqual.isEqual(savedDataFilter, this.currentDataFilter)) {
            this.updateCustomSortProps();
            this.currentDataFilter = this.model.getDataFilter();
        }
        else {
            this.customSortLabels = this.model.getOrderByList();
        }
        // split-by should be disabled if there are no numeric fields or if there are more than one numeric field and a category is selected
        this.disableSplitBy =
            this.model.getNumericFields().length === 0 ||
                (this.model.getNumericFields().length > 1 && this.model.getCategory() !== restJsObjectLiterals.eo);
    }
    /**
     * @category Render UX
     */
    buildCustomSortListItems() {
        const customSortListItems = [];
        for (let index$1 = 0; index$1 < this.customSortLabels.length; index$1 += 1) {
            const label = this.customSortLabels[index$1];
            const description = restJsObjectLiterals.Cl(this.layerFieldsInfo, label);
            customSortListItems.push(index.h("calcite-list-item", { id: label, key: label, label: label ?? "", description: description, value: label, selected: this.selectedCustomSortItemId === label, onCalciteListItemSelect: this.onCustomSortItemSelected }, index.h("calcite-icon", { slot: "content-end" })));
        }
        return customSortListItems;
    }
    /**
     * @category Render UX
     */
    buildCustomSortList() {
        return (index.h("calcite-list", { label: "", class: HTMLClasses$1.list, dragEnabled: true, selectionMode: "single", selectionAppearance: "border", onCalciteListOrderChange: this.onCalciteListOrderChange }, this.buildCustomSortListItems()));
    }
    renderCustomSortUI() {
        const sortOrder = this.model.getSortOrder();
        const valueType = this.model.getXAxisValueFormat()?.type;
        const index$2 = this.customSortLabels.indexOf(this.selectedCustomSortItemId);
        const customSortListUI = valueType ===
            chartObjectLiterals.WebChartTypes.CategoryAxisFormat /*render the custom sort for the only fields with value format set to CategoryAxisFormat */ &&
            sortOrder === index$1.Zf.customSort &&
            !this.isCustomSortDisabled ? (index.h("calcite-label", { class: HTMLClasses$1.label }, index.h("div", { class: HTMLClasses$1.customSortButtons }, index.h("div", null, index.h("calcite-button", { appearance: "transparent", disabled: index$2 === 0 || index$2 === -1 || this.selectedCustomSortItemId.trim() === "", iconStart: "arrow-bold-up", id: interfaces.ButtonDirections.Up, kind: "neutral", scale: "s", onClick: this.onCustomSortItemMoved }), index.h("calcite-button", { appearance: "transparent", disabled: index$2 === -1 ||
                index$2 === this.customSortLabels.length - 1 ||
                this.selectedCustomSortItemId.trim() === "", iconStart: "arrow-bold-down", id: interfaces.ButtonDirections.Down, kind: "neutral", scale: "s", onClick: this.onCustomSortItemMoved })), index.h("calcite-button", { onClick: this.resetToOriginalCustomSortLabels, disabled: isEqual.isEqual(this.customSortLabels, this.originalCustomSortLabels), appearance: "transparent", iconEnd: "reset" }, this.strings.reset)), this.model.getCategory() === restJsObjectLiterals.eo ? this.strings.values : this.strings.category, this.buildCustomSortList())) : null;
        return customSortListUI;
    }
    /**
     * @category Render UX
     */
    renderNumericFields(fields) {
        const fieldList = [];
        for (let i = 0; i < fields.length; i += 1) {
            fieldList.push(this.buildNumericFieldItem(fields[i]));
        }
        return (index.h("calcite-list", { label: "", class: HTMLClasses$1.fieldList, ref: (e) => {
                this.numericFieldsElement = e;
            } }, fieldList));
    }
    /**
     * Note: using a calcite-action rather than the `closable={true}` property given
     * it was removing too many fields from the list when clicking on the "x" icon
     * @param field
     */
    buildNumericFieldItem(field) {
        return (index.h("calcite-list-item", { label: restJsObjectLiterals.Tl(this.layerFieldsInfo, field), value: field, key: field, closable: true, onCalciteListItemClose: this.onRemoveNumericField }));
    }
    /**
     * @category Render UX
     */
    renderCategory() {
        const categoryString = this.getCorrectedCategoryValue();
        // category should be disabled if there are no numeric fields or if there are more than one numeric field and a split-by is selected
        const disabled = this.model.getNumericFields().length === 0 ||
            (this.model.getNumericFields().length > 1 && this.model.getSplitByField() !== "");
        return (index.h("arcgis-charts-config-field-select", { label: categoryString, disabled: disabled, ref: (e) => {
                this.categoryElement = e;
            }, onClick: this.onCategorySelect }));
    }
    /**
     * @category Render UX
     */
    renderSplitBy() {
        const splitByString = this.getCorrectedSplitByValue();
        return (index.h("arcgis-charts-config-field-select", { label: splitByString, disabled: this.disableSplitBy, ref: (e) => {
                this.splitByFieldElement = e;
            }, onClick: this.onSplitBySelect }));
    }
    /**
     * @category Render UX
     */
    renderSorting() {
        return (index.h("arcgis-charts-config-field-select", { label: this.strings[this.model.getSortOrder()], ref: (e) => {
                this.sortOrderElement = e;
            }, onClick: this.onSortOrderSelect }));
    }
    /**
     * @category Lifecycle
     */
    render() {
        const categoryUI = this.renderCategory();
        const numericFieldsUI = this.renderNumericFields([...this.model.getNumericFields()]);
        const splitByUI = this.renderSplitBy();
        const sortingUI = this.renderSorting();
        const customSortUI = this.renderCustomSortUI();
        return (index.h(index.Host, { key: 'cc75b64ad20cb075936afa26f80935ad5cdfe906', class: { [HTMLClasses$1.rtl]: this.direction === "rtl" } }, index.h("calcite-label", { key: '0dbf49c20d1777e0450ea64baff966cfdf51008d', class: HTMLClasses$1.label }, this.strings.numericFields, numericFieldsUI), index.h("div", { key: '3071277d5b95dee21a3e40d45bfb6c81afa6e0ae', class: HTMLClasses$1.fab }, index.h("calcite-fab", { key: '135d17641f4dd93b1f09b27de71885f93e26698a', appearance: "outline-fill", kind: "neutral", scale: "m", label: this.strings.selectNumericFields, "text-enabled": true, text: this.strings.selectNumericFields, icon: "plus", onClick: this.onAddNumericFields })), index.h("calcite-label", { key: '7baa4b742ffc4b357e208a87151d2d3e3e0f09a3', class: HTMLClasses$1.label }, index.h("div", { key: 'c7025c74ff2ac688fa57902a44dfcc966e40edb9' }, this.strings.category, " ", index.h("span", { key: '5c03d992841481729fb2396a751de07ac3bb4c8e', class: HTMLClasses$1.dimText }, "(", this.strings.optional, ")")), categoryUI), index.h("calcite-label", { key: '68ae7c61ce920aafa3e13c45c08bfd6dbda5b064', class: HTMLClasses$1.label }, index.h("div", { key: '7482d8325464608aa062e55293972bfd3e44b1cc', class: this.disableSplitBy ? HTMLClasses$1.dimText : "" }, this.strings.splitBy, " ", index.h("span", { key: 'b3cd9c2ccc08fc424cc939a5e0bab2fc5e689169', class: HTMLClasses$1.dimText }, "(", this.strings.optional, ")")), splitByUI), index.h("div", { key: '5f98ab70bb32bd3e81cd016eeb5a081c38ccc39d' }, this.model.getNumericFields().length > 1 ? (index.h("calcite-label", { class: HTMLClasses$1.label, layout: "inline-space-between" }, this.strings.standardizeValues, index.h("calcite-switch", { checked: this.model.getStandardizeValues(), onCalciteSwitchChange: this.onStandardizeValuesChange }))) : null), index.h("calcite-label", { key: '43e30d282adeae27b50a3a16d60454c26e582fbe', class: HTMLClasses$1.label, layout: "inline-space-between" }, this.strings.showOutliers, index.h("calcite-switch", { key: 'ece331d79f8ecfe2525dca40cfbe878584e97b50', checked: this.model.getShowOutliers(), onCalciteSwitchChange: this.onShowOutliersChange })), index.h("calcite-label", { key: '262ba118dd084bdf8b91d9927ec7d5ddb85de3da', class: HTMLClasses$1.label }, this.strings.sortOrder, sortingUI), customSortUI));
    }
    /**
     * @category Private
     */
    setupPopover() {
        // remove already existing chart popover
        // TODO: this is a hotfix for https://devtopia.esri.com/webgis/arcgis-charts/issues/5366
        // have to find a better way to do this
        this.boxPlotPopover = restJsObjectLiterals.Jy(this.boxPlotPopover);
        // boxPlotPopover config
        const popoverConfig = {
            layerFieldsInfo: this.layerFieldsInfo,
            onBoxPlotDataChange: this.onBoxPlotDataChange,
            popoverClose: this.popoverClose,
        };
        // create a new boxPlotPopover
        this.boxPlotPopover = restJsObjectLiterals.Zy(restJsObjectLiterals.Qy.BoxPlotDataPopover, popoverConfig);
        if (this.boxPlotPopover !== null) {
            // switch content of box plot popover based on the provided content
            switch (this.contentKind) {
                case interfaces.BoxPlotDataPopoverKinds.category:
                    this.boxPlotPopover.referenceElement = this.categoryElement;
                    this.boxPlotPopover.headingTitle = this.strings.categoryHeader;
                    this.boxPlotPopover.selectedContent =
                        this.model.getCategory() === restJsObjectLiterals.eo ? "" : this.model.getCategory();
                    break;
                case interfaces.BoxPlotDataPopoverKinds.numericFields:
                    this.boxPlotPopover.referenceElement = this.numericFieldsElement;
                    this.boxPlotPopover.headingTitle = this.strings.numericFieldsHeader;
                    this.boxPlotPopover.selectedContent = this.model.getNumericFields();
                    break;
                case interfaces.BoxPlotDataPopoverKinds.splitByField:
                    this.boxPlotPopover.referenceElement = this.splitByFieldElement;
                    this.boxPlotPopover.headingTitle = this.strings.splitByFieldHeader;
                    this.boxPlotPopover.selectedContent = this.model.getSplitByField();
                    break;
                case interfaces.BoxPlotDataPopoverKinds.sortOrder:
                    this.boxPlotPopover.referenceElement = this.sortOrderElement;
                    this.boxPlotPopover.headingTitle = this.strings.selectSortOrder;
                    this.boxPlotPopover.selectedContent = this.model.getSortOrder();
                    this.boxPlotPopover.isCustomSortDisabled = this.isCustomSortDisabled;
                    break;
            }
            this.boxPlotPopover.contentKind = this.contentKind;
            this.boxPlotPopover.open = true;
            this.addPopover();
        }
    }
    /**
     * @category Private
     */
    addPopover() {
        if (!document.body.contains(this.boxPlotPopover) && this.boxPlotPopover !== null) {
            document.body.appendChild(this.boxPlotPopover);
        }
    }
    /**
     * Get the split by value based on the current model's split by field.
     *
     * **NOTE**: If the split by field is empty or there are more than one numeric fields, return an empty string.
     * @category Private
     * @returns {string} - The corrected split by value.
     */
    getCorrectedSplitByValue() {
        return this.model.getSplitByField()?.trim() === ""
            ? ""
            : restJsObjectLiterals.Tl(this.layerFieldsInfo, this.model.getSplitByField());
    }
    /**
     * Get the category value based on the current model's category field.
     *
     * **NOTE**: If the category field is the default value (`arcgis_charts_box_plot_category`), return an empty string.
     * @category Private
     * @returns {string} - The corrected category value.
     */
    getCorrectedCategoryValue() {
        return this.model.getCategory() === restJsObjectLiterals.eo
            ? ""
            : restJsObjectLiterals.Tl(this.layerFieldsInfo, this.model.getCategory());
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
};
ArcGISChartsConfigBoxPlotData.style = ArcgisChartsConfigBoxPlotDataStyle0;

const HTMLClasses = {
    topSection: "top-section",
    sectionLabel: "section-label",
    list: "list",
    infoIcon: "info-icon",
};

const arcgisChartsConfigBoxPlotSeriesCss = ":host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}.top-section{margin-top:var(--arcgis-charts-config-margin-minor)}.section-label{display:flex;margin-bottom:var(--arcgis-charts-config-margin-major);margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}.list{margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-major)}.info-icon{margin:auto 1rem;pointer-events:auto}";
const ArcgisChartsConfigBoxPlotSeriesStyle0 = arcgisChartsConfigBoxPlotSeriesCss;

const ArcGISChartsConfigBoxPlotSeries = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigBoxPlotSeriesPopoverChange = index.createEvent(this, "arcgisChartsConfigBoxPlotSeriesPopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = index.createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        /**
         * @category Private
         */
        this.resetSeriesOriginal = () => {
            this.configSeriesOpen = false;
            this.selectedSeriesIndex = undefined;
            // reset series styling
            this.model.resetSeriesStyling();
        };
        /**
         * @category Event handler
         */
        this.onMultipleSeriesSelect = async (event) => {
            if (!this.shouldDisableMeanLinesOption()) {
                const target = event.target;
                const value = target.value ??
                    target.parentElement.value ??
                    "";
                await this.model.setShowMeanLines(value === chartObjectLiterals.WebChartBoxPlotMultipleSeriesKinds.MeanLines);
            }
        };
        /**
         * @category Event handler
         */
        this.seriesNameChange = (event) => {
            if (event.detail !== null || event.detail !== undefined) {
                const name = event.detail?.name;
                this.model.setSeriesName(name, this.selectedSeriesIndex ?? -1);
            }
        };
        /**
         * @category Event handler
         */
        this.seriesColorChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { color } = e.detail;
                if (color !== undefined) {
                    if (this.meanLinesBoxColorIsSelected) {
                        this.model.setMeanLinesBoxColor(color);
                    }
                    else {
                        this.model.setColorMatch(false);
                        this.model.setSeriesColor(color, this.selectedSeriesIndex ?? -1);
                    }
                }
            }
        };
        /**
         * @category Event handler
         */
        this.seriesLineStyleChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { style } = e.detail;
                if (style !== undefined) {
                    this.model.setSeriesLineStyle(style, this.selectedSeriesIndex ?? -1);
                }
            }
        };
        /**
         * @category Event handler
         */
        this.seriesLineWidthChange = (e) => {
            if (e.detail !== null && e.detail !== undefined) {
                const { width } = e.detail;
                if (width !== undefined) {
                    this.model.setSeriesLineWidth(width, this.selectedSeriesIndex ?? -1);
                }
            }
        };
        /**
         * @category Event handler
         */
        this.onCalciteListOrderChange = (e) => {
            const boxPlotSeriesIndex = this.model.getBoxPlotSeriesIndexWhenMeanLinesShown();
            if (e.detail !== null && e.detail !== undefined) {
                const { newIndex, oldIndex } = e.detail;
                let adjustedOldIndex = oldIndex;
                let adjustedNewIndex = newIndex;
                // If the mean line series is enabled, we need to adjust the indices to account for the box plot series
                if (boxPlotSeriesIndex !== -1) {
                    adjustedOldIndex = oldIndex >= boxPlotSeriesIndex ? oldIndex + 1 : oldIndex;
                    adjustedNewIndex = newIndex >= boxPlotSeriesIndex ? newIndex + 1 : newIndex;
                }
                this.model.moveSeries(adjustedOldIndex, adjustedNewIndex);
            }
        };
        /**
         * @category Event handler
         */
        this.seriesPopoverClose = () => {
            this.selectedSeriesIndex = undefined;
            this.meanLinesBoxColorIsSelected = false;
            this.configSeriesOpen = false;
            this.seriesPopover = restJsObjectLiterals.Jy(this.seriesPopover);
        };
        /**
         * @category Event handler
         */
        this.seriesPopoverChange = (open) => {
            this.arcgisChartsConfigBoxPlotSeriesPopoverChange.emit({
                open,
                element: this.seriesPopover,
            });
        };
        /**
         * @category Event handler
         */
        this.openSeriesPopOver = (event) => {
            // The target can be either the list item or the icon
            const target = event.target;
            const listItem = target.localName === "calcite-list-item"
                ? target
                : target.parentNode;
            const negateConfigSeriesOpen = !this.configSeriesOpen;
            const seriesIndex = this.model.getSeriesIndex(listItem.value);
            if (seriesIndex !== undefined && seriesIndex !== -1) {
                this.configSeriesOpen = this.selectedSeriesIndex === seriesIndex ? negateConfigSeriesOpen : true;
                if (this.configSeriesOpen) {
                    this.selectedSeriesIndex = seriesIndex;
                }
                else {
                    this.selectedSeriesIndex = undefined;
                }
                this.meanLinesBoxColorIsSelected = false;
            }
            else if (listItem.value === "box-plot-color") {
                const negateMeanLinesBoxColorSelected = !this.meanLinesBoxColorIsSelected;
                this.configSeriesOpen = negateMeanLinesBoxColorSelected;
                this.meanLinesBoxColorIsSelected = negateMeanLinesBoxColorSelected;
                this.selectedSeriesIndex = undefined;
            }
        };
        /**
         * Creates a tooltip for the hovered action.
         * @category Event handler
         */
        this.createTooltip = (e, text) => {
            const iconElement = e.target;
            this.tooltip = chartUiUtils.createActionTooltip(iconElement);
            this.tooltip.innerHTML = text;
            // append tooltip to the document body instead of action element
            // to avoid tooltip being cut off by calcite panel header element
            document.body.appendChild(this.tooltip);
        };
        /**
         * Destroys tooltip for the action that was being hovered.
         * @category Event handler
         */
        this.destroyTooltip = () => {
            chartUiUtils.destroyActionTooltip(this.tooltip);
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Emit event on open popover.
         * @param e
         * @category Private
         */
        this.openChange = (e) => {
            this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
        };
        this.model = undefined;
        this.configSeriesOpen = false;
        this.activeColorMatch = false;
        this.popoverPlacement = "leading";
        this.selectedSeriesIndex = undefined;
        this.meanLinesBoxColorIsSelected = false;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Watch handler
     */
    selectedSeriesIndexChange() {
        if (this.selectedSeriesIndex !== undefined && this.configSeriesOpen) {
            this.setupSeriesPopover();
            if (this.seriesPopover !== null) {
                // sync back to seriesPopover
                this.seriesPopover.selectedName = this.model.getSeriesName(this.selectedSeriesIndex);
                this.seriesPopover.selectedColor = this.model.getSeriesColor(this.selectedSeriesIndex);
                this.seriesPopover.isLineSymbol = this.model.getShowMeanLines() === true;
                this.seriesPopover.selectedLineStyle = this.model.getSeriesLineStyle(this.selectedSeriesIndex);
                this.seriesPopover.selectedLineWidth = this.model.getSeriesLineWidth(this.selectedSeriesIndex);
                if (!this.seriesPopover.open) {
                    this.seriesPopover.open = true;
                }
            }
            this.addSeriesPopover();
        }
        else {
            this.removeSeriesPopover();
        }
    }
    /**
     * @category Watch handler
     */
    meanLinesBoxColorIsSelectedChange() {
        if (this.meanLinesBoxColorIsSelected && this.configSeriesOpen) {
            this.setupSeriesPopover();
            if (this.seriesPopover !== null) {
                this.seriesPopover.selectedColor = this.model.getMeanLinesBoxColor();
                this.seriesPopover.isLineSymbol = false;
                if (!this.seriesPopover.open) {
                    this.seriesPopover.open = true;
                }
            }
            this.addSeriesPopover();
        }
        else {
            this.removeSeriesPopover();
        }
    }
    /**
     * @category Private
     */
    removeSeriesPopover() {
        if (this.seriesPopover !== null && this.seriesPopover !== undefined) {
            this.seriesPopover.open = false;
            this.seriesPopover = restJsObjectLiterals.Jy(this.seriesPopover);
        }
        this.seriesPopoverChange(false);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removeSeriesPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Render UX
     */
    buildSeriesListItems() {
        const seriesLength = this.model.getSeriesLength();
        const seriesListItems = [];
        const boxPlotSeriesIndex = this.model.getBoxPlotSeriesIndexWhenMeanLinesShown();
        for (let index$1 = 0; index$1 < seriesLength; index$1 += 1) {
            // skip displaying the box plot series in the series list when mean lines are shown
            if (boxPlotSeriesIndex === index$1) {
                continue;
            }
            const id = this.model.getSeriesId(index$1);
            const color = this.model.getSeriesColor(index$1);
            const name = this.model.getSeriesName(index$1);
            const chartSubType = this.model.getChartSubType();
            const description = chartSubType === restJsObjectLiterals.ml.BoxPlotMonoField || chartSubType === restJsObjectLiterals.ml.BoxPlotMultiFields
                ? this.strings.series
                : id;
            // If `undefined` is provided for the series, we default the color icon to a grey minus square
            let iconColor = "#CCCCCC";
            let icon = "minus-square";
            if ((seriesLength > 1 || !this.activeColorMatch) && color !== undefined) {
                icon = this.model.getShowMeanLines() === true ? "line-solid" : "square-f";
                const [r, g, b, a] = [...color];
                iconColor = `rgba(${r},${g},${b},${a / 255})`;
            }
            seriesListItems.push(index.h("calcite-list-item", { key: id, label: name ?? id ?? "", description: description, value: id, selected: this.selectedSeriesIndex === index$1, onClick: this.openSeriesPopOver }, index.h("calcite-icon", { slot: "content-end", icon: icon, style: { color: iconColor } })));
        }
        return seriesListItems;
    }
    /**
     * @category Render UX
     */
    buildSeriesList() {
        return (index.h("calcite-list", { label: "", class: HTMLClasses.list, dragEnabled: true, selectionMode: "single", selectionAppearance: "border", onCalciteListOrderChange: this.onCalciteListOrderChange }, this.buildSeriesListItems()));
    }
    /**
     * @category Render UX
     */
    renderMeanLinesBoxColorItem() {
        // If `undefined` is provided for the series, we default the color icon to a grey minus square
        let iconColor = "#CCCCCC";
        let icon = "minus-square";
        const color = this.model.getMeanLinesBoxColor();
        if (color !== undefined) {
            icon = "square-f";
            const [r, g, b, a] = [...color];
            iconColor = `rgba(${r},${g},${b},${a / 255})`;
        }
        return (index.h("calcite-list", { label: "", class: HTMLClasses.list }, index.h("calcite-list-item", { key: "box-plot-color", value: "box-plot-color", label: this.strings.boxPlotColor, selected: this.meanLinesBoxColorIsSelected, onClick: this.openSeriesPopOver }, index.h("calcite-icon", { slot: "content-end", icon: icon, style: { color: iconColor } }))));
    }
    /**
     * @category Render UX
     */
    renderMultipleSeriesOption() {
        const meanLinesDisabled = this.shouldDisableMeanLinesOption();
        return !meanLinesDisabled
            ? [
                index.h("div", { class: `${HTMLClasses.sectionLabel} ${HTMLClasses.topSection}` }, this.strings.displayMultipleSeries),
                index.h("calcite-list", { label: "", class: HTMLClasses.list, selectionMode: "single-persist", selectionAppearance: "border", onClick: this.onMultipleSeriesSelect }, index.h("calcite-list-item", { label: this.strings.sideBySide, value: chartObjectLiterals.WebChartBoxPlotMultipleSeriesKinds.Side, selected: this.model.getShowMeanLines() !== true }, index.h("calcite-icon", { slot: "content-start", scale: "l", icon: "graph-box-side-by-side" }), index.h("calcite-icon", { class: HTMLClasses.infoIcon, slot: "actions-end", icon: "information", scale: "s", flipRtl: true, onMouseOver: (e) => this.createTooltip(e, this.strings.sideBySideTooltip), onMouseOut: this.destroyTooltip })), index.h("calcite-list-item", { label: this.strings.meanLines, value: chartObjectLiterals.WebChartBoxPlotMultipleSeriesKinds.MeanLines, disabled: meanLinesDisabled, selected: this.model.getShowMeanLines() === true }, index.h("calcite-icon", { slot: "content-start", scale: "l", icon: "graph-box-mean-lines" }), index.h("calcite-icon", { class: HTMLClasses.infoIcon, slot: "actions-end", icon: "information", scale: "s", flipRtl: true, onMouseOver: (e) => this.createTooltip(e, this.strings.meanLinesTooltip), onMouseOut: this.destroyTooltip }))),
                this.model.getShowMeanLines() === true ? this.renderMeanLinesBoxColorItem() : null,
            ]
            : [];
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (index.h(index.Host, { key: 'd0ae5b1967c07286e9715eec73bc545c1bc2f5d8' }, this.renderMultipleSeriesOption(), index.h("div", { key: '03827b8daedfa818a995b05dfe1c83adec045994', class: HTMLClasses.sectionLabel }, this.strings.series, index.h("calcite-button", { key: '52a49fd526283240fb3fe8174f3356e7f87bd2fa', onClick: this.resetSeriesOriginal, disabled: !this.model.resetAvailable(), appearance: "transparent", iconEnd: "reset" }, this.strings.reset)), this.buildSeriesList()));
    }
    /**
     * @category Private
     */
    setupSeriesPopover() {
        if (isNil.isNil(this.seriesPopover) && this.hostElement !== undefined) {
            // seriesPopover config
            const popoverConfig = {
                seriesNameChange: this.seriesNameChange,
                seriesColorChange: this.seriesColorChange,
                seriesLineStyleChange: this.seriesLineStyleChange,
                seriesLineWidthChange: this.seriesLineWidthChange,
                openChange: this.openChange,
                hostElement: this.hostElement,
                placement: this.popoverPlacement,
                labelCanBeConfigured: !this.meanLinesBoxColorIsSelected,
                popoverClose: this.seriesPopoverClose,
            };
            // create a new seriesPopover
            this.seriesPopover = restJsObjectLiterals.Zy(restJsObjectLiterals.Qy.BoxPlotSeriesPopover, popoverConfig);
        }
    }
    /**
     * @category Private
     */
    addSeriesPopover() {
        if (this.seriesPopover !== null && !document.body.contains(this.seriesPopover)) {
            document.body.appendChild(this.seriesPopover);
        }
        this.seriesPopoverChange(true);
    }
    /**
     * @category Private
     */
    shouldDisableMeanLinesOption() {
        return this.model.getSplitByField() === "" || this.model.getSplitByField() === undefined;
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "selectedSeriesIndex": ["selectedSeriesIndexChange"],
        "meanLinesBoxColorIsSelected": ["meanLinesBoxColorIsSelectedChange"]
    }; }
};
ArcGISChartsConfigBoxPlotSeries.style = ArcgisChartsConfigBoxPlotSeriesStyle0;

exports.arcgis_charts_config_box_plot_data = ArcGISChartsConfigBoxPlotData;
exports.arcgis_charts_config_box_plot_series = ArcGISChartsConfigBoxPlotSeries;
