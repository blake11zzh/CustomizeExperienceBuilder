/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2e64cfc1.js');
const restJsObjectLiterals = require('./rest-js-object-literals-acb59afb.js');
const interfaces = require('./interfaces-28e1772a.js');
const chartUiUtils = require('./chart-ui-utils-ba499862.js');
const store = require('./store-fbc7ac07.js');
const debounce = require('./debounce-2f0b5b14.js');
const chartObjectLiterals = require('./chart-object-literals-a706ca0f.js');
require('./index-e5a6a075.js');
require('./isObject-b063d8a9.js');
require('./toNumber-b227ab04.js');

const HTMLClasses = {
    label: "label",
    text: "text",
    row: "row",
    binCountContainer: "bin-count-container",
    iconSelect: "icon-select",
    sectionLabel: "section-label",
    binTextPadding: "bin-text-padding",
    rtl: "arcgis-charts-rtl",
    histogramStatsList: "histogram-stats-list",
};

const arcgisChartsConfigHistogramDataCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}:host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}calcite-list-item{margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor)}.label{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.text{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);width:calc(100% - 1.5rem);height:2rem;margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.row{padding-top:1rem}.bin-count-container{display:flex;flex-wrap:wrap;padding:var(--arcgis-charts-config-margin-minor)}.bin-count-container>calcite-slider{flex-grow:10;min-width:50%}.bin-count-container>calcite-input{margin-bottom:0.5rem;margin-top:var(--arcgis-charts-config-margin-minor);margin-left:var(--arcgis-charts-config-margin-minor);width:5rem}.section-label{display:flex;margin:var(--arcgis-charts-config-margin-major) var(--arcgis-charts-config-margin-minor);justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}.bin-text-padding{margin-left:var(--arcgis-charts-config-margin-minor)}:host(.arcgis-charts-rtl) .text{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}:host(.arcgis-charts-rtl) .bin-count-container>calcite-input{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}:host(.arcgis-charts-rtl) .heading-text{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}:host(.arcgis-charts-rtl) .bin-text-padding{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}.histogram-stats-list{pointer-events:none;margin-bottom:var(--arcgis-charts-config-margin-minor)}";
const ArcgisChartsConfigHistogramDataStyle0 = arcgisChartsConfigHistogramDataCss;

const ArcGISChartsConfigHistogramData = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigHistogramDataPopoverChange = index.createEvent(this, "arcgisChartsConfigHistogramDataPopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = index.createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        this.arcgisChartsConfigDataChangeError = index.createEvent(this, "arcgisChartsConfigDataChangeError", 7);
        /**
         * @category Private
         */
        this.histogramPopover = null;
        /**
         * @category Event handler
         */
        this.onBinCountChange = debounce.debounce(() => {
            const { value } = this.binInputElement;
            if (value !== undefined && chartUiUtils.isCalciteInputValidNumber(value, this.binInputElement.min, this.binInputElement.max)) {
                this.binCountChange(value);
            }
            else {
                chartUiUtils.modifyCalciteInputStatus({
                    inputElement: this.binInputElement,
                    status: chartUiUtils.UIInputStatus.INVALID,
                });
            }
        }, chartUiUtils.UIDefaults.DebounceTimer);
        /**
         * @category Event handler
         */
        this.onBinCountSliderChange = debounce.debounce(() => {
            this.binCountChange(this.binSliderElement.value?.toString() ?? "");
        }, chartUiUtils.UIDefaults.DebounceTimer);
        /**
         * @category Event handler
         */
        this.binCountChange = (value) => {
            const binCount = Number.parseInt(value);
            if (this.model.getBinCount() !== binCount) {
                this.model.setBinCount(binCount);
                chartUiUtils.modifyCalciteInputStatus({
                    inputElement: this.binInputElement,
                    status: chartUiUtils.UIInputStatus.IDLE,
                });
            }
        };
        /**
         * @category Event handler
         */
        this.onColorElementSelect = (elementColor, popoverHeading, overlaySectionElement) => {
            if (elementColor.type === restJsObjectLiterals.RESTSymbolType.SFS) {
                this.selectedOverlaySymbol = undefined;
                this.selectedBinColorSymbol = elementColor;
                this.contentKind = interfaces.HistogramDataPopoverKinds.fillSymbol;
            }
            else {
                this.selectedBinColorSymbol = undefined;
                this.selectedOverlaySymbol = elementColor;
                this.overlaySectionElement = overlaySectionElement;
                this.contentKind = interfaces.HistogramDataPopoverKinds.lineSymbol;
            }
            this.popoverHeading = popoverHeading;
            this.setupPopover();
        };
        /**
         * @category Event handler
         */
        this.onNumericFieldSelect = () => {
            this.selectedNumericalField = this.model.getNumericField();
            this.contentKind = interfaces.HistogramDataPopoverKinds.numericFields;
            this.setupPopover();
        };
        /**
         * @category Event handler
         */
        this.onTransformationSelect = () => {
            this.selectedTransformationType = this.model.getDataTransformationType();
            this.contentKind = interfaces.HistogramDataPopoverKinds.transformation;
            this.setupPopover();
        };
        /**
         * @category Event handler
         */
        this.onBinColorSelect = () => {
            this.onColorElementSelect(this.model.getBinColor(), this.strings.binColor);
        };
        /**
         * @category Event handler
         */
        this.onNormalDistColorSelect = () => {
            this.onColorElementSelect(this.model.getNormalDistColor(), this.strings.normalDistStyle, this.normalDistOverlayElement);
        };
        /**
         * @category Event handler
         */
        this.onMeanColorSelect = () => {
            this.onColorElementSelect(this.model.getMeanColor(), this.strings.meanStyle, this.meanOverlayElement);
        };
        /**
         * @category Event handler
         */
        this.onMedianColorSelect = () => {
            this.onColorElementSelect(this.model.getMedianColor(), this.strings.medianStyle, this.medianOverlayElement);
        };
        /**
         * @category Event handler
         */
        this.onStandardDevColorSelect = () => {
            this.onColorElementSelect(this.model.getStandardDevColor(), this.strings.standardDevStyle, this.standardDevOverlayElement);
        };
        /**
         * @category Event handler
         */
        this.onBinColorChange = (e) => {
            this.model.setColorMatch(false);
            this.model.setBinColor(e.detail);
        };
        /**
         * @category Event handler
         */
        this.onMeanStyleChange = (e) => {
            this.model.setMeanColor(e.detail);
        };
        /**
         * @category Event handler
         */
        this.onMedianStyleChange = (e) => {
            this.model.setMedianColor(e.detail);
        };
        /**
         * @category Event handler
         */
        this.onStandardDevStyleChange = (e) => {
            this.model.setStandardDevColor(e.detail);
        };
        /**
         * @category Event handler
         */
        this.onNormalDistStyleChange = (e) => {
            this.model.setNormalDistColor(e.detail);
        };
        /**
         * @category Event handler
         */
        this.onShowDataLabelsChange = (e) => {
            this.model.setDataLabelsVisibility(e.target.checked);
        };
        /**
         * @category Event handler
         */
        this.onOverlayListChange = (e) => {
            const overlayList = e.target.selectedItems.map((item) => item.value);
            const hasMean = overlayList.includes(interfaces.HistogramOverlays.Mean);
            const hasMedian = overlayList.includes(interfaces.HistogramOverlays.Median);
            const hasStandardDev = overlayList.includes(interfaces.HistogramOverlays.StandardDev);
            const hasNormalDist = overlayList.includes(interfaces.HistogramOverlays.NormalDist);
            if (this.meanOverlayVisible !== hasMean) {
                this.model.setShowMeanOverlay(hasMean);
                this.meanOverlayVisible = hasMean;
            }
            if (this.medianOverlayVisible !== hasMedian) {
                this.model.setShowMedianOverlay(hasMedian);
                this.medianOverlayVisible = hasMedian;
            }
            if (this.standardDevOverlayVisible !== hasStandardDev) {
                this.model.setShowStandardDevOverlay(hasStandardDev);
                this.standardDevOverlayVisible = hasStandardDev;
            }
            if (this.normalDistOverlayVisible !== hasNormalDist) {
                this.model.setShowNormalDistOverlay(hasNormalDist);
                this.normalDistOverlayVisible = hasNormalDist;
            }
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * Emit event on open popover.
         * @param e
         * @category Private
         */
        this.openChange = (e) => {
            this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
        };
        /**
         * @category Event handler
         */
        this.updateProps = async (e) => {
            try {
                if (e.detail !== null && e.detail !== undefined) {
                    const { contentKind } = e.detail;
                    const { value } = e.detail;
                    // reset axes bounds for this chart in stencil store
                    store.deleteMinMaxAxisKey(store.state);
                    switch (contentKind) {
                        case interfaces.HistogramDataPopoverKinds.transformation:
                            this.model.setDataTransformationType(value ?? chartObjectLiterals.WebChartDataTransformations.None);
                            break;
                        case interfaces.HistogramDataPopoverKinds.numericFields:
                            await this.model.setNumericField(value ?? "");
                            break;
                    }
                }
            }
            catch (error) {
                this.arcgisChartsConfigDataChangeError.emit({ error, model: this.model });
                throw error;
            }
            this.removeHistogramDataPopover();
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        /**
         * @category Event handler
         */
        this.updateSymbolProps = (e) => {
            if (this.selectedBinColorSymbol !== undefined) {
                this.onBinColorChange(e);
            }
            else {
                switch (this.selectedOverlayKind) {
                    case interfaces.HistogramOverlays.Mean:
                        this.onMeanStyleChange(e);
                        break;
                    case interfaces.HistogramOverlays.Median:
                        this.onMedianStyleChange(e);
                        break;
                    case interfaces.HistogramOverlays.StandardDev:
                        this.onStandardDevStyleChange(e);
                        break;
                    case interfaces.HistogramOverlays.NormalDist:
                        this.onNormalDistStyleChange(e);
                        break;
                }
            }
        };
        /**
         * @category Private
         */
        this.popoverClose = () => {
            this.selectedOverlaySymbol = undefined;
            this.selectedBinColorSymbol = undefined;
            this.selectedNumericalField = undefined;
            this.selectedTransformationType = undefined;
        };
        this.model = undefined;
        this.meanValue = undefined;
        this.medianValue = undefined;
        this.standardDevValue = undefined;
        this.minValue = undefined;
        this.maxValue = undefined;
        this.sumValue = undefined;
        this.nullsValue = undefined;
        this.countValue = undefined;
        this.layerFieldsInfo = undefined;
        this.open = true;
        this.selectedBinColorSymbol = undefined;
        this.selectedOverlaySymbol = undefined;
        this.selectedNumericalField = undefined;
        this.selectedTransformationType = undefined;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removeHistogramDataPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
        this.onModelConfigChange();
    }
    /**
     * Removing the popover whenever disconnected.
     * @category Private
     */
    removeHistogramDataPopover() {
        if (this.histogramPopover !== null) {
            this.histogramPopover.open = false;
            this.histogramPopover = restJsObjectLiterals.Jy(this.histogramPopover);
        }
        this.histogramPopoverChange(false);
    }
    /**
     * @param field
     * @category Render UX
     */
    renderFieldSelect() {
        return (index.h("arcgis-charts-config-field-select", { label: restJsObjectLiterals.Tl(this.layerFieldsInfo, this.model.getNumericField()), ref: (e) => {
                this.numericalFieldSelectionElement = e;
            }, onClick: this.onNumericFieldSelect }));
    }
    /**
     * @category Render UX
     */
    renderDataTransformationType() {
        return (index.h("arcgis-charts-config-field-select", { label: this.getDataTransformationLabel(), ref: (e) => {
                this.transformationSelectionElement = e;
            }, onClick: this.onTransformationSelect }));
    }
    /**
     * @category Private
     */
    getDataTransformationLabel() {
        let label;
        switch (this.model.getDataTransformationType()) {
            case chartObjectLiterals.WebChartDataTransformations.None:
                label = this.strings.none;
                break;
            case chartObjectLiterals.WebChartDataTransformations.Log:
                label = this.strings.log;
                break;
            case chartObjectLiterals.WebChartDataTransformations.Sqrt:
                label = this.strings.sqRt;
                break;
            default:
                label = this.strings.none;
                break;
        }
        return label;
    }
    /**
     * @param props
     * @category Render UX
     */
    // TODO: to see for better pattern to move TSX based utility methods.
    renderColorListItem(props) {
        const { textLabel, key, value, selected, ref, colorAction, color } = props;
        const [r, g, b, a] = [...(color ?? restJsObjectLiterals.oo())];
        return (index.h("calcite-list-item", { label: textLabel ?? "", key: key, value: value, selected: selected, ref: ref ?? undefined }, index.h("calcite-action", { text: "color", slot: "actions-end", appearance: "transparent", onClick: colorAction }, index.h("calcite-icon", { icon: "line-solid", style: r !== undefined ? { color: `rgba(${r},${g},${b},${(a ?? 0) / 255})` } : {} }))));
    }
    /**
     * @category Render UX
     */
    renderBinColorElement() {
        const [r, g, b, a] = [...(this.model.getBinColor()?.color ?? restJsObjectLiterals.no(0))];
        return (index.h("calcite-list", { label: "", selectionMode: "single", selectionAppearance: "border" }, index.h("calcite-list-item", { label: this.strings.binColor, value: "selectTrendLine", ref: (e) => {
                this.binColorSectionElement = e;
            }, onClick: this.onBinColorSelect }, index.h("calcite-icon", { slot: "content-end", icon: "square-f", style: { color: `rgba(${r},${g},${b},${a / 255})` }, class: HTMLClasses.iconSelect }))));
    }
    /**
     * @category Render UX
     */
    renderNormalDistOverlay() {
        this.normalDistOverlayVisible = this.model.getShowNormalDistOverlay();
        return this.renderColorListItem({
            textLabel: this.strings.normalDist,
            color: this.model.getNormalDistColor()?.color,
            key: interfaces.HistogramOverlays.NormalDist,
            value: interfaces.HistogramOverlays.NormalDist,
            selected: this.model.getShowNormalDistOverlay(),
            ref: (e) => {
                this.normalDistOverlayElement = e;
            },
            colorAction: this.onNormalDistColorSelect,
        });
    }
    /**
     * @category Render UX
     */
    renderMeanOverlay() {
        this.meanOverlayVisible = this.model.getShowMeanOverlay();
        return this.renderColorListItem({
            textLabel: this.strings.mean,
            textDescription: this.meanValue,
            color: this.model.getMeanColor()?.color,
            key: interfaces.HistogramOverlays.Mean,
            value: interfaces.HistogramOverlays.Mean,
            selected: this.model.getShowMeanOverlay(),
            ref: (e) => {
                this.meanOverlayElement = e;
            },
            colorAction: this.onMeanColorSelect,
        });
    }
    /**
     * @category Render UX
     */
    renderStandardDevOverlay() {
        this.standardDevOverlayVisible = this.model.getShowStandardDevOverlay();
        return this.renderColorListItem({
            textLabel: this.strings.standardDev,
            textDescription: this.standardDevValue,
            color: this.model.getStandardDevColor()?.color,
            key: interfaces.HistogramOverlays.StandardDev,
            value: interfaces.HistogramOverlays.StandardDev,
            selected: this.model.getShowStandardDevOverlay(),
            ref: (e) => {
                this.standardDevOverlayElement = e;
            },
            colorAction: this.onStandardDevColorSelect,
        });
    }
    /**
     * @category Render UX
     */
    renderMedianOverlay() {
        this.medianOverlayVisible = this.model.getShowMedianOverlay();
        return this.renderColorListItem({
            textLabel: this.strings.median,
            textDescription: this.medianValue,
            color: this.model.getMedianColor()?.color,
            key: interfaces.HistogramOverlays.Median,
            value: interfaces.HistogramOverlays.Median,
            selected: this.model.getShowMedianOverlay(),
            ref: (e) => {
                this.medianOverlayElement = e;
            },
            colorAction: this.onMedianColorSelect,
        });
    }
    /**
     * @category Render UX
     */
    renderOverlayList() {
        return (index.h("calcite-list", { label: "", selectionMode: "multiple", onCalciteListChange: this.onOverlayListChange }, this.renderNormalDistOverlay(), this.renderMeanOverlay(), this.renderMedianOverlay(), this.renderStandardDevOverlay()));
    }
    /**
     * @param statName
     * @category Render UX
     */
    renderStatItem(statName) {
        return (index.h("calcite-list-item", { label: this.strings[statName], description: this.getStatValue(statName), key: statName, value: statName }));
    }
    /**
     * @category Render UX
     */
    renderStats() {
        const otherStats = Object.values(interfaces.HistogramStatistics);
        return (index.h("calcite-list", { label: "", class: HTMLClasses.histogramStatsList }, otherStats.map((value) => this.renderStatItem(value))));
    }
    /**
     * @category Render UX
     */
    renderShowDataLabels() {
        return (index.h("div", { class: HTMLClasses.row }, index.h("calcite-label", { class: HTMLClasses.label, layout: "inline-space-between" }, this.strings.showDataLabels, index.h("calcite-switch", { checked: this.model.getDataLabelsVisibility(), onCalciteSwitchChange: this.onShowDataLabelsChange }))));
    }
    /**
     * @category Render UX
     */
    renderBinsSection() {
        return (index.h("div", { class: HTMLClasses.binCountContainer }, index.h("calcite-slider", { labelHandles: true, min: 1, max: 64, step: 1, snap: true, value: this.model.getBinCount(), ref: (e) => {
                this.binSliderElement = e;
            }, onCalciteSliderChange: this.onBinCountSliderChange }), index.h("calcite-input", { type: "number", min: 1, max: 64, step: 1, value: chartUiUtils.sanitizeNumber(this.model.getBinCount()), onCalciteInputInput: this.onBinCountChange, ref: (e) => {
                this.binInputElement = e;
            } })));
    }
    /**
     * @category Lifecycle
     */
    render() {
        const fieldSelectUI = this.renderFieldSelect();
        const transformationUI = this.renderDataTransformationType();
        return (index.h(index.Host, { key: '437ac8257c7316b1a29f8bb2ffb91311c7a1a42b', class: { [HTMLClasses.rtl]: this.direction === "rtl" } }, index.h("div", { key: '0c5c164d9362be063d5533b925e4cf69b8e69f28', class: HTMLClasses.sectionLabel }, this.strings.variables), index.h("calcite-label", { key: '8ee73ae612e7e52d03d2afaf839c701e36febbad', class: HTMLClasses.label }, this.strings.number, fieldSelectUI), index.h("calcite-label", { key: '07fd6197abe0dbbb3ef43808a12cef53b49d078c', class: HTMLClasses.label }, this.strings.withTransformation, transformationUI), index.h("div", { key: 'c6bd23a4f4a24143f94fa5f668d1d5d8a09c942b', class: HTMLClasses.sectionLabel }, this.strings.bins), index.h("p", { key: '058f0ea15093c1c2d8ae07c633ac3401cb7de01d', class: HTMLClasses.binTextPadding }, this.strings.numberOfBins), this.renderBinsSection(), this.renderBinColorElement(), index.h("div", { key: 'd48ec21d02b4c6a89ecb088191b0e4634078fcc6', class: HTMLClasses.sectionLabel }, this.strings.overlays), this.renderOverlayList(), this.renderShowDataLabels(), index.h("div", { key: 'bb7cd7facaf52137b6104a9065ac0597d17c2535', class: HTMLClasses.sectionLabel }, this.strings.statistics), this.renderStats()));
    }
    /**
     * @param statName
     * @category Private
     */
    getStatValue(statName) {
        let statValue;
        switch (statName) {
            case interfaces.HistogramStatistics.Min:
                statValue = this.minValue;
                break;
            case interfaces.HistogramStatistics.Max:
                statValue = this.maxValue;
                break;
            case interfaces.HistogramStatistics.Sum:
                statValue = this.sumValue;
                break;
            case interfaces.HistogramStatistics.Nulls:
                statValue = this.nullsValue;
                break;
            case interfaces.HistogramStatistics.Count:
                // Inferring this stat from the stats Count and Nulls
                statValue = this.countValue + this.nullsValue;
                break;
            case interfaces.HistogramStatistics.CountExcludingNulls:
                statValue = this.countValue;
                break;
            case interfaces.HistogramStatistics.Mean:
                statValue = this.meanValue;
                break;
            case interfaces.HistogramStatistics.Median:
                statValue = this.medianValue;
                break;
            case interfaces.HistogramStatistics.StandardDev:
                statValue = this.standardDevValue;
                break;
            default:
                statValue = undefined;
                break;
        }
        statValue = chartUiUtils.formatNumberToLocale(statValue, chartUiUtils.DefaultStatNumberFormat);
        return statValue;
    }
    /**
     * @category Private
     */
    histogramPopoverChange(open) {
        this.arcgisChartsConfigHistogramDataPopoverChange.emit({
            open,
            element: this.histogramPopover,
        });
    }
    /**
     * @category Private
     */
    // Popover related functions
    // TODO: Move these and other popover functions to common utility methods
    setupPopover() {
        // remove already existing chart popover
        // TODO: this is a hotfix for https://devtopia.esri.com/webgis/arcgis-charts/issues/5366
        // have to find a better way to do this
        this.removeHistogramDataPopover();
        // histogramPopover config
        const popoverConfig = {
            layerFieldsInfo: this.layerFieldsInfo,
            updateProps: this.updateProps,
            updateSymbolProps: this.updateSymbolProps,
            popoverClose: this.popoverClose,
            openChange: this.openChange,
        };
        // create a histogramPopover
        this.histogramPopover = restJsObjectLiterals.Zy(restJsObjectLiterals.Qy.HistogramDataPopover, popoverConfig);
        if (this.histogramPopover !== undefined && this.histogramPopover !== null) {
            switch (this.contentKind) {
                case interfaces.HistogramDataPopoverKinds.transformation:
                    this.histogramPopover.selectedTransformationType = this.selectedTransformationType;
                    this.histogramPopover.referenceElement = this.transformationSelectionElement;
                    this.histogramPopover.placement = "trailing";
                    this.histogramPopover.selectedBinColor = undefined;
                    this.histogramPopover.selectedOverlaySymbol = undefined;
                    this.histogramPopover.selectedNumericField = undefined;
                    break;
                case interfaces.HistogramDataPopoverKinds.numericFields:
                    this.histogramPopover.selectedNumericField = this.selectedNumericalField;
                    this.histogramPopover.referenceElement = this.numericalFieldSelectionElement;
                    this.histogramPopover.placement = "trailing";
                    this.histogramPopover.selectedBinColor = undefined;
                    this.histogramPopover.selectedOverlaySymbol = undefined;
                    this.histogramPopover.selectedTransformationType = undefined;
                    break;
                case interfaces.HistogramDataPopoverKinds.fillSymbol:
                    this.histogramPopover.referenceElement = this.binColorSectionElement;
                    this.histogramPopover.selectedBinColor = this.selectedBinColorSymbol;
                    this.histogramPopover.headingTitle = this.popoverHeading;
                    this.histogramPopover.placement = "leading";
                    this.histogramPopover.selectedOverlaySymbol = undefined;
                    this.histogramPopover.selectedTransformationType = undefined;
                    this.histogramPopover.selectedNumericField = undefined;
                    break;
                case interfaces.HistogramDataPopoverKinds.lineSymbol:
                    this.selectedOverlayKind = this.overlaySectionElement.value;
                    this.histogramPopover.referenceElement = this.overlaySectionElement;
                    this.histogramPopover.selectedOverlaySymbol = this.selectedOverlaySymbol;
                    this.histogramPopover.headingTitle = this.popoverHeading;
                    this.histogramPopover.placement = "leading";
                    this.histogramPopover.selectedBinColor = undefined;
                    this.histogramPopover.selectedTransformationType = undefined;
                    this.histogramPopover.selectedNumericField = undefined;
                    break;
            }
            this.histogramPopover.contentKind = this.contentKind;
            this.histogramPopover.open = true;
            this.addPopover();
        }
    }
    /**
     * @category Private
     */
    addPopover() {
        if (this.histogramPopover !== undefined && this.histogramPopover !== null) {
            if (!document.body.contains(this.histogramPopover)) {
                document.body.appendChild(this.histogramPopover);
            }
        }
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"]
    }; }
};
ArcGISChartsConfigHistogramData.style = ArcgisChartsConfigHistogramDataStyle0;

exports.arcgis_charts_config_histogram_data = ArcGISChartsConfigHistogramData;
