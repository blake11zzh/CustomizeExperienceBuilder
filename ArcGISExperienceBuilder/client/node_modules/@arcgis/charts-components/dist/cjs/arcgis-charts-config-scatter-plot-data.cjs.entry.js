/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-2e64cfc1.js');
const restJsObjectLiterals = require('./rest-js-object-literals-acb59afb.js');
const chartUiUtils = require('./chart-ui-utils-ba499862.js');
const interfaces = require('./interfaces-28e1772a.js');
const store = require('./store-fbc7ac07.js');
const cloneDeep = require('./cloneDeep-3503ada6.js');
const isEmpty = require('./isEmpty-b0fd430d.js');
const toNumber = require('./toNumber-b227ab04.js');
const chartObjectLiterals = require('./chart-object-literals-a706ca0f.js');
require('./index-e5a6a075.js');
require('./_Uint8Array-9bd4a4da.js');
require('./_Map-d0ba2c83.js');
require('./isObject-b063d8a9.js');
require('./_initCloneObject-76ab9e25.js');
require('./_getAllKeys-facd90a6.js');
require('./_getTag-66a55d52.js');

const HTMLClasses = {
    label: "label",
    text: "text",
    r2: "r2",
    numberInput: "number-input",
    iconSelect: "icon-select",
    sectionLabel: "section-label",
    switchElement: "switch-element",
    sectionContainer: "section-container",
    multiInputSection: "multi-input-section",
    rtl: "arcgis-charts-rtl",
};

const arcgisChartsConfigScatterPlotDataCss = ".hide{display:none}.am5-modal{width:100%;height:100%;position:absolute;z-index:100000;top:0px;left:0px}.am5-modal-curtain{top:0px;left:0px;width:100%;height:100%;position:absolute;background:rgba(255, 255, 255, 0.5);z-index:100}.am5-modal-wrapper{top:0px;left:0px;width:100%;height:100%;position:absolute;display:flex;align-items:center;justify-content:center;white-space:nowrap;background:rgba(255, 255, 255, 0.5);z-index:101}.am5-modal-content{display:inline-block;padding:1.2em;vertical-align:middle;text-align:left;white-space:normal;background:rgb(255, 255, 255);border-radius:4px;box-shadow:rgba(0, 0, 0, 0.45) 0px 0px 36px 0px;color:rgb(0, 0, 0)}.arcgis-charts-modal{box-shadow:none !important}.arcgis-charts-modal-header{background-color:rgba(0, 0, 0, 0.05);font-weight:bold;padding:4px 4px 4px 4px}.show{display:block}.notifyPanel{flex:0 1 auto}.disable-interactions{pointer-events:none}.dim-text{color:var(--arcgis-charts-dim-text)}:host{display:flex;flex-direction:column;width:var(--arcgis-charts-config-calcite-block-default-width);margin:var(--arcgis-charts-config-calcite-block-default-margin)}:host .number-input{margin-bottom:0.5rem;display:flex}:host .number-input>div{width:100%}calcite-list-item{margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor)}calcite-slider{margin-top:-1.5rem}.r2{margin:var(--arcgis-charts-config-margin-major) var(--arcgis-charts-config-margin-minor)}.label{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);margin-right:var(--arcgis-charts-config-margin-minor);margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.text{display:flex;margin-left:var(--arcgis-charts-config-margin-minor);width:calc(100% - 1.5rem);height:2rem;margin-bottom:var(--arcgis-charts-config-margin-minor);justify-content:space-between}.section-container{display:flex;flex-direction:column}.icon-select{cursor:pointer}.section-label{display:flex;margin:var(--arcgis-charts-config-margin-major) var(--arcgis-charts-config-margin-minor);justify-content:space-between;align-items:center;font-weight:var(--calcite-font-weight-medium);font-size:var(--calcite-font-size-0)}.switch-element{margin-right:var(--arcgis-charts-config-margin-minor)}.multi-input-section{display:flex;justify-content:space-between;align-items:center}:host(.arcgis-charts-rtl) .text{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}:host(.arcgis-charts-rtl) .sub-header{margin-left:0rem;margin-right:var(--arcgis-charts-config-margin-minor)}:host(.arcgis-charts-rtl) .switch-element{margin-left:var(--arcgis-charts-config-margin-minor);margin-right:0rem}";
const ArcgisChartsConfigScatterPlotDataStyle0 = arcgisChartsConfigScatterPlotDataCss;

const ArcgisChartsConfigScatterPlotData = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigScatterPlotPopoverChange = index.createEvent(this, "arcgisChartsConfigScatterPlotPopoverChange", 7);
        this.arcgisChartsConfigPopoverOpenChange = index.createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        this.arcgisChartsConfigDataChangeError = index.createEvent(this, "arcgisChartsConfigDataChangeError", 7);
        /**
         * @category Private
         */
        this.scatterPlotPopover = null;
        /**
         * @category Private
         */
        this.items = [];
        /**
         * @category Event handler
         */
        this.setShowTrendLine = (e) => {
            const showTrendLine = e.target.checked;
            this.model.setShowLinearTrend(showTrendLine);
            if (!showTrendLine && this.contentKind === interfaces.ScatterPlotDataPopoverKinds.trendLine) {
                this.closeScatterPlotPopover(e);
            }
        };
        /**
         * @category Event handler
         */
        this.setTrendLineSymbol = (e) => {
            const lineSymbol = e.detail;
            this.model.setLinearTrendSymbol(cloneDeep.cloneDeep(lineSymbol));
        };
        /**
         * @category Event handler
         */
        this.symbolSizeChange = (e) => {
            const referenceElement = e.target;
            const { value } = referenceElement;
            if (value !== undefined && chartUiUtils.isCalciteInputValidNumber(value, referenceElement.min, referenceElement.max)) {
                const size = Number.parseInt(value);
                const sizePolicy = this.model.getSizePolicy();
                const fixedMarkerSymbol = this.model.getFixedMarkerSymbol();
                switch (referenceElement.name) {
                    case "fixed-symbol-size":
                        if (fixedMarkerSymbol !== undefined) {
                            this.model.setFixedMarkerSymbol({
                                ...fixedMarkerSymbol,
                                size,
                            });
                        }
                        break;
                    case "proportional-symbol-min-size":
                        if (sizePolicy !== undefined) {
                            this.model.setSizePolicy({
                                ...sizePolicy,
                                minSize: size,
                            });
                        }
                        break;
                    case "proportional-symbol-max-size":
                        if (sizePolicy !== undefined) {
                            this.model.setSizePolicy({
                                ...sizePolicy,
                                maxSize: size,
                            });
                        }
                        break;
                }
                chartUiUtils.modifyCalciteInputStatus({
                    inputElement: referenceElement,
                    status: chartUiUtils.UIInputStatus.IDLE,
                });
            }
            else {
                chartUiUtils.modifyCalciteInputStatus({
                    inputElement: referenceElement,
                    status: chartUiUtils.UIInputStatus.INVALID,
                });
            }
        };
        /**
         * @category Event handler
         */
        this.symbolSizeRangeSliderInput = (e) => {
            const inputElement = e.target;
            const { minValue, maxValue } = inputElement;
            const sizePolicy = this.model.getSizePolicy();
            if (sizePolicy !== undefined) {
                this.model.setSizePolicy({
                    ...sizePolicy,
                    minSize: minValue,
                    maxSize: maxValue,
                });
                // sync up values in the input elements
                if (this.minSizeInputElement !== undefined) {
                    this.minSizeInputElement.value = `${minValue}`;
                }
                if (this.maxSizeInputElement !== undefined) {
                    this.maxSizeInputElement.value = `${maxValue}`;
                }
            }
        };
        /**
         * @category Event handler
         */
        this.changeColorTypeToggle = () => {
            const colorMatch = this.colorModeElement?.selectedItem?.value;
            this.model.setColorMatch(colorMatch === this.strings.useLayerColors);
        };
        /**
         * @category Event handler
         */
        this.changeSymbolSizeTypeToggle = () => {
            const symbolSizeType = this.symbolSizeModeElement?.value;
            this.selectedSizeType = symbolSizeType;
            const appStateSizePolicyField = store.state.scatterPlotData[store.state.selectedChartId]?.sizePolicyField;
            /**
             * NOTE: we use `field` from `sizePolicy` from config to determine if the size is proportional or fixed.
             * If the field is empty, then it is treated as `fixed` in `ac-js`. Otherwise, it is proportional.
             */
            if (symbolSizeType === interfaces.ScatterPlotSymbolSizeTypes.Proportional && appStateSizePolicyField !== undefined) {
                // set the size policy field to the one in the app state if `field` is defined in the stencil store
                this.model.setSizePolicy({
                    ...this.model.getSizePolicy(),
                    type: chartObjectLiterals.WebChartTypes.SizePolicy,
                    field: appStateSizePolicyField,
                });
            }
            else if (symbolSizeType === interfaces.ScatterPlotSymbolSizeTypes.Fixed) {
                // set the size policy field to empty if the size type is fixed
                this.model.setSizePolicy({
                    ...this.model.getSizePolicy(),
                    type: chartObjectLiterals.WebChartTypes.SizePolicy,
                    field: "",
                });
            }
        };
        /**
         * @category Event handler
         */
        this.setFixedSymbolRGBAColor = (e) => {
            const color = e.detail;
            const [r, g, b] = color;
            const a = restJsObjectLiterals.Hn * 255;
            this.model.setFixedMarkerSymbol({
                ...this.model.getFixedMarkerSymbol(),
                color: [r, g, b, a],
            });
        };
        /**
         *
         * @category Event handler
         */
        this.changeElementStyle = (e) => {
            let target = e.target;
            if (target.localName === "calcite-icon") {
                target = target.parentElement;
            }
            /* computing a boolean rather than directly using target.selected given that property is not populated
            when the user clicks on the icon */
            if (target.value === "selectColor") {
                this.contentKind = interfaces.ScatterPlotDataPopoverKinds.symbol;
                this.selectedElement = this.model.getFixedMarkerSymbol()?.color;
            }
            else if (target.value === "selectTrendLine") {
                this.contentKind = interfaces.ScatterPlotDataPopoverKinds.trendLine;
                this.selectedElement = this.model.getLinearTrendSymbol();
            }
        };
        /**
         * @category Event handler
         *
         * called when the X-axis variable is clicked
         */
        this.onXVariableSelectChange = () => {
            this.contentKind = interfaces.ScatterPlotDataPopoverKinds.xAxisField;
            this.selectedElement = this.model.getXAxisField();
        };
        /**
         * @category Event handler
         *
         * called when the Y-axis variable is clicked
         */
        this.onYVariableSelectChange = () => {
            this.contentKind = interfaces.ScatterPlotDataPopoverKinds.yAxisField;
            this.selectedElement = this.model.getYAxisField();
        };
        /**
         * @category Event handler
         *
         * called when the size variable is clicked
         */
        this.onSizeVariableSelectChange = () => {
            this.contentKind = interfaces.ScatterPlotDataPopoverKinds.sizeVariable;
            this.selectedElement = this.model.getSizePolicy()?.field ?? "";
        };
        /**
         * @category Event handler
         *
         * @param e
         */
        this.setXYField = async (e) => {
            try {
                const fieldName = e.detail;
                // reset axes bounds for this chart in stencil store
                store.deleteMinMaxAxisKey(store.state);
                if (this.contentKind === interfaces.ScatterPlotDataPopoverKinds.xAxisField) {
                    await this.model.setXAxisField(fieldName);
                }
                else {
                    // ScatterPlotDataPopoverKinds.yAxisField
                    await this.model.setYAxisField(fieldName);
                }
                this.removeScatterPlotPopover();
            }
            catch (error) {
                this.arcgisChartsConfigDataChangeError.emit({ error, model: this.model });
                throw error;
            }
        };
        /**
         * @category Event handler
         *
         * @param e
         */
        this.setSizeVariableField = (e) => {
            try {
                const fieldName = e.detail;
                // set the size policy field in the model only if the field is not empty.
                // NOTE: The fieldsName is set to `null` when the user deselects the field.
                if (fieldName) {
                    this.model.setSizePolicy({
                        ...this.model.getSizePolicy(),
                        type: chartObjectLiterals.WebChartTypes.SizePolicy,
                        field: fieldName,
                    });
                }
                else {
                    this.model.setSizePolicy(undefined);
                }
                // update the size policy field in the stencil store every time the field is changed
                store.state.scatterPlotData[store.state.selectedChartId] = {
                    ...store.state.scatterPlotData[store.state.selectedChartId],
                    sizePolicyField: this.model.getSizePolicy()?.field ?? undefined,
                };
                this.removeScatterPlotPopover();
            }
            catch (error) {
                this.arcgisChartsConfigDataChangeError.emit({ error, model: this.model });
                throw error;
            }
        };
        /**
         * @category Event handler
         */
        this.closeScatterPlotPopover = (e) => {
            if (this.scatterPlotPopover === e?.target) {
                this.contentKind = interfaces.ScatterPlotDataPopoverKinds.none;
                this.removeScatterPlotPopover();
            }
        };
        /**
         * Emit event on open popover.
         * @param e
         * @category Event handler
         */
        this.openChange = (e) => {
            this.arcgisChartsConfigPopoverOpenChange.emit(e.detail);
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = () => {
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
            const { minSize, maxSize } = this.model.getSizePolicy() ?? {};
            // check validity of min size value
            if (this.minSizeInputElement !== undefined && minSize !== undefined) {
                this.minSizeInputElement.value = `${minSize}`;
                if (chartUiUtils.isCalciteInputValidNumber(this.minSizeInputElement.value, this.minSizeInputElement.min, this.minSizeInputElement.max)) {
                    chartUiUtils.modifyCalciteInputStatus({
                        inputElement: this.minSizeInputElement,
                        status: chartUiUtils.UIInputStatus.IDLE,
                    });
                }
                else {
                    chartUiUtils.modifyCalciteInputStatus({
                        inputElement: this.minSizeInputElement,
                        status: chartUiUtils.UIInputStatus.INVALID,
                    });
                }
            }
            // check validity of max size value
            if (this.maxSizeInputElement !== undefined && maxSize !== undefined) {
                this.maxSizeInputElement.value = `${maxSize}`;
                if (chartUiUtils.isCalciteInputValidNumber(this.maxSizeInputElement.value, this.maxSizeInputElement.min, this.maxSizeInputElement.max)) {
                    chartUiUtils.modifyCalciteInputStatus({
                        inputElement: this.maxSizeInputElement,
                        status: chartUiUtils.UIInputStatus.IDLE,
                    });
                }
                else {
                    chartUiUtils.modifyCalciteInputStatus({
                        inputElement: this.maxSizeInputElement,
                        status: chartUiUtils.UIInputStatus.INVALID,
                    });
                }
            }
        };
        this.model = undefined;
        this.r2 = undefined;
        this.layerFieldsInfo = undefined;
        this.isTableLayer = undefined;
        this.open = true;
        this.selectedElement = undefined;
        this.selectedSizeType = undefined;
        this.updatesOccurred = 0;
    }
    /**
     * @category Watch handler
     */
    modelChange(newModel, oldModel) {
        // config change handler for chart model
        oldModel?.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        newModel?.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    openPopover() {
        if (typeof this.selectedElement === "string" || !isEmpty.isEmpty(this.selectedElement)) {
            this.setupScatterPlotPopover();
        }
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        this.modelChange(this.model);
        this.onModelConfigChange();
        this.defaultR2Label = await restJsObjectLiterals.na();
        this.selectedSizeType = this.getCurrentSymbolSizeType();
        // update the size policy field in the stencil store if selected size type is proportional
        if (this.selectedSizeType === interfaces.ScatterPlotSymbolSizeTypes.Proportional) {
            store.state.scatterPlotData[store.state.selectedChartId] = {
                ...store.state.scatterPlotData[store.state.selectedChartId],
                sizePolicyField: this.model.getSizePolicy()?.field,
            };
        }
    }
    // TODO: as of Nov 2020, only fixed symbol is supported.
    // When proportionalSymbol is supported, need to rework on the UI
    // to replace select element with another calcite component.
    // This function will no longer needed.
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.removeScatterPlotPopover();
        this.model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
    }
    /**
     * @category Render UX
     */
    renderXVariable() {
        return (index.h("arcgis-charts-config-field-select", { label: restJsObjectLiterals.Tl(this.layerFieldsInfo, this.model.getXAxisField() ?? ""), ref: (e) => {
                this.xAxisElement = e;
            }, onClick: this.onXVariableSelectChange }));
    }
    /**
     * @category Render UX
     */
    renderYVariable() {
        return (index.h("arcgis-charts-config-field-select", { label: restJsObjectLiterals.Tl(this.layerFieldsInfo, this.model.getYAxisField() ?? ""), ref: (e) => {
                this.yAxisElement = e;
            }, onClick: this.onYVariableSelectChange }));
    }
    /**
     * @category Render UX
     */
    renderStatistics() {
        const [r, g, b, a] = [...(this.model.getLinearTrendSymbol()?.color ?? restJsObjectLiterals.no(0))];
        const stats = (index.h("div", { class: HTMLClasses.sectionContainer }, index.h("calcite-label", { class: HTMLClasses.label, layout: "inline-space-between" }, this.strings.showLinearTrend, index.h("calcite-switch", { class: HTMLClasses.switchElement, checked: this.model.getShowLinearTrend(), onCalciteSwitchChange: this.setShowTrendLine })), index.h("calcite-list", { label: "", selectionMode: "single", selectionAppearance: "border" }, index.h("calcite-list-item", { label: this.strings.trendLineStyle, value: "selectTrendLine", hidden: !this.model.getShowLinearTrend(), selected: this.selectedElement?.type === restJsObjectLiterals.RESTSymbolType.SLS, ref: (e) => {
                this.selectTrendLineElement = e;
            }, onClick: this.changeElementStyle }, index.h("calcite-icon", { slot: "content-end", icon: "line-solid", style: { color: `rgba(${r},${g},${b},${a / 255})` }, class: HTMLClasses.iconSelect, onClick: this.changeElementStyle }))), index.h("div", { class: HTMLClasses.r2, hidden: !this.model.getShowLinearTrend() }, `${this.strings.r2}: ${Number.isNaN(this.r2) ? this.defaultR2Label : chartUiUtils.formatNumberToLocale(this.r2, chartUiUtils.DefaultStatNumberFormat)}`)));
        return stats;
    }
    /**
     * @category Render UX
     */
    renderFixedSymbol() {
        const fixedSymbol = (index.h("calcite-label", { class: HTMLClasses.label }, this.strings.size, index.h("calcite-input", { type: "number", name: "fixed-symbol-size", class: HTMLClasses.numberInput, min: 1, max: 100, step: 1, value: chartUiUtils.sanitizeNumber(this.model.getFixedMarkerSymbol()?.size), onCalciteInputInput: this.symbolSizeChange })));
        return fixedSymbol;
    }
    /**
     * @category Lifecycle
     */
    async componentDidLoad() {
        // we need the following to logic to fix the scroll issue with the `calcite-segmented-control-item` - https://github.com/Esri/calcite-design-system/issues/10595#issuecomment-2457945296
        const waitForTimeout = async (duration) => void (await new Promise((resolve) => setTimeout(() => resolve(), duration)));
        await waitForTimeout(250);
        this.items.forEach((item) => {
            delete item.focus; // restores HTMLElement#focus
        });
        //
    }
    /**
     * @category Render UX
     */
    renderSizeVariable() {
        return (index.h("arcgis-charts-config-field-select", { label: restJsObjectLiterals.Tl(this.layerFieldsInfo, this.model.getSizePolicy()?.field ?? ""), invalid: this.layerFieldsInfo.find((field) => field.name === this.model.getSizePolicy()?.field) === undefined, ref: (e) => {
                this.sizeVariableElement = e;
            }, onClick: this.onSizeVariableSelectChange }));
    }
    /**
     * @category Render UX
     */
    renderMinSizeInput() {
        return (index.h("calcite-input", { type: "number", name: "proportional-symbol-min-size", class: HTMLClasses.numberInput, min: 1, max: this.model.getSizePolicy()?.maxSize ?? 100, step: 1, value: chartUiUtils.sanitizeNumber(this.model.getSizePolicy()?.minSize), onCalciteInputInput: this.symbolSizeChange, ref: (e) => {
                this.minSizeInputElement = e;
            } }));
    }
    /**
     * @category Render UX
     */
    renderMaxSizeInput() {
        return (index.h("calcite-input", { type: "number", name: "proportional-symbol-max-size", class: HTMLClasses.numberInput, min: this.model.getSizePolicy()?.minSize ?? 1, max: 100, step: 1, value: chartUiUtils.sanitizeNumber(this.model.getSizePolicy()?.maxSize), onCalciteInputInput: this.symbolSizeChange, ref: (e) => {
                this.maxSizeInputElement = e;
            } }));
    }
    /**
     * @category Render UX
     */
    renderProportionalSymbol() {
        const proportionalSymbol = (index.h("div", { class: HTMLClasses.sectionContainer }, index.h("calcite-label", { class: HTMLClasses.label }, this.strings.numberRequired, this.renderSizeVariable()), index.h("div", { class: HTMLClasses.multiInputSection }, index.h("calcite-label", { class: HTMLClasses.label }, this.strings.minSize, this.renderMinSizeInput()), index.h("calcite-label", { class: HTMLClasses.label }, this.strings.maxSize, this.renderMaxSizeInput())), index.h("calcite-label", null, index.h("calcite-slider", { min: 1, max: 100, minValue: toNumber.toNumber(chartUiUtils.sanitizeNumber(this.model.getSizePolicy()?.minSize)), maxValue: toNumber.toNumber(chartUiUtils.sanitizeNumber(this.model.getSizePolicy()?.maxSize)), step: 1, onCalciteSliderInput: this.symbolSizeRangeSliderInput }))));
        return proportionalSymbol;
    }
    /**
     * @category Render UX
     */
    renderSymbolSizeType() {
        const symbolSizeTypeUI = (index.h("calcite-label", { class: HTMLClasses.label }, this.strings.size, index.h("calcite-segmented-control", { name: "symbolSizeType", layout: "horizontal", scale: "s", onCalciteSegmentedControlChange: this.changeSymbolSizeTypeToggle, ref: (e) => {
                this.symbolSizeModeElement = e;
            } }, index.h("calcite-segmented-control-item", { value: interfaces.ScatterPlotSymbolSizeTypes.Fixed, checked: interfaces.ScatterPlotSymbolSizeTypes.Fixed === this.selectedSizeType, ref: (el) => {
                el.focus = () => { };
                this.items.push(el);
            } }, this.strings.fixed), index.h("calcite-segmented-control-item", { value: interfaces.ScatterPlotSymbolSizeTypes.Proportional, checked: interfaces.ScatterPlotSymbolSizeTypes.Proportional === this.selectedSizeType, ref: (el) => {
                el.focus = () => { };
                this.items.push(el);
            } }, this.strings.proportional))));
        return symbolSizeTypeUI;
    }
    /**
     * @category Render UX
     */
    renderSymbol() {
        const [r, g, b, a] = [...(this.model.getFixedMarkerSymbol()?.color ?? restJsObjectLiterals.no(0))];
        const symbol = (index.h("div", { class: HTMLClasses.sectionContainer }, this.renderSymbolSizeType(), this.selectedSizeType === interfaces.ScatterPlotSymbolSizeTypes.Proportional
            ? this.renderProportionalSymbol()
            : this.renderFixedSymbol(), index.h("calcite-label", { class: HTMLClasses.label }, this.strings.color, this.isTableLayer !== true ? (index.h("calcite-segmented-control", { name: "layerColor", layout: "horizontal", scale: "s", onCalciteSegmentedControlChange: this.changeColorTypeToggle, ref: (e) => {
                this.colorModeElement = e;
            } }, index.h("calcite-segmented-control-item", { value: this.strings.useLayerColors, checked: this.model.getColorMatch(), ref: (el) => {
                el.focus = () => { };
                this.items.push(el);
            } }, this.strings.useLayerColors), index.h("calcite-segmented-control-item", { value: this.strings.singleColor, checked: !this.model.getColorMatch(), ref: (el) => {
                el.focus = () => { };
                this.items.push(el);
            } }, this.strings.singleColor))) : null), index.h("calcite-list", { label: "", selectionMode: "single", selectionAppearance: "border" }, index.h("calcite-list-item", { label: this.strings.color, value: "selectColor", hidden: this.model.getColorMatch() && this.isTableLayer !== true, selected: Array.isArray(this.selectedElement), ref: (e) => {
                this.selectColorElement = e;
            }, onClick: this.changeElementStyle }, index.h("calcite-icon", { slot: "content-end", icon: "circle-f", style: { color: `rgba(${r},${g},${b},${a / 255})` }, class: HTMLClasses.iconSelect, onClick: this.changeElementStyle })))));
        return symbol;
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (index.h(index.Host, { key: '03f7f44733f9914b780dc1dc5f82f9a79438375e', class: { [HTMLClasses.rtl]: this.direction === "rtl" } }, index.h("h3", { key: 'dbfad812d143ff1f4d3cfd3ad1dadf9b31f26da4', class: HTMLClasses.sectionLabel }, this.strings.variables), index.h("calcite-label", { key: '59babdeb9d2a1c55416e0b5b9685e764446f7208', class: HTMLClasses.label }, this.strings.xAxisNumber, this.renderXVariable()), index.h("calcite-label", { key: '75fd11346598c9fee68f4b8c5049950845afc826', class: HTMLClasses.label }, this.strings.yAxisNumber, this.renderYVariable()), index.h("h3", { key: '6cbe9dba31d458f104e261814903bdb5f1824e66', class: HTMLClasses.sectionLabel }, this.strings.statistics), this.renderStatistics(), index.h("h3", { key: '4f60b0e15124a68050d18dd7588193ae7f9c5dda', class: HTMLClasses.sectionLabel }, this.strings.symbol), this.renderSymbol()));
    }
    /**
     * @category Private
     */
    setupScatterPlotPopover() {
        this.scatterPlotPopover = restJsObjectLiterals.Jy(this.scatterPlotPopover);
        // scatterPlotPopover config
        const popoverConfig = {
            setTrendLineSymbol: this.setTrendLineSymbol,
            setFixedSymbolRGBAColor: this.setFixedSymbolRGBAColor,
            setXYField: this.setXYField,
            setSizeVariableField: this.setSizeVariableField,
            openChange: this.openChange,
            popoverClose: this.closeScatterPlotPopover,
        };
        // create a new scatterPlotPopover
        this.scatterPlotPopover = restJsObjectLiterals.Zy(restJsObjectLiterals.Qy.ScatterPlotDataPopover, popoverConfig);
        this.scatterPlotPopover.layerFieldsInfo = [...this.layerFieldsInfo];
        this.scatterPlotPopover.contentKind = this.contentKind;
        switch (this.contentKind) {
            case interfaces.ScatterPlotDataPopoverKinds.xAxisField:
                this.scatterPlotPopover.referenceElement = this.xAxisElement;
                this.scatterPlotPopover.placement = "trailing";
                this.scatterPlotPopover.selectedContent = this.model.getXAxisField();
                this.scatterPlotPopover.headingTitle = this.strings.selectAField;
                break;
            case interfaces.ScatterPlotDataPopoverKinds.yAxisField:
                this.scatterPlotPopover.referenceElement = this.yAxisElement;
                this.scatterPlotPopover.placement = "trailing";
                this.scatterPlotPopover.selectedContent = this.model.getYAxisField();
                this.scatterPlotPopover.headingTitle = this.strings.selectAField;
                break;
            case interfaces.ScatterPlotDataPopoverKinds.sizeVariable:
                this.scatterPlotPopover.referenceElement = this.sizeVariableElement;
                this.scatterPlotPopover.placement = "trailing";
                this.scatterPlotPopover.selectedContent = this.model.getSizePolicy()?.field ?? "";
                this.scatterPlotPopover.headingTitle = this.strings.selectAField;
                break;
            case interfaces.ScatterPlotDataPopoverKinds.symbol:
            case interfaces.ScatterPlotDataPopoverKinds.trendLine: {
                const element = this.selectedElement;
                this.scatterPlotPopover.selectedContent = this.selectedElement;
                this.scatterPlotPopover.placement = "leading";
                if (Array.isArray(this.selectedElement)) {
                    this.scatterPlotPopover.referenceElement = this.selectColorElement;
                }
                else if (element?.type === restJsObjectLiterals.RESTSymbolType.SLS) {
                    this.scatterPlotPopover.referenceElement = this.selectTrendLineElement;
                }
                break;
            }
            default:
                this.contentKind = interfaces.ScatterPlotDataPopoverKinds.none;
                this.removeScatterPlotPopover();
                break;
        }
        if (this.contentKind !== interfaces.ScatterPlotDataPopoverKinds.none) {
            this.scatterPlotPopover.open = true;
            this.addScatterPlotPopover();
        }
    }
    /**
     * @category Private
     */
    removeScatterPlotPopover() {
        if (this.scatterPlotPopover !== null) {
            this.scatterPlotPopover = restJsObjectLiterals.Jy(this.scatterPlotPopover);
        }
        this.selectedElement = {};
    }
    /**
     * @category Private
     */
    addScatterPlotPopover() {
        if (!document.body.contains(this.scatterPlotPopover) &&
            this.scatterPlotPopover !== undefined &&
            this.scatterPlotPopover !== null) {
            document.body.appendChild(this.scatterPlotPopover);
        }
    }
    /**
     * @category Private
     */
    getCurrentSymbolSizeType() {
        const sizePolicy = this.model.getSizePolicy();
        return sizePolicy === undefined || sizePolicy.field === ""
            ? interfaces.ScatterPlotSymbolSizeTypes.Fixed
            : interfaces.ScatterPlotSymbolSizeTypes.Proportional;
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "model": ["modelChange"],
        "selectedElement": ["openPopover"]
    }; }
};
ArcgisChartsConfigScatterPlotData.style = ArcgisChartsConfigScatterPlotDataStyle0;

exports.arcgis_charts_config_scatter_plot_data = ArcgisChartsConfigScatterPlotData;
