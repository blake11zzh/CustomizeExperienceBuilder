/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See LICENSE.md for details.
 * v4.32.1
 */
'use strict';

const index = require('./index-2e64cfc1.js');
const index$1 = require('./index-e5a6a075.js');
const restJsObjectLiterals = require('./rest-js-object-literals-acb59afb.js');
const interfaces$1 = require('./interfaces-28e1772a.js');
const chartUiUtils = require('./chart-ui-utils-ba499862.js');
const store = require('./store-fbc7ac07.js');
const interfaces = require('./interfaces-a45100c7.js');
const axisModelWrapper = require('./axis-model-wrapper-340f3f39.js');
const isEqual = require('./isEqual-7c4e90f5.js');
const chartObjectLiterals = require('./chart-object-literals-a706ca0f.js');

const HTMLClasses = {
    addChartContainer: "add-chart-container",
    addChart: "add-chart",
    chartEditPanel: "chart-edit-panel",
    tabBar: "tab-bar",
    tab: "tab",
    rtl: "arcgis-charts-rtl",
};
function replaceDuplicateIds(modelList, selectedChartId) {
    // check for any duplicate ids in the modelList and replace them with new ids
    const modelIds = new Set();
    let newSelectedChartId = selectedChartId;
    modelList?.forEach((model, i) => {
        const id = model.getChartId();
        if (modelIds.has(id) || id === undefined || id === "") {
            model.setChartId(`Chart_${Date.now()}_${i}`);
            if (selectedChartId === id) {
                newSelectedChartId = model.getChartId();
            }
        }
        modelIds.add(id);
    });
    return newSelectedChartId;
}
/**
 * Filters the model list by the layer id and supported chart types.
 * @param modelList
 * @param layerId
 * @param supportedChartTypes
 */
function filterModelListByLayerId(modelList, layerId, supportedChartTypes) {
    return (modelList?.filter((model) => restJsObjectLiterals.xl(supportedChartTypes, model.getConfig()) && model.getLayer()?.id === layerId) ?? []);
}
/**
 * Gets a combination of the unique layers (by `layer.id`) found in the `modelList` and `layerList`.
 * @param modelList
 * @param selectedLayerId
 */
function getCombinedLayerList(props) {
    const { modelList, layerList, activeLayerId, disableEditing } = props;
    const mergedLayerList = new Map();
    modelList?.forEach((model) => {
        const layer = model.getLayer();
        if (layer) {
            mergedLayerList.set(layer.id, layer);
        }
    });
    // Only add layers from the layerList if editing is enabled. If editing is disabled, we only care about layers with existing charts, which are all already covered by the modelList.
    if (!disableEditing) {
        layerList.forEach((layer) => mergedLayerList.set(layer.id, layer));
    }
    // filter layers based on selectedLayerId if provided
    return Array.from(mergedLayerList.values()).filter((layer) => !activeLayerId || layer.id === activeLayerId);
}
/**
 * Update each layer's charts list based on the model list.
 * @param layers The whose `charts` arrays will be updated.
 * @param modelList The list of chart models to update the layers based on.
 */
function updateAllChartsOnLayers(layers, modelList) {
    layers.forEach((layer) => {
        modelList.forEach((model) => {
            if (layer?.id === model.getLayer()?.id) {
                updateChartOnLayer(layer, model);
            }
        });
    });
}
/**
 * Update the chart on the layer's `charts` array.
 * @param layer The layer whose `charts` array will be updated.
 * @param model The chart model to update the layer based on.
 */
function updateChartOnLayer(layer, model) {
    const theLayer = layer;
    const index = theLayer?.charts?.findIndex((chart) => chart.id === model.getChartId());
    if (theLayer?.charts && index !== undefined && index > -1) {
        theLayer.charts[index] = model.getConfig();
    }
    else if (theLayer) {
        addChartToLayer(layer, model);
    }
}
/**
 * Add a new chart to the layer's `charts` array.
 * @param layer The layer to add the chart to.
 * @param model The chart model to add to the layer.
 */
function addChartToLayer(layer, model) {
    const theLayer = layer;
    if (theLayer?.charts) {
        theLayer.charts.push(model.getConfig());
    }
    else if (theLayer) {
        theLayer.charts = [model.getConfig()];
    }
}
/**
 * Delete a chart from the layer's `charts` array.
 * @param layer The layer to delete the chart from.
 * @param chartId The id of the chart to delete.
 */
function deleteChartFromLayer(layer, chartId) {
    const theLayer = layer;
    if (theLayer?.charts) {
        const index = theLayer.charts.findIndex((chart) => chart.id === chartId);
        if (index > -1) {
            theLayer.charts.splice(index, 1);
        }
    }
}

const arcgisChartsConfigCreateFlowCss = ":host{display:flex;flex-direction:column;flex:1 1 auto;overflow:hidden}.label{display:flex;margin-left:1rem;margin-bottom:0.5rem;justify-content:space-between}.text{display:flex;margin-left:1rem;width:calc(100% - 1.5rem);height:2rem;margin-bottom:0.5rem;justify-content:space-between}.field-list{max-height:50vh;overflow-y:scroll}.row{padding:0.5rem 0.5rem}.bin-count-container{display:flex;width:calc(100% - 1rem);padding:0.5rem}.bin-count-slider{margin-left:1rem;width:calc(90% - 1rem)}.bin-count-input{margin-left:1rem;height:2rem;width:2rem}.bin-row{padding:0.5rem 0 0.5rem 0.5rem}.tab-bar{display:flex}.tab{flex:1;height:2.5rem}:host(.arcgis-charts-rtl) .label{margin-left:0rem;margin-right:1rem}:host(.arcgis-charts-rtl) .text{margin-left:0rem;margin-right:1rem}:host(.arcgis-charts-rtl) .bin-count-slider{margin-left:0rem;margin-right:1rem}:host(.arcgis-charts-rtl) .bin-count-input{margin-left:0rem;margin-right:1rem}";
const ArcgisChartsConfigCreateFlowStyle0 = arcgisChartsConfigCreateFlowCss;

const ArcGISChartsConfigCreateFlow = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisChartsConfigNewChart = index.createEvent(this, "arcgisChartsConfigNewChart", 7);
        this.arcgisChartsConfigSelectedChartChange = index.createEvent(this, "arcgisChartsConfigSelectedChartChange", 7);
        this.arcgisChartsConfigModelListChange = index.createEvent(this, "arcgisChartsConfigModelListChange", 7);
        this.arcgisChartsConfigChartViewChartClose = index.createEvent(this, "arcgisChartsConfigChartViewChartClose", 7);
        this.arcgisChartsConfigPopoverOpenChange = index.createEvent(this, "arcgisChartsConfigPopoverOpenChange", 7);
        this.arcgisChartsConfigPanelNumberChange = index.createEvent(this, "arcgisChartsConfigPanelNumberChange", 7);
        /**
         * Supported chart types
         * @category Private
         */
        this.supportedChartTypes = [
            chartObjectLiterals.WebChartTypes.BarSeries,
            chartObjectLiterals.WebChartTypes.BoxPlotSeries,
            chartObjectLiterals.WebChartTypes.LineSeries,
            chartObjectLiterals.WebChartTypes.PieSeries,
            chartObjectLiterals.WebChartTypes.HistogramSeries,
            chartObjectLiterals.WebChartTypes.ScatterSeries,
        ];
        /**
         * Assigns some specific data if the data is processed by a chart component matching the selected chart.
         * @category Event handler
         */
        this.chartDataProcessComplete = (e) => {
            const { chartData, model } = e.detail;
            const selectedModel = this.getModel(this.selectedChartId);
            const eventIsForSelectedChart = model?.isSameChartAs(selectedModel);
            if (eventIsForSelectedChart) {
                switch (selectedModel?.getChartType()) {
                    case chartObjectLiterals.WebChartTypes.HistogramSeries:
                        this.chartData = chartData;
                        break;
                    case chartObjectLiterals.WebChartTypes.PieSeries: {
                        this.chartData = chartData;
                        break;
                    }
                    case chartObjectLiterals.WebChartTypes.ScatterSeries: {
                        const scatterPlotData = chartData;
                        const { dataItems, r2 } = scatterPlotData;
                        let newR2 = r2;
                        // Necessary check because a NaN value for instance will trigger an infinite rendering loop (see issues #2502 & #4079)
                        // TODO: Find the reason of the infinite loop would help avoiding this check
                        if (!Number.isFinite(r2)) {
                            newR2 = undefined;
                        }
                        this.r2 = newR2;
                        this.calculatedDataMinMaxBounds = this.getDataExtent(dataItems);
                        break;
                    }
                    case chartObjectLiterals.WebChartTypes.LineSeries: {
                        const { dataItems, timeIntervalInfo } = chartData;
                        if (index$1.Ig(selectedModel)) {
                            if (timeIntervalInfo?.timeIntervalSize !== undefined &&
                                selectedModel.getTimeIntervalSize() !== timeIntervalInfo?.timeIntervalSize) {
                                selectedModel.setTimeIntervalSize(timeIntervalInfo?.timeIntervalSize);
                            }
                            if (timeIntervalInfo?.timeIntervalUnits !== undefined &&
                                selectedModel.getTimeIntervalUnits() !== timeIntervalInfo?.timeIntervalUnits) {
                                selectedModel.setTimeIntervalUnits(timeIntervalInfo?.timeIntervalUnits);
                            }
                        }
                        this.calculatedDataMinMaxBounds = this.getDataExtent(dataItems);
                        break;
                    }
                }
            }
        };
        /**
         * @param chartData The chart's data
         * @category private
         */
        this.getDataExtent = (chartData) => {
            const config = this.getModel(this.selectedChartId)?.getConfig();
            let dataExtent = [];
            if (config !== undefined && chartData !== undefined) {
                const dataMinMax = restJsObjectLiterals.fs({
                    chartConfig: config,
                    chartData,
                });
                const { minY, maxY, minX, maxX } = dataMinMax;
                dataExtent = [
                    { isXAxis: true, minimum: minX, maximum: maxX },
                    { isXAxis: false, minimum: minY, maximum: maxY },
                ];
            }
            return dataExtent;
        };
        /**
         * Update the axes bounds in the app state for the selected chart when the chart component calculates new min/max bounds.
         * @category Private
         */
        this.updateAxesBoundsInAppState = (bounds) => {
            bounds?.forEach((bound) => {
                const { isXAxis, maximum, minimum } = bound;
                // find the model for the selected chart
                const model = this.getModel(this.selectedChartId);
                if (model !== undefined && index$1.Dg(model) && this.selectedChartId !== undefined) {
                    // create an axis model wrapper
                    const axisModel = new axisModelWrapper.AxisModelWrapper(model, isXAxis);
                    // generate the key to store min/max bounds in the app state
                    const key = store.generateAxisMinMaxKey({
                        chartId: this.selectedChartId,
                        isXAxis,
                        isLogarithmic: axisModel.getLogarithmic(),
                    });
                    // fetch the axes bounds map from the app state
                    const chartAxesBoundDataMap = store.state.chartAxesBoundDataMap;
                    // initialize the axes bounds info for the selected chart if it doesn't exist
                    if (chartAxesBoundDataMap[this.selectedChartId] === undefined) {
                        chartAxesBoundDataMap[this.selectedChartId] = {};
                    }
                    // fetch the current axes bounds info for the selected chart
                    const currAxisBoundData = chartAxesBoundDataMap[this.selectedChartId]?.[key];
                    // create new axes bounds info
                    const newAxisBoundData = {
                        defaultMinBound: currAxisBoundData?.defaultMinBound === currAxisBoundData?.currMinBound
                            ? minimum
                            : currAxisBoundData?.defaultMinBound,
                        currMinBound: minimum,
                        defaultMaxBound: currAxisBoundData?.defaultMaxBound === currAxisBoundData?.currMaxBound
                            ? maximum
                            : currAxisBoundData?.defaultMaxBound,
                        currMaxBound: maximum,
                    };
                    // update the axes bounds info in the app state if the new bounds are different from the current bounds
                    if (!isEqual.isEqual(currAxisBoundData, newAxisBoundData) &&
                        this.selectedChartId !== undefined &&
                        chartAxesBoundDataMap?.[this.selectedChartId] !== undefined) {
                        chartAxesBoundDataMap[this.selectedChartId][key] = newAxisBoundData;
                    }
                }
            });
        };
        /**
         * Assigns new min/max bounds in to match those calculated by the chart component.
         * @category Event handler
         */
        this.chartAxesMinMaxChange = (e) => {
            const { bounds, model } = e.detail;
            const selectedModel = this.getModel(this.selectedChartId);
            const eventIsForSelectedChart = model?.isSameChartAs(selectedModel);
            const currentChartType = selectedModel?.getChartType();
            if (eventIsForSelectedChart) {
                switch (currentChartType) {
                    case chartObjectLiterals.WebChartTypes.BarSeries:
                    case chartObjectLiterals.WebChartTypes.BoxPlotSeries:
                    case chartObjectLiterals.WebChartTypes.LineSeries:
                    case chartObjectLiterals.WebChartTypes.HistogramSeries:
                    case chartObjectLiterals.WebChartTypes.ScatterSeries:
                        this.calculatedMinMaxBounds = bounds;
                        this.updateAxesBoundsInAppState(bounds);
                        break;
                }
            }
        };
        /**
         * Assigns new series color in order to align with the colors generated by the chart component.
         * @category Event handler
         */
        this.chartSeriesColorChange = (e) => {
            const { data, model } = e.detail;
            const selectedModel = this.getModel(this.selectedChartId);
            const eventIsForSelectedChart = model?.isSameChartAs(selectedModel);
            if (eventIsForSelectedChart) {
                switch (selectedModel?.getChartType()) {
                    case chartObjectLiterals.WebChartTypes.BarSeries:
                    case chartObjectLiterals.WebChartTypes.BoxPlotSeries:
                    case chartObjectLiterals.WebChartTypes.LineSeries:
                    case chartObjectLiterals.WebChartTypes.HistogramSeries:
                        // updating the config component
                        this.seriesColor = data;
                        break;
                    case chartObjectLiterals.WebChartTypes.PieSeries: {
                        const pieSeriesSymbolsMap = new Map([[0, data]]);
                        // update the config component
                        this.seriesColor = pieSeriesSymbolsMap;
                        break;
                    }
                }
            }
        };
        /**
         * Updates relevant model props to sync changes from chart component.
         * @category Event handler
         */
        this.chartNoRenderPropChange = (e) => {
            const { propName, value, model } = e.detail;
            const listedModel = this.modelList.find((m) => model?.isSameChartAs(m));
            if (listedModel) {
                switch (propName) {
                    case "rotation":
                        if (typeof value === "boolean" && index$1.$g(listedModel)) {
                            listedModel.setRotatedState(value);
                        }
                        break;
                    case "legendPosition":
                        if (typeof value === "string" && index$1.Mg(listedModel)) {
                            listedModel.setLegendPosition(value);
                        }
                        break;
                    case "legendVisibility":
                        if (typeof value === "boolean" && index$1.Mg(listedModel)) {
                            listedModel.setLegendVisibility(value);
                        }
                        break;
                }
            }
        };
        /**
         * Applies the visibility change to config. Also resets the min/max bounds to null when legend item visibility changes to allow new bounds to be set for the visible items.
         * @category Event handler
         */
        this.chartLegendItemVisibilityChange = async (e) => {
            const { legendItemVisibility, model } = e.detail;
            const listedModel = this.modelList.find((m) => model?.isSameChartAs(m));
            listedModel?.setSeriesVisibility(legendItemVisibility);
            // Reset axes bounds
            if (index$1.Dg(listedModel)) {
                // Reset y-axis bounds
                if (listedModel.getMinYBound() === null || Number.isNaN(listedModel.getMinYBound())) {
                    await listedModel.setMinYBound(null);
                }
                if (listedModel.getMaxYBound() === null || Number.isNaN(listedModel.getMaxYBound())) {
                    await listedModel.setMaxYBound(null);
                }
                // Reset x-axis bounds for line chart
                if (index$1.Ig(listedModel)) {
                    if (listedModel.getMinXBound() === null || Number.isNaN(listedModel.getMinXBound())) {
                        await listedModel.setMinXBound(null);
                    }
                    if (listedModel.getMaxXBound() === null || Number.isNaN(listedModel.getMaxXBound())) {
                        await listedModel.setMaxXBound(null);
                    }
                }
            }
        };
        /**
         * When selected chart type changed in create mode.
         * @category Event handler
         */
        this.onSelectChartTypeChange = (e) => {
            this.currentChartTypeText = "";
            // reset min and max bounds when the new chart is selected/about to be created
            this.calculatedDataMinMaxBounds = undefined;
            this.calculatedMinMaxBounds = undefined;
            this.removeSelectChartTypePopover();
            const { selectedChartType, layerId } = e.target;
            if (selectedChartType !== undefined) {
                this.arcgisChartsConfigNewChart.emit({
                    key: "key",
                    chartType: selectedChartType,
                    layerId,
                });
            }
        };
        /**
         * Get the popover placement based on chart list length.
         * @category private
         */
        this.getPlacement = () => {
            let placement;
            if (this.popoverPlacement !== undefined) {
                placement = this.popoverPlacement;
            }
            else {
                const supportedChartsLength = this.modelList?.filter((model) => restJsObjectLiterals.xl(interfaces.supportedChartTypes, model.getConfig())).length;
                // undefined will evaluate to false and give top placement
                const maxLengthForBottom = 2;
                placement = Number(supportedChartsLength) <= maxLengthForBottom ? "bottom" : "top";
            }
            return placement;
        };
        /**
         * Event handler when a panel back clicked. reduces the drill by one.
         * @category Event handler
         */
        this.onBackFlow = () => {
            this.panelNumber -= 1;
        };
        /**
         * Event handler on add chart.
         * @category Event handler
         */
        this.onAddChartClick = (e) => {
            const { referenceElement, layerId } = e.detail;
            this.setupSelectChartTypePopover(referenceElement, layerId);
            this.addSelectChartTypePopover();
        };
        /**
         * Setup attributes and events on the popover
         * @category Private
         */
        this.setupSelectChartTypePopover = (referenceElement, layerId) => {
            if (this.selectChartTypePopover === undefined) {
                // selectChartTypePopover config
                const popoverConfig = {
                    onSelectChartTypeChange: this.onSelectChartTypeChange,
                    popoverClose: this.onAddChartClose,
                };
                // create a new selectChartTypePopover
                this.selectChartTypePopover = restJsObjectLiterals.Zy(restJsObjectLiterals.Qy.SelectChartTypePopover, popoverConfig);
            }
            if (this.selectChartTypePopover !== undefined) {
                this.selectChartTypePopover.layerId = layerId;
                this.selectChartTypePopover.popoverReferenceElement = referenceElement;
                this.selectChartTypePopover.popoverPlacement = this.getPlacement();
            }
        };
        /**
         * Ddd the popover to the dom
         * @category Private
         */
        this.addSelectChartTypePopover = () => {
            if (this.selectChartTypePopover !== undefined) {
                if (!document.body.contains(this.selectChartTypePopover)) {
                    this.selectChartTypePopover.open = true;
                    document.body.appendChild(this.selectChartTypePopover);
                    this.arcgisChartsConfigPopoverOpenChange.emit({ open: true });
                }
            }
        };
        /**
         * Close and remove the popover
         * @category Private
         */
        this.removeSelectChartTypePopover = () => {
            this.selectChartTypePopover?.remove();
            this.selectChartTypePopover = undefined;
            this.arcgisChartsConfigPopoverOpenChange.emit({ open: false });
        };
        /**
         * Clear partial models from the model list
         * @category Private
         */
        this.clearPartialModels = () => {
            this.modelList = this.modelList.filter((model) => !restJsObjectLiterals.Yc(model.getConfig()));
        };
        /**
         * Event handler closing add chart.
         * @category Event handler
         */
        this.onAddChartClose = () => {
            this.removeSelectChartTypePopover();
        };
        /**
         * Event handler chart delete.
         * @category Event handler
         */
        this.onViewChartDelete = (e) => {
            const { chartId } = e.detail;
            const model = this.modelList.find((model) => model.getChartId() === chartId);
            const layer = this.layerList.find((layer) => layer.id === model?.getLayer()?.id);
            this.modelList = [...this.modelList.filter((model) => model.getChartId() !== chartId)];
            if (layer && this.syncChartsToLayers) {
                deleteChartFromLayer(layer, chartId);
            }
        };
        /**
         * Event handler chart to be selected.
         * @category Event handler
         */
        this.onViewChartsSelect = (e) => {
            // This event normally gets fired in `selectedChartIdChange()`. But if the selected chart is the same as the previous one, we still need to fire the event since we want any listening routines to handle the click on the charts list (e.g. refocusing the chart tab)
            if (this.selectedChartId === e.detail.chartId) {
                this.arcgisChartsConfigSelectedChartChange.emit({
                    key: "key",
                    model: this.getModel(this.selectedChartId),
                });
            }
            this.selectedChartId = e.detail.chartId;
        };
        /**
         * event handled when chart config edited.
         * @category Event handler
         */
        this.onViewChartsEdit = (e) => {
            this.onViewChartsSelect(e);
            this.panelNumber = 1;
        };
        /**
         * Event handler view charts to be closed.
         * @category Event handler
         */
        this.onViewChartClose = () => {
            this.open = false;
            this.removeSelectChartTypePopover();
            this.selectChartTypePopover = undefined;
            this.arcgisChartsConfigChartViewChartClose.emit();
        };
        /**
         * Creates a tooltip for the hovered action.
         * @category Event handler
         */
        this.createTooltip = (e) => {
            const actionElement = e.target;
            this.tooltip = chartUiUtils.createActionTooltip(actionElement);
            // Set tooltip content to reflect the associated action
            switch (actionElement.icon) {
                case "configure":
                    this.tooltip.innerHTML = this.strings.data;
                    break;
                case "graph-bar-stacked":
                case "graph-line-series":
                case "box-chart-series":
                    this.tooltip.innerHTML = this.strings.series;
                    break;
                case "graph-pie-slice":
                    this.tooltip.innerHTML = this.strings.slices;
                    break;
                case "graph-axis":
                    this.tooltip.innerHTML = this.strings.axes;
                    break;
                case "graph-guides":
                    this.tooltip.innerHTML = this.strings.guides;
                    break;
                case "palette":
                    this.tooltip.innerHTML = this.strings.format;
                    break;
                case "text":
                    this.tooltip.innerHTML = this.strings.general;
                    break;
                default:
                    this.tooltip.innerHTML = "";
                    break;
            }
            // append tooltip to the document body instead of action element
            // to avoid tooltip being cut off by calcite panel header element
            document.body.appendChild(this.tooltip);
        };
        /**
         * Destroys tooltip for the action that was being hovered.
         * @category Event handler
         */
        this.destroyTooltip = () => {
            chartUiUtils.destroyActionTooltip(this.tooltip);
        };
        /**
         * Event handler when model config changes.
         * @category Event handler
         */
        this.onModelConfigChange = (e) => {
            if (this.syncChartsToLayers) {
                const model = e.target;
                updateChartOnLayer(model?.getLayer(), model);
            }
            const prevUpdates = this.updatesOccurred;
            this.updatesOccurred = prevUpdates + 1;
        };
        this.modelList = [];
        this.layerList = [];
        this.selectedChartId = undefined;
        this.activeLayerId = undefined;
        this.disableEditing = false;
        this.syncChartsToLayers = false;
        this.timeZone = undefined;
        this.headerTitle = undefined;
        this.open = undefined;
        this.chartData = undefined;
        this.r2 = undefined;
        this.calculatedDataMinMaxBounds = undefined;
        this.calculatedMinMaxBounds = undefined;
        this.seriesColor = undefined;
        this.popoverPlacement = undefined;
        this.usePopupTemplateFieldsInfo = undefined;
        this.panelNumber = 0;
        this.modelLoading = undefined;
        this.filterBySelection = undefined;
        this.selectedPanel = undefined;
        this.currentChartTypeText = undefined;
        this.updatesOccurred = 0;
    }
    /**
     * Called every time layerList is updated
     * @category Watch handler
     */
    async layerListChange() {
        const newModelListFromLayers = [];
        // The new model list should only include models from a layer that exists in the new layer list. e.g. if a layer is removed from the layer list, the models from that layer should be removed from the model list also.
        const layerIds = this.layerList.map((l) => l.id.toString());
        const modelList = [...this.modelList.filter((m) => layerIds.includes(m.getLayer()?.id ?? ""))];
        for (let layer of this.layerList ?? []) {
            if (layer.type === "sublayer") {
                const newLayer = await layer.createFeatureLayer();
                if (!newLayer) {
                    continue;
                }
                layer = newLayer;
            }
            const layerWithCharts = layer;
            for (const config of layerWithCharts.charts ?? []) {
                const model = await index$1.qg({
                    layer,
                    chartType: restJsObjectLiterals.fl(config.series),
                    config,
                });
                if (model !== undefined) {
                    newModelListFromLayers.push(model);
                }
            }
        }
        // replace duplicate ids before overwriting existing models, because otherwise the duplicates will overwrite each other.
        replaceDuplicateIds(newModelListFromLayers);
        // only add new models that are not already in the model list, leave the existing models as they are
        // this is important to allow the consumer to control the model list without the layer list overwriting it
        newModelListFromLayers.forEach((newModel) => {
            const existingModel = modelList.find((m) => m.isSameChartAs(newModel));
            if (existingModel === undefined) {
                modelList.push(newModel);
            }
        });
        this.modelList = modelList;
    }
    /**
     * Called every time modelList is updated
     * @category Watch handler
     */
    async modelListChange(newModelList, oldModelList) {
        this.selectedChartId = replaceDuplicateIds(newModelList, this.selectedChartId);
        // remove event listeners from old models
        oldModelList.forEach((model) => {
            model.removeEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        });
        // add event listeners to new models
        newModelList.forEach((model) => {
            model.addEventListener("arcgisChartsModelConfigChange", this.onModelConfigChange);
        });
        // update current chart type text since it may have changed
        const newModel = this.getModel(this.selectedChartId);
        this.currentChartTypeText =
            newModel?.getChartType() !== undefined ? await restJsObjectLiterals.iu(newModel.getChartType()) : "";
        if (this.syncChartsToLayers) {
            updateAllChartsOnLayers(this.layerList, newModelList);
        }
        this.arcgisChartsConfigModelListChange.emit({ modelList: newModelList });
    }
    /**
     * Called every time selectedChartId is updated
     * @category Watch handler
     */
    async selectedChartIdChange(newSelectedChartId) {
        if (this.selectedChartId === undefined) {
            // return to the charts list (panel 0) when no chart is selected
            this.panelNumber = 0;
        }
        // reset to Data tab
        this.selectedPanel = interfaces$1.ChartAuthoringPages.Data;
        // reset seriesColor
        this.seriesColor = undefined;
        const newModel = this.getModel(newSelectedChartId);
        this.currentChartTypeText =
            newModel?.getChartType() !== undefined ? await restJsObjectLiterals.iu(newModel.getChartType()) : "";
        if (newSelectedChartId !== undefined && newSelectedChartId !== store.state.selectedChartId) {
            store.state.selectedChartId = newSelectedChartId;
        }
        this.arcgisChartsConfigSelectedChartChange.emit({
            key: "key",
            model: newModel,
        });
    }
    /**
     * Called every time panel number is updated
     * @category Watch handler
     */
    panelNumberChange(newValue) {
        // TODO: remove this when amCharts supports firefox cursor hiding.
        // TODO: Remove all code related to the arcgisChartsConfigPopoverOpenChange
        // if panelNumber is one it closed all popover. hence open changed to false.
        if (newValue === 0) {
            this.clearPartialModels();
        }
        else if (newValue === 1) {
            this.arcgisChartsConfigPopoverOpenChange.emit({ open: false });
            this.removeSelectChartTypePopover();
            this.selectChartTypePopover = undefined;
        }
        this.arcgisChartsConfigPanelNumberChange.emit({ panelNumber: newValue, modelList: this.modelList });
    }
    /**
     * Sets the focus to the calcite flow item.
     * @category Public
     */
    async setFocus() {
        this.chartsListFlowItem?.setFocus();
    }
    /**
     * @category Lifecycle
     */
    connectedCallback() {
        this.addChartEventListeners();
    }
    /**
     * @category Lifecycle
     */
    async componentWillLoad() {
        ({ strings: this.strings, direction: this.direction } = await restJsObjectLiterals.Mn(this.hostElement, index.getAssetPath(`.`)));
        await this.layerListChange();
    }
    /**
     * @category Lifecycle
     */
    disconnectedCallback() {
        this.clearPartialModels();
        this.removeSelectChartTypePopover();
        this.removeChartEventListeners();
        this.selectChartTypePopover = undefined;
    }
    /**
     * @category Render UX
     */
    renderViewCharts() {
        // Since the user is allowed to define the layers either by layerList or modelList, we need to merge them to get the final list of layers.
        const combinedLayerList = getCombinedLayerList({
            modelList: this.modelList,
            layerList: this.layerList,
            activeLayerId: this.activeLayerId,
            disableEditing: this.disableEditing,
        });
        return combinedLayerList.map((layer) => (index.h("arcgis-charts-config-view-charts", { key: layer.id, noGroup: this.activeLayerId !== undefined, modelList: filterModelListByLayerId(this.modelList, layer.id.toString(), this.supportedChartTypes), selectedChartId: this.selectedChartId ?? "", layer: layer, disableEditing: this.disableEditing, onArcgisChartsConfigViewChartSelect: this.onViewChartsSelect, onArcgisChartsConfigViewChartEdit: this.onViewChartsEdit, onArcgisChartsConfigViewChartDelete: this.onViewChartDelete, onArcgisChartsConfigViewChartAddChart: this.onAddChartClick })));
    }
    /**
     * @category Lifecycle
     */
    render() {
        return (index.h(index.Host, { key: '2bf1e9ed56494c3e591040c06d0ffa825322ff8e', class: { [HTMLClasses.rtl]: this.direction === "rtl" } }, this.open !== false ? (index.h("calcite-flow", { dir: this.direction }, index.h("calcite-flow-item", { key: "charts-list", selected: this.panelNumber === 0 || this.disableEditing, heading: this.headerTitle ?? this.strings.defaultHeaderTitle, closable: true, onCalciteFlowItemClose: this.onViewChartClose, ref: (e) => {
                this.chartsListFlowItem = e;
            } }, this.renderViewCharts()), this.renderTabs())) : null));
    }
    /**
     * Adds event listeners for chart components. These listeners will generally check if the event is for the selected chart, and only update the state if so.
     * @category Private
     */
    addChartEventListeners() {
        document.addEventListener(restJsObjectLiterals.Wy.DataProcessComplete, this.chartDataProcessComplete);
        document.addEventListener(restJsObjectLiterals.Wy.AxesMinMaxChange, this.chartAxesMinMaxChange);
        document.addEventListener(restJsObjectLiterals.Wy.SeriesColorChange, this.chartSeriesColorChange);
        document.addEventListener(restJsObjectLiterals.Wy.NoRenderPropChange, this.chartNoRenderPropChange);
        document.addEventListener(restJsObjectLiterals.Wy.LegendItemVisibilityChange, this.chartLegendItemVisibilityChange);
    }
    /**
     * Removes event listeners for chart components.
     * @category Private
     */
    removeChartEventListeners() {
        document.removeEventListener(restJsObjectLiterals.Wy.DataProcessComplete, this.chartDataProcessComplete);
        document.removeEventListener(restJsObjectLiterals.Wy.AxesMinMaxChange, this.chartAxesMinMaxChange);
        document.removeEventListener(restJsObjectLiterals.Wy.SeriesColorChange, this.chartSeriesColorChange);
        document.removeEventListener(restJsObjectLiterals.Wy.NoRenderPropChange, this.chartNoRenderPropChange);
        document.removeEventListener(restJsObjectLiterals.Wy.LegendItemVisibilityChange, this.chartLegendItemVisibilityChange);
    }
    /**
     * Renders list of charts authoring tabs and their content.
     * @category Private
     */
    renderTabs() {
        const model = this.getModel(this.selectedChartId);
        // if panel number is greater than or equal to 1 display the chart editing UI
        return (index.h("calcite-flow-item", { key: "chart-edit", selected: this.panelNumber >= 1 && !this.disableEditing, onCalciteFlowItemBack: this.onBackFlow, heading: this.strings[this.selectedPanel ?? interfaces$1.ChartAuthoringPages.Data], description: this.currentChartTypeText !== ""
                ? restJsObjectLiterals.On(this.strings.pageFlowTitle, {
                    chartName: model?.getTitleText() ?? this.currentChartTypeText,
                    layerName: model?.getLayer()?.title ?? "",
                })
                : "" }, model?.getChartType() !== undefined ? (index.h("calcite-action-bar", { class: HTMLClasses.tabBar, layout: "horizontal", expandDisabled: true, dir: this.direction }, index.h("calcite-action", { class: HTMLClasses.tab, icon: "configure", scale: "s", alignment: "center", active: this.selectedPanel === interfaces$1.ChartAuthoringPages.Data || this.selectedPanel === undefined, onClick: () => {
                this.selectedPanel = interfaces$1.ChartAuthoringPages.Data;
            }, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip, text: "", textEnabled: false }), model?.getChartType() === chartObjectLiterals.WebChartTypes.BarSeries ? (index.h("calcite-action", { class: HTMLClasses.tab, icon: "graph-bar-stacked", scale: "s", alignment: "center", active: this.selectedPanel === interfaces$1.ChartAuthoringPages.Series, onClick: () => {
                this.selectedPanel = interfaces$1.ChartAuthoringPages.Series;
            }, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip, text: "", textEnabled: false })) : null, model?.getChartType() === chartObjectLiterals.WebChartTypes.LineSeries ? (index.h("calcite-action", { class: HTMLClasses.tab, icon: "graph-line-series", scale: "s", alignment: "center", active: this.selectedPanel === interfaces$1.ChartAuthoringPages.Series, onClick: () => {
                this.selectedPanel = interfaces$1.ChartAuthoringPages.Series;
            }, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip, text: "", textEnabled: false })) : null, model?.getChartType() === chartObjectLiterals.WebChartTypes.BoxPlotSeries ? (index.h("calcite-action", { class: HTMLClasses.tab, icon: "box-chart-series", scale: "s", alignment: "center", active: this.selectedPanel === interfaces$1.ChartAuthoringPages.Series, onClick: () => {
                this.selectedPanel = interfaces$1.ChartAuthoringPages.Series;
            }, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip, text: "", textEnabled: false })) : null, model?.getChartType() === chartObjectLiterals.WebChartTypes.PieSeries ? (index.h("calcite-action", { class: HTMLClasses.tab, icon: "graph-pie-slice", scale: "s", alignment: "center", active: this.selectedPanel === interfaces$1.ChartAuthoringPages.Slices, onClick: () => {
                this.selectedPanel = interfaces$1.ChartAuthoringPages.Slices;
            }, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip, text: "", textEnabled: false })) : null, model?.getChartType() !== chartObjectLiterals.WebChartTypes.PieSeries ? (index.h("calcite-action", { class: HTMLClasses.tab, icon: "graph-axis", scale: "s", alignment: "center", active: this.selectedPanel === interfaces$1.ChartAuthoringPages.Axes, onClick: () => {
                this.selectedPanel = interfaces$1.ChartAuthoringPages.Axes;
            }, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip, text: "", textEnabled: false })) : null, model?.getChartType() !== chartObjectLiterals.WebChartTypes.PieSeries ? (index.h("calcite-action", { class: HTMLClasses.tab, icon: "graph-guides", scale: "s", alignment: "center", active: this.selectedPanel === interfaces$1.ChartAuthoringPages.Guides, onClick: () => {
                this.selectedPanel = interfaces$1.ChartAuthoringPages.Guides;
            }, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip, text: "", textEnabled: false })) : null, index.h("calcite-action", { class: HTMLClasses.tab, icon: "palette", scale: "s", alignment: "center", active: this.selectedPanel === interfaces$1.ChartAuthoringPages.Format, onClick: () => {
                this.selectedPanel = interfaces$1.ChartAuthoringPages.Format;
            }, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip, text: "", textEnabled: false }), index.h("calcite-action", { class: HTMLClasses.tab, icon: "text", scale: "s", alignment: "center", active: this.selectedPanel === interfaces$1.ChartAuthoringPages.General, onClick: () => {
                this.selectedPanel = interfaces$1.ChartAuthoringPages.General;
            }, onMouseOver: this.createTooltip, onMouseOut: this.destroyTooltip, text: "", textEnabled: false }))) : null, this.renderChartUIComponent()));
    }
    /**
     * Renders the chart UI editing component.
     * @category Private
     */
    renderChartUIComponent() {
        const model = this.getModel(this.selectedChartId);
        const layer = model?.getLayer();
        let chartConfigElement = null;
        if (model !== undefined && !this.modelLoading && !this.disableEditing) {
            // create the config component based on chart type
            switch (model?.getChartType()) {
                case "barSeries":
                    chartConfigElement = (index.h("arcgis-charts-config-bar-chart", { model: model, timeZone: this.timeZone, usePopupTemplateFieldsInfo: this.usePopupTemplateFieldsInfo, layer: layer, page: this.selectedPanel ?? interfaces$1.ChartAuthoringPages.Data, calculatedMinMaxBounds: this.calculatedMinMaxBounds, seriesColor: this.seriesColor }));
                    break;
                case "lineSeries":
                    chartConfigElement = (index.h("arcgis-charts-config-line-chart", { model: model, timeZone: this.timeZone, usePopupTemplateFieldsInfo: this.usePopupTemplateFieldsInfo, layer: layer, page: this.selectedPanel ?? interfaces$1.ChartAuthoringPages.Data, calculatedDataMinMaxBounds: this.calculatedDataMinMaxBounds, calculatedMinMaxBounds: this.calculatedMinMaxBounds, seriesColor: this.seriesColor }));
                    break;
                case "pieSeries":
                    chartConfigElement = (index.h("arcgis-charts-config-pie-chart", { model: model, usePopupTemplateFieldsInfo: this.usePopupTemplateFieldsInfo, layer: layer, chartData: this.chartData, page: this.selectedPanel ?? interfaces$1.ChartAuthoringPages.Data, calculatedMinMaxBounds: this.calculatedMinMaxBounds, seriesColor: this.seriesColor, filterBySelection: this.filterBySelection }));
                    break;
                case "histogramSeries":
                    chartConfigElement = (index.h("arcgis-charts-config-histogram", { model: model, usePopupTemplateFieldsInfo: this.usePopupTemplateFieldsInfo, layer: layer, page: this.selectedPanel ?? interfaces$1.ChartAuthoringPages.Data, chartData: this.chartData, calculatedMinMaxBounds: this.calculatedMinMaxBounds, seriesColor: this.seriesColor }));
                    break;
                case "scatterSeries":
                    chartConfigElement = (index.h("arcgis-charts-config-scatter-plot", { model: model, usePopupTemplateFieldsInfo: this.usePopupTemplateFieldsInfo, layer: layer, page: this.selectedPanel ?? interfaces$1.ChartAuthoringPages.Data, r2: this.r2, calculatedDataMinMaxBounds: this.calculatedDataMinMaxBounds, calculatedMinMaxBounds: this.calculatedMinMaxBounds }));
                    break;
                case "boxPlotSeries":
                    chartConfigElement = (index.h("arcgis-charts-config-box-plot", { model: model, usePopupTemplateFieldsInfo: this.usePopupTemplateFieldsInfo, layer: layer, page: this.selectedPanel ?? interfaces$1.ChartAuthoringPages.Data, calculatedMinMaxBounds: this.calculatedMinMaxBounds, seriesColor: this.seriesColor }));
                    break;
            }
        }
        return chartConfigElement;
    }
    /**
     * Gets a model from the list based on the id.
     * @param id Id of the model to get.
     */
    getModel(id) {
        return this.modelList?.find((model) => model.getChartId() === id);
    }
    static get assetsDirs() { return ["assets"]; }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "layerList": ["layerListChange"],
        "modelList": ["modelListChange"],
        "selectedChartId": ["selectedChartIdChange"],
        "panelNumber": ["panelNumberChange"]
    }; }
};
ArcGISChartsConfigCreateFlow.style = ArcgisChartsConfigCreateFlowStyle0;

exports.ArcGISChartsConfigCreateFlow = ArcGISChartsConfigCreateFlow;
