import type { WebChartSeriesType, WebMapWebChart } from "@arcgis/charts-spec";
import { RESTSymbolType, WebChartTypes, WebChartVersionStatus } from "@arcgis/charts-spec";
import { ChartSubType } from "../../misc/interfaces";
/**
 * Retrieve and construct chart version information based on the input version and the currently supported ArcGIS Chart versions
 * defined in `chartConfigVersions`.  Returned information includes:
 *
 * - versionStatus: whether the input chart version is the same | older | newer | unrecognized, comparing with the current chart version,
 * which is defined in `WebChartCurrentVersion`.  An unrecognized version is one that is neither undefined nor conformed to the
 * sematic versioning spec, that is `Major.Minor.Patch`
 * - versions: an array of versions that will be used in the `appConversion()`.
 *  + For any version that is not recognized, versions will be set to `unrecognizedVersion`;
 *  + If the input version is the same or newer, versions will be the input version;
 *  + Otherwise, versions will be a list of versions that is older and closer to the input version, plus all the supported versions
 * that are newer than the input version.
 *
 * Note: The input chart version needs to conform to the format defined by sematic versioning spec; otherwise it will be treated as unrecognized.
 *
 * @param configVersion The input config version.
 */
export declare function getChartVersionInfo(configVersion?: string): {
    versionStatus: WebChartVersionStatus;
    versions: string[];
};
/**
 * Get the series to use as a reference for the chart. That's the one containing important common information like the query,
 * the split-by field, etc.
 * For box plot we need to handle the specific case of the mean line series.
 * @param chartConfig The chart config
 */
export declare function getSeriesReference(chartConfig: WebMapWebChart): WebChartSeriesType;
/**
 * Find the expected symbol type for a guide given the start and end values.
 * @param guide The guide to analyze
 */
export declare function findExpectedGuideSymbol(start: Date | number | string | null, end: Date | number | string | null | undefined): RESTSymbolType;
/**
 * Extract the field name from equality-where clauses like `field = 'some_value'`.
 * This field is actually stored in each series where clause.
 * TODO: do we want to enforce the test by seeing if the extracted field is part of the feature layer list of fields?
 * E.g.:
 * "field = 'some_value'" => "field"
 * "field > 'some_value'" => ""
 * @param where the where clause to extract the field from
 * @param normalize whether to normalize the extracted field; by default it's true
 */
export declare function getSplitByField(where: string | undefined, normalize?: boolean): string;
/**
 * Extract the value from equality-where clauses like `field = 'some_value'`.
 * Optionally normalize or escape single quotes in the returned value according to the `normalize` param value.
 * If normalize is undefined then normalize the returned value.
 * For string value, if normalize is set to false and escape is set to false or undefined, the value is returned as is.
 * @param props.where the where clause to extract the value from
 * @param props.normalize whether to normalize the extracted value; default is true
 * @param props.keepSurroundingQuotes whether to keep the surrounding quotes; default is false
 * @param props.escape whether to escape the extracted value; default is false
 */
export declare function getSplitByValue(props: {
    where: string | undefined;
    normalize?: boolean;
    keepSurroundingQuotes?: boolean;
    escape?: boolean;
}): number | string | null;
/**
 * Detects a where clause being always true, as in 1=1, 2 = 2, 'some_value'='some_value'
 * @param where
 */
export declare function isAbsoluteTruthWhereClause(where?: string): boolean;
/**
 * Normalizes a where clause, by escaping the "'" character and other special characters if needed.
 * Ex:
 *   - where = "field = 5" => returns "field = 5"
 *   - where = "field = 'value'" => returns "field = 'value'"
 *   - where = "field = 'va'lue'" => returns "field = 'va''lue'"
 * @param props.where the where clause to normalize
 * @param props.normalize whether to normalize the where clause
 * @param props.escape whether to escape the where clause
 */
export declare function normalizeWhereClause(props: {
    where: string;
    normalize?: boolean;
    escape?: boolean;
}): string;
/**
 * Gets the query type for box plot chart.
 * @param seriesConfig the box plot series config
 */
export declare function getBoxPlotChartSubType(seriesConfig: WebChartSeriesType[]): ChartSubType;
/**
 * Returns the type of query we're dealing with. The actual values are:
 * a. Simple (0): single query using an aggregation
 * b. NoAggregation (1): single or multiple queries not using any aggregation
 * c. SplitByFieldValues (2): multiple queries using a specific field as a split-by
 * d. SplitByNumericalFields (3): multiple queries using multiple numerical fields as a split-by
 * e. PieFromFields (4): single query using more than one statistics fields
 * f. For Box-plot: one of the 7 combinations.
 * @param series The config series. Refrain from using `[firstSeries]` in place of `config.series` to avoid incorrect result,
 * especially for box-plot, bar and line charts.
 */
export declare function getChartSubType(series?: WebChartSeriesType[]): ChartSubType;
/**
 * Indicates whether the bar or line series is configured to use time binning.
 * @param props.seriesConfig The series configuration
 * @param props.xAxisValueFormatType The x-axis value format type
 * @param props.setTimeBinningInfoWhenNotProvided Boolean indicating whether we want to set the time binning info when not provided
 */
export declare function isSeriesUsingTimeBinning(props: {
    seriesConfig: WebChartSeriesType;
    xAxisValueFormatType?: WebChartTypes;
    setTimeBinningInfoWhenNotProvided?: boolean;
}): boolean;
