import type { IFeatureLayer, IField, WebChart, WebChartDataFilters, WebChartQuery, SupportedLayer } from "@arcgis/charts-spec";
import type FeatureLayer from "@arcgis/core/layers/FeatureLayer";
import type Renderer from "@arcgis/core/renderers/Renderer";
import type { QueryObject, QueryObjectProps, RendererInfo, SubtypeInfo } from "./interfaces";
/**
 * Returns the renderer type and the field and normalization field if applicable.
 * @param layerRenderer
 */
export declare function getRendererInfo(layerRenderer?: Renderer): RendererInfo;
/**
 * Function creating a FeatureLayer from a set of parameters.
 * It returns the created Feature Layer.
 * It is memoized (cached) to avoid multiple requests for a same feature layer.
 */
export declare const getFeatureLayer: (featureLayer: IFeatureLayer) => Promise<FeatureLayer>;
/**
 * Returns the proper query object to use according to the situation.
 * If can return either a FeatureLayer or a FeatureLayerView (and possibly nothing)
 * @param props
 */
export declare function getQueryObject(props: QueryObjectProps): Promise<QueryObject>;
/**
 * Fetches all the fields info a feature layer.
 * @param queryObject
 * @param usePopupTemplateFieldsInfo whether to use the aliases from the popupTemplate
 */
export declare function fetchLayerFieldsInfo(queryObject: QueryObject, usePopupTemplateFieldsInfo?: boolean): Promise<IField[]>;
/**
 * Looks into a list of fields for one having a specific name, and returning it if found.
 * Returns nothing if the field is not found.
 * @param fields The list of fields containing all the information regarding the fields, including the name
 */
export declare function getFieldFromName(fieldName: string, fields?: IField[]): IField | undefined;
/**
 * Look for an OID field among a list of feature layer fields.
 * The function `find` used can return in theory an `undefined` value, but in our case we're sure to bring back
 * the field ID (every feature layer has one).
 * As a consequence the backup value returned if `oidField.name` is `undefined` doesn't matter because it will not happen.
 */
export declare function getObjectIdField(layerFieldsInfo: IField[]): string;
/**
 * Checks whether the given field has a valid numeric type.
 * Fields descriptions are [here](http://resources.esri.com/help/9.3/ArcGISEngine/ArcObjects/esriGeoDatabase/esriFieldType.htm).
 * @param field
 */
export declare function isNumericField(field: IField): boolean;
/**
 * Checks whether the given field has a valid date type.
 * Fields descriptions are [here](http://resources.esri.com/help/9.3/ArcGISEngine/ArcObjects/esriGeoDatabase/esriFieldType.htm).
 * @param field
 */
export declare function isDateField(field: IField): boolean;
/**
 * Checks whether the given field has a valid integer type.
 * Fields descriptions are [here](http://resources.esri.com/help/9.3/ArcGISEngine/ArcObjects/esriGeoDatabase/esriFieldType.htm).
 * @param field
 */
export declare function isIntegerField(field: IField): boolean;
/**
 * Returns list of date field names from an array of fields of type IField
 * @param fieldsInfo
 */
export declare function getLayerDateFields(fieldsInfo: IField[]): string[];
/**
 * Returns list of numeric field names from an array of fields of type IField
 * @param fieldsInfo
 */
export declare function getLayerNumericFields(fieldsInfo: IField[]): string[];
/**
 * Retrieve subtype information from the query object.
 * @param queryObject The query object from which to retrieve the feature layer.
 * @returns subtype info like typeIdField and the subtypes, if defined; otherwise undefined.
 * //TODO: may need to revise regrading the typeIdField property (See https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/42555)
 */
export declare function getLayerSubtypeInfo(queryObject: QueryObject): SubtypeInfo | undefined;
/**
 * Get the field description if the field contains subtype or domain value.
 * This field description is mainly for displaying purpose (while its id is used in queries).
 * @param props.fieldName the name of the field
 * @param props.fieldValueToMatch the value to search for a match in the subtypes or domains; if the field contains subtype or domain it's likely the id.
 * @param props.subtypeInfo the subtype information, which includes typeIdField and types.
 * @param props.fieldList the list of fields
 * @returns The field description if available; otherwise undefined.
 */
export declare function getFieldDescription(props: {
    fieldName: string;
    fieldValueToMatch: number | string;
    subtypeInfo?: SubtypeInfo;
    fieldList?: IField[];
}): string | undefined;
/**
 * Returns feature layer field names used in its renderer.
 * @param {FeatureLayer} layer
 * @returns {Promise<string[]>}
 */
export declare function getRendererFieldNames(layer: SupportedLayer): Promise<string[]>;
/**
 * Returns a boolean to indicate if the feature layer is on standard feature data store or not.
 * https://doc.arcgis.com/en/arcgis-online/reference/faq.htm#anchor7
 * @param {FeatureLayer} layer
 * @returns {Promise<boolean>}
 */
export declare function isStandardLayer(layer: SupportedLayer): Promise<boolean>;
/**
 * Finds the matching field name for a given layer based on the fieldToMatch parameter.
 * @param {QueryObject} props.queryObject
 * @param {string} props.fieldToMatch
 * @param {boolean} props.returnUndefinedIfNotFound
 * @returns {Promise<string>}
 */
export declare function findMatchingLayerFieldName(props: {
    queryObject: QueryObject;
    fieldToMatch: string;
    returnUndefinedIfNotFound?: boolean;
}): Promise<string>;
/**
 * Finds the matching layer fields for a list of fields.
 *
 * @param {(string[] | undefined)} props.fields
 * @param {SupportedLayer} props.queryObject
 * @param {boolean} props.returnUndefinedIfNotFound
 * @returns
 */
export declare function matchFieldsList(props: {
    fieldsList: string[] | undefined;
    queryObject: SupportedLayer;
    returnUndefinedIfNotFound?: boolean;
}): Promise<string[] | undefined>;
/**
 * Builds a WebChartQuery based on information coming from the runtime filters (chart options), the config and the data source.
 * The filters by attributes from all sources are all combined together (using the AND operator).
 * Regarding the other filters (by geometry, gdb version and time extent) only one of each can be applied. The runtime
 * filters are chosen over the config filters.
 * @param props.queryObject The query object (feature layer or feature layer view)
 * @param props.chartConfig The chart's config
 * @param props.runtimeDataFilters The runtime data filters
 * @param props.ignoreViewExtent Whether to ignore the view extent
 */
export declare function buildQueryConfig(props: {
    queryObject?: QueryObject;
    chartConfig: WebChart;
    runtimeDataFilters?: WebChartDataFilters;
    ignoreViewExtent?: boolean;
}): WebChartQuery;
/**
 * Ger the list of the fields used in the charts
 * @category Public
 *
 *
 * @param {WebMapWebChart[] | undefined} layer - the supported layer
 * @param {WebMapWebChart[] | undefined} chartList - List of charts stored in the layer
 *
 * @returns {Promise<string[]>} - The list of fields used in the charts
 */
export declare function getFieldsUsedInCharts(layer: SupportedLayer): Promise<string[]>;
/**
 * Fetches the fields used in the chart configuration and returns the matching fields from the feature layer.
 * @param {ChartConfig} config The chart configuration
 * @param {SupportedLayer} layer The feature layer
 *
 * @returns {Promise<string[]>} The list of matching fields
 */
export declare function extractFieldsUsedInConfig(config: WebChart, layer: SupportedLayer | undefined): Promise<string[]>;
/**
 * Get the list of layer fields from the series list of the chart config.
 * @param {SupportedLayer} layer The layer
 *
 * @returns {string[]} The list of layer fields
 */
export declare function extractFieldsFromConfigList(layer: SupportedLayer): Promise<string[]>;
