import { CompletionItem, Range, DiagnosticSeverity, TextEdit, Position, CompletionList } from 'vscode-languageserver-types';
export { DiagnosticSeverity } from 'vscode-languageserver-types';
import { TextDocument } from 'vscode-languageserver-textdocument';

/**
 * Supported function bundles
 */
type SqlBundleType = "core";

/**
 * Union of bundle types that can be used in any sdk schema
 */
type BundleType = ArcadeBundleType | SqlBundleType;

/**
 * Supported function bundles
 */
type ArcadeBundleType = "core" | "data-access" | "database" | "geometry" | "knowledge-graph" | "portal-access" | "track";
/**
 * Supported profile variable types
 */
type SdkVariableType = "array" | "boolean" | "date" | "dateOnly" | "dictionary" | "feature" | "featureSet" | "featureSetCollection" | "geometry" | "knowledgeGraph" | "number" | "text" | "time" | "voxel";

/**
 * The list of supported profiles
 */
type ArcadeProfileId = "aggregate-field" | "alias" | "attribute-rule-calculation" | "attribute-rule-constraint" | "attribute-rule-validation" | "dashboard-data" | "dashboard-indicator-formatting" | "dashboard-list-formatting" | "dashboard-table-formatting" | "data-pipelines" | "dictionary-renderer" | "feature-display-title" | "feature-z" | "field-calculation" | "field-mapping" | "form-calculation" | "form-constraint" | "geoanalytics" | "geotrigger-notification" | "labeling" | "layout" | "location-update-constraint" | "measure-visualization" | "minimalist" | "model-builder" | "popup-element-feature-reduction" | "popup-element-voxel" | "popup-element" | "popup-feature-reduction" | "popup-voxel" | "popup" | "quick-capture" | "tasks" | "velocity" | "visualization";

/**
 * The list of supported profiles
 */
type SqlProfileId = "field-calculation";
/**
 * A union of all language profile ids
 */
type ProfileId = ArcadeProfileId | SqlProfileId;

/**
 * Represents an api category and its items
 */
interface SdkCategory {
    /**
     * The unique ID for the category
     */
    id: string;
    /**
     * The title for the category
     */
    title: string;
    /**
     * The collection of api items for the category
     */
    items: SdkItem[];
}
interface SdkItemBase {
    /**
     * The name of the function or constant.
     */
    name: string;
    /**
     * The version string when the api item was introduced. If undefined then it was from the origin.
     */
    sinceVersion?: string;
    /**
     * The api bundle this item belongs to.
     */
    bundle: BundleType;
    /**
     * Markdown description of the item.
     */
    description: string;
    /**
     * Markdown containing examples.
     */
    examples: string;
    /**
     * Link for additional information about the item.
     */
    link: string;
    /**
     * Completion item directly leveraged by the editor.
     */
    completion: CompletionItem;
    /**
     * Indicates if the documentation for this item should be disabled.
     */
    disableDocumentation?: boolean;
}
/**
 * Represents a constant in the arcade api.
 */
interface SdkConstant extends SdkItemBase {
    type: "constant";
}
/**
 * Represents a function in the arcade api
 */
interface SdkFunction extends SdkItemBase {
    type: "function";
    /**
     * Information leveraged by the editor to validate function call.
     * Indicates the minimum number of expected parameters and the maximum number of parameters expected.
     */
    parametersInfo: {
        min: number;
        max: number;
    };
}
/**
 * Represents an item in the arcade api.
 */
type SdkItem = SdkConstant | SdkFunction | SdkFunction[];

/**
 * Represent items stored in the library
 */
type ApiItem = SdkConstant | SdkFunction;
/**
 * Represent a category of api items in the api library
 */
interface ApiCategory extends SdkCategory {
    items: ApiItem[];
}

/**
 * The editor can be extended with custom snippets
 */
interface ApiSnippet {
    /**
     * The label for the snippet. The editor will use it to offer the snippet based on the text typed in the editor.
     * It's recommended to keep it short and as close as possible to what the user may be looking for.
     * For example: 'polyline'
     */
    label: string;
    /**
     * A slightly longer description of what the snippet offers.
     */
    detail: string;
    /**
     * A string that should be inserted into the script when selecting
     * this snippet.
     *
     * The `insertText` is subject to interpretation by the editor.
     * Use this rules: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#snippet_syntax
     */
    insertText: string;
}
/**
 * Language service api options
 */
interface ApiContext {
    /**
     * The profile (variables, additional api items, bundles, etc.)
     */
    profile?: ApiProfile;
    /**
     * The locale for the Api
     */
    locale?: string;
    /**
     * Allows to augment the language snippets with a collection of snippets
     */
    snippets?: ApiSnippet[];
}
/**
 * Language service profile
 */
interface ApiProfile {
    /**
     * The wellknown profile id if applicable
     */
    id?: ProfileId;
    /**
     * The set of profile variables
     */
    variables: ApiVariable[];
    /**
     * The api version to use
     */
    apiVersion?: string;
    /**
     * The api bundles to use
     */
    bundles?: BundleType[];
    /**
     * A collection of api item names to hide.
     */
    hiddenApiItems?: string[];
}
/**
 * The type for value variable.
 */
type ApiValueVariableType = Exclude<SdkVariableType, "dictionary">;
interface ApiVariableBase {
    /**
     * Name of the variable
     */
    name: string;
    /**
     * Optional short description for the variable
     */
    description?: string;
    /**
     * Completion item for the variable, leveraged bu the editor
     */
    completion?: CompletionItem;
}
/**
 * Describes a dictionary type (feature, dictionary)
 */
interface ApiDictionaryVariable extends ApiVariableBase {
    type: "dictionary";
    /**
     * Dictionary properties
     */
    properties?: ApiVariable[];
}
/**
 * Describes a simple variable type (number, featureSet, etc.)
 */
interface ApiValueVariable extends ApiVariableBase {
    type: ApiValueVariableType;
}
/**
 * The profile variable type
 */
type ApiVariable = ApiDictionaryVariable | ApiValueVariable;

/**
 * Language service settings
 */
interface LanguageServiceSettings {
    getApiLibrary: (locale: string) => Promise<ApiCategory[]>;
}

/**
 * Describes the formatting options
 */
interface FormattingOptions {
    /**
     * Number of spaces the formatter should use for indentation.
     * If you do not pass this option explicitly, it will be
     * (quite reliably!) inferred from the original code.
     * @default 2
     */
    indentWidth?: number;
    /**
     * Some of the formatter code (such as that for printing function
     * parameter lists) makes a valiant attempt to prevent really long
     * lines. You can adjust the limit by changing this option; however,
     * there is no guarantee that line length will fit inside this limit.
     * @default 80
     */
    wrapColumn?: number;
    /**
     * If you want to override the quotes used in string literals, specify
     * either "single", "double", or "auto" here ("auto" will select the one
     * which results in the shorter literal) Otherwise, use double quotes.
     * @default null
     */
    quote?: "auto" | "double" | "single" | null;
}

interface ArcadeApiContext extends ApiContext {
    /**
     * Options to control how the script should be formatted
     */
    formattingOptions?: FormattingOptions;
}

/**
 * Arcade diagnostic error codes.
 */
declare const DiagnosticCodes$1: {
    readonly InvalidModuleUri: "InvalidModuleUri";
    readonly ForInOfLoopInitializer: "ForInOfLoopInitializer";
    readonly IdentifierExpected: "IdentifierExpected";
    readonly InvalidEscapedReservedWord: "InvalidEscapedReservedWord";
    readonly InvalidExpression: "InvalidExpression";
    readonly InvalidFunctionIdentifier: "InvalidFunctionIdentifier";
    readonly InvalidHexEscapeSequence: "InvalidHexEscapeSequence";
    readonly InvalidLeftHandSideInAssignment: "InvalidLeftHandSideInAssignment";
    readonly InvalidLeftHandSideInForIn: "InvalidLeftHandSideInForIn";
    readonly InvalidTemplateHead: "InvalidTemplateHead";
    readonly InvalidVariableAssignment: "InvalidVariableAssignment";
    readonly KeyMustBeString: "KeyMustBeString";
    readonly NoFunctionInsideBlock: "NoFunctionInsideBlock";
    readonly NoFunctionInsideFunction: "NoFunctionInsideFunction";
    readonly ModuleExportRootOnly: "ModuleExportRootOnly";
    readonly ModuleImportRootOnly: "ModuleImportRootOnly";
    readonly PunctuatorExpected: "PunctuatorExpected";
    readonly TemplateOctalLiteral: "TemplateOctalLiteral";
    readonly UnexpectedBoolean: "UnexpectedBoolean";
    readonly UnexpectedEndOfScript: "UnexpectedEndOfScript";
    readonly UnexpectedIdentifier: "UnexpectedIdentifier";
    readonly UnexpectedKeyword: "UnexpectedKeyword";
    readonly UnexpectedNull: "UnexpectedNull";
    readonly UnexpectedNumber: "UnexpectedNumber";
    readonly UnexpectedPunctuator: "UnexpectedPunctuator";
    readonly UnexpectedString: "UnexpectedString";
    readonly UnexpectedTemplate: "UnexpectedTemplate";
    readonly UnexpectedToken: "UnexpectedToken";
};
/**
 * Arcade diagnostic error codes.
 */
type DiagnosticCodes$1 = (typeof DiagnosticCodes$1)[keyof typeof DiagnosticCodes$1];

/**
 * Represents the data associated with a diagnostic.
 * For example in case of an error associated to an identifier,
 * the DiagnosticData will contain a key 'identifier' and its value.
 */
type DiagnosticData = Record<string, number | string>;
/**
 * The combined diagnostic codes
 */
type DiagnosticCodes = DiagnosticCodes$1 | ValidationDiagnosticCodes;
/**
 * Represents a diagnostic, such as a parsing error or warning.
 */
interface Diagnostic {
    /**
     * The range at which the message applies
     */
    range: Range;
    /**
     * The diagnostic's severity. Can be omitted. If omitted it is up to the
     * client to interpret diagnostics as error, warning, info or hint.
     */
    severity?: DiagnosticSeverity;
    /**
     * The diagnostic's code.
     */
    code: DiagnosticCodes;
    /**
     * The diagnostic's message. It usually appears in the user interface
     */
    message: string;
    /**
     * A data entry field that is preserved between a `textDocument/publishDiagnostics`
     * notification and `textDocument/codeAction` request.
     */
    data?: DiagnosticData | null;
}
declare const ValidationDiagnosticCodes: {
    readonly AlreadyDefined: "AlreadyDefined";
    readonly ApiConflict: "ApiConflict";
    readonly AssignedNeverUsed: "AssignedNeverUsed";
    readonly DefinedNeverAssigned: "DefinedNeverAssigned";
    readonly DefinedNeverUsed: "DefinedNeverUsed";
    readonly EmptyBlockStatement: "EmptyBlockStatement";
    readonly ExecutionError: "ExecutionError";
    readonly InvalidApiFunctionUsage: "InvalidApiFunctionUsage";
    readonly InvalidConstantIdentifier: "InvalidConstantIdentifier";
    readonly InvalidPropertyIdentifier: "InvalidPropertyIdentifier";
    readonly NoArgumentExpected: "NoArgumentExpected";
    readonly NotADictionary: "NotADictionary";
    readonly NotDefined: "NotDefined";
    readonly NotEnoughArguments: "NotEnoughArguments";
    readonly ProfileVariablesAreImmutable: "ProfileVariablesAreImmutable";
    readonly ProfileVariablesConflict: "ProfileVariablesConflict";
    readonly ReservedKeyword: "ReservedKeyword";
    readonly TooManyArguments: "TooManyArguments";
    readonly UnexpectedEmptyFunction: "UnexpectedEmptyFunction";
    readonly UnexpectedPropertyIdentifier: "UnexpectedPropertyIdentifier";
    readonly UnknownPropertyIdentifier: "UnknownPropertyIdentifier";
};
type ValidationDiagnosticCodes = (typeof ValidationDiagnosticCodes)[keyof typeof ValidationDiagnosticCodes];
declare const DiagnosticMessages: {
    readonly InvalidModuleUri: string;
    readonly ForInOfLoopInitializer: string;
    readonly IdentifierExpected: string;
    readonly InvalidEscapedReservedWord: string;
    readonly InvalidExpression: string;
    readonly InvalidFunctionIdentifier: string;
    readonly InvalidHexEscapeSequence: string;
    readonly InvalidLeftHandSideInAssignment: string;
    readonly InvalidLeftHandSideInForIn: string;
    readonly InvalidTemplateHead: string;
    readonly InvalidVariableAssignment: string;
    readonly KeyMustBeString: string;
    readonly NoFunctionInsideBlock: string;
    readonly NoFunctionInsideFunction: string;
    readonly ModuleExportRootOnly: string;
    readonly ModuleImportRootOnly: string;
    readonly PunctuatorExpected: string;
    readonly TemplateOctalLiteral: string;
    readonly UnexpectedBoolean: string;
    readonly UnexpectedEndOfScript: string;
    readonly UnexpectedIdentifier: string;
    readonly UnexpectedKeyword: string;
    readonly UnexpectedNull: string;
    readonly UnexpectedNumber: string;
    readonly UnexpectedPunctuator: string;
    readonly UnexpectedString: string;
    readonly UnexpectedTemplate: string;
    readonly UnexpectedToken: string;
    readonly AlreadyDefined: "'${identifier}' is already defined.";
    readonly ApiConflict: "'${identifier}' is already defined as an Arcade constant or function.";
    readonly AssignedNeverUsed: "'${identifier}' is assigned but never used.";
    readonly DefinedNeverAssigned: "'${identifier}' is defined but never assigned.";
    readonly DefinedNeverUsed: "'${identifier}' is defined but never used.";
    readonly EmptyBlockStatement: "Empty block statement.";
    readonly ExecutionError: "Execution Error: '${stack}'";
    readonly InvalidApiFunctionUsage: "Arcade function '${identifier}' not used in a call expression.";
    readonly InvalidConstantIdentifier: "Invalid constant identifier, expecting ${list}.";
    readonly InvalidPropertyIdentifier: "Invalid property identifier, expecting ${list}.";
    readonly NoArgumentExpected: "Expecting no argument.";
    readonly NotADictionary: "'${identifier}' doesn't have properties.";
    readonly NotDefined: "'${identifier}' is not defined.";
    readonly NotEnoughArguments: "Expecting at least ${min} argument(s).";
    readonly ProfileVariablesAreImmutable: "Profile variables cannot be modified.";
    readonly ProfileVariablesConflict: "'${identifier}' is already defined as a profile variable.";
    readonly ReservedKeyword: "'${identifier}' is a reserved keyword.";
    readonly TooManyArguments: "Too many arguments, expecting ${max}.";
    readonly UnexpectedEmptyFunction: "Unexpected empty function '${identifier}'.";
    readonly UnexpectedPropertyIdentifier: "Unexpected property identifier.";
    readonly UnknownPropertyIdentifier: "Unknown property identifier '${identifier}'.";
};

declare function arcadeFormat(document: TextDocument, context?: ArcadeApiContext): TextEdit[];
/**
 * Format code using options.
 */
declare function format(script: string, options?: FormattingOptions): string;

declare const ArcadeKeywords: ("function" | "else" | "import" | "break" | "continue" | "for" | "if" | "export" | "in" | "return" | "var" | "while")[];
declare const ArcadeLiterals: ("false" | "null" | "true")[];
declare const ArcadeReservedKeywords: string[];

declare class ArcadeLanguageService {
    private apiService;
    configure(settings: LanguageServiceSettings): void;
    doValidation(document: TextDocument, context: ArcadeApiContext): Promise<Diagnostic[]>;
    doComplete(document: TextDocument, position: Position, context: ArcadeApiContext): Promise<CompletionList>;
}

export { type ArcadeApiContext, ArcadeKeywords, ArcadeLanguageService, ArcadeLiterals, ArcadeReservedKeywords, type Diagnostic, type DiagnosticCodes, type DiagnosticData, DiagnosticMessages, ValidationDiagnosticCodes, arcadeFormat, format };
